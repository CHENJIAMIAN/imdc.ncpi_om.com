const __vite__mapDeps = (i, m=__vite__mapDeps, d=(m.f || (m.f = ["./DRACOLoader-DRfW5f7D.js", "./index-D4L0IM0P.js", "./GLTFLoader-Cky4qAiS.js", "./FBXLoader-BkFCIu1-.js", "./EffectComposer-BBPlgFtC.js", "./CopyShader-BzTUYzf6.js", "./ShaderPass-CMl3JXW9.js", "./Pass-CZqO-Rxm.js", "./RenderPass-DlCygASy.js", "./FXAAShader-3Vj3PVLq.js", "./OutlinePass-wl3jTg2D.js", "./OutputPass-ihIgfo1d.js", "./OrbitControls-DvibNlCA.js"]))) => i.map(i => d[i]);
var uf = Object.defineProperty;
var df = (t, e, n) => e in t ? uf(t, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : t[e] = n;
var sn = (t, e, n) => df(t, typeof e != "symbol" ? e + "" : e, n);
import {D as pf, H as $i, F as ao, a as Ui, L as hf, b as Ml, c as ff, T as mf, _ as gt, S as Do, E as vf, d as ud, R as gf, V as vs, e as Se, O as bf, M as dd, f as pd, B as _f, g as Bs, h as yf, i as kn, P as hd, j as qr, C as wf, k as xf, W as Cf, l as fd, G as $s, m as md, n as Ef, o as Pf, A as Of, p as Tf, q as Af, r as Ll, s as Sf, t as kf, u as Mf, v as Lf, w as va, x as Ff, y as vd, z as Rf, Q as If, I as M, J as W, K as v, N as Vf, U as Df, X as Ve, Y as De, Z as ke, $ as ze, a0 as Bf, a1 as H, a2 as S, a3 as j, a4 as $, a5 as _n, a6 as gs, a7 as $f, a8 as ti, a9 as E, aa as le, ab as Vn, ac as Kt, ad as Fn, ae as Dt, af as Uf, ag as ut, ah as he, ai as Wt, aj as Gt, ak as jf, al as Dn, am as Hn, an as Us, ao as D, ap as Nf, aq as Y, ar as Ze, as as gi, at as G, au as ae, av as yt, aw as qe, ax as bt, ay as Ue, az as J, aA as zf, aB as Hf, aC as ni, aD as Mt, aE as Kf, aF as gd, aG as Gf, aH as qf, aI as Wr, aJ as bs, aK as Wf, aL as Yf, aM as Fl, aN as _s, aO as Zf, aP as Sn, aQ as Rl, aR as Xf, aS as Mr, aT as Qf, aU as bd, aV as _d, aW as Jf, aX as js, aY as Il, aZ as yd, a_ as wd, a$ as ga, b0 as at, b1 as em, b2 as xd, b3 as Vl, b4 as ba} from "./index-D4L0IM0P.js";
const tm = "" + new URL("../../assets/ImdcPod/textures/AO/ACDU_AO.jpg",import.meta.url).href
  , nm = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: tm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , rm = "" + new URL("../../assets/ImdcPod/textures/AO/CDU_AO.jpg",import.meta.url).href
  , im = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: rm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , sm = "" + new URL("../../assets/ImdcPod/textures/AO/UPS_AO.jpg",import.meta.url).href
  , om = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: sm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , am = "" + new URL("../../assets/ImdcPod/textures/AO/内部_AO.jpg",import.meta.url).href
  , lm = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: am
}, Symbol.toStringTag, {
    value: "Module"
}))
  , cm = "" + new URL("../../assets/ImdcPod/textures/AO/前门_AO.jpg",import.meta.url).href
  , um = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: cm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , dm = "" + new URL("../../assets/ImdcPod/textures/AO/后门_AO.jpg",import.meta.url).href
  , pm = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: dm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , hm = "" + new URL("../../assets/ImdcPod/textures/AO/天窗_AO.jpg",import.meta.url).href
  , fm = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: hm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , mm = "" + new URL("../../assets/ImdcPod/textures/AO/散热塔_AO.jpg",import.meta.url).href
  , vm = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: mm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , gm = "" + new URL("../../assets/ImdcPod/textures/AO/机柜底座_AO.jpg",import.meta.url).href
  , bm = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: gm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , _m = "" + new URL("../../assets/ImdcPod/textures/AO/母线_AO.jpg",import.meta.url).href
  , ym = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: _m
}, Symbol.toStringTag, {
    value: "Module"
}))
  , wm = "" + new URL("../../assets/ImdcPod/textures/AO/母线支架AO.jpg",import.meta.url).href
  , xm = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: wm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Cm = "" + new URL("../../assets/ImdcPod/textures/AO/母线箱_AO.jpg",import.meta.url).href
  , Em = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Cm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Pm = "" + new URL("../../assets/ImdcPod/textures/AO/水泵_AO.jpg",import.meta.url).href
  , Om = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Pm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Tm = "" + new URL("../../assets/ImdcPod/textures/AO/水网_AO.jpg",import.meta.url).href
  , Am = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Tm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Sm = "" + new URL("../../assets/ImdcPod/textures/AO/水网底座_AO.jpg",import.meta.url).href
  , km = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Sm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Mm = "" + new URL("../../assets/ImdcPod/textures/AO/水网接口_AO.jpg",import.meta.url).href
  , Lm = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Mm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Fm = "" + new URL("../../assets/ImdcPod/textures/AO/水网阀门_AO.jpg",import.meta.url).href
  , Rm = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Fm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Im = "" + new URL("../../assets/ImdcPod/textures/AO/空调_AO.jpg",import.meta.url).href
  , Vm = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Im
}, Symbol.toStringTag, {
    value: "Module"
}));
class Dm extends pf {
    constructor(e) {
        super(e),
        this.type = $i
    }
    parse(e) {
        const o = function(T, L) {
            switch (T) {
            case 1:
                throw new Error("THREE.RGBELoader: Read Error: " + (L || ""));
            case 2:
                throw new Error("THREE.RGBELoader: Write Error: " + (L || ""));
            case 3:
                throw new Error("THREE.RGBELoader: Bad File Format: " + (L || ""));
            default:
            case 4:
                throw new Error("THREE.RGBELoader: Memory Error: " + (L || ""))
            }
        }
          , u = `
`
          , d = function(T, L, I) {
            L = L || 1024;
            let B = T.pos
              , V = -1
              , z = 0
              , K = ""
              , A = String.fromCharCode.apply(null, new Uint16Array(T.subarray(B, B + 128)));
            for (; 0 > (V = A.indexOf(u)) && z < L && B < T.byteLength; )
                K += A,
                z += A.length,
                B += 128,
                A += String.fromCharCode.apply(null, new Uint16Array(T.subarray(B, B + 128)));
            return -1 < V ? (T.pos += z + V + 1,
            K + A.slice(0, V)) : !1
        }
          , m = function(T) {
            const L = /^#\?(\S+)/
              , I = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/
              , U = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/
              , B = /^\s*FORMAT=(\S+)\s*$/
              , V = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/
              , z = {
                valid: 0,
                string: "",
                comments: "",
                programtype: "RGBE",
                format: "",
                gamma: 1,
                exposure: 1,
                width: 0,
                height: 0
            };
            let K, A;
            for ((T.pos >= T.byteLength || !(K = d(T))) && o(1, "no header found"),
            (A = K.match(L)) || o(3, "bad initial token"),
            z.valid |= 1,
            z.programtype = A[1],
            z.string += K + `
`; K = d(T),
            K !== !1; ) {
                if (z.string += K + `
`,
                K.charAt(0) === "#") {
                    z.comments += K + `
`;
                    continue
                }
                if ((A = K.match(I)) && (z.gamma = parseFloat(A[1])),
                (A = K.match(U)) && (z.exposure = parseFloat(A[1])),
                (A = K.match(B)) && (z.valid |= 2,
                z.format = A[1]),
                (A = K.match(V)) && (z.valid |= 4,
                z.height = parseInt(A[1], 10),
                z.width = parseInt(A[2], 10)),
                z.valid & 2 && z.valid & 4)
                    break
            }
            return z.valid & 2 || o(3, "missing format specifier"),
            z.valid & 4 || o(3, "missing image size specifier"),
            z
        }
          , g = function(T, L, I) {
            const U = L;
            if (U < 8 || U > 32767 || T[0] !== 2 || T[1] !== 2 || T[2] & 128)
                return new Uint8Array(T);
            U !== (T[2] << 8 | T[3]) && o(3, "wrong scanline width");
            const B = new Uint8Array(4 * L * I);
            B.length || o(4, "unable to allocate buffer space");
            let V = 0
              , z = 0;
            const K = 4 * U
              , A = new Uint8Array(4)
              , X = new Uint8Array(K);
            let de = I;
            for (; de > 0 && z < T.byteLength; ) {
                z + 4 > T.byteLength && o(1),
                A[0] = T[z++],
                A[1] = T[z++],
                A[2] = T[z++],
                A[3] = T[z++],
                (A[0] != 2 || A[1] != 2 || (A[2] << 8 | A[3]) != U) && o(3, "bad rgbe scanline format");
                let pe = 0, Pe;
                for (; pe < K && z < T.byteLength; ) {
                    Pe = T[z++];
                    const _e = Pe > 128;
                    if (_e && (Pe -= 128),
                    (Pe === 0 || pe + Pe > K) && o(3, "bad scanline data"),
                    _e) {
                        const Oe = T[z++];
                        for (let $e = 0; $e < Pe; $e++)
                            X[pe++] = Oe
                    } else
                        X.set(T.subarray(z, z + Pe), pe),
                        pe += Pe,
                        z += Pe
                }
                const Be = U;
                for (let _e = 0; _e < Be; _e++) {
                    let Oe = 0;
                    B[V] = X[_e + Oe],
                    Oe += U,
                    B[V + 1] = X[_e + Oe],
                    Oe += U,
                    B[V + 2] = X[_e + Oe],
                    Oe += U,
                    B[V + 3] = X[_e + Oe],
                    V += 4
                }
                de--
            }
            return B
        }
          , f = function(T, L, I, U) {
            const B = T[L + 3]
              , V = Math.pow(2, B - 128) / 255;
            I[U + 0] = T[L + 0] * V,
            I[U + 1] = T[L + 1] * V,
            I[U + 2] = T[L + 2] * V,
            I[U + 3] = 1
        }
          , h = function(T, L, I, U) {
            const B = T[L + 3]
              , V = Math.pow(2, B - 128) / 255;
            I[U + 0] = Ui.toHalfFloat(Math.min(T[L + 0] * V, 65504)),
            I[U + 1] = Ui.toHalfFloat(Math.min(T[L + 1] * V, 65504)),
            I[U + 2] = Ui.toHalfFloat(Math.min(T[L + 2] * V, 65504)),
            I[U + 3] = Ui.toHalfFloat(1)
        }
          , _ = new Uint8Array(e);
        _.pos = 0;
        const p = m(_)
          , b = p.width
          , y = p.height
          , w = g(_.subarray(_.pos), b, y);
        let x, C, P;
        switch (this.type) {
        case ao:
            P = w.length / 4;
            const T = new Float32Array(P * 4);
            for (let I = 0; I < P; I++)
                f(w, I * 4, T, I * 4);
            x = T,
            C = ao;
            break;
        case $i:
            P = w.length / 4;
            const L = new Uint16Array(P * 4);
            for (let I = 0; I < P; I++)
                h(w, I * 4, L, I * 4);
            x = L,
            C = $i;
            break;
        default:
            throw new Error("THREE.RGBELoader: Unsupported type: " + this.type)
        }
        return {
            width: b,
            height: y,
            data: x,
            header: p.string,
            gamma: p.gamma,
            exposure: p.exposure,
            type: C
        }
    }
    setDataType(e) {
        return this.type = e,
        this
    }
    load(e, n, r, i) {
        function s(o, a) {
            switch (o.type) {
            case ao:
            case $i:
                o.colorSpace = hf,
                o.minFilter = Ml,
                o.magFilter = Ml,
                o.generateMipmaps = !1,
                o.flipY = !0;
                break
            }
            n && n(o, a)
        }
        return super.load(e, s, r, i)
    }
}
class Bm {
    constructor() {
        sn(this, "set", new Set);
        sn(this, "loadingManager", new ff);
        sn(this, "textureLoader", new mf(this.loadingManager));
        sn(this, "rgbeLoader", new Dm(this.loadingManager));
        sn(this, "items");
        sn(this, "hasFinishLoading");
        sn(this, "progress");
        this.hasFinishLoading = !1,
        this.items = [],
        this.progress = 0,
        this.loadingManager.onStart = (e, n, r) => {
            this.set.add(e),
            this.items = Array.from(this.set),
            this.progress = n / r,
            this.hasFinishLoading = !1,
            this.set.clear()
        }
        ,
        this.loadingManager.onLoad = () => {
            this.hasFinishLoading = !0
        }
        ,
        this.loadingManager.onProgress = (e, n, r) => {
            this.set.add(e),
            this.items = Array.from(this.set),
            this.progress = n / r
        }
        ,
        this.loadingManager.onError = e => {
            console.error("加载出错", e)
        }
    }
    loaderOnProgress() {}
    async loaderGLTF(e) {
        const {url: n, onLoad: r=void 0, onProgress: i=this.loaderOnProgress, onError: s=void 0, manager: o=this.loadingManager} = typeof e == "string" ? {
            url: e
        } : e
          , {DRACOLoader: a} = await gt(async () => {
            const {DRACOLoader: d} = await import("./DRACOLoader-DRfW5f7D.js");
            return {
                DRACOLoader: d
            }
        }
        , __vite__mapDeps([0, 1]), import.meta.url)
          , {GLTFLoader: l} = await gt(async () => {
            const {GLTFLoader: d} = await import("./GLTFLoader-Cky4qAiS.js");
            return {
                GLTFLoader: d
            }
        }
        , __vite__mapDeps([2, 1]), import.meta.url)
          , c = new a;
        c.setDecoderPath("./draco/gltf/");
        const u = new l(o);
        return u.setDRACOLoader(c),
        new Promise( (d, m) => {
            u.load(n, function(g) {
                r == null || r(g),
                d(g)
            }, i, s)
        }
        )
    }
    async loaderFbx(e) {
        const {url: n, onLoad: r=void 0, onProgress: i=this.loaderOnProgress, onError: s=void 0, manager: o=this.loadingManager} = typeof e == "string" ? {
            url: e
        } : e
          , {FBXLoader: a} = await gt(async () => {
            const {FBXLoader: c} = await import("./FBXLoader-BkFCIu1-.js");
            return {
                FBXLoader: c
            }
        }
        , __vite__mapDeps([3, 1]), import.meta.url)
          , l = new a(o);
        return new Promise( (c, u) => {
            l.load(n, function(d) {
                r == null || r(d),
                c(d)
            }, i, s)
        }
        )
    }
    loaderGltfTexture(e, n, r=this.loaderOnProgress, i) {
        const s = this.textureLoader.load(e, n, r, i);
        return s.colorSpace = Do,
        s.flipY = !1,
        s
    }
    loaderTexture(e, n, r=this.loaderOnProgress, i) {
        const s = this.textureLoader.load(e, n, r, i);
        return s.colorSpace = Do,
        s
    }
    loaderRgbe(e, n, r=this.loaderOnProgress, i) {
        const s = this.rgbeLoader.load(e, n, r, i);
        return s.mapping = vf,
        s.dispose(),
        s
    }
}
function $m(t, e=100) {
    let n, r = 0, i;
    return function(...s) {
        i = s;
        let o = this
          , a = new Date().getTime()
          , l = e - (a - r);
        l <= 0 || l > e ? (n && (clearTimeout(n),
        n = null),
        r = a,
        t.apply(o, i)) : n || (n = setTimeout( () => {
            r = new Date().getTime(),
            n = null,
            t.apply(o, i)
        }
        , l))
    }
}
const Dl = {
    type: "downObjects"
}
  , ji = {
    type: "moveObjects"
}
  , Bl = {
    type: "upObjects"
}
  , $l = {
    type: "clickObjects"
}
  , Ul = {
    type: "clickPoint2"
}
  , jl = {
    type: "clickPoint3"
};
class Cd extends ud {
    constructor(e, n, r=[], {throttleMs: i=100}={}) {
        super(),
        this.enabled = !0,
        this.recursive = !0,
        this.camera = e,
        this.object3Ds = Array.isArray(r) ? r : [r],
        this.domElement = n || document.body,
        this.enableMoveGetObject = !0;
        const s = this
          , o = new gf;
        this.raycaster = o;
        const a = new vs
          , l = new vs
          , c = new Se;
        let u = null;
        this.getIntersects = m,
        this.setMouse = d;
        function d(b) {
            let {offsetX: y, offsetY: w} = b;
            if (!y) {
                const {left: x, top: C} = s.domElement.getBoundingClientRect();
                y = b.pageX - x,
                w = b.pageY - C
            }
            a.set(y / s.domElement.offsetWidth * 2 - 1, -(w / s.domElement.offsetHeight) * 2 + 1)
        }
        this.getMouse = function() {
            return a
        }
        ;
        function m({m: b=a, c: y=s.camera, s: w=s.object3Ds}={}) {
            return o.setFromCamera(b, y),
            o.intersectObjects(w, s.recursive)
        }
        function g(b, y, w) {
            return b.intersects = y,
            b.event = w,
            b.button = w == null ? void 0 : w.button,
            b
        }
        function f(b) {
            if (d(b),
            !s.enabled)
                return;
            l.copy(a);
            let y = m();
            y.length && (c.copy(y[0].point),
            u = y[0].object),
            g(Dl, y, b),
            s.dispatchEvent(Dl)
        }
        function h(b) {
            var y;
            d(b),
            !(!s.enabled || !((y = s._listeners) != null && y.moveObjects)) && (s.enableMoveGetObject ? (g(ji, m(), b),
            s.dispatchEvent(ji)) : (g(ji, [], b),
            s.dispatchEvent(ji)))
        }
        function _(b) {
            if (d(b),
            !s.enabled)
                return;
            let y = m();
            y.length && y[0].object === u && (g($l, y, b),
            s.dispatchEvent($l),
            c.equals(y[0].point) && (g(jl, y, b),
            s.dispatchEvent(jl))),
            g(Bl, y, b),
            s.dispatchEvent(Bl),
            l.equals(a) && (g(Ul, y, b),
            s.dispatchEvent(Ul))
        }
        function p(b) {
            s.enabled && b.preventDefault()
        }
        s.domElement.addEventListener("contextmenu", p),
        s.domElement.addEventListener("pointerdown", f),
        s.domElement.addEventListener("pointermove", $m(h, i)),
        s.domElement.addEventListener("pointerup", _)
    }
}
class Ed extends bf {
    constructor(e) {
        super(),
        this.element = e || document.createElement("div"),
        this.element.style.position = "absolute",
        this.addEventListener("removed", function() {
            this.traverse(function(n) {
                n.element instanceof Element && n.element.parentNode !== null && n.element.parentNode.removeChild(n.element)
            })
        })
    }
    copy(e, n) {
        return super.copy(e, n),
        this.element = e.element.cloneNode(!0),
        this
    }
}
Ed.prototype.isCSS2DObject = !0;
const on = new Se
  , Nl = new dd
  , zl = new dd
  , Hl = new Se
  , Kl = new Se;
class Um {
    constructor(e=document.createElement("div")) {
        const n = this;
        let r, i, s, o;
        const a = {
            objects: new WeakMap
        };
        e.style.overflow = "hidden",
        this.domElement = e,
        this.getSize = function() {
            return {
                width: r,
                height: i
            }
        }
        ,
        this.render = function(m, g) {
            m.matrixWorldAutoUpdate === !0 && m.updateMatrixWorld(),
            g.parent === null && g.updateMatrixWorld(),
            Nl.copy(g.matrixWorldInverse),
            zl.multiplyMatrices(g.projectionMatrix, Nl),
            l(m, m, g),
            d(m)
        }
        ,
        this.setSize = function(m, g) {
            r = m,
            i = g,
            s = r / 2,
            o = i / 2,
            e.style.width = m + "px",
            e.style.height = g + "px"
        }
        ;
        function l(m, g, f) {
            if (m.isCSS2DObject) {
                m.onBeforeRender(n, g, f),
                on.setFromMatrixPosition(m.matrixWorld),
                on.applyMatrix4(zl);
                const h = m.element;
                /apple/i.test(navigator.vendor) ? h.style.transform = "translate(-50%,-50%) translate(" + Math.round(on.x * s + s) + "px," + Math.round(-on.y * o + o) + "px)" : h.style.transform = "translate(-50%,-50%) translate(" + (on.x * s + s) + "px," + (-on.y * o + o) + "px)",
                h.style.display = m.visible && on.z >= -1 && on.z <= 1 ? "" : "none";
                const _ = {
                    distanceToCameraSquared: c(f, m)
                };
                a.objects.set(m, _),
                h.parentNode !== e && e.appendChild(h),
                m.onAfterRender(n, g, f)
            }
            for (let h = 0, _ = m.children.length; h < _; h++)
                l(m.children[h], g, f)
        }
        function c(m, g) {
            return Hl.setFromMatrixPosition(m.matrixWorld),
            Kl.setFromMatrixPosition(g.matrixWorld),
            Hl.distanceToSquared(Kl)
        }
        function u(m) {
            const g = [];
            return m.traverse(function(f) {
                f.isCSS2DObject && g.push(f)
            }),
            g
        }
        function d(m) {
            const g = u(m).sort(function(h, _) {
                const p = a.objects.get(h).distanceToCameraSquared
                  , b = a.objects.get(_).distanceToCameraSquared;
                return p - b
            })
              , f = g.length;
            for (let h = 0, _ = g.length; h < _; h++)
                g[h].element.style.zIndex = f - h
        }
    }
}
class jm extends pd {
    constructor() {
        super();
        const e = new _f;
        e.deleteAttribute("uv");
        const n = new Bs({
            metalness: 0,
            side: yf
        })
          , r = new kn(e,n);
        r.scale.setScalar(10),
        this.add(r);
        const i = new hd(16777215,50,0,2);
        this.add(i);
        const s = new qr({
            color: 16711680,
            emissive: 16777215,
            emissiveIntensity: 10
        })
          , o = new kn(e,s);
        o.position.set(-5, 2, 0),
        o.scale.set(.1, 1, 1),
        this.add(o);
        const a = new qr({
            color: 65280,
            emissive: 16777215,
            emissiveIntensity: 10
        })
          , l = new kn(e,a);
        l.position.set(0, 5, 0),
        l.scale.set(1, .1, 1),
        this.add(l);
        const c = new qr({
            color: 255,
            emissive: 16777215,
            emissiveIntensity: 10
        })
          , u = new kn(e,c);
        u.position.set(2, 1, 5),
        u.scale.set(1.5, 2, .1),
        this.add(u)
    }
}
class Nm extends ud {
    constructor({container: e, canvas: n, cssEL: r, options: i={}}={}) {
        super(),
        this.clock = new wf,
        this.clocks = {
            delta: 0
        },
        this.container = e,
        this.canvas = n,
        this.cssEL = r;
        const s = this.container.offsetWidth
          , o = this.container.offsetHeight
          , a = s / o
          , l = window.devicePixelRatio;
        this.sizes = {
            width: s,
            height: o,
            aspect: a,
            pixelRatio: l
        },
        this.camera = new xf(60,this.sizes.aspect,.1,2e3),
        this.camera.position.set(0, 0, 5),
        this.scene = new pd,
        this.renderer = new Cf({
            canvas: this.canvas,
            antialias: !0,
            alpha: !0
        }),
        this.renderer.shadowMap.type = fd,
        this.renderer.setPixelRatio(l),
        this.renderer.setSize(s, o),
        this.camera.updateProjectionMatrix(),
        this.css2DRen = new Um(this.cssEL),
        this.css2DRen.setSize(s, o),
        this.orbitControls = null,
        i.orbitControls && this.enabledOrbitControls(),
        this.cameraControls = null,
        i.enabledCameraControls && this.enabledCameraControls(),
        this.packing = new Cd(this.camera,this.canvas,this.scene),
        this.packing.enabled = !1,
        this.loader = new Bm,
        window.addEventListener("resize", this.resetSize.bind(this)),
        this.composer = null,
        this.renderPass = null,
        this.effectFXAA = null,
        this.outlinePass = null,
        this.outputPass = null,
        i.enabledPostprocessing && this.enabledPostprocessing(),
        this.lightGroup = new $s,
        this.lightGroup.name = "lightGroup",
        this.scene.add(this.lightGroup),
        this.defaultSky()
    }
    async enabledPostprocessing(e={}) {
        const {EffectComposer: n} = await gt( () => import("./EffectComposer-BBPlgFtC.js"), __vite__mapDeps([4, 1, 5, 6, 7]), import.meta.url)
          , {RenderPass: r} = await gt( () => import("./RenderPass-DlCygASy.js"), __vite__mapDeps([8, 1, 7]), import.meta.url)
          , {ShaderPass: i} = await gt( () => import("./ShaderPass-CMl3JXW9.js"), __vite__mapDeps([6, 1, 7]), import.meta.url)
          , {FXAAShader: s} = await gt( () => import("./FXAAShader-3Vj3PVLq.js"), __vite__mapDeps([9, 1]), import.meta.url)
          , {OutlinePass: o} = await gt( () => import("./OutlinePass-wl3jTg2D.js"), __vite__mapDeps([10, 1, 7, 5]), import.meta.url)
          , {OutputPass: a} = await gt( () => import("./OutputPass-ihIgfo1d.js"), __vite__mapDeps([11, 1, 7]), import.meta.url);
        this.composer = new n(this.renderer),
        this.renderPass = new r(this.scene,this.camera),
        this.composer.addPass(this.renderPass),
        this.effectFXAA = new i(s),
        this.effectFXAA.uniforms.resolution.value.set(1 / this.sizes.width * this.sizes.pixelRatio, 1 / this.sizes.height * this.sizes.pixelRatio),
        this.composer.addPass(this.effectFXAA),
        this.outlinePass = new o(new vs(this.sizes.width,this.sizes.height),this.scene,this.camera),
        this.composer.addPass(this.outlinePass),
        this.outputPass = new a,
        this.composer.addPass(this.outputPass)
    }
    async enabledOrbitControls(e) {
        if (this.orbitControls)
            return console.warn("OrbitControls already initialized!");
        const {OrbitControls: n} = await gt(async () => {
            const {OrbitControls: i} = await import("./OrbitControls-DvibNlCA.js");
            return {
                OrbitControls: i
            }
        }
        , __vite__mapDeps([12, 1]), import.meta.url)
          , r = new n(this.camera,this.canvas);
        r.minDistance = 1e-6,
        r.enableDamping = !0,
        r.dampingFactor = .2,
        r.update(),
        this.orbitControls = r
    }
    async enabledCameraControls(e) {
        if (this.cameraControls)
            return console.warn("CameraControls is already initialized!");
        const {default: n} = await gt(async () => {
            const {default: i} = await Promise.resolve().then( () => f0);
            return {
                default: i
            }
        }
        , void 0, import.meta.url);
        n.install({
            THREE: md
        });
        const r = new n(this.camera,this.renderer.domElement);
        r.azimuthRotateSpeed = 1,
        r.polarRotateSpeed = 1,
        r.truckSpeed = 1,
        r.dollySpeed = window.innerWidth > 1e3 ? .3 : 1,
        r.mouseButtons.wheel = n.ACTION.DOLLY,
        r.touches.two = n.ACTION.TOUCH_DOLLY_TRUCK,
        this.cameraControls = r
    }
    createDLight(e, n) {
        const r = new Ef(e,n);
        return this.lightGroup.add(r),
        {
            light: r
        }
    }
    createPLight(e, n) {
        const r = new hd(e,n);
        return this.lightGroup.add(r),
        {
            light: r
        }
    }
    createSLight(e, n) {
        const r = new Pf(e,n);
        return this.lightGroup.add(r),
        {
            light: r
        }
    }
    createAmbientLight(e, n) {
        const r = new Of(e,n);
        return this.lightGroup.add(r),
        {
            light: r
        }
    }
    createHLight(e, n, r) {
        const i = new Tf(e,n,r);
        return this.lightGroup.add(i),
        {
            light: i
        }
    }
    defaultSky(e=!0) {
        if (!e)
            return this.scene.environment = null;
        const n = new jm
          , r = new Af(this.renderer);
        this.scene.environment = r.fromScene(n).texture
    }
    updateHDR(e, n, r) {
        return this.loader.loaderRgbe(e, i => {
            this.scene.environment = i,
            n && n(i)
        }
        , r, i => {
            console.error(i)
        }
        )
    }
    resetSize() {
        var s;
        const e = this.sizes.width = this.container.offsetWidth
          , n = this.sizes.height = this.container.offsetHeight
          , r = this.sizes.aspect = e / n
          , i = this.sizes.pixelRatio = window.devicePixelRatio;
        this.renderer.setPixelRatio(window.devicePixelRatio),
        this.camera.aspect = r,
        this.renderer.setSize(e, n),
        this.camera.updateProjectionMatrix(),
        this.css2DRen.setSize(e, n),
        (s = this.composer) == null || s.setSize(e, n),
        this.effectFXAA && this.effectFXAA.uniforms.resolution.value.set(1 / e * i, 1 / n * i)
    }
    render() {
        const e = this.clock.getDelta();
        this.clocks.delta = e,
        this.orbitControls ? this.orbitControls.update() : this.cameraControls && this.cameraControls.update(e),
        this.renderer.render(this.scene, this.camera),
        this.css2DRen.render(this.scene, this.camera)
    }
    renderComposer() {
        var n;
        const e = this.clock.getDelta();
        this.clocks.delta = e,
        this.orbitControls ? this.orbitControls.update() : this.cameraControls && this.cameraControls.update(e),
        (n = this.composer) == null || n.render(),
        this.css2DRen.render(this.scene, this.camera)
    }
    destroyObject3D(e) {
        e.traverse(n => {
            n instanceof kn && (n.geometry.dispose(),
            Array.isArray(n.material) ? n.material.forEach(r => r.dispose()) : n.material.dispose())
        }
        )
    }
    destroy() {
        var e, n, r, i, s, o, a;
        this.destroyObject3D(this.scene),
        this.scene = null,
        this.camera = null,
        this.renderer.dispose(),
        this.renderer.forceContextLoss(),
        this.renderer.context = null,
        this.renderer.domElement = null,
        this.renderer = null,
        (e = this.composer) == null || e.dispose(),
        this.composer = null,
        (n = this.renderPass) == null || n.dispose(),
        this.renderPass = null,
        (r = this.effectFXAA) == null || r.dispose(),
        this.effectFXAA = null,
        (i = this.outlinePass) == null || i.dispose(),
        this.outlinePass = null,
        (s = this.outputPass) == null || s.dispose(),
        this.outputPass = null,
        (o = this.orbitControls) == null || o.dispose(),
        this.orbitControls = null,
        (a = this.cameraControls) == null || a.dispose(),
        this.cameraControls = null
    }
}
var Yr = function() {
    var t = 0
      , e = document.createElement("div");
    e.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",
    e.addEventListener("click", function(u) {
        u.preventDefault(),
        r(++t % e.children.length)
    }, !1);
    function n(u) {
        return e.appendChild(u.dom),
        u
    }
    function r(u) {
        for (var d = 0; d < e.children.length; d++)
            e.children[d].style.display = d === u ? "block" : "none";
        t = u
    }
    var i = (performance || Date).now()
      , s = i
      , o = 0
      , a = n(new Yr.Panel("FPS","#0ff","#002"))
      , l = n(new Yr.Panel("MS","#0f0","#020"));
    if (self.performance && self.performance.memory)
        var c = n(new Yr.Panel("MB","#f08","#201"));
    return r(0),
    {
        REVISION: 16,
        dom: e,
        addPanel: n,
        showPanel: r,
        begin: function() {
            i = (performance || Date).now()
        },
        end: function() {
            o++;
            var u = (performance || Date).now();
            if (l.update(u - i, 200),
            u >= s + 1e3 && (a.update(o * 1e3 / (u - s), 100),
            s = u,
            o = 0,
            c)) {
                var d = performance.memory;
                c.update(d.usedJSHeapSize / 1048576, d.jsHeapSizeLimit / 1048576)
            }
            return u
        },
        update: function() {
            i = this.end()
        },
        domElement: e,
        setMode: r
    }
};
Yr.Panel = function(t, e, n) {
    var r = 1 / 0
      , i = 0
      , s = Math.round
      , o = s(window.devicePixelRatio || 1)
      , a = 80 * o
      , l = 48 * o
      , c = 3 * o
      , u = 2 * o
      , d = 3 * o
      , m = 15 * o
      , g = 74 * o
      , f = 30 * o
      , h = document.createElement("canvas");
    h.width = a,
    h.height = l,
    h.style.cssText = "width:80px;height:48px";
    var _ = h.getContext("2d");
    return _.font = "bold " + 9 * o + "px Helvetica,Arial,sans-serif",
    _.textBaseline = "top",
    _.fillStyle = n,
    _.fillRect(0, 0, a, l),
    _.fillStyle = e,
    _.fillText(t, c, u),
    _.fillRect(d, m, g, f),
    _.fillStyle = n,
    _.globalAlpha = .9,
    _.fillRect(d, m, g, f),
    {
        dom: h,
        update: function(p, b) {
            r = Math.min(r, p),
            i = Math.max(i, p),
            _.fillStyle = n,
            _.globalAlpha = 1,
            _.fillRect(0, 0, a, m),
            _.fillStyle = e,
            _.fillText(s(p) + " " + t + " (" + s(r) + "-" + s(i) + ")", c, u),
            _.drawImage(h, d + o, m, g - o, f, d, m, g - o, f),
            _.fillRect(d + g - o, m, o, f),
            _.fillStyle = n,
            _.globalAlpha = .9,
            _.fillRect(d + g - o, m, o, s((1 - p / b) * f))
        }
    }
}
;
/*! Tweakpane 4.0.4 (c) 2016 cocopon, licensed under the MIT license. */
function ge(t) {
    return t == null
}
function _a(t) {
    return t !== null && typeof t == "object"
}
function Bo(t) {
    return t !== null && typeof t == "object"
}
function zm(t, e) {
    if (t.length !== e.length)
        return !1;
    for (let n = 0; n < t.length; n++)
        if (t[n] !== e[n])
            return !1;
    return !0
}
function Bn(t, e) {
    return Array.from(new Set([...Object.keys(t), ...Object.keys(e)])).reduce( (r, i) => {
        const s = t[i]
          , o = e[i];
        return Bo(s) && Bo(o) ? Object.assign(Object.assign({}, r), {
            [i]: Bn(s, o)
        }) : Object.assign(Object.assign({}, r), {
            [i]: i in e ? o : s
        })
    }
    , {})
}
function ya(t) {
    return _a(t) ? "target"in t : !1
}
const Hm = {
    alreadydisposed: () => "View has been already disposed",
    invalidparams: t => `Invalid parameters for '${t.name}'`,
    nomatchingcontroller: t => `No matching controller for '${t.key}'`,
    nomatchingview: t => `No matching view for '${JSON.stringify(t.params)}'`,
    notbindable: () => "Value is not bindable",
    notcompatible: t => `Not compatible with  plugin '${t.id}'`,
    propertynotfound: t => `Property '${t.name}' not found`,
    shouldneverhappen: () => "This error should never happen"
};
class Te {
    static alreadyDisposed() {
        return new Te({
            type: "alreadydisposed"
        })
    }
    static notBindable() {
        return new Te({
            type: "notbindable"
        })
    }
    static notCompatible(e, n) {
        return new Te({
            type: "notcompatible",
            context: {
                id: `${e}.${n}`
            }
        })
    }
    static propertyNotFound(e) {
        return new Te({
            type: "propertynotfound",
            context: {
                name: e
            }
        })
    }
    static shouldNeverHappen() {
        return new Te({
            type: "shouldneverhappen"
        })
    }
    constructor(e) {
        var n;
        this.message = (n = Hm[e.type](e.context)) !== null && n !== void 0 ? n : "Unexpected error",
        this.name = this.constructor.name,
        this.stack = new Error(this.message).stack,
        this.type = e.type
    }
    toString() {
        return this.message
    }
}
class ys {
    constructor(e, n) {
        this.obj_ = e,
        this.key = n
    }
    static isBindable(e) {
        return !(e === null || typeof e != "object" && typeof e != "function")
    }
    read() {
        return this.obj_[this.key]
    }
    write(e) {
        this.obj_[this.key] = e
    }
    writeProperty(e, n) {
        const r = this.read();
        if (!ys.isBindable(r))
            throw Te.notBindable();
        if (!(e in r))
            throw Te.propertyNotFound(e);
        r[e] = n
    }
}
class Me {
    constructor() {
        this.observers_ = {}
    }
    on(e, n, r) {
        var i;
        let s = this.observers_[e];
        return s || (s = this.observers_[e] = []),
        s.push({
            handler: n,
            key: (i = r == null ? void 0 : r.key) !== null && i !== void 0 ? i : n
        }),
        this
    }
    off(e, n) {
        const r = this.observers_[e];
        return r && (this.observers_[e] = r.filter(i => i.key !== n)),
        this
    }
    emit(e, n) {
        const r = this.observers_[e];
        r && r.forEach(i => {
            i.handler(n)
        }
        )
    }
}
class Km {
    constructor(e, n) {
        var r;
        this.constraint_ = n == null ? void 0 : n.constraint,
        this.equals_ = (r = n == null ? void 0 : n.equals) !== null && r !== void 0 ? r : (i, s) => i === s,
        this.emitter = new Me,
        this.rawValue_ = e
    }
    get constraint() {
        return this.constraint_
    }
    get rawValue() {
        return this.rawValue_
    }
    set rawValue(e) {
        this.setRawValue(e, {
            forceEmit: !1,
            last: !0
        })
    }
    setRawValue(e, n) {
        const r = n ?? {
            forceEmit: !1,
            last: !0
        }
          , i = this.constraint_ ? this.constraint_.constrain(e) : e
          , s = this.rawValue_;
        this.equals_(s, i) && !r.forceEmit || (this.emitter.emit("beforechange", {
            sender: this
        }),
        this.rawValue_ = i,
        this.emitter.emit("change", {
            options: r,
            previousRawValue: s,
            rawValue: i,
            sender: this
        }))
    }
}
class Gm {
    constructor(e) {
        this.emitter = new Me,
        this.value_ = e
    }
    get rawValue() {
        return this.value_
    }
    set rawValue(e) {
        this.setRawValue(e, {
            forceEmit: !1,
            last: !0
        })
    }
    setRawValue(e, n) {
        const r = n ?? {
            forceEmit: !1,
            last: !0
        }
          , i = this.value_;
        i === e && !r.forceEmit || (this.emitter.emit("beforechange", {
            sender: this
        }),
        this.value_ = e,
        this.emitter.emit("change", {
            options: r,
            previousRawValue: i,
            rawValue: this.value_,
            sender: this
        }))
    }
}
class qm {
    constructor(e) {
        this.emitter = new Me,
        this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this),
        this.onValueChange_ = this.onValueChange_.bind(this),
        this.value_ = e,
        this.value_.emitter.on("beforechange", this.onValueBeforeChange_),
        this.value_.emitter.on("change", this.onValueChange_)
    }
    get rawValue() {
        return this.value_.rawValue
    }
    onValueBeforeChange_(e) {
        this.emitter.emit("beforechange", Object.assign(Object.assign({}, e), {
            sender: this
        }))
    }
    onValueChange_(e) {
        this.emitter.emit("change", Object.assign(Object.assign({}, e), {
            sender: this
        }))
    }
}
function ye(t, e) {
    const n = e == null ? void 0 : e.constraint
      , r = e == null ? void 0 : e.equals;
    return !n && !r ? new Gm(t) : new Km(t,e)
}
function Wm(t) {
    return [new qm(t), (e, n) => {
        t.setRawValue(e, n)
    }
    ]
}
class Q {
    constructor(e) {
        this.emitter = new Me,
        this.valMap_ = e;
        for (const n in this.valMap_)
            this.valMap_[n].emitter.on("change", () => {
                this.emitter.emit("change", {
                    key: n,
                    sender: this
                })
            }
            )
    }
    static createCore(e) {
        return Object.keys(e).reduce( (r, i) => Object.assign(r, {
            [i]: ye(e[i])
        }), {})
    }
    static fromObject(e) {
        const n = this.createCore(e);
        return new Q(n)
    }
    get(e) {
        return this.valMap_[e].rawValue
    }
    set(e, n) {
        this.valMap_[e].rawValue = n
    }
    value(e) {
        return this.valMap_[e]
    }
}
class bi {
    constructor(e) {
        this.values = Q.fromObject({
            max: e.max,
            min: e.min
        })
    }
    constrain(e) {
        const n = this.values.get("max")
          , r = this.values.get("min");
        return Math.min(Math.max(e, r), n)
    }
}
class Ym {
    constructor(e) {
        this.values = Q.fromObject({
            max: e.max,
            min: e.min
        })
    }
    constrain(e) {
        const n = this.values.get("max")
          , r = this.values.get("min");
        let i = e;
        return ge(r) || (i = Math.max(i, r)),
        ge(n) || (i = Math.min(i, n)),
        i
    }
}
class Zm {
    constructor(e, n=0) {
        this.step = e,
        this.origin = n
    }
    constrain(e) {
        const n = this.origin % this.step
          , r = Math.round((e - n) / this.step);
        return n + r * this.step
    }
}
class Xm {
    constructor(e) {
        this.text = e
    }
    evaluate() {
        return Number(this.text)
    }
    toString() {
        return this.text
    }
}
const Qm = {
    "**": (t, e) => Math.pow(t, e),
    "*": (t, e) => t * e,
    "/": (t, e) => t / e,
    "%": (t, e) => t % e,
    "+": (t, e) => t + e,
    "-": (t, e) => t - e,
    "<<": (t, e) => t << e,
    ">>": (t, e) => t >> e,
    ">>>": (t, e) => t >>> e,
    "&": (t, e) => t & e,
    "^": (t, e) => t ^ e,
    "|": (t, e) => t | e
};
class Jm {
    constructor(e, n, r) {
        this.left = n,
        this.operator = e,
        this.right = r
    }
    evaluate() {
        const e = Qm[this.operator];
        if (!e)
            throw new Error(`unexpected binary operator: '${this.operator}`);
        return e(this.left.evaluate(), this.right.evaluate())
    }
    toString() {
        return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ")
    }
}
const ev = {
    "+": t => t,
    "-": t => -t,
    "~": t => ~t
};
class tv {
    constructor(e, n) {
        this.operator = e,
        this.expression = n
    }
    evaluate() {
        const e = ev[this.operator];
        if (!e)
            throw new Error(`unexpected unary operator: '${this.operator}`);
        return e(this.expression.evaluate())
    }
    toString() {
        return ["u(", this.operator, this.expression.toString(), ")"].join(" ")
    }
}
function wa(t) {
    return (e, n) => {
        for (let r = 0; r < t.length; r++) {
            const i = t[r](e, n);
            if (i !== "")
                return i
        }
        return ""
    }
}
function ri(t, e) {
    var n;
    const r = t.substr(e).match(/^\s+/);
    return (n = r && r[0]) !== null && n !== void 0 ? n : ""
}
function nv(t, e) {
    const n = t.substr(e, 1);
    return n.match(/^[1-9]$/) ? n : ""
}
function ii(t, e) {
    var n;
    const r = t.substr(e).match(/^[0-9]+/);
    return (n = r && r[0]) !== null && n !== void 0 ? n : ""
}
function rv(t, e) {
    const n = ii(t, e);
    if (n !== "")
        return n;
    const r = t.substr(e, 1);
    if (e += 1,
    r !== "-" && r !== "+")
        return "";
    const i = ii(t, e);
    return i === "" ? "" : r + i
}
function xa(t, e) {
    const n = t.substr(e, 1);
    if (e += 1,
    n.toLowerCase() !== "e")
        return "";
    const r = rv(t, e);
    return r === "" ? "" : n + r
}
function Pd(t, e) {
    const n = t.substr(e, 1);
    if (n === "0")
        return n;
    const r = nv(t, e);
    return e += r.length,
    r === "" ? "" : r + ii(t, e)
}
function iv(t, e) {
    const n = Pd(t, e);
    if (e += n.length,
    n === "")
        return "";
    const r = t.substr(e, 1);
    if (e += r.length,
    r !== ".")
        return "";
    const i = ii(t, e);
    return e += i.length,
    n + r + i + xa(t, e)
}
function sv(t, e) {
    const n = t.substr(e, 1);
    if (e += n.length,
    n !== ".")
        return "";
    const r = ii(t, e);
    return e += r.length,
    r === "" ? "" : n + r + xa(t, e)
}
function ov(t, e) {
    const n = Pd(t, e);
    return e += n.length,
    n === "" ? "" : n + xa(t, e)
}
const av = wa([iv, sv, ov]);
function lv(t, e) {
    var n;
    const r = t.substr(e).match(/^[01]+/);
    return (n = r && r[0]) !== null && n !== void 0 ? n : ""
}
function cv(t, e) {
    const n = t.substr(e, 2);
    if (e += n.length,
    n.toLowerCase() !== "0b")
        return "";
    const r = lv(t, e);
    return r === "" ? "" : n + r
}
function uv(t, e) {
    var n;
    const r = t.substr(e).match(/^[0-7]+/);
    return (n = r && r[0]) !== null && n !== void 0 ? n : ""
}
function dv(t, e) {
    const n = t.substr(e, 2);
    if (e += n.length,
    n.toLowerCase() !== "0o")
        return "";
    const r = uv(t, e);
    return r === "" ? "" : n + r
}
function pv(t, e) {
    var n;
    const r = t.substr(e).match(/^[0-9a-f]+/i);
    return (n = r && r[0]) !== null && n !== void 0 ? n : ""
}
function hv(t, e) {
    const n = t.substr(e, 2);
    if (e += n.length,
    n.toLowerCase() !== "0x")
        return "";
    const r = pv(t, e);
    return r === "" ? "" : n + r
}
const fv = wa([cv, dv, hv])
  , mv = wa([fv, av]);
function vv(t, e) {
    const n = mv(t, e);
    return e += n.length,
    n === "" ? null : {
        evaluable: new Xm(n),
        cursor: e
    }
}
function gv(t, e) {
    const n = t.substr(e, 1);
    if (e += n.length,
    n !== "(")
        return null;
    const r = Td(t, e);
    if (!r)
        return null;
    e = r.cursor,
    e += ri(t, e).length;
    const i = t.substr(e, 1);
    return e += i.length,
    i !== ")" ? null : {
        evaluable: r.evaluable,
        cursor: e
    }
}
function bv(t, e) {
    var n;
    return (n = vv(t, e)) !== null && n !== void 0 ? n : gv(t, e)
}
function Od(t, e) {
    const n = bv(t, e);
    if (n)
        return n;
    const r = t.substr(e, 1);
    if (e += r.length,
    r !== "+" && r !== "-" && r !== "~")
        return null;
    const i = Od(t, e);
    return i ? (e = i.cursor,
    {
        cursor: e,
        evaluable: new tv(r,i.evaluable)
    }) : null
}
function _v(t, e, n) {
    n += ri(e, n).length;
    const r = t.filter(i => e.startsWith(i, n))[0];
    return r ? (n += r.length,
    n += ri(e, n).length,
    {
        cursor: n,
        operator: r
    }) : null
}
function yv(t, e) {
    return (n, r) => {
        const i = t(n, r);
        if (!i)
            return null;
        r = i.cursor;
        let s = i.evaluable;
        for (; ; ) {
            const o = _v(e, n, r);
            if (!o)
                break;
            r = o.cursor;
            const a = t(n, r);
            if (!a)
                return null;
            r = a.cursor,
            s = new Jm(o.operator,s,a.evaluable)
        }
        return s ? {
            cursor: r,
            evaluable: s
        } : null
    }
}
const wv = [["**"], ["*", "/", "%"], ["+", "-"], ["<<", ">>>", ">>"], ["&"], ["^"], ["|"]].reduce( (t, e) => yv(t, e), Od);
function Td(t, e) {
    return e += ri(t, e).length,
    wv(t, e)
}
function xv(t) {
    const e = Td(t, 0);
    return !e || e.cursor + ri(t, e.cursor).length !== t.length ? null : e.evaluable
}
function Xt(t) {
    var e;
    const n = xv(t);
    return (e = n == null ? void 0 : n.evaluate()) !== null && e !== void 0 ? e : null
}
function Ad(t) {
    if (typeof t == "number")
        return t;
    if (typeof t == "string") {
        const e = Xt(t);
        if (!ge(e))
            return e
    }
    return 0
}
function Cv(t) {
    return String(t)
}
function et(t) {
    return e => e.toFixed(Math.max(Math.min(t, 20), 0))
}
function ue(t, e, n, r, i) {
    const s = (t - e) / (n - e);
    return r + s * (i - r)
}
function Gl(t) {
    return String(t.toFixed(10)).split(".")[1].replace(/0+$/, "").length
}
function Le(t, e, n) {
    return Math.min(Math.max(t, e), n)
}
function Sd(t, e) {
    return (t % e + e) % e
}
function Ev(t, e) {
    return ge(t.step) ? Math.max(Gl(e), 2) : Gl(t.step)
}
function kd(t) {
    var e;
    return (e = t.step) !== null && e !== void 0 ? e : 1
}
function Md(t, e) {
    var n;
    const r = Math.abs((n = t.step) !== null && n !== void 0 ? n : e);
    return r === 0 ? .1 : Math.pow(10, Math.floor(Math.log10(r)) - 1)
}
function Ld(t, e) {
    return ge(t.step) ? null : new Zm(t.step,e)
}
function Fd(t) {
    return !ge(t.max) && !ge(t.min) ? new bi({
        max: t.max,
        min: t.min
    }) : !ge(t.max) || !ge(t.min) ? new Ym({
        max: t.max,
        min: t.min
    }) : null
}
function Rd(t, e) {
    var n, r, i;
    return {
        formatter: (n = t.format) !== null && n !== void 0 ? n : et(Ev(t, e)),
        keyScale: (r = t.keyScale) !== null && r !== void 0 ? r : kd(t),
        pointerScale: (i = t.pointerScale) !== null && i !== void 0 ? i : Md(t, e)
    }
}
function Id(t) {
    return {
        format: t.optional.function,
        keyScale: t.optional.number,
        max: t.optional.number,
        min: t.optional.number,
        pointerScale: t.optional.number,
        step: t.optional.number
    }
}
function Ca(t) {
    return {
        constraint: t.constraint,
        textProps: Q.fromObject(Rd(t.params, t.initialValue))
    }
}
class Kn {
    constructor(e) {
        this.controller = e
    }
    get element() {
        return this.controller.view.element
    }
    get disabled() {
        return this.controller.viewProps.get("disabled")
    }
    set disabled(e) {
        this.controller.viewProps.set("disabled", e)
    }
    get hidden() {
        return this.controller.viewProps.get("hidden")
    }
    set hidden(e) {
        this.controller.viewProps.set("hidden", e)
    }
    dispose() {
        this.controller.viewProps.set("disposed", !0)
    }
    importState(e) {
        return this.controller.importState(e)
    }
    exportState() {
        return this.controller.exportState()
    }
}
class Ns {
    constructor(e) {
        this.target = e
    }
}
class _i extends Ns {
    constructor(e, n, r) {
        super(e),
        this.value = n,
        this.last = r ?? !0
    }
}
class Pv extends Ns {
    constructor(e, n) {
        super(e),
        this.expanded = n
    }
}
class Ov extends Ns {
    constructor(e, n) {
        super(e),
        this.index = n
    }
}
class Tv extends Ns {
    constructor(e, n) {
        super(e),
        this.native = n
    }
}
class si extends Kn {
    constructor(e) {
        super(e),
        this.onValueChange_ = this.onValueChange_.bind(this),
        this.emitter_ = new Me,
        this.controller.value.emitter.on("change", this.onValueChange_)
    }
    get label() {
        return this.controller.labelController.props.get("label")
    }
    set label(e) {
        this.controller.labelController.props.set("label", e)
    }
    get key() {
        return this.controller.value.binding.target.key
    }
    get tag() {
        return this.controller.tag
    }
    set tag(e) {
        this.controller.tag = e
    }
    on(e, n) {
        const r = n.bind(this);
        return this.emitter_.on(e, i => {
            r(i)
        }
        , {
            key: n
        }),
        this
    }
    off(e, n) {
        return this.emitter_.off(e, n),
        this
    }
    refresh() {
        this.controller.value.fetch()
    }
    onValueChange_(e) {
        const n = this.controller.value;
        this.emitter_.emit("change", new _i(this,n.binding.target.read(),e.options.last))
    }
}
class Av {
    constructor(e, n) {
        this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this),
        this.onValueChange_ = this.onValueChange_.bind(this),
        this.binding = n,
        this.value_ = e,
        this.value_.emitter.on("beforechange", this.onValueBeforeChange_),
        this.value_.emitter.on("change", this.onValueChange_),
        this.emitter = new Me
    }
    get rawValue() {
        return this.value_.rawValue
    }
    set rawValue(e) {
        this.value_.rawValue = e
    }
    setRawValue(e, n) {
        this.value_.setRawValue(e, n)
    }
    fetch() {
        this.value_.rawValue = this.binding.read()
    }
    push() {
        this.binding.write(this.value_.rawValue)
    }
    onValueBeforeChange_(e) {
        this.emitter.emit("beforechange", Object.assign(Object.assign({}, e), {
            sender: this
        }))
    }
    onValueChange_(e) {
        this.push(),
        this.emitter.emit("change", Object.assign(Object.assign({}, e), {
            sender: this
        }))
    }
}
function Sv(t) {
    if (!("binding"in t))
        return !1;
    const e = t.binding;
    return ya(e) && "read"in e && "write"in e
}
function kv(t, e) {
    const r = Object.keys(e).reduce( (i, s) => {
        if (i === void 0)
            return;
        const o = e[s]
          , a = o(t[s]);
        return a.succeeded ? Object.assign(Object.assign({}, i), {
            [s]: a.value
        }) : void 0
    }
    , {});
    return r
}
function Mv(t, e) {
    return t.reduce( (n, r) => {
        if (n === void 0)
            return;
        const i = e(r);
        if (!(!i.succeeded || i.value === void 0))
            return [...n, i.value]
    }
    , [])
}
function Lv(t) {
    return t === null ? !1 : typeof t == "object"
}
function jt(t) {
    return e => n => {
        if (!e && n === void 0)
            return {
                succeeded: !1,
                value: void 0
            };
        if (e && n === void 0)
            return {
                succeeded: !0,
                value: void 0
            };
        const r = t(n);
        return r !== void 0 ? {
            succeeded: !0,
            value: r
        } : {
            succeeded: !1,
            value: void 0
        }
    }
}
function ql(t) {
    return {
        custom: e => jt(e)(t),
        boolean: jt(e => typeof e == "boolean" ? e : void 0)(t),
        number: jt(e => typeof e == "number" ? e : void 0)(t),
        string: jt(e => typeof e == "string" ? e : void 0)(t),
        function: jt(e => typeof e == "function" ? e : void 0)(t),
        constant: e => jt(n => n === e ? e : void 0)(t),
        raw: jt(e => e)(t),
        object: e => jt(n => {
            if (Lv(n))
                return kv(n, e)
        }
        )(t),
        array: e => jt(n => {
            if (Array.isArray(n))
                return Mv(n, e)
        }
        )(t)
    }
}
const $o = {
    optional: ql(!0),
    required: ql(!1)
};
function Ee(t, e) {
    const n = e($o)
      , r = $o.required.object(n)(t);
    return r.succeeded ? r.value : void 0
}
function rt(t, e, n, r) {
    if (e && !e(t))
        return !1;
    const i = Ee(t, n);
    return i ? r(i) : !1
}
function it(t, e) {
    var n;
    return Bn((n = t == null ? void 0 : t()) !== null && n !== void 0 ? n : {}, e)
}
function Rn(t) {
    return "value"in t
}
function Vd(t) {
    if (!_a(t) || !("binding"in t))
        return !1;
    const e = t.binding;
    return ya(e)
}
const kt = "http://www.w3.org/2000/svg";
function ws(t) {
    t.offsetHeight
}
function Fv(t, e) {
    const n = t.style.transition;
    t.style.transition = "none",
    e(),
    t.style.transition = n
}
function Ea(t) {
    return t.ontouchstart !== void 0
}
function Rv() {
    return globalThis
}
function Iv() {
    return Rv().document
}
function Vv(t) {
    const e = t.ownerDocument.defaultView;
    return e && "document"in e ? t.getContext("2d", {
        willReadFrequently: !0
    }) : null
}
const Dv = {
    check: '<path d="M2 8l4 4l8 -8"/>',
    dropdown: '<path d="M5 7h6l-3 3 z"/>',
    p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
};
function zs(t, e) {
    const n = t.createElementNS(kt, "svg");
    return n.innerHTML = Dv[e],
    n
}
function Dd(t, e, n) {
    t.insertBefore(e, t.children[n])
}
function Pa(t) {
    t.parentElement && t.parentElement.removeChild(t)
}
function Bd(t) {
    for (; t.children.length > 0; )
        t.removeChild(t.children[0])
}
function Bv(t) {
    for (; t.childNodes.length > 0; )
        t.removeChild(t.childNodes[0])
}
function $d(t) {
    return t.relatedTarget ? t.relatedTarget : "explicitOriginalTarget"in t ? t.explicitOriginalTarget : null
}
function Yt(t, e) {
    t.emitter.on("change", n => {
        e(n.rawValue)
    }
    ),
    e(t.rawValue)
}
function Ft(t, e, n) {
    Yt(t.value(e), n)
}
const $v = "tp";
function ie(t) {
    return (n, r) => [$v, "-", t, "v", n ? `_${n}` : "", r ? `-${r}` : ""].join("")
}
const Lr = ie("lbl");
function Uv(t, e) {
    const n = t.createDocumentFragment();
    return e.split(`
`).map(i => t.createTextNode(i)).forEach( (i, s) => {
        s > 0 && n.appendChild(t.createElement("br")),
        n.appendChild(i)
    }
    ),
    n
}
class Ud {
    constructor(e, n) {
        this.element = e.createElement("div"),
        this.element.classList.add(Lr()),
        n.viewProps.bindClassModifiers(this.element);
        const r = e.createElement("div");
        r.classList.add(Lr("l")),
        Ft(n.props, "label", s => {
            ge(s) ? this.element.classList.add(Lr(void 0, "nol")) : (this.element.classList.remove(Lr(void 0, "nol")),
            Bv(r),
            r.appendChild(Uv(e, s)))
        }
        ),
        this.element.appendChild(r),
        this.labelElement = r;
        const i = e.createElement("div");
        i.classList.add(Lr("v")),
        this.element.appendChild(i),
        this.valueElement = i
    }
}
class jd {
    constructor(e, n) {
        this.props = n.props,
        this.valueController = n.valueController,
        this.viewProps = n.valueController.viewProps,
        this.view = new Ud(e,{
            props: n.props,
            viewProps: this.viewProps
        }),
        this.view.valueElement.appendChild(this.valueController.view.element)
    }
    importProps(e) {
        return rt(e, null, n => ({
            label: n.optional.string
        }), n => (this.props.set("label", n.label),
        !0))
    }
    exportProps() {
        return it(null, {
            label: this.props.get("label")
        })
    }
}
function jv() {
    return ["veryfirst", "first", "last", "verylast"]
}
const Wl = ie("")
  , Yl = {
    veryfirst: "vfst",
    first: "fst",
    last: "lst",
    verylast: "vlst"
};
class Hs {
    constructor(e) {
        this.parent_ = null,
        this.blade = e.blade,
        this.view = e.view,
        this.viewProps = e.viewProps;
        const n = this.view.element;
        this.blade.value("positions").emitter.on("change", () => {
            jv().forEach(r => {
                n.classList.remove(Wl(void 0, Yl[r]))
            }
            ),
            this.blade.get("positions").forEach(r => {
                n.classList.add(Wl(void 0, Yl[r]))
            }
            )
        }
        ),
        this.viewProps.handleDispose( () => {
            Pa(n)
        }
        )
    }
    get parent() {
        return this.parent_
    }
    set parent(e) {
        this.parent_ = e,
        this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null)
    }
    importState(e) {
        return rt(e, null, n => ({
            disabled: n.required.boolean,
            hidden: n.required.boolean
        }), n => (this.viewProps.importState(n),
        !0))
    }
    exportState() {
        return it(null, Object.assign({}, this.viewProps.exportState()))
    }
}
class $n extends Hs {
    constructor(e, n) {
        if (n.value !== n.valueController.value)
            throw Te.shouldNeverHappen();
        const r = n.valueController.viewProps
          , i = new jd(e,{
            blade: n.blade,
            props: n.props,
            valueController: n.valueController
        });
        super(Object.assign(Object.assign({}, n), {
            view: new Ud(e,{
                props: n.props,
                viewProps: r
            }),
            viewProps: r
        })),
        this.labelController = i,
        this.value = n.value,
        this.valueController = n.valueController,
        this.view.valueElement.appendChild(this.valueController.view.element)
    }
    importState(e) {
        return rt(e, n => {
            var r, i, s;
            return super.importState(n) && this.labelController.importProps(n) && ((s = (i = (r = this.valueController).importProps) === null || i === void 0 ? void 0 : i.call(r, e)) !== null && s !== void 0 ? s : !0)
        }
        , n => ({
            value: n.optional.raw
        }), n => (n.value && (this.value.rawValue = n.value),
        !0))
    }
    exportState() {
        var e, n, r;
        return it( () => super.exportState(), Object.assign(Object.assign({
            value: this.value.rawValue
        }, this.labelController.exportProps()), (r = (n = (e = this.valueController).exportProps) === null || n === void 0 ? void 0 : n.call(e)) !== null && r !== void 0 ? r : {}))
    }
}
function Zl(t) {
    const e = Object.assign({}, t);
    return delete e.value,
    e
}
class Nd extends $n {
    constructor(e, n) {
        super(e, n),
        this.tag = n.tag
    }
    importState(e) {
        return rt(e, n => super.importState(Zl(e)), n => ({
            tag: n.optional.string
        }), n => (this.tag = n.tag,
        !0))
    }
    exportState() {
        return it( () => Zl(super.exportState()), {
            binding: {
                key: this.value.binding.target.key,
                value: this.value.binding.target.read()
            },
            tag: this.tag
        })
    }
}
function Nv(t) {
    return Rn(t) && Vd(t.value)
}
class zv extends Nd {
    importState(e) {
        return rt(e, n => super.importState(n), n => ({
            binding: n.required.object({
                value: n.required.raw
            })
        }), n => (this.value.binding.inject(n.binding.value),
        this.value.fetch(),
        !0))
    }
}
function Hv(t) {
    return Rn(t) && Sv(t.value)
}
function zd(t, e) {
    for (; t.length < e; )
        t.push(void 0)
}
function Kv(t) {
    const e = [];
    return zd(e, t),
    e
}
function Gv(t) {
    const e = t.indexOf(void 0);
    return e < 0 ? t : t.slice(0, e)
}
function qv(t, e) {
    const n = [...Gv(t), e];
    return n.length > t.length ? n.splice(0, n.length - t.length) : zd(n, t.length),
    n
}
class Wv {
    constructor(e) {
        this.emitter = new Me,
        this.onTick_ = this.onTick_.bind(this),
        this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this),
        this.onValueChange_ = this.onValueChange_.bind(this),
        this.binding = e.binding,
        this.value_ = ye(Kv(e.bufferSize)),
        this.value_.emitter.on("beforechange", this.onValueBeforeChange_),
        this.value_.emitter.on("change", this.onValueChange_),
        this.ticker = e.ticker,
        this.ticker.emitter.on("tick", this.onTick_),
        this.fetch()
    }
    get rawValue() {
        return this.value_.rawValue
    }
    set rawValue(e) {
        this.value_.rawValue = e
    }
    setRawValue(e, n) {
        this.value_.setRawValue(e, n)
    }
    fetch() {
        this.value_.rawValue = qv(this.value_.rawValue, this.binding.read())
    }
    onTick_() {
        this.fetch()
    }
    onValueBeforeChange_(e) {
        this.emitter.emit("beforechange", Object.assign(Object.assign({}, e), {
            sender: this
        }))
    }
    onValueChange_(e) {
        this.emitter.emit("change", Object.assign(Object.assign({}, e), {
            sender: this
        }))
    }
}
function Yv(t) {
    if (!("binding"in t))
        return !1;
    const e = t.binding;
    return ya(e) && "read"in e && !("write"in e)
}
class Zv extends Nd {
    exportState() {
        return it( () => super.exportState(), {
            binding: {
                readonly: !0
            }
        })
    }
}
function Xv(t) {
    return Rn(t) && Yv(t.value)
}
class Qv extends Kn {
    get label() {
        return this.controller.labelController.props.get("label")
    }
    set label(e) {
        this.controller.labelController.props.set("label", e)
    }
    get title() {
        var e;
        return (e = this.controller.buttonController.props.get("title")) !== null && e !== void 0 ? e : ""
    }
    set title(e) {
        this.controller.buttonController.props.set("title", e)
    }
    on(e, n) {
        const r = n.bind(this);
        return this.controller.buttonController.emitter.on(e, s => {
            r(new Tv(this,s.nativeEvent))
        }
        ),
        this
    }
    off(e, n) {
        return this.controller.buttonController.emitter.off(e, n),
        this
    }
}
function Jv(t, e, n) {
    n ? t.classList.add(e) : t.classList.remove(e)
}
function _r(t, e) {
    return n => {
        Jv(t, e, n)
    }
}
function Oa(t, e) {
    Yt(t, n => {
        e.textContent = n ?? ""
    }
    )
}
const lo = ie("btn");
class eg {
    constructor(e, n) {
        this.element = e.createElement("div"),
        this.element.classList.add(lo()),
        n.viewProps.bindClassModifiers(this.element);
        const r = e.createElement("button");
        r.classList.add(lo("b")),
        n.viewProps.bindDisabled(r),
        this.element.appendChild(r),
        this.buttonElement = r;
        const i = e.createElement("div");
        i.classList.add(lo("t")),
        Oa(n.props.value("title"), i),
        this.buttonElement.appendChild(i)
    }
}
class tg {
    constructor(e, n) {
        this.emitter = new Me,
        this.onClick_ = this.onClick_.bind(this),
        this.props = n.props,
        this.viewProps = n.viewProps,
        this.view = new eg(e,{
            props: this.props,
            viewProps: this.viewProps
        }),
        this.view.buttonElement.addEventListener("click", this.onClick_)
    }
    importProps(e) {
        return rt(e, null, n => ({
            title: n.optional.string
        }), n => (this.props.set("title", n.title),
        !0))
    }
    exportProps() {
        return it(null, {
            title: this.props.get("title")
        })
    }
    onClick_(e) {
        this.emitter.emit("click", {
            nativeEvent: e,
            sender: this
        })
    }
}
class Xl extends Hs {
    constructor(e, n) {
        const r = new tg(e,{
            props: n.buttonProps,
            viewProps: n.viewProps
        })
          , i = new jd(e,{
            blade: n.blade,
            props: n.labelProps,
            valueController: r
        });
        super({
            blade: n.blade,
            view: i.view,
            viewProps: n.viewProps
        }),
        this.buttonController = r,
        this.labelController = i
    }
    importState(e) {
        return rt(e, n => super.importState(n) && this.buttonController.importProps(n) && this.labelController.importProps(n), () => ({}), () => !0)
    }
    exportState() {
        return it( () => super.exportState(), Object.assign(Object.assign({}, this.buttonController.exportProps()), this.labelController.exportProps()))
    }
}
class Hd {
    constructor(e) {
        const [n,r] = e.split("-")
          , i = n.split(".");
        this.major = parseInt(i[0], 10),
        this.minor = parseInt(i[1], 10),
        this.patch = parseInt(i[2], 10),
        this.prerelease = r ?? null
    }
    toString() {
        const e = [this.major, this.minor, this.patch].join(".");
        return this.prerelease !== null ? [e, this.prerelease].join("-") : e
    }
}
const yr = new Hd("2.0.4");
function We(t) {
    return Object.assign({
        core: yr
    }, t)
}
const ng = We({
    id: "button",
    type: "blade",
    accept(t) {
        const e = Ee(t, n => ({
            title: n.required.string,
            view: n.required.constant("button"),
            label: n.optional.string
        }));
        return e ? {
            params: e
        } : null
    },
    controller(t) {
        return new Xl(t.document,{
            blade: t.blade,
            buttonProps: Q.fromObject({
                title: t.params.title
            }),
            labelProps: Q.fromObject({
                label: t.params.label
            }),
            viewProps: t.viewProps
        })
    },
    api(t) {
        return t.controller instanceof Xl ? new Qv(t.controller) : null
    }
});
function rg(t, e) {
    return t.addBlade(Object.assign(Object.assign({}, e), {
        view: "button"
    }))
}
function ig(t, e) {
    return t.addBlade(Object.assign(Object.assign({}, e), {
        view: "folder"
    }))
}
function sg(t, e) {
    return t.addBlade(Object.assign(Object.assign({}, e), {
        view: "tab"
    }))
}
function og(t) {
    return _a(t) ? "refresh"in t && typeof t.refresh == "function" : !1
}
function ag(t, e) {
    if (!ys.isBindable(t))
        throw Te.notBindable();
    return new ys(t,e)
}
class lg {
    constructor(e, n) {
        this.onRackValueChange_ = this.onRackValueChange_.bind(this),
        this.controller_ = e,
        this.emitter_ = new Me,
        this.pool_ = n,
        this.controller_.rack.emitter.on("valuechange", this.onRackValueChange_)
    }
    get children() {
        return this.controller_.rack.children.map(e => this.pool_.createApi(e))
    }
    addBinding(e, n, r) {
        const i = r ?? {}
          , s = this.controller_.element.ownerDocument
          , o = this.pool_.createBinding(s, ag(e, n), i)
          , a = this.pool_.createBindingApi(o);
        return this.add(a, i.index)
    }
    addFolder(e) {
        return ig(this, e)
    }
    addButton(e) {
        return rg(this, e)
    }
    addTab(e) {
        return sg(this, e)
    }
    add(e, n) {
        const r = e.controller;
        return this.controller_.rack.add(r, n),
        e
    }
    remove(e) {
        this.controller_.rack.remove(e.controller)
    }
    addBlade(e) {
        const n = this.controller_.element.ownerDocument
          , r = this.pool_.createBlade(n, e)
          , i = this.pool_.createApi(r);
        return this.add(i, e.index)
    }
    on(e, n) {
        const r = n.bind(this);
        return this.emitter_.on(e, i => {
            r(i)
        }
        , {
            key: n
        }),
        this
    }
    off(e, n) {
        return this.emitter_.off(e, n),
        this
    }
    refresh() {
        this.children.forEach(e => {
            og(e) && e.refresh()
        }
        )
    }
    onRackValueChange_(e) {
        const n = e.bladeController
          , r = this.pool_.createApi(n)
          , i = Vd(n.value) ? n.value.binding : null;
        this.emitter_.emit("change", new _i(r,i ? i.target.read() : n.value.rawValue,e.options.last))
    }
}
class Ta extends Kn {
    constructor(e, n) {
        super(e),
        this.rackApi_ = new lg(e.rackController,n)
    }
    refresh() {
        this.rackApi_.refresh()
    }
}
class Aa extends Hs {
    constructor(e) {
        super({
            blade: e.blade,
            view: e.view,
            viewProps: e.rackController.viewProps
        }),
        this.rackController = e.rackController
    }
    importState(e) {
        return rt(e, n => super.importState(n), n => ({
            children: n.required.array(n.required.raw)
        }), n => this.rackController.rack.children.every( (r, i) => r.importState(n.children[i])))
    }
    exportState() {
        return it( () => super.exportState(), {
            children: this.rackController.rack.children.map(e => e.exportState())
        })
    }
}
function Uo(t) {
    return "rackController"in t
}
class cg {
    constructor(e) {
        this.emitter = new Me,
        this.items_ = [],
        this.cache_ = new Set,
        this.onSubListAdd_ = this.onSubListAdd_.bind(this),
        this.onSubListRemove_ = this.onSubListRemove_.bind(this),
        this.extract_ = e
    }
    get items() {
        return this.items_
    }
    allItems() {
        return Array.from(this.cache_)
    }
    find(e) {
        for (const n of this.allItems())
            if (e(n))
                return n;
        return null
    }
    includes(e) {
        return this.cache_.has(e)
    }
    add(e, n) {
        if (this.includes(e))
            throw Te.shouldNeverHappen();
        const r = n !== void 0 ? n : this.items_.length;
        this.items_.splice(r, 0, e),
        this.cache_.add(e);
        const i = this.extract_(e);
        i && (i.emitter.on("add", this.onSubListAdd_),
        i.emitter.on("remove", this.onSubListRemove_),
        i.allItems().forEach(s => {
            this.cache_.add(s)
        }
        )),
        this.emitter.emit("add", {
            index: r,
            item: e,
            root: this,
            target: this
        })
    }
    remove(e) {
        const n = this.items_.indexOf(e);
        if (n < 0)
            return;
        this.items_.splice(n, 1),
        this.cache_.delete(e);
        const r = this.extract_(e);
        r && (r.allItems().forEach(i => {
            this.cache_.delete(i)
        }
        ),
        r.emitter.off("add", this.onSubListAdd_),
        r.emitter.off("remove", this.onSubListRemove_)),
        this.emitter.emit("remove", {
            index: n,
            item: e,
            root: this,
            target: this
        })
    }
    onSubListAdd_(e) {
        this.cache_.add(e.item),
        this.emitter.emit("add", {
            index: e.index,
            item: e.item,
            root: this,
            target: e.target
        })
    }
    onSubListRemove_(e) {
        this.cache_.delete(e.item),
        this.emitter.emit("remove", {
            index: e.index,
            item: e.item,
            root: this,
            target: e.target
        })
    }
}
function ug(t, e) {
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        if (Rn(r) && r.value === e)
            return r
    }
    return null
}
function dg(t) {
    return Uo(t) ? t.rackController.rack.bcSet_ : null
}
class pg {
    constructor(e) {
        var n, r;
        this.emitter = new Me,
        this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this),
        this.onSetAdd_ = this.onSetAdd_.bind(this),
        this.onSetRemove_ = this.onSetRemove_.bind(this),
        this.onChildDispose_ = this.onChildDispose_.bind(this),
        this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this),
        this.onChildValueChange_ = this.onChildValueChange_.bind(this),
        this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this),
        this.onRackLayout_ = this.onRackLayout_.bind(this),
        this.onRackValueChange_ = this.onRackValueChange_.bind(this),
        this.blade_ = (n = e.blade) !== null && n !== void 0 ? n : null,
        (r = this.blade_) === null || r === void 0 || r.value("positions").emitter.on("change", this.onBladePositionsChange_),
        this.viewProps = e.viewProps,
        this.bcSet_ = new cg(dg),
        this.bcSet_.emitter.on("add", this.onSetAdd_),
        this.bcSet_.emitter.on("remove", this.onSetRemove_)
    }
    get children() {
        return this.bcSet_.items
    }
    add(e, n) {
        var r;
        (r = e.parent) === null || r === void 0 || r.remove(e),
        e.parent = this,
        this.bcSet_.add(e, n)
    }
    remove(e) {
        e.parent = null,
        this.bcSet_.remove(e)
    }
    find(e) {
        return this.bcSet_.allItems().filter(e)
    }
    onSetAdd_(e) {
        this.updatePositions_();
        const n = e.target === e.root;
        if (this.emitter.emit("add", {
            bladeController: e.item,
            index: e.index,
            root: n,
            sender: this
        }),
        !n)
            return;
        const r = e.item;
        if (r.viewProps.emitter.on("change", this.onChildViewPropsChange_),
        r.blade.value("positions").emitter.on("change", this.onChildPositionsChange_),
        r.viewProps.handleDispose(this.onChildDispose_),
        Rn(r))
            r.value.emitter.on("change", this.onChildValueChange_);
        else if (Uo(r)) {
            const i = r.rackController.rack;
            if (i) {
                const s = i.emitter;
                s.on("layout", this.onRackLayout_),
                s.on("valuechange", this.onRackValueChange_)
            }
        }
    }
    onSetRemove_(e) {
        this.updatePositions_();
        const n = e.target === e.root;
        if (this.emitter.emit("remove", {
            bladeController: e.item,
            root: n,
            sender: this
        }),
        !n)
            return;
        const r = e.item;
        if (Rn(r))
            r.value.emitter.off("change", this.onChildValueChange_);
        else if (Uo(r)) {
            const i = r.rackController.rack;
            if (i) {
                const s = i.emitter;
                s.off("layout", this.onRackLayout_),
                s.off("valuechange", this.onRackValueChange_)
            }
        }
    }
    updatePositions_() {
        const e = this.bcSet_.items.filter(i => !i.viewProps.get("hidden"))
          , n = e[0]
          , r = e[e.length - 1];
        this.bcSet_.items.forEach(i => {
            const s = [];
            i === n && (s.push("first"),
            (!this.blade_ || this.blade_.get("positions").includes("veryfirst")) && s.push("veryfirst")),
            i === r && (s.push("last"),
            (!this.blade_ || this.blade_.get("positions").includes("verylast")) && s.push("verylast")),
            i.blade.set("positions", s)
        }
        )
    }
    onChildPositionsChange_() {
        this.updatePositions_(),
        this.emitter.emit("layout", {
            sender: this
        })
    }
    onChildViewPropsChange_(e) {
        this.updatePositions_(),
        this.emitter.emit("layout", {
            sender: this
        })
    }
    onChildDispose_() {
        this.bcSet_.items.filter(n => n.viewProps.get("disposed")).forEach(n => {
            this.bcSet_.remove(n)
        }
        )
    }
    onChildValueChange_(e) {
        const n = ug(this.find(Rn), e.sender);
        if (!n)
            throw Te.alreadyDisposed();
        this.emitter.emit("valuechange", {
            bladeController: n,
            options: e.options,
            sender: this
        })
    }
    onRackLayout_(e) {
        this.updatePositions_(),
        this.emitter.emit("layout", {
            sender: this
        })
    }
    onRackValueChange_(e) {
        this.emitter.emit("valuechange", {
            bladeController: e.bladeController,
            options: e.options,
            sender: this
        })
    }
    onBladePositionsChange_() {
        this.updatePositions_()
    }
}
class Sa {
    constructor(e) {
        this.onRackAdd_ = this.onRackAdd_.bind(this),
        this.onRackRemove_ = this.onRackRemove_.bind(this),
        this.element = e.element,
        this.viewProps = e.viewProps;
        const n = new pg({
            blade: e.root ? void 0 : e.blade,
            viewProps: e.viewProps
        });
        n.emitter.on("add", this.onRackAdd_),
        n.emitter.on("remove", this.onRackRemove_),
        this.rack = n,
        this.viewProps.handleDispose( () => {
            for (let r = this.rack.children.length - 1; r >= 0; r--)
                this.rack.children[r].viewProps.set("disposed", !0)
        }
        )
    }
    onRackAdd_(e) {
        e.root && Dd(this.element, e.bladeController.view.element, e.index)
    }
    onRackRemove_(e) {
        e.root && Pa(e.bladeController.view.element)
    }
}
function wr() {
    return new Q({
        positions: ye([], {
            equals: zm
        })
    })
}
class yi extends Q {
    constructor(e) {
        super(e)
    }
    static create(e) {
        const n = {
            completed: !0,
            expanded: e,
            expandedHeight: null,
            shouldFixHeight: !1,
            temporaryExpanded: null
        }
          , r = Q.createCore(n);
        return new yi(r)
    }
    get styleExpanded() {
        var e;
        return (e = this.get("temporaryExpanded")) !== null && e !== void 0 ? e : this.get("expanded")
    }
    get styleHeight() {
        if (!this.styleExpanded)
            return "0";
        const e = this.get("expandedHeight");
        return this.get("shouldFixHeight") && !ge(e) ? `${e}px` : "auto"
    }
    bindExpandedClass(e, n) {
        const r = () => {
            this.styleExpanded ? e.classList.add(n) : e.classList.remove(n)
        }
        ;
        Ft(this, "expanded", r),
        Ft(this, "temporaryExpanded", r)
    }
    cleanUpTransition() {
        this.set("shouldFixHeight", !1),
        this.set("expandedHeight", null),
        this.set("completed", !0)
    }
}
function hg(t, e) {
    let n = 0;
    return Fv(e, () => {
        t.set("expandedHeight", null),
        t.set("temporaryExpanded", !0),
        ws(e),
        n = e.clientHeight,
        t.set("temporaryExpanded", null),
        ws(e)
    }
    ),
    n
}
function Ql(t, e) {
    e.style.height = t.styleHeight
}
function ka(t, e) {
    t.value("expanded").emitter.on("beforechange", () => {
        if (t.set("completed", !1),
        ge(t.get("expandedHeight"))) {
            const n = hg(t, e);
            n > 0 && t.set("expandedHeight", n)
        }
        t.set("shouldFixHeight", !0),
        ws(e)
    }
    ),
    t.emitter.on("change", () => {
        Ql(t, e)
    }
    ),
    Ql(t, e),
    e.addEventListener("transitionend", n => {
        n.propertyName === "height" && t.cleanUpTransition()
    }
    )
}
class Kd extends Ta {
    constructor(e, n) {
        super(e, n),
        this.emitter_ = new Me,
        this.controller.foldable.value("expanded").emitter.on("change", r => {
            this.emitter_.emit("fold", new Pv(this,r.sender.rawValue))
        }
        ),
        this.rackApi_.on("change", r => {
            this.emitter_.emit("change", r)
        }
        )
    }
    get expanded() {
        return this.controller.foldable.get("expanded")
    }
    set expanded(e) {
        this.controller.foldable.set("expanded", e)
    }
    get title() {
        return this.controller.props.get("title")
    }
    set title(e) {
        this.controller.props.set("title", e)
    }
    get children() {
        return this.rackApi_.children
    }
    addBinding(e, n, r) {
        return this.rackApi_.addBinding(e, n, r)
    }
    addFolder(e) {
        return this.rackApi_.addFolder(e)
    }
    addButton(e) {
        return this.rackApi_.addButton(e)
    }
    addTab(e) {
        return this.rackApi_.addTab(e)
    }
    add(e, n) {
        return this.rackApi_.add(e, n)
    }
    remove(e) {
        this.rackApi_.remove(e)
    }
    addBlade(e) {
        return this.rackApi_.addBlade(e)
    }
    on(e, n) {
        const r = n.bind(this);
        return this.emitter_.on(e, i => {
            r(i)
        }
        , {
            key: n
        }),
        this
    }
    off(e, n) {
        return this.emitter_.off(e, n),
        this
    }
}
const Gd = ie("cnt");
class fg {
    constructor(e, n) {
        var r;
        this.className_ = ie((r = n.viewName) !== null && r !== void 0 ? r : "fld"),
        this.element = e.createElement("div"),
        this.element.classList.add(this.className_(), Gd()),
        n.viewProps.bindClassModifiers(this.element),
        this.foldable_ = n.foldable,
        this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")),
        Ft(this.foldable_, "completed", _r(this.element, this.className_(void 0, "cpl")));
        const i = e.createElement("button");
        i.classList.add(this.className_("b")),
        Ft(n.props, "title", c => {
            ge(c) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"))
        }
        ),
        n.viewProps.bindDisabled(i),
        this.element.appendChild(i),
        this.buttonElement = i;
        const s = e.createElement("div");
        s.classList.add(this.className_("i")),
        this.element.appendChild(s);
        const o = e.createElement("div");
        o.classList.add(this.className_("t")),
        Oa(n.props.value("title"), o),
        this.buttonElement.appendChild(o),
        this.titleElement = o;
        const a = e.createElement("div");
        a.classList.add(this.className_("m")),
        this.buttonElement.appendChild(a);
        const l = e.createElement("div");
        l.classList.add(this.className_("c")),
        this.element.appendChild(l),
        this.containerElement = l
    }
}
class jo extends Aa {
    constructor(e, n) {
        var r;
        const i = yi.create((r = n.expanded) !== null && r !== void 0 ? r : !0)
          , s = new fg(e,{
            foldable: i,
            props: n.props,
            viewName: n.root ? "rot" : void 0,
            viewProps: n.viewProps
        });
        super(Object.assign(Object.assign({}, n), {
            rackController: new Sa({
                blade: n.blade,
                element: s.containerElement,
                root: n.root,
                viewProps: n.viewProps
            }),
            view: s
        })),
        this.onTitleClick_ = this.onTitleClick_.bind(this),
        this.props = n.props,
        this.foldable = i,
        ka(this.foldable, this.view.containerElement),
        this.rackController.rack.emitter.on("add", () => {
            this.foldable.cleanUpTransition()
        }
        ),
        this.rackController.rack.emitter.on("remove", () => {
            this.foldable.cleanUpTransition()
        }
        ),
        this.view.buttonElement.addEventListener("click", this.onTitleClick_)
    }
    get document() {
        return this.view.element.ownerDocument
    }
    importState(e) {
        return rt(e, n => super.importState(n), n => ({
            expanded: n.required.boolean,
            title: n.optional.string
        }), n => (this.foldable.set("expanded", n.expanded),
        this.props.set("title", n.title),
        !0))
    }
    exportState() {
        return it( () => super.exportState(), {
            expanded: this.foldable.get("expanded"),
            title: this.props.get("title")
        })
    }
    onTitleClick_() {
        this.foldable.set("expanded", !this.foldable.get("expanded"))
    }
}
const mg = We({
    id: "folder",
    type: "blade",
    accept(t) {
        const e = Ee(t, n => ({
            title: n.required.string,
            view: n.required.constant("folder"),
            expanded: n.optional.boolean
        }));
        return e ? {
            params: e
        } : null
    },
    controller(t) {
        return new jo(t.document,{
            blade: t.blade,
            expanded: t.params.expanded,
            props: Q.fromObject({
                title: t.params.title
            }),
            viewProps: t.viewProps
        })
    },
    api(t) {
        return t.controller instanceof jo ? new Kd(t.controller,t.pool) : null
    }
})
  , vg = ie("");
function Jl(t, e) {
    return _r(t, vg(void 0, e))
}
class tn extends Q {
    constructor(e) {
        var n;
        super(e),
        this.onDisabledChange_ = this.onDisabledChange_.bind(this),
        this.onParentChange_ = this.onParentChange_.bind(this),
        this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this),
        [this.globalDisabled_,this.setGlobalDisabled_] = Wm(ye(this.getGlobalDisabled_())),
        this.value("disabled").emitter.on("change", this.onDisabledChange_),
        this.value("parent").emitter.on("change", this.onParentChange_),
        (n = this.get("parent")) === null || n === void 0 || n.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_)
    }
    static create(e) {
        var n, r, i;
        const s = e ?? {};
        return new tn(Q.createCore({
            disabled: (n = s.disabled) !== null && n !== void 0 ? n : !1,
            disposed: !1,
            hidden: (r = s.hidden) !== null && r !== void 0 ? r : !1,
            parent: (i = s.parent) !== null && i !== void 0 ? i : null
        }))
    }
    get globalDisabled() {
        return this.globalDisabled_
    }
    bindClassModifiers(e) {
        Yt(this.globalDisabled_, Jl(e, "disabled")),
        Ft(this, "hidden", Jl(e, "hidden"))
    }
    bindDisabled(e) {
        Yt(this.globalDisabled_, n => {
            e.disabled = n
        }
        )
    }
    bindTabIndex(e) {
        Yt(this.globalDisabled_, n => {
            e.tabIndex = n ? -1 : 0
        }
        )
    }
    handleDispose(e) {
        this.value("disposed").emitter.on("change", n => {
            n && e()
        }
        )
    }
    importState(e) {
        this.set("disabled", e.disabled),
        this.set("hidden", e.hidden)
    }
    exportState() {
        return {
            disabled: this.get("disabled"),
            hidden: this.get("hidden")
        }
    }
    getGlobalDisabled_() {
        const e = this.get("parent");
        return (e ? e.globalDisabled.rawValue : !1) || this.get("disabled")
    }
    updateGlobalDisabled_() {
        this.setGlobalDisabled_(this.getGlobalDisabled_())
    }
    onDisabledChange_() {
        this.updateGlobalDisabled_()
    }
    onParentGlobalDisabledChange_() {
        this.updateGlobalDisabled_()
    }
    onParentChange_(e) {
        var n;
        const r = e.previousRawValue;
        r == null || r.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_),
        (n = this.get("parent")) === null || n === void 0 || n.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_),
        this.updateGlobalDisabled_()
    }
}
const ec = ie("tbp");
class gg {
    constructor(e, n) {
        this.element = e.createElement("div"),
        this.element.classList.add(ec()),
        n.viewProps.bindClassModifiers(this.element);
        const r = e.createElement("div");
        r.classList.add(ec("c")),
        this.element.appendChild(r),
        this.containerElement = r
    }
}
const Fr = ie("tbi");
class bg {
    constructor(e, n) {
        this.element = e.createElement("div"),
        this.element.classList.add(Fr()),
        n.viewProps.bindClassModifiers(this.element),
        Ft(n.props, "selected", s => {
            s ? this.element.classList.add(Fr(void 0, "sel")) : this.element.classList.remove(Fr(void 0, "sel"))
        }
        );
        const r = e.createElement("button");
        r.classList.add(Fr("b")),
        n.viewProps.bindDisabled(r),
        this.element.appendChild(r),
        this.buttonElement = r;
        const i = e.createElement("div");
        i.classList.add(Fr("t")),
        Oa(n.props.value("title"), i),
        this.buttonElement.appendChild(i),
        this.titleElement = i
    }
}
class _g {
    constructor(e, n) {
        this.emitter = new Me,
        this.onClick_ = this.onClick_.bind(this),
        this.props = n.props,
        this.viewProps = n.viewProps,
        this.view = new bg(e,{
            props: n.props,
            viewProps: n.viewProps
        }),
        this.view.buttonElement.addEventListener("click", this.onClick_)
    }
    onClick_() {
        this.emitter.emit("click", {
            sender: this
        })
    }
}
class No extends Aa {
    constructor(e, n) {
        const r = new gg(e,{
            viewProps: n.viewProps
        });
        super(Object.assign(Object.assign({}, n), {
            rackController: new Sa({
                blade: n.blade,
                element: r.containerElement,
                viewProps: n.viewProps
            }),
            view: r
        })),
        this.onItemClick_ = this.onItemClick_.bind(this),
        this.ic_ = new _g(e,{
            props: n.itemProps,
            viewProps: tn.create()
        }),
        this.ic_.emitter.on("click", this.onItemClick_),
        this.props = n.props,
        Ft(this.props, "selected", i => {
            this.itemController.props.set("selected", i),
            this.viewProps.set("hidden", !i)
        }
        )
    }
    get itemController() {
        return this.ic_
    }
    importState(e) {
        return rt(e, n => super.importState(n), n => ({
            selected: n.required.boolean,
            title: n.required.string
        }), n => (this.ic_.props.set("selected", n.selected),
        this.ic_.props.set("title", n.title),
        !0))
    }
    exportState() {
        return it( () => super.exportState(), {
            selected: this.ic_.props.get("selected"),
            title: this.ic_.props.get("title")
        })
    }
    onItemClick_() {
        this.props.set("selected", !0)
    }
}
class yg extends Ta {
    constructor(e, n) {
        super(e, n),
        this.emitter_ = new Me,
        this.onSelect_ = this.onSelect_.bind(this),
        this.pool_ = n,
        this.rackApi_.on("change", r => {
            this.emitter_.emit("change", r)
        }
        ),
        this.controller.tab.selectedIndex.emitter.on("change", this.onSelect_)
    }
    get pages() {
        return this.rackApi_.children
    }
    addPage(e) {
        const n = this.controller.view.element.ownerDocument
          , r = new No(n,{
            blade: wr(),
            itemProps: Q.fromObject({
                selected: !1,
                title: e.title
            }),
            props: Q.fromObject({
                selected: !1
            }),
            viewProps: tn.create()
        })
          , i = this.pool_.createApi(r);
        return this.rackApi_.add(i, e.index)
    }
    removePage(e) {
        this.rackApi_.remove(this.rackApi_.children[e])
    }
    on(e, n) {
        const r = n.bind(this);
        return this.emitter_.on(e, i => {
            r(i)
        }
        , {
            key: n
        }),
        this
    }
    off(e, n) {
        return this.emitter_.off(e, n),
        this
    }
    onSelect_(e) {
        this.emitter_.emit("select", new Ov(this,e.rawValue))
    }
}
class wg extends Ta {
    get title() {
        var e;
        return (e = this.controller.itemController.props.get("title")) !== null && e !== void 0 ? e : ""
    }
    set title(e) {
        this.controller.itemController.props.set("title", e)
    }
    get selected() {
        return this.controller.props.get("selected")
    }
    set selected(e) {
        this.controller.props.set("selected", e)
    }
    get children() {
        return this.rackApi_.children
    }
    addButton(e) {
        return this.rackApi_.addButton(e)
    }
    addFolder(e) {
        return this.rackApi_.addFolder(e)
    }
    addTab(e) {
        return this.rackApi_.addTab(e)
    }
    add(e, n) {
        this.rackApi_.add(e, n)
    }
    remove(e) {
        this.rackApi_.remove(e)
    }
    addBinding(e, n, r) {
        return this.rackApi_.addBinding(e, n, r)
    }
    addBlade(e) {
        return this.rackApi_.addBlade(e)
    }
}
const tc = -1;
class xg {
    constructor() {
        this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this),
        this.empty = ye(!0),
        this.selectedIndex = ye(tc),
        this.items_ = []
    }
    add(e, n) {
        const r = n ?? this.items_.length;
        this.items_.splice(r, 0, e),
        e.emitter.on("change", this.onItemSelectedChange_),
        this.keepSelection_()
    }
    remove(e) {
        const n = this.items_.indexOf(e);
        n < 0 || (this.items_.splice(n, 1),
        e.emitter.off("change", this.onItemSelectedChange_),
        this.keepSelection_())
    }
    keepSelection_() {
        if (this.items_.length === 0) {
            this.selectedIndex.rawValue = tc,
            this.empty.rawValue = !0;
            return
        }
        const e = this.items_.findIndex(n => n.rawValue);
        e < 0 ? (this.items_.forEach( (n, r) => {
            n.rawValue = r === 0
        }
        ),
        this.selectedIndex.rawValue = 0) : (this.items_.forEach( (n, r) => {
            n.rawValue = r === e
        }
        ),
        this.selectedIndex.rawValue = e),
        this.empty.rawValue = !1
    }
    onItemSelectedChange_(e) {
        if (e.rawValue) {
            const n = this.items_.findIndex(r => r === e.sender);
            this.items_.forEach( (r, i) => {
                r.rawValue = i === n
            }
            ),
            this.selectedIndex.rawValue = n
        } else
            this.keepSelection_()
    }
}
const Rr = ie("tab");
class Cg {
    constructor(e, n) {
        this.element = e.createElement("div"),
        this.element.classList.add(Rr(), Gd()),
        n.viewProps.bindClassModifiers(this.element),
        Yt(n.empty, _r(this.element, Rr(void 0, "nop")));
        const r = e.createElement("div");
        r.classList.add(Rr("t")),
        this.element.appendChild(r),
        this.itemsElement = r;
        const i = e.createElement("div");
        i.classList.add(Rr("i")),
        this.element.appendChild(i);
        const s = e.createElement("div");
        s.classList.add(Rr("c")),
        this.element.appendChild(s),
        this.contentsElement = s
    }
}
class nc extends Aa {
    constructor(e, n) {
        const r = new xg
          , i = new Cg(e,{
            empty: r.empty,
            viewProps: n.viewProps
        });
        super({
            blade: n.blade,
            rackController: new Sa({
                blade: n.blade,
                element: i.contentsElement,
                viewProps: n.viewProps
            }),
            view: i
        }),
        this.onRackAdd_ = this.onRackAdd_.bind(this),
        this.onRackRemove_ = this.onRackRemove_.bind(this);
        const s = this.rackController.rack;
        s.emitter.on("add", this.onRackAdd_),
        s.emitter.on("remove", this.onRackRemove_),
        this.tab = r
    }
    add(e, n) {
        this.rackController.rack.add(e, n)
    }
    remove(e) {
        this.rackController.rack.remove(this.rackController.rack.children[e])
    }
    onRackAdd_(e) {
        if (!e.root)
            return;
        const n = e.bladeController;
        Dd(this.view.itemsElement, n.itemController.view.element, e.index),
        n.itemController.viewProps.set("parent", this.viewProps),
        this.tab.add(n.props.value("selected"))
    }
    onRackRemove_(e) {
        if (!e.root)
            return;
        const n = e.bladeController;
        Pa(n.itemController.view.element),
        n.itemController.viewProps.set("parent", null),
        this.tab.remove(n.props.value("selected"))
    }
}
const qd = We({
    id: "tab",
    type: "blade",
    accept(t) {
        const e = Ee(t, n => ({
            pages: n.required.array(n.required.object({
                title: n.required.string
            })),
            view: n.required.constant("tab")
        }));
        return !e || e.pages.length === 0 ? null : {
            params: e
        }
    },
    controller(t) {
        const e = new nc(t.document,{
            blade: t.blade,
            viewProps: t.viewProps
        });
        return t.params.pages.forEach(n => {
            const r = new No(t.document,{
                blade: wr(),
                itemProps: Q.fromObject({
                    selected: !1,
                    title: n.title
                }),
                props: Q.fromObject({
                    selected: !1
                }),
                viewProps: tn.create()
            });
            e.add(r)
        }
        ),
        e
    },
    api(t) {
        return t.controller instanceof nc ? new yg(t.controller,t.pool) : t.controller instanceof No ? new wg(t.controller,t.pool) : null
    }
});
function Eg(t, e) {
    const n = t.accept(e.params);
    if (!n)
        return null;
    const r = Ee(e.params, i => ({
        disabled: i.optional.boolean,
        hidden: i.optional.boolean
    }));
    return t.controller({
        blade: wr(),
        document: e.document,
        params: Object.assign(Object.assign({}, n.params), {
            disabled: r == null ? void 0 : r.disabled,
            hidden: r == null ? void 0 : r.hidden
        }),
        viewProps: tn.create({
            disabled: r == null ? void 0 : r.disabled,
            hidden: r == null ? void 0 : r.hidden
        })
    })
}
class Ma extends si {
    get options() {
        return this.controller.valueController.props.get("options")
    }
    set options(e) {
        this.controller.valueController.props.set("options", e)
    }
}
class Pg {
    constructor() {
        this.disabled = !1,
        this.emitter = new Me
    }
    dispose() {}
    tick() {
        this.disabled || this.emitter.emit("tick", {
            sender: this
        })
    }
}
class Og {
    constructor(e, n) {
        this.disabled_ = !1,
        this.timerId_ = null,
        this.onTick_ = this.onTick_.bind(this),
        this.doc_ = e,
        this.emitter = new Me,
        this.interval_ = n,
        this.setTimer_()
    }
    get disabled() {
        return this.disabled_
    }
    set disabled(e) {
        this.disabled_ = e,
        this.disabled_ ? this.clearTimer_() : this.setTimer_()
    }
    dispose() {
        this.clearTimer_()
    }
    clearTimer_() {
        if (this.timerId_ === null)
            return;
        const e = this.doc_.defaultView;
        e && e.clearInterval(this.timerId_),
        this.timerId_ = null
    }
    setTimer_() {
        if (this.clearTimer_(),
        this.interval_ <= 0)
            return;
        const e = this.doc_.defaultView;
        e && (this.timerId_ = e.setInterval(this.onTick_, this.interval_))
    }
    onTick_() {
        this.disabled_ || this.emitter.emit("tick", {
            sender: this
        })
    }
}
class wi {
    constructor(e) {
        this.constraints = e
    }
    constrain(e) {
        return this.constraints.reduce( (n, r) => r.constrain(n), e)
    }
}
function xs(t, e) {
    if (t instanceof e)
        return t;
    if (t instanceof wi) {
        const n = t.constraints.reduce( (r, i) => r || (i instanceof e ? i : null), null);
        if (n)
            return n
    }
    return null
}
class xi {
    constructor(e) {
        this.values = Q.fromObject({
            options: e
        })
    }
    constrain(e) {
        const n = this.values.get("options");
        return n.length === 0 || n.filter(i => i.value === e).length > 0 ? e : n[0].value
    }
}
function Ci(t) {
    var e;
    const n = $o;
    if (Array.isArray(t))
        return (e = Ee({
            items: t
        }, r => ({
            items: r.required.array(r.required.object({
                text: r.required.string,
                value: r.required.raw
            }))
        }))) === null || e === void 0 ? void 0 : e.items;
    if (typeof t == "object")
        return n.required.raw(t).value
}
function La(t) {
    if (Array.isArray(t))
        return t;
    const e = [];
    return Object.keys(t).forEach(n => {
        e.push({
            text: n,
            value: t[n]
        })
    }
    ),
    e
}
function Fa(t) {
    return ge(t) ? null : new xi(La(t))
}
const co = ie("lst");
class Tg {
    constructor(e, n) {
        this.onValueChange_ = this.onValueChange_.bind(this),
        this.props_ = n.props,
        this.element = e.createElement("div"),
        this.element.classList.add(co()),
        n.viewProps.bindClassModifiers(this.element);
        const r = e.createElement("select");
        r.classList.add(co("s")),
        n.viewProps.bindDisabled(r),
        this.element.appendChild(r),
        this.selectElement = r;
        const i = e.createElement("div");
        i.classList.add(co("m")),
        i.appendChild(zs(e, "dropdown")),
        this.element.appendChild(i),
        n.value.emitter.on("change", this.onValueChange_),
        this.value_ = n.value,
        Ft(this.props_, "options", s => {
            Bd(this.selectElement),
            s.forEach(o => {
                const a = e.createElement("option");
                a.textContent = o.text,
                this.selectElement.appendChild(a)
            }
            ),
            this.update_()
        }
        )
    }
    update_() {
        const e = this.props_.get("options").map(n => n.value);
        this.selectElement.selectedIndex = e.indexOf(this.value_.rawValue)
    }
    onValueChange_() {
        this.update_()
    }
}
class yn {
    constructor(e, n) {
        this.onSelectChange_ = this.onSelectChange_.bind(this),
        this.props = n.props,
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.view = new Tg(e,{
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
        }),
        this.view.selectElement.addEventListener("change", this.onSelectChange_)
    }
    onSelectChange_(e) {
        const n = e.currentTarget;
        this.value.rawValue = this.props.get("options")[n.selectedIndex].value
    }
    importProps(e) {
        return rt(e, null, n => ({
            options: n.required.custom(Ci)
        }), n => (this.props.set("options", La(n.options)),
        !0))
    }
    exportProps() {
        return it(null, {
            options: this.props.get("options")
        })
    }
}
const rc = ie("pop");
class Ag {
    constructor(e, n) {
        this.element = e.createElement("div"),
        this.element.classList.add(rc()),
        n.viewProps.bindClassModifiers(this.element),
        Yt(n.shows, _r(this.element, rc(void 0, "v")))
    }
}
class Wd {
    constructor(e, n) {
        this.shows = ye(!1),
        this.viewProps = n.viewProps,
        this.view = new Ag(e,{
            shows: this.shows,
            viewProps: this.viewProps
        })
    }
}
const ic = ie("txt");
class Sg {
    constructor(e, n) {
        this.onChange_ = this.onChange_.bind(this),
        this.element = e.createElement("div"),
        this.element.classList.add(ic()),
        n.viewProps.bindClassModifiers(this.element),
        this.props_ = n.props,
        this.props_.emitter.on("change", this.onChange_);
        const r = e.createElement("input");
        r.classList.add(ic("i")),
        r.type = "text",
        n.viewProps.bindDisabled(r),
        this.element.appendChild(r),
        this.inputElement = r,
        n.value.emitter.on("change", this.onChange_),
        this.value_ = n.value,
        this.refresh()
    }
    refresh() {
        const e = this.props_.get("formatter");
        this.inputElement.value = e(this.value_.rawValue)
    }
    onChange_() {
        this.refresh()
    }
}
class oi {
    constructor(e, n) {
        this.onInputChange_ = this.onInputChange_.bind(this),
        this.parser_ = n.parser,
        this.props = n.props,
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.view = new Sg(e,{
            props: n.props,
            value: this.value,
            viewProps: this.viewProps
        }),
        this.view.inputElement.addEventListener("change", this.onInputChange_)
    }
    onInputChange_(e) {
        const r = e.currentTarget.value
          , i = this.parser_(r);
        ge(i) || (this.value.rawValue = i),
        this.view.refresh()
    }
}
function kg(t) {
    return String(t)
}
function Yd(t) {
    return t === "false" ? !1 : !!t
}
function sc(t) {
    return kg(t)
}
function Mg(t) {
    return e => t.reduce( (n, r) => n !== null ? n : r(e), null)
}
const Lg = et(0);
function Cs(t) {
    return Lg(t) + "%"
}
function Zd(t) {
    return String(t)
}
function zo(t) {
    return t
}
function xr({primary: t, secondary: e, forward: n, backward: r}) {
    let i = !1;
    function s(o) {
        i || (i = !0,
        o(),
        i = !1)
    }
    t.emitter.on("change", o => {
        s( () => {
            e.setRawValue(n(t.rawValue, e.rawValue), o.options)
        }
        )
    }
    ),
    e.emitter.on("change", o => {
        s( () => {
            t.setRawValue(r(t.rawValue, e.rawValue), o.options)
        }
        ),
        s( () => {
            e.setRawValue(n(t.rawValue, e.rawValue), o.options)
        }
        )
    }
    ),
    s( () => {
        e.setRawValue(n(t.rawValue, e.rawValue), {
            forceEmit: !1,
            last: !0
        })
    }
    )
}
function Xe(t, e) {
    const n = t * (e.altKey ? .1 : 1) * (e.shiftKey ? 10 : 1);
    return e.upKey ? +n : e.downKey ? -n : 0
}
function ai(t) {
    return {
        altKey: t.altKey,
        downKey: t.key === "ArrowDown",
        shiftKey: t.shiftKey,
        upKey: t.key === "ArrowUp"
    }
}
function Qt(t) {
    return {
        altKey: t.altKey,
        downKey: t.key === "ArrowLeft",
        shiftKey: t.shiftKey,
        upKey: t.key === "ArrowRight"
    }
}
function Fg(t) {
    return t === "ArrowUp" || t === "ArrowDown"
}
function Xd(t) {
    return Fg(t) || t === "ArrowLeft" || t === "ArrowRight"
}
function uo(t, e) {
    var n, r;
    const i = e.ownerDocument.defaultView
      , s = e.getBoundingClientRect();
    return {
        x: t.pageX - (((n = i && i.scrollX) !== null && n !== void 0 ? n : 0) + s.left),
        y: t.pageY - (((r = i && i.scrollY) !== null && r !== void 0 ? r : 0) + s.top)
    }
}
class Gn {
    constructor(e) {
        this.lastTouch_ = null,
        this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this),
        this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this),
        this.onMouseDown_ = this.onMouseDown_.bind(this),
        this.onTouchEnd_ = this.onTouchEnd_.bind(this),
        this.onTouchMove_ = this.onTouchMove_.bind(this),
        this.onTouchStart_ = this.onTouchStart_.bind(this),
        this.elem_ = e,
        this.emitter = new Me,
        e.addEventListener("touchstart", this.onTouchStart_, {
            passive: !1
        }),
        e.addEventListener("touchmove", this.onTouchMove_, {
            passive: !0
        }),
        e.addEventListener("touchend", this.onTouchEnd_),
        e.addEventListener("mousedown", this.onMouseDown_)
    }
    computePosition_(e) {
        const n = this.elem_.getBoundingClientRect();
        return {
            bounds: {
                width: n.width,
                height: n.height
            },
            point: e ? {
                x: e.x,
                y: e.y
            } : null
        }
    }
    onMouseDown_(e) {
        var n;
        e.preventDefault(),
        (n = e.currentTarget) === null || n === void 0 || n.focus();
        const r = this.elem_.ownerDocument;
        r.addEventListener("mousemove", this.onDocumentMouseMove_),
        r.addEventListener("mouseup", this.onDocumentMouseUp_),
        this.emitter.emit("down", {
            altKey: e.altKey,
            data: this.computePosition_(uo(e, this.elem_)),
            sender: this,
            shiftKey: e.shiftKey
        })
    }
    onDocumentMouseMove_(e) {
        this.emitter.emit("move", {
            altKey: e.altKey,
            data: this.computePosition_(uo(e, this.elem_)),
            sender: this,
            shiftKey: e.shiftKey
        })
    }
    onDocumentMouseUp_(e) {
        const n = this.elem_.ownerDocument;
        n.removeEventListener("mousemove", this.onDocumentMouseMove_),
        n.removeEventListener("mouseup", this.onDocumentMouseUp_),
        this.emitter.emit("up", {
            altKey: e.altKey,
            data: this.computePosition_(uo(e, this.elem_)),
            sender: this,
            shiftKey: e.shiftKey
        })
    }
    onTouchStart_(e) {
        e.preventDefault();
        const n = e.targetTouches.item(0)
          , r = this.elem_.getBoundingClientRect();
        this.emitter.emit("down", {
            altKey: e.altKey,
            data: this.computePosition_(n ? {
                x: n.clientX - r.left,
                y: n.clientY - r.top
            } : void 0),
            sender: this,
            shiftKey: e.shiftKey
        }),
        this.lastTouch_ = n
    }
    onTouchMove_(e) {
        const n = e.targetTouches.item(0)
          , r = this.elem_.getBoundingClientRect();
        this.emitter.emit("move", {
            altKey: e.altKey,
            data: this.computePosition_(n ? {
                x: n.clientX - r.left,
                y: n.clientY - r.top
            } : void 0),
            sender: this,
            shiftKey: e.shiftKey
        }),
        this.lastTouch_ = n
    }
    onTouchEnd_(e) {
        var n;
        const r = (n = e.targetTouches.item(0)) !== null && n !== void 0 ? n : this.lastTouch_
          , i = this.elem_.getBoundingClientRect();
        this.emitter.emit("up", {
            altKey: e.altKey,
            data: this.computePosition_(r ? {
                x: r.clientX - i.left,
                y: r.clientY - i.top
            } : void 0),
            sender: this,
            shiftKey: e.shiftKey
        })
    }
}
const st = ie("txt");
class Rg {
    constructor(e, n) {
        this.onChange_ = this.onChange_.bind(this),
        this.props_ = n.props,
        this.props_.emitter.on("change", this.onChange_),
        this.element = e.createElement("div"),
        this.element.classList.add(st(), st(void 0, "num")),
        n.arrayPosition && this.element.classList.add(st(void 0, n.arrayPosition)),
        n.viewProps.bindClassModifiers(this.element);
        const r = e.createElement("input");
        r.classList.add(st("i")),
        r.type = "text",
        n.viewProps.bindDisabled(r),
        this.element.appendChild(r),
        this.inputElement = r,
        this.onDraggingChange_ = this.onDraggingChange_.bind(this),
        this.dragging_ = n.dragging,
        this.dragging_.emitter.on("change", this.onDraggingChange_),
        this.element.classList.add(st()),
        this.inputElement.classList.add(st("i"));
        const i = e.createElement("div");
        i.classList.add(st("k")),
        this.element.appendChild(i),
        this.knobElement = i;
        const s = e.createElementNS(kt, "svg");
        s.classList.add(st("g")),
        this.knobElement.appendChild(s);
        const o = e.createElementNS(kt, "path");
        o.classList.add(st("gb")),
        s.appendChild(o),
        this.guideBodyElem_ = o;
        const a = e.createElementNS(kt, "path");
        a.classList.add(st("gh")),
        s.appendChild(a),
        this.guideHeadElem_ = a;
        const l = e.createElement("div");
        l.classList.add(ie("tt")()),
        this.knobElement.appendChild(l),
        this.tooltipElem_ = l,
        n.value.emitter.on("change", this.onChange_),
        this.value = n.value,
        this.refresh()
    }
    onDraggingChange_(e) {
        if (e.rawValue === null) {
            this.element.classList.remove(st(void 0, "drg"));
            return
        }
        this.element.classList.add(st(void 0, "drg"));
        const n = e.rawValue / this.props_.get("pointerScale")
          , r = n + (n > 0 ? -1 : n < 0 ? 1 : 0)
          , i = Le(-r, -4, 4);
        this.guideHeadElem_.setAttributeNS(null, "d", [`M ${r + i},0 L${r},4 L${r + i},8`, `M ${n},-1 L${n},9`].join(" ")),
        this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${n},4`);
        const s = this.props_.get("formatter");
        this.tooltipElem_.textContent = s(this.value.rawValue),
        this.tooltipElem_.style.left = `${n}px`
    }
    refresh() {
        const e = this.props_.get("formatter");
        this.inputElement.value = e(this.value.rawValue)
    }
    onChange_() {
        this.refresh()
    }
}
class Ei {
    constructor(e, n) {
        var r;
        this.originRawValue_ = 0,
        this.onInputChange_ = this.onInputChange_.bind(this),
        this.onInputKeyDown_ = this.onInputKeyDown_.bind(this),
        this.onInputKeyUp_ = this.onInputKeyUp_.bind(this),
        this.onPointerDown_ = this.onPointerDown_.bind(this),
        this.onPointerMove_ = this.onPointerMove_.bind(this),
        this.onPointerUp_ = this.onPointerUp_.bind(this),
        this.parser_ = n.parser,
        this.props = n.props,
        this.sliderProps_ = (r = n.sliderProps) !== null && r !== void 0 ? r : null,
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.dragging_ = ye(null),
        this.view = new Rg(e,{
            arrayPosition: n.arrayPosition,
            dragging: this.dragging_,
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
        }),
        this.view.inputElement.addEventListener("change", this.onInputChange_),
        this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_),
        this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
        const i = new Gn(this.view.knobElement);
        i.emitter.on("down", this.onPointerDown_),
        i.emitter.on("move", this.onPointerMove_),
        i.emitter.on("up", this.onPointerUp_)
    }
    constrainValue_(e) {
        var n, r;
        const i = (n = this.sliderProps_) === null || n === void 0 ? void 0 : n.get("min")
          , s = (r = this.sliderProps_) === null || r === void 0 ? void 0 : r.get("max");
        let o = e;
        return i !== void 0 && (o = Math.max(o, i)),
        s !== void 0 && (o = Math.min(o, s)),
        o
    }
    onInputChange_(e) {
        const r = e.currentTarget.value
          , i = this.parser_(r);
        ge(i) || (this.value.rawValue = this.constrainValue_(i)),
        this.view.refresh()
    }
    onInputKeyDown_(e) {
        const n = Xe(this.props.get("keyScale"), ai(e));
        n !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + n), {
            forceEmit: !1,
            last: !1
        })
    }
    onInputKeyUp_(e) {
        Xe(this.props.get("keyScale"), ai(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
        })
    }
    onPointerDown_() {
        this.originRawValue_ = this.value.rawValue,
        this.dragging_.rawValue = 0
    }
    computeDraggingValue_(e) {
        if (!e.point)
            return null;
        const n = e.point.x - e.bounds.width / 2;
        return this.constrainValue_(this.originRawValue_ + n * this.props.get("pointerScale"))
    }
    onPointerMove_(e) {
        const n = this.computeDraggingValue_(e.data);
        n !== null && (this.value.setRawValue(n, {
            forceEmit: !1,
            last: !1
        }),
        this.dragging_.rawValue = this.value.rawValue - this.originRawValue_)
    }
    onPointerUp_(e) {
        const n = this.computeDraggingValue_(e.data);
        n !== null && (this.value.setRawValue(n, {
            forceEmit: !0,
            last: !0
        }),
        this.dragging_.rawValue = null)
    }
}
const po = ie("sld");
class Ig {
    constructor(e, n) {
        this.onChange_ = this.onChange_.bind(this),
        this.props_ = n.props,
        this.props_.emitter.on("change", this.onChange_),
        this.element = e.createElement("div"),
        this.element.classList.add(po()),
        n.viewProps.bindClassModifiers(this.element);
        const r = e.createElement("div");
        r.classList.add(po("t")),
        n.viewProps.bindTabIndex(r),
        this.element.appendChild(r),
        this.trackElement = r;
        const i = e.createElement("div");
        i.classList.add(po("k")),
        this.trackElement.appendChild(i),
        this.knobElement = i,
        n.value.emitter.on("change", this.onChange_),
        this.value = n.value,
        this.update_()
    }
    update_() {
        const e = Le(ue(this.value.rawValue, this.props_.get("min"), this.props_.get("max"), 0, 100), 0, 100);
        this.knobElement.style.width = `${e}%`
    }
    onChange_() {
        this.update_()
    }
}
class Vg {
    constructor(e, n) {
        this.onKeyDown_ = this.onKeyDown_.bind(this),
        this.onKeyUp_ = this.onKeyUp_.bind(this),
        this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this),
        this.onPointerUp_ = this.onPointerUp_.bind(this),
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.props = n.props,
        this.view = new Ig(e,{
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
        }),
        this.ptHandler_ = new Gn(this.view.trackElement),
        this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_),
        this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_),
        this.ptHandler_.emitter.on("up", this.onPointerUp_),
        this.view.trackElement.addEventListener("keydown", this.onKeyDown_),
        this.view.trackElement.addEventListener("keyup", this.onKeyUp_)
    }
    handlePointerEvent_(e, n) {
        e.point && this.value.setRawValue(ue(Le(e.point.x, 0, e.bounds.width), 0, e.bounds.width, this.props.get("min"), this.props.get("max")), n)
    }
    onPointerDownOrMove_(e) {
        this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerUp_(e) {
        this.handlePointerEvent_(e.data, {
            forceEmit: !0,
            last: !0
        })
    }
    onKeyDown_(e) {
        const n = Xe(this.props.get("keyScale"), Qt(e));
        n !== 0 && this.value.setRawValue(this.value.rawValue + n, {
            forceEmit: !1,
            last: !1
        })
    }
    onKeyUp_(e) {
        Xe(this.props.get("keyScale"), Qt(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
        })
    }
}
const ho = ie("sldtxt");
class Dg {
    constructor(e, n) {
        this.element = e.createElement("div"),
        this.element.classList.add(ho());
        const r = e.createElement("div");
        r.classList.add(ho("s")),
        this.sliderView_ = n.sliderView,
        r.appendChild(this.sliderView_.element),
        this.element.appendChild(r);
        const i = e.createElement("div");
        i.classList.add(ho("t")),
        this.textView_ = n.textView,
        i.appendChild(this.textView_.element),
        this.element.appendChild(i)
    }
}
class Es {
    constructor(e, n) {
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.sliderC_ = new Vg(e,{
            props: n.sliderProps,
            value: n.value,
            viewProps: this.viewProps
        }),
        this.textC_ = new Ei(e,{
            parser: n.parser,
            props: n.textProps,
            sliderProps: n.sliderProps,
            value: n.value,
            viewProps: n.viewProps
        }),
        this.view = new Dg(e,{
            sliderView: this.sliderC_.view,
            textView: this.textC_.view
        })
    }
    get sliderController() {
        return this.sliderC_
    }
    get textController() {
        return this.textC_
    }
    importProps(e) {
        return rt(e, null, n => ({
            max: n.required.number,
            min: n.required.number
        }), n => {
            const r = this.sliderC_.props;
            return r.set("max", n.max),
            r.set("min", n.min),
            !0
        }
        )
    }
    exportProps() {
        const e = this.sliderC_.props;
        return it(null, {
            max: e.get("max"),
            min: e.get("min")
        })
    }
}
function Qd(t) {
    return {
        sliderProps: new Q({
            keyScale: t.keyScale,
            max: t.max,
            min: t.min
        }),
        textProps: new Q({
            formatter: ye(t.formatter),
            keyScale: t.keyScale,
            pointerScale: ye(t.pointerScale)
        })
    }
}
const Bg = {
    containerUnitSize: "cnt-usz"
};
function Jd(t) {
    return `--${Bg[t]}`
}
function li(t) {
    return Id(t)
}
function fn(t) {
    if (Bo(t))
        return Ee(t, li)
}
function qt(t, e) {
    if (!t)
        return;
    const n = []
      , r = Ld(t, e);
    r && n.push(r);
    const i = Fd(t);
    return i && n.push(i),
    new wi(n)
}
function $g(t) {
    return t ? t.major === yr.major : !1
}
function ep(t) {
    if (t === "inline" || t === "popup")
        return t
}
function Pi(t, e) {
    t.write(e)
}
const Ni = ie("ckb");
class Ug {
    constructor(e, n) {
        this.onValueChange_ = this.onValueChange_.bind(this),
        this.element = e.createElement("div"),
        this.element.classList.add(Ni()),
        n.viewProps.bindClassModifiers(this.element);
        const r = e.createElement("label");
        r.classList.add(Ni("l")),
        this.element.appendChild(r),
        this.labelElement = r;
        const i = e.createElement("input");
        i.classList.add(Ni("i")),
        i.type = "checkbox",
        this.labelElement.appendChild(i),
        this.inputElement = i,
        n.viewProps.bindDisabled(this.inputElement);
        const s = e.createElement("div");
        s.classList.add(Ni("w")),
        this.labelElement.appendChild(s);
        const o = zs(e, "check");
        s.appendChild(o),
        n.value.emitter.on("change", this.onValueChange_),
        this.value = n.value,
        this.update_()
    }
    update_() {
        this.inputElement.checked = this.value.rawValue
    }
    onValueChange_() {
        this.update_()
    }
}
class jg {
    constructor(e, n) {
        this.onInputChange_ = this.onInputChange_.bind(this),
        this.onLabelMouseDown_ = this.onLabelMouseDown_.bind(this),
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.view = new Ug(e,{
            value: this.value,
            viewProps: this.viewProps
        }),
        this.view.inputElement.addEventListener("change", this.onInputChange_),
        this.view.labelElement.addEventListener("mousedown", this.onLabelMouseDown_)
    }
    onInputChange_(e) {
        const n = e.currentTarget;
        this.value.rawValue = n.checked,
        e.preventDefault(),
        e.stopPropagation()
    }
    onLabelMouseDown_(e) {
        e.preventDefault()
    }
}
function Ng(t) {
    const e = []
      , n = Fa(t.options);
    return n && e.push(n),
    new wi(e)
}
const zg = We({
    id: "input-bool",
    type: "input",
    accept: (t, e) => {
        if (typeof t != "boolean")
            return null;
        const n = Ee(e, r => ({
            options: r.optional.custom(Ci),
            readonly: r.optional.constant(!1)
        }));
        return n ? {
            initialValue: t,
            params: n
        } : null
    }
    ,
    binding: {
        reader: t => Yd,
        constraint: t => Ng(t.params),
        writer: t => Pi
    },
    controller: t => {
        const e = t.document
          , n = t.value
          , r = t.constraint
          , i = r && xs(r, xi);
        return i ? new yn(e,{
            props: new Q({
                options: i.values.value("options")
            }),
            value: n,
            viewProps: t.viewProps
        }) : new jg(e,{
            value: n,
            viewProps: t.viewProps
        })
    }
    ,
    api(t) {
        return typeof t.controller.value.rawValue != "boolean" ? null : t.controller.valueController instanceof yn ? new Ma(t.controller) : null
    }
})
  , En = ie("col");
class Hg {
    constructor(e, n) {
        this.element = e.createElement("div"),
        this.element.classList.add(En()),
        n.foldable.bindExpandedClass(this.element, En(void 0, "expanded")),
        Ft(n.foldable, "completed", _r(this.element, En(void 0, "cpl")));
        const r = e.createElement("div");
        r.classList.add(En("h")),
        this.element.appendChild(r);
        const i = e.createElement("div");
        i.classList.add(En("s")),
        r.appendChild(i),
        this.swatchElement = i;
        const s = e.createElement("div");
        if (s.classList.add(En("t")),
        r.appendChild(s),
        this.textElement = s,
        n.pickerLayout === "inline") {
            const o = e.createElement("div");
            o.classList.add(En("p")),
            this.element.appendChild(o),
            this.pickerElement = o
        } else
            this.pickerElement = null
    }
}
function Kg(t, e, n) {
    const r = Le(t / 255, 0, 1)
      , i = Le(e / 255, 0, 1)
      , s = Le(n / 255, 0, 1)
      , o = Math.max(r, i, s)
      , a = Math.min(r, i, s)
      , l = o - a;
    let c = 0
      , u = 0;
    const d = (a + o) / 2;
    return l !== 0 && (u = l / (1 - Math.abs(o + a - 1)),
    r === o ? c = (i - s) / l : i === o ? c = 2 + (s - r) / l : c = 4 + (r - i) / l,
    c = c / 6 + (c < 0 ? 1 : 0)),
    [c * 360, u * 100, d * 100]
}
function Gg(t, e, n) {
    const r = (t % 360 + 360) % 360
      , i = Le(e / 100, 0, 1)
      , s = Le(n / 100, 0, 1)
      , o = (1 - Math.abs(2 * s - 1)) * i
      , a = o * (1 - Math.abs(r / 60 % 2 - 1))
      , l = s - o / 2;
    let c, u, d;
    return r >= 0 && r < 60 ? [c,u,d] = [o, a, 0] : r >= 60 && r < 120 ? [c,u,d] = [a, o, 0] : r >= 120 && r < 180 ? [c,u,d] = [0, o, a] : r >= 180 && r < 240 ? [c,u,d] = [0, a, o] : r >= 240 && r < 300 ? [c,u,d] = [a, 0, o] : [c,u,d] = [o, 0, a],
    [(c + l) * 255, (u + l) * 255, (d + l) * 255]
}
function qg(t, e, n) {
    const r = Le(t / 255, 0, 1)
      , i = Le(e / 255, 0, 1)
      , s = Le(n / 255, 0, 1)
      , o = Math.max(r, i, s)
      , a = Math.min(r, i, s)
      , l = o - a;
    let c;
    l === 0 ? c = 0 : o === r ? c = 60 * (((i - s) / l % 6 + 6) % 6) : o === i ? c = 60 * ((s - r) / l + 2) : c = 60 * ((r - i) / l + 4);
    const u = o === 0 ? 0 : l / o
      , d = o;
    return [c, u * 100, d * 100]
}
function tp(t, e, n) {
    const r = Sd(t, 360)
      , i = Le(e / 100, 0, 1)
      , s = Le(n / 100, 0, 1)
      , o = s * i
      , a = o * (1 - Math.abs(r / 60 % 2 - 1))
      , l = s - o;
    let c, u, d;
    return r >= 0 && r < 60 ? [c,u,d] = [o, a, 0] : r >= 60 && r < 120 ? [c,u,d] = [a, o, 0] : r >= 120 && r < 180 ? [c,u,d] = [0, o, a] : r >= 180 && r < 240 ? [c,u,d] = [0, a, o] : r >= 240 && r < 300 ? [c,u,d] = [a, 0, o] : [c,u,d] = [o, 0, a],
    [(c + l) * 255, (u + l) * 255, (d + l) * 255]
}
function Wg(t, e, n) {
    const r = n + e * (100 - Math.abs(2 * n - 100)) / 200;
    return [t, r !== 0 ? e * (100 - Math.abs(2 * n - 100)) / r : 0, n + e * (100 - Math.abs(2 * n - 100)) / (2 * 100)]
}
function Yg(t, e, n) {
    const r = 100 - Math.abs(n * (200 - e) / 100 - 100);
    return [t, r !== 0 ? e * n / r : 0, n * (200 - e) / (2 * 100)]
}
function Rt(t) {
    return [t[0], t[1], t[2]]
}
function Ks(t, e) {
    return [t[0], t[1], t[2], e]
}
const Zg = {
    hsl: {
        hsl: (t, e, n) => [t, e, n],
        hsv: Wg,
        rgb: Gg
    },
    hsv: {
        hsl: Yg,
        hsv: (t, e, n) => [t, e, n],
        rgb: tp
    },
    rgb: {
        hsl: Kg,
        hsv: qg,
        rgb: (t, e, n) => [t, e, n]
    }
};
function dr(t, e) {
    return [e === "float" ? 1 : t === "rgb" ? 255 : 360, e === "float" ? 1 : t === "rgb" ? 255 : 100, e === "float" ? 1 : t === "rgb" ? 255 : 100]
}
function Xg(t, e) {
    return t === e ? e : Sd(t, e)
}
function np(t, e, n) {
    var r;
    const i = dr(e, n);
    return [e === "rgb" ? Le(t[0], 0, i[0]) : Xg(t[0], i[0]), Le(t[1], 0, i[1]), Le(t[2], 0, i[2]), Le((r = t[3]) !== null && r !== void 0 ? r : 1, 0, 1)]
}
function oc(t, e, n, r) {
    const i = dr(e, n)
      , s = dr(e, r);
    return t.map( (o, a) => o / i[a] * s[a])
}
function rp(t, e, n) {
    const r = oc(t, e.mode, e.type, "int")
      , i = Zg[e.mode][n.mode](...r);
    return oc(i, n.mode, "int", n.type)
}
class oe {
    static black() {
        return new oe([0, 0, 0],"rgb")
    }
    constructor(e, n) {
        this.type = "int",
        this.mode = n,
        this.comps_ = np(e, n, this.type)
    }
    getComponents(e) {
        return Ks(rp(Rt(this.comps_), {
            mode: this.mode,
            type: this.type
        }, {
            mode: e ?? this.mode,
            type: this.type
        }), this.comps_[3])
    }
    toRgbaObject() {
        const e = this.getComponents("rgb");
        return {
            r: e[0],
            g: e[1],
            b: e[2],
            a: e[3]
        }
    }
}
const an = ie("colp");
class Qg {
    constructor(e, n) {
        this.alphaViews_ = null,
        this.element = e.createElement("div"),
        this.element.classList.add(an()),
        n.viewProps.bindClassModifiers(this.element);
        const r = e.createElement("div");
        r.classList.add(an("hsv"));
        const i = e.createElement("div");
        i.classList.add(an("sv")),
        this.svPaletteView_ = n.svPaletteView,
        i.appendChild(this.svPaletteView_.element),
        r.appendChild(i);
        const s = e.createElement("div");
        s.classList.add(an("h")),
        this.hPaletteView_ = n.hPaletteView,
        s.appendChild(this.hPaletteView_.element),
        r.appendChild(s),
        this.element.appendChild(r);
        const o = e.createElement("div");
        if (o.classList.add(an("rgb")),
        this.textsView_ = n.textsView,
        o.appendChild(this.textsView_.element),
        this.element.appendChild(o),
        n.alphaViews) {
            this.alphaViews_ = {
                palette: n.alphaViews.palette,
                text: n.alphaViews.text
            };
            const a = e.createElement("div");
            a.classList.add(an("a"));
            const l = e.createElement("div");
            l.classList.add(an("ap")),
            l.appendChild(this.alphaViews_.palette.element),
            a.appendChild(l);
            const c = e.createElement("div");
            c.classList.add(an("at")),
            c.appendChild(this.alphaViews_.text.element),
            a.appendChild(c),
            this.element.appendChild(a)
        }
    }
    get allFocusableElements() {
        const e = [this.svPaletteView_.element, this.hPaletteView_.element, this.textsView_.modeSelectElement, ...this.textsView_.inputViews.map(n => n.inputElement)];
        return this.alphaViews_ && e.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement),
        e
    }
}
function Jg(t) {
    return t === "int" ? "int" : t === "float" ? "float" : void 0
}
function Ra(t) {
    return Ee(t, e => ({
        color: e.optional.object({
            alpha: e.optional.boolean,
            type: e.optional.custom(Jg)
        }),
        expanded: e.optional.boolean,
        picker: e.optional.custom(ep),
        readonly: e.optional.constant(!1)
    }))
}
function Un(t) {
    return t ? .1 : 1
}
function ip(t) {
    var e;
    return (e = t.color) === null || e === void 0 ? void 0 : e.type
}
class Ia {
    constructor(e, n) {
        this.type = "float",
        this.mode = n,
        this.comps_ = np(e, n, this.type)
    }
    getComponents(e) {
        return Ks(rp(Rt(this.comps_), {
            mode: this.mode,
            type: this.type
        }, {
            mode: e ?? this.mode,
            type: this.type
        }), this.comps_[3])
    }
    toRgbaObject() {
        const e = this.getComponents("rgb");
        return {
            r: e[0],
            g: e[1],
            b: e[2],
            a: e[3]
        }
    }
}
const eb = {
    int: (t, e) => new oe(t,e),
    float: (t, e) => new Ia(t,e)
};
function Va(t, e, n) {
    return eb[n](t, e)
}
function tb(t) {
    return t.type === "float"
}
function nb(t) {
    return t.type === "int"
}
function rb(t) {
    const e = t.getComponents()
      , n = dr(t.mode, "int");
    return new oe([Math.round(ue(e[0], 0, 1, 0, n[0])), Math.round(ue(e[1], 0, 1, 0, n[1])), Math.round(ue(e[2], 0, 1, 0, n[2])), e[3]],t.mode)
}
function ib(t) {
    const e = t.getComponents()
      , n = dr(t.mode, "int");
    return new Ia([ue(e[0], 0, n[0], 0, 1), ue(e[1], 0, n[1], 0, 1), ue(e[2], 0, n[2], 0, 1), e[3]],t.mode)
}
function Ge(t, e) {
    if (t.type === e)
        return t;
    if (nb(t) && e === "float")
        return ib(t);
    if (tb(t) && e === "int")
        return rb(t);
    throw Te.shouldNeverHappen()
}
function sb(t, e) {
    return t.alpha === e.alpha && t.mode === e.mode && t.notation === e.notation && t.type === e.type
}
function lt(t, e) {
    const n = t.match(/^(.+)%$/);
    return Math.min(n ? parseFloat(n[1]) * .01 * e : parseFloat(t), e)
}
const ob = {
    deg: t => t,
    grad: t => t * 360 / 400,
    rad: t => t * 360 / (2 * Math.PI),
    turn: t => t * 360
};
function sp(t) {
    const e = t.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
    if (!e)
        return parseFloat(t);
    const n = parseFloat(e[1])
      , r = e[2];
    return ob[r](n)
}
function op(t) {
    const e = t.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
    if (!e)
        return null;
    const n = [lt(e[1], 255), lt(e[2], 255), lt(e[3], 255)];
    return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) ? null : n
}
function ab(t) {
    const e = op(t);
    return e ? new oe(e,"rgb") : null
}
function ap(t) {
    const e = t.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
    if (!e)
        return null;
    const n = [lt(e[1], 255), lt(e[2], 255), lt(e[3], 255), lt(e[4], 1)];
    return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) || isNaN(n[3]) ? null : n
}
function lb(t) {
    const e = ap(t);
    return e ? new oe(e,"rgb") : null
}
function lp(t) {
    const e = t.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
    if (!e)
        return null;
    const n = [sp(e[1]), lt(e[2], 100), lt(e[3], 100)];
    return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) ? null : n
}
function cb(t) {
    const e = lp(t);
    return e ? new oe(e,"hsl") : null
}
function cp(t) {
    const e = t.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
    if (!e)
        return null;
    const n = [sp(e[1]), lt(e[2], 100), lt(e[3], 100), lt(e[4], 1)];
    return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) || isNaN(n[3]) ? null : n
}
function ub(t) {
    const e = cp(t);
    return e ? new oe(e,"hsl") : null
}
function up(t) {
    const e = t.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
    if (e)
        return [parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16), parseInt(e[3] + e[3], 16)];
    const n = t.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
    return n ? [parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16)] : null
}
function db(t) {
    const e = up(t);
    return e ? new oe(e,"rgb") : null
}
function dp(t) {
    const e = t.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
    if (e)
        return [parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16), parseInt(e[3] + e[3], 16), ue(parseInt(e[4] + e[4], 16), 0, 255, 0, 1)];
    const n = t.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
    return n ? [parseInt(n[1], 16), parseInt(n[2], 16), parseInt(n[3], 16), ue(parseInt(n[4], 16), 0, 255, 0, 1)] : null
}
function pb(t) {
    const e = dp(t);
    return e ? new oe(e,"rgb") : null
}
function pp(t) {
    const e = t.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
    if (!e)
        return null;
    const n = [parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3])];
    return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) ? null : n
}
function hb(t) {
    return e => {
        const n = pp(e);
        return n ? Va(n, "rgb", t) : null
    }
}
function hp(t) {
    const e = t.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
    if (!e)
        return null;
    const n = [parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3]), parseFloat(e[4])];
    return isNaN(n[0]) || isNaN(n[1]) || isNaN(n[2]) || isNaN(n[3]) ? null : n
}
function fb(t) {
    return e => {
        const n = hp(e);
        return n ? Va(n, "rgb", t) : null
    }
}
const mb = [{
    parser: up,
    result: {
        alpha: !1,
        mode: "rgb",
        notation: "hex"
    }
}, {
    parser: dp,
    result: {
        alpha: !0,
        mode: "rgb",
        notation: "hex"
    }
}, {
    parser: op,
    result: {
        alpha: !1,
        mode: "rgb",
        notation: "func"
    }
}, {
    parser: ap,
    result: {
        alpha: !0,
        mode: "rgb",
        notation: "func"
    }
}, {
    parser: lp,
    result: {
        alpha: !1,
        mode: "hsl",
        notation: "func"
    }
}, {
    parser: cp,
    result: {
        alpha: !0,
        mode: "hsl",
        notation: "func"
    }
}, {
    parser: pp,
    result: {
        alpha: !1,
        mode: "rgb",
        notation: "object"
    }
}, {
    parser: hp,
    result: {
        alpha: !0,
        mode: "rgb",
        notation: "object"
    }
}];
function vb(t) {
    return mb.reduce( (e, {parser: n, result: r}) => e || (n(t) ? r : null), null)
}
function gb(t, e="int") {
    const n = vb(t);
    return n ? n.notation === "hex" && e !== "float" ? Object.assign(Object.assign({}, n), {
        type: "int"
    }) : n.notation === "func" ? Object.assign(Object.assign({}, n), {
        type: e
    }) : null : null
}
function Oi(t) {
    const e = [db, pb, ab, lb, cb, ub];
    e.push(hb("int"), fb("int"));
    const n = Mg(e);
    return r => {
        const i = n(r);
        return i ? Ge(i, t) : null
    }
}
function bb(t) {
    const e = Oi("int");
    if (typeof t != "string")
        return oe.black();
    const n = e(t);
    return n ?? oe.black()
}
function fp(t) {
    const e = Le(Math.floor(t), 0, 255).toString(16);
    return e.length === 1 ? `0${e}` : e
}
function Da(t, e="#") {
    const n = Rt(t.getComponents("rgb")).map(fp).join("");
    return `${e}${n}`
}
function Ba(t, e="#") {
    const n = t.getComponents("rgb")
      , r = [n[0], n[1], n[2], n[3] * 255].map(fp).join("");
    return `${e}${r}`
}
function mp(t) {
    const e = et(0)
      , n = Ge(t, "int");
    return `rgb(${Rt(n.getComponents("rgb")).map(i => e(i)).join(", ")})`
}
function ss(t) {
    const e = et(2)
      , n = et(0);
    return `rgba(${Ge(t, "int").getComponents("rgb").map( (s, o) => (o === 3 ? e : n)(s)).join(", ")})`
}
function _b(t) {
    const e = [et(0), Cs, Cs]
      , n = Ge(t, "int");
    return `hsl(${Rt(n.getComponents("hsl")).map( (i, s) => e[s](i)).join(", ")})`
}
function yb(t) {
    const e = [et(0), Cs, Cs, et(2)];
    return `hsla(${Ge(t, "int").getComponents("hsl").map( (i, s) => e[s](i)).join(", ")})`
}
function vp(t, e) {
    const n = et(e === "float" ? 2 : 0)
      , r = ["r", "g", "b"]
      , i = Ge(t, e);
    return `{${Rt(i.getComponents("rgb")).map( (o, a) => `${r[a]}: ${n(o)}`).join(", ")}}`
}
function wb(t) {
    return e => vp(e, t)
}
function gp(t, e) {
    const n = et(2)
      , r = et(e === "float" ? 2 : 0)
      , i = ["r", "g", "b", "a"];
    return `{${Ge(t, e).getComponents("rgb").map( (a, l) => {
        const c = l === 3 ? n : r;
        return `${i[l]}: ${c(a)}`
    }
    ).join(", ")}}`
}
function xb(t) {
    return e => gp(e, t)
}
const Cb = [{
    format: {
        alpha: !1,
        mode: "rgb",
        notation: "hex",
        type: "int"
    },
    stringifier: Da
}, {
    format: {
        alpha: !0,
        mode: "rgb",
        notation: "hex",
        type: "int"
    },
    stringifier: Ba
}, {
    format: {
        alpha: !1,
        mode: "rgb",
        notation: "func",
        type: "int"
    },
    stringifier: mp
}, {
    format: {
        alpha: !0,
        mode: "rgb",
        notation: "func",
        type: "int"
    },
    stringifier: ss
}, {
    format: {
        alpha: !1,
        mode: "hsl",
        notation: "func",
        type: "int"
    },
    stringifier: _b
}, {
    format: {
        alpha: !0,
        mode: "hsl",
        notation: "func",
        type: "int"
    },
    stringifier: yb
}, ...["int", "float"].reduce( (t, e) => [...t, {
    format: {
        alpha: !1,
        mode: "rgb",
        notation: "object",
        type: e
    },
    stringifier: wb(e)
}, {
    format: {
        alpha: !0,
        mode: "rgb",
        notation: "object",
        type: e
    },
    stringifier: xb(e)
}], [])];
function bp(t) {
    return Cb.reduce( (e, n) => e || (sb(n.format, t) ? n.stringifier : null), null)
}
const Ir = ie("apl");
class Eb {
    constructor(e, n) {
        this.onValueChange_ = this.onValueChange_.bind(this),
        this.value = n.value,
        this.value.emitter.on("change", this.onValueChange_),
        this.element = e.createElement("div"),
        this.element.classList.add(Ir()),
        n.viewProps.bindClassModifiers(this.element),
        n.viewProps.bindTabIndex(this.element);
        const r = e.createElement("div");
        r.classList.add(Ir("b")),
        this.element.appendChild(r);
        const i = e.createElement("div");
        i.classList.add(Ir("c")),
        r.appendChild(i),
        this.colorElem_ = i;
        const s = e.createElement("div");
        s.classList.add(Ir("m")),
        this.element.appendChild(s),
        this.markerElem_ = s;
        const o = e.createElement("div");
        o.classList.add(Ir("p")),
        this.markerElem_.appendChild(o),
        this.previewElem_ = o,
        this.update_()
    }
    update_() {
        const e = this.value.rawValue
          , n = e.getComponents("rgb")
          , r = new oe([n[0], n[1], n[2], 0],"rgb")
          , i = new oe([n[0], n[1], n[2], 255],"rgb")
          , s = ["to right", ss(r), ss(i)];
        this.colorElem_.style.background = `linear-gradient(${s.join(",")})`,
        this.previewElem_.style.backgroundColor = ss(e);
        const o = ue(n[3], 0, 1, 0, 100);
        this.markerElem_.style.left = `${o}%`
    }
    onValueChange_() {
        this.update_()
    }
}
class Pb {
    constructor(e, n) {
        this.onKeyDown_ = this.onKeyDown_.bind(this),
        this.onKeyUp_ = this.onKeyUp_.bind(this),
        this.onPointerDown_ = this.onPointerDown_.bind(this),
        this.onPointerMove_ = this.onPointerMove_.bind(this),
        this.onPointerUp_ = this.onPointerUp_.bind(this),
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.view = new Eb(e,{
            value: this.value,
            viewProps: this.viewProps
        }),
        this.ptHandler_ = new Gn(this.view.element),
        this.ptHandler_.emitter.on("down", this.onPointerDown_),
        this.ptHandler_.emitter.on("move", this.onPointerMove_),
        this.ptHandler_.emitter.on("up", this.onPointerUp_),
        this.view.element.addEventListener("keydown", this.onKeyDown_),
        this.view.element.addEventListener("keyup", this.onKeyUp_)
    }
    handlePointerEvent_(e, n) {
        if (!e.point)
            return;
        const r = e.point.x / e.bounds.width
          , i = this.value.rawValue
          , [s,o,a] = i.getComponents("hsv");
        this.value.setRawValue(new oe([s, o, a, r],"hsv"), n)
    }
    onPointerDown_(e) {
        this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerMove_(e) {
        this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerUp_(e) {
        this.handlePointerEvent_(e.data, {
            forceEmit: !0,
            last: !0
        })
    }
    onKeyDown_(e) {
        const n = Xe(Un(!0), Qt(e));
        if (n === 0)
            return;
        const r = this.value.rawValue
          , [i,s,o,a] = r.getComponents("hsv");
        this.value.setRawValue(new oe([i, s, o, a + n],"hsv"), {
            forceEmit: !1,
            last: !1
        })
    }
    onKeyUp_(e) {
        Xe(Un(!0), Qt(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
        })
    }
}
const Xn = ie("coltxt");
function Ob(t) {
    const e = t.createElement("select")
      , n = [{
        text: "RGB",
        value: "rgb"
    }, {
        text: "HSL",
        value: "hsl"
    }, {
        text: "HSV",
        value: "hsv"
    }, {
        text: "HEX",
        value: "hex"
    }];
    return e.appendChild(n.reduce( (r, i) => {
        const s = t.createElement("option");
        return s.textContent = i.text,
        s.value = i.value,
        r.appendChild(s),
        r
    }
    , t.createDocumentFragment())),
    e
}
class Tb {
    constructor(e, n) {
        this.element = e.createElement("div"),
        this.element.classList.add(Xn()),
        n.viewProps.bindClassModifiers(this.element);
        const r = e.createElement("div");
        r.classList.add(Xn("m")),
        this.modeElem_ = Ob(e),
        this.modeElem_.classList.add(Xn("ms")),
        r.appendChild(this.modeSelectElement),
        n.viewProps.bindDisabled(this.modeElem_);
        const i = e.createElement("div");
        i.classList.add(Xn("mm")),
        i.appendChild(zs(e, "dropdown")),
        r.appendChild(i),
        this.element.appendChild(r);
        const s = e.createElement("div");
        s.classList.add(Xn("w")),
        this.element.appendChild(s),
        this.inputsElem_ = s,
        this.inputViews_ = n.inputViews,
        this.applyInputViews_(),
        Yt(n.mode, o => {
            this.modeElem_.value = o
        }
        )
    }
    get modeSelectElement() {
        return this.modeElem_
    }
    get inputViews() {
        return this.inputViews_
    }
    set inputViews(e) {
        this.inputViews_ = e,
        this.applyInputViews_()
    }
    applyInputViews_() {
        Bd(this.inputsElem_);
        const e = this.element.ownerDocument;
        this.inputViews_.forEach(n => {
            const r = e.createElement("div");
            r.classList.add(Xn("c")),
            r.appendChild(n.element),
            this.inputsElem_.appendChild(r)
        }
        )
    }
}
function Ab(t) {
    return et(t === "float" ? 2 : 0)
}
function Sb(t, e, n) {
    const r = dr(t, e)[n];
    return new bi({
        min: 0,
        max: r
    })
}
function kb(t, e, n) {
    return new Ei(t,{
        arrayPosition: n === 0 ? "fst" : n === 2 ? "lst" : "mid",
        parser: e.parser,
        props: Q.fromObject({
            formatter: Ab(e.colorType),
            keyScale: Un(!1),
            pointerScale: e.colorType === "float" ? .01 : 1
        }),
        value: ye(0, {
            constraint: Sb(e.colorMode, e.colorType, n)
        }),
        viewProps: e.viewProps
    })
}
function Mb(t, e) {
    const n = {
        colorMode: e.colorMode,
        colorType: e.colorType,
        parser: Xt,
        viewProps: e.viewProps
    };
    return [0, 1, 2].map(r => {
        const i = kb(t, n, r);
        return xr({
            primary: e.value,
            secondary: i.value,
            forward(s) {
                return Ge(s, e.colorType).getComponents(e.colorMode)[r]
            },
            backward(s, o) {
                const a = e.colorMode
                  , c = Ge(s, e.colorType).getComponents(a);
                c[r] = o;
                const u = Va(Ks(Rt(c), c[3]), a, e.colorType);
                return Ge(u, "int")
            }
        }),
        i
    }
    )
}
function Lb(t, e) {
    const n = new oi(t,{
        parser: Oi("int"),
        props: Q.fromObject({
            formatter: Da
        }),
        value: ye(oe.black()),
        viewProps: e.viewProps
    });
    return xr({
        primary: e.value,
        secondary: n.value,
        forward: r => new oe(Rt(r.getComponents()),r.mode),
        backward: (r, i) => new oe(Ks(Rt(i.getComponents(r.mode)), r.getComponents()[3]),r.mode)
    }),
    [n]
}
function Fb(t) {
    return t !== "hex"
}
class Rb {
    constructor(e, n) {
        this.onModeSelectChange_ = this.onModeSelectChange_.bind(this),
        this.colorType_ = n.colorType,
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.colorMode = ye(this.value.rawValue.mode),
        this.ccs_ = this.createComponentControllers_(e),
        this.view = new Tb(e,{
            mode: this.colorMode,
            inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
            viewProps: this.viewProps
        }),
        this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_)
    }
    createComponentControllers_(e) {
        const n = this.colorMode.rawValue;
        return Fb(n) ? Mb(e, {
            colorMode: n,
            colorType: this.colorType_,
            value: this.value,
            viewProps: this.viewProps
        }) : Lb(e, {
            value: this.value,
            viewProps: this.viewProps
        })
    }
    onModeSelectChange_(e) {
        const n = e.currentTarget;
        this.colorMode.rawValue = n.value,
        this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument),
        this.view.inputViews = this.ccs_.map(r => r.view)
    }
}
const fo = ie("hpl");
class Ib {
    constructor(e, n) {
        this.onValueChange_ = this.onValueChange_.bind(this),
        this.value = n.value,
        this.value.emitter.on("change", this.onValueChange_),
        this.element = e.createElement("div"),
        this.element.classList.add(fo()),
        n.viewProps.bindClassModifiers(this.element),
        n.viewProps.bindTabIndex(this.element);
        const r = e.createElement("div");
        r.classList.add(fo("c")),
        this.element.appendChild(r);
        const i = e.createElement("div");
        i.classList.add(fo("m")),
        this.element.appendChild(i),
        this.markerElem_ = i,
        this.update_()
    }
    update_() {
        const e = this.value.rawValue
          , [n] = e.getComponents("hsv");
        this.markerElem_.style.backgroundColor = mp(new oe([n, 100, 100],"hsv"));
        const r = ue(n, 0, 360, 0, 100);
        this.markerElem_.style.left = `${r}%`
    }
    onValueChange_() {
        this.update_()
    }
}
class Vb {
    constructor(e, n) {
        this.onKeyDown_ = this.onKeyDown_.bind(this),
        this.onKeyUp_ = this.onKeyUp_.bind(this),
        this.onPointerDown_ = this.onPointerDown_.bind(this),
        this.onPointerMove_ = this.onPointerMove_.bind(this),
        this.onPointerUp_ = this.onPointerUp_.bind(this),
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.view = new Ib(e,{
            value: this.value,
            viewProps: this.viewProps
        }),
        this.ptHandler_ = new Gn(this.view.element),
        this.ptHandler_.emitter.on("down", this.onPointerDown_),
        this.ptHandler_.emitter.on("move", this.onPointerMove_),
        this.ptHandler_.emitter.on("up", this.onPointerUp_),
        this.view.element.addEventListener("keydown", this.onKeyDown_),
        this.view.element.addEventListener("keyup", this.onKeyUp_)
    }
    handlePointerEvent_(e, n) {
        if (!e.point)
            return;
        const r = ue(Le(e.point.x, 0, e.bounds.width), 0, e.bounds.width, 0, 360)
          , i = this.value.rawValue
          , [,s,o,a] = i.getComponents("hsv");
        this.value.setRawValue(new oe([r, s, o, a],"hsv"), n)
    }
    onPointerDown_(e) {
        this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerMove_(e) {
        this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerUp_(e) {
        this.handlePointerEvent_(e.data, {
            forceEmit: !0,
            last: !0
        })
    }
    onKeyDown_(e) {
        const n = Xe(Un(!1), Qt(e));
        if (n === 0)
            return;
        const r = this.value.rawValue
          , [i,s,o,a] = r.getComponents("hsv");
        this.value.setRawValue(new oe([i + n, s, o, a],"hsv"), {
            forceEmit: !1,
            last: !1
        })
    }
    onKeyUp_(e) {
        Xe(Un(!1), Qt(e)) !== 0 && this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
        })
    }
}
const mo = ie("svp")
  , ac = 64;
class Db {
    constructor(e, n) {
        this.onValueChange_ = this.onValueChange_.bind(this),
        this.value = n.value,
        this.value.emitter.on("change", this.onValueChange_),
        this.element = e.createElement("div"),
        this.element.classList.add(mo()),
        n.viewProps.bindClassModifiers(this.element),
        n.viewProps.bindTabIndex(this.element);
        const r = e.createElement("canvas");
        r.height = ac,
        r.width = ac,
        r.classList.add(mo("c")),
        this.element.appendChild(r),
        this.canvasElement = r;
        const i = e.createElement("div");
        i.classList.add(mo("m")),
        this.element.appendChild(i),
        this.markerElem_ = i,
        this.update_()
    }
    update_() {
        const e = Vv(this.canvasElement);
        if (!e)
            return;
        const r = this.value.rawValue.getComponents("hsv")
          , i = this.canvasElement.width
          , s = this.canvasElement.height
          , o = e.getImageData(0, 0, i, s)
          , a = o.data;
        for (let u = 0; u < s; u++)
            for (let d = 0; d < i; d++) {
                const m = ue(d, 0, i, 0, 100)
                  , g = ue(u, 0, s, 100, 0)
                  , f = tp(r[0], m, g)
                  , h = (u * i + d) * 4;
                a[h] = f[0],
                a[h + 1] = f[1],
                a[h + 2] = f[2],
                a[h + 3] = 255
            }
        e.putImageData(o, 0, 0);
        const l = ue(r[1], 0, 100, 0, 100);
        this.markerElem_.style.left = `${l}%`;
        const c = ue(r[2], 0, 100, 100, 0);
        this.markerElem_.style.top = `${c}%`
    }
    onValueChange_() {
        this.update_()
    }
}
class Bb {
    constructor(e, n) {
        this.onKeyDown_ = this.onKeyDown_.bind(this),
        this.onKeyUp_ = this.onKeyUp_.bind(this),
        this.onPointerDown_ = this.onPointerDown_.bind(this),
        this.onPointerMove_ = this.onPointerMove_.bind(this),
        this.onPointerUp_ = this.onPointerUp_.bind(this),
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.view = new Db(e,{
            value: this.value,
            viewProps: this.viewProps
        }),
        this.ptHandler_ = new Gn(this.view.element),
        this.ptHandler_.emitter.on("down", this.onPointerDown_),
        this.ptHandler_.emitter.on("move", this.onPointerMove_),
        this.ptHandler_.emitter.on("up", this.onPointerUp_),
        this.view.element.addEventListener("keydown", this.onKeyDown_),
        this.view.element.addEventListener("keyup", this.onKeyUp_)
    }
    handlePointerEvent_(e, n) {
        if (!e.point)
            return;
        const r = ue(e.point.x, 0, e.bounds.width, 0, 100)
          , i = ue(e.point.y, 0, e.bounds.height, 100, 0)
          , [s,,,o] = this.value.rawValue.getComponents("hsv");
        this.value.setRawValue(new oe([s, r, i, o],"hsv"), n)
    }
    onPointerDown_(e) {
        this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerMove_(e) {
        this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerUp_(e) {
        this.handlePointerEvent_(e.data, {
            forceEmit: !0,
            last: !0
        })
    }
    onKeyDown_(e) {
        Xd(e.key) && e.preventDefault();
        const [n,r,i,s] = this.value.rawValue.getComponents("hsv")
          , o = Un(!1)
          , a = Xe(o, Qt(e))
          , l = Xe(o, ai(e));
        a === 0 && l === 0 || this.value.setRawValue(new oe([n, r + a, i + l, s],"hsv"), {
            forceEmit: !1,
            last: !1
        })
    }
    onKeyUp_(e) {
        const n = Un(!1)
          , r = Xe(n, Qt(e))
          , i = Xe(n, ai(e));
        r === 0 && i === 0 || this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
        })
    }
}
class $b {
    constructor(e, n) {
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.hPaletteC_ = new Vb(e,{
            value: this.value,
            viewProps: this.viewProps
        }),
        this.svPaletteC_ = new Bb(e,{
            value: this.value,
            viewProps: this.viewProps
        }),
        this.alphaIcs_ = n.supportsAlpha ? {
            palette: new Pb(e,{
                value: this.value,
                viewProps: this.viewProps
            }),
            text: new Ei(e,{
                parser: Xt,
                props: Q.fromObject({
                    pointerScale: .01,
                    keyScale: .1,
                    formatter: et(2)
                }),
                value: ye(0, {
                    constraint: new bi({
                        min: 0,
                        max: 1
                    })
                }),
                viewProps: this.viewProps
            })
        } : null,
        this.alphaIcs_ && xr({
            primary: this.value,
            secondary: this.alphaIcs_.text.value,
            forward: r => r.getComponents()[3],
            backward: (r, i) => {
                const s = r.getComponents();
                return s[3] = i,
                new oe(s,r.mode)
            }
        }),
        this.textsC_ = new Rb(e,{
            colorType: n.colorType,
            value: this.value,
            viewProps: this.viewProps
        }),
        this.view = new Qg(e,{
            alphaViews: this.alphaIcs_ ? {
                palette: this.alphaIcs_.palette.view,
                text: this.alphaIcs_.text.view
            } : null,
            hPaletteView: this.hPaletteC_.view,
            supportsAlpha: n.supportsAlpha,
            svPaletteView: this.svPaletteC_.view,
            textsView: this.textsC_.view,
            viewProps: this.viewProps
        })
    }
    get textsController() {
        return this.textsC_
    }
}
const vo = ie("colsw");
class Ub {
    constructor(e, n) {
        this.onValueChange_ = this.onValueChange_.bind(this),
        n.value.emitter.on("change", this.onValueChange_),
        this.value = n.value,
        this.element = e.createElement("div"),
        this.element.classList.add(vo()),
        n.viewProps.bindClassModifiers(this.element);
        const r = e.createElement("div");
        r.classList.add(vo("sw")),
        this.element.appendChild(r),
        this.swatchElem_ = r;
        const i = e.createElement("button");
        i.classList.add(vo("b")),
        n.viewProps.bindDisabled(i),
        this.element.appendChild(i),
        this.buttonElement = i,
        this.update_()
    }
    update_() {
        const e = this.value.rawValue;
        this.swatchElem_.style.backgroundColor = Ba(e)
    }
    onValueChange_() {
        this.update_()
    }
}
class jb {
    constructor(e, n) {
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.view = new Ub(e,{
            value: this.value,
            viewProps: this.viewProps
        })
    }
}
class $a {
    constructor(e, n) {
        this.onButtonBlur_ = this.onButtonBlur_.bind(this),
        this.onButtonClick_ = this.onButtonClick_.bind(this),
        this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this),
        this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this),
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.foldable_ = yi.create(n.expanded),
        this.swatchC_ = new jb(e,{
            value: this.value,
            viewProps: this.viewProps
        });
        const r = this.swatchC_.view.buttonElement;
        r.addEventListener("blur", this.onButtonBlur_),
        r.addEventListener("click", this.onButtonClick_),
        this.textC_ = new oi(e,{
            parser: n.parser,
            props: Q.fromObject({
                formatter: n.formatter
            }),
            value: this.value,
            viewProps: this.viewProps
        }),
        this.view = new Hg(e,{
            foldable: this.foldable_,
            pickerLayout: n.pickerLayout
        }),
        this.view.swatchElement.appendChild(this.swatchC_.view.element),
        this.view.textElement.appendChild(this.textC_.view.element),
        this.popC_ = n.pickerLayout === "popup" ? new Wd(e,{
            viewProps: this.viewProps
        }) : null;
        const i = new $b(e,{
            colorType: n.colorType,
            supportsAlpha: n.supportsAlpha,
            value: this.value,
            viewProps: this.viewProps
        });
        i.view.allFocusableElements.forEach(s => {
            s.addEventListener("blur", this.onPopupChildBlur_),
            s.addEventListener("keydown", this.onPopupChildKeydown_)
        }
        ),
        this.pickerC_ = i,
        this.popC_ ? (this.view.element.appendChild(this.popC_.view.element),
        this.popC_.view.element.appendChild(i.view.element),
        xr({
            primary: this.foldable_.value("expanded"),
            secondary: this.popC_.shows,
            forward: s => s,
            backward: (s, o) => o
        })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element),
        ka(this.foldable_, this.view.pickerElement))
    }
    get textController() {
        return this.textC_
    }
    onButtonBlur_(e) {
        if (!this.popC_)
            return;
        const n = this.view.element
          , r = e.relatedTarget;
        (!r || !n.contains(r)) && (this.popC_.shows.rawValue = !1)
    }
    onButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")),
        this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
    }
    onPopupChildBlur_(e) {
        if (!this.popC_)
            return;
        const n = this.popC_.view.element
          , r = $d(e);
        r && n.contains(r) || r && r === this.swatchC_.view.buttonElement && !Ea(n.ownerDocument) || (this.popC_.shows.rawValue = !1)
    }
    onPopupChildKeydown_(e) {
        this.popC_ ? e.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && e.key === "Escape" && this.swatchC_.view.buttonElement.focus()
    }
}
function Nb(t) {
    return Rt(t.getComponents("rgb")).reduce( (e, n) => e << 8 | Math.floor(n) & 255, 0)
}
function zb(t) {
    return t.getComponents("rgb").reduce( (e, n, r) => {
        const i = Math.floor(r === 3 ? n * 255 : n) & 255;
        return e << 8 | i
    }
    , 0) >>> 0
}
function Hb(t) {
    return new oe([t >> 16 & 255, t >> 8 & 255, t & 255],"rgb")
}
function Kb(t) {
    return new oe([t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, ue(t & 255, 0, 255, 0, 1)],"rgb")
}
function Gb(t) {
    return typeof t != "number" ? oe.black() : Hb(t)
}
function qb(t) {
    return typeof t != "number" ? oe.black() : Kb(t)
}
function os(t, e) {
    return typeof t != "object" || ge(t) ? !1 : e in t && typeof t[e] == "number"
}
function _p(t) {
    return os(t, "r") && os(t, "g") && os(t, "b")
}
function yp(t) {
    return _p(t) && os(t, "a")
}
function wp(t) {
    return _p(t)
}
function Ua(t, e) {
    if (t.mode !== e.mode || t.type !== e.type)
        return !1;
    const n = t.getComponents()
      , r = e.getComponents();
    for (let i = 0; i < n.length; i++)
        if (n[i] !== r[i])
            return !1;
    return !0
}
function lc(t) {
    return "a"in t ? [t.r, t.g, t.b, t.a] : [t.r, t.g, t.b]
}
function Wb(t) {
    const e = bp(t);
    return e ? (n, r) => {
        Pi(n, e(r))
    }
    : null
}
function Yb(t) {
    const e = t ? zb : Nb;
    return (n, r) => {
        Pi(n, e(r))
    }
}
function Zb(t, e, n) {
    const i = Ge(e, n).toRgbaObject();
    t.writeProperty("r", i.r),
    t.writeProperty("g", i.g),
    t.writeProperty("b", i.b),
    t.writeProperty("a", i.a)
}
function Xb(t, e, n) {
    const i = Ge(e, n).toRgbaObject();
    t.writeProperty("r", i.r),
    t.writeProperty("g", i.g),
    t.writeProperty("b", i.b)
}
function Qb(t, e) {
    return (n, r) => {
        t ? Zb(n, r, e) : Xb(n, r, e)
    }
}
function Jb(t) {
    var e;
    return !!(!((e = t == null ? void 0 : t.color) === null || e === void 0) && e.alpha)
}
function e_(t) {
    return t ? e => Ba(e, "0x") : e => Da(e, "0x")
}
function t_(t) {
    return "color"in t || t.view === "color"
}
const n_ = We({
    id: "input-color-number",
    type: "input",
    accept: (t, e) => {
        if (typeof t != "number" || !t_(e))
            return null;
        const n = Ra(e);
        return n ? {
            initialValue: t,
            params: Object.assign(Object.assign({}, n), {
                supportsAlpha: Jb(e)
            })
        } : null
    }
    ,
    binding: {
        reader: t => t.params.supportsAlpha ? qb : Gb,
        equals: Ua,
        writer: t => Yb(t.params.supportsAlpha)
    },
    controller: t => {
        var e, n;
        return new $a(t.document,{
            colorType: "int",
            expanded: (e = t.params.expanded) !== null && e !== void 0 ? e : !1,
            formatter: e_(t.params.supportsAlpha),
            parser: Oi("int"),
            pickerLayout: (n = t.params.picker) !== null && n !== void 0 ? n : "popup",
            supportsAlpha: t.params.supportsAlpha,
            value: t.value,
            viewProps: t.viewProps
        })
    }
});
function r_(t, e) {
    if (!wp(t))
        return Ge(oe.black(), e);
    if (e === "int") {
        const n = lc(t);
        return new oe(n,"rgb")
    }
    if (e === "float") {
        const n = lc(t);
        return new Ia(n,"rgb")
    }
    return Ge(oe.black(), "int")
}
function i_(t) {
    return yp(t)
}
function s_(t) {
    return e => {
        const n = r_(e, t);
        return Ge(n, "int")
    }
}
function o_(t, e) {
    return n => t ? gp(n, e) : vp(n, e)
}
const a_ = We({
    id: "input-color-object",
    type: "input",
    accept: (t, e) => {
        var n;
        if (!wp(t))
            return null;
        const r = Ra(e);
        return r ? {
            initialValue: t,
            params: Object.assign(Object.assign({}, r), {
                colorType: (n = ip(e)) !== null && n !== void 0 ? n : "int"
            })
        } : null
    }
    ,
    binding: {
        reader: t => s_(t.params.colorType),
        equals: Ua,
        writer: t => Qb(i_(t.initialValue), t.params.colorType)
    },
    controller: t => {
        var e, n;
        const r = yp(t.initialValue);
        return new $a(t.document,{
            colorType: t.params.colorType,
            expanded: (e = t.params.expanded) !== null && e !== void 0 ? e : !1,
            formatter: o_(r, t.params.colorType),
            parser: Oi("int"),
            pickerLayout: (n = t.params.picker) !== null && n !== void 0 ? n : "popup",
            supportsAlpha: r,
            value: t.value,
            viewProps: t.viewProps
        })
    }
})
  , l_ = We({
    id: "input-color-string",
    type: "input",
    accept: (t, e) => {
        if (typeof t != "string" || e.view === "text")
            return null;
        const n = gb(t, ip(e));
        if (!n)
            return null;
        const r = bp(n);
        if (!r)
            return null;
        const i = Ra(e);
        return i ? {
            initialValue: t,
            params: Object.assign(Object.assign({}, i), {
                format: n,
                stringifier: r
            })
        } : null
    }
    ,
    binding: {
        reader: () => bb,
        equals: Ua,
        writer: t => {
            const e = Wb(t.params.format);
            if (!e)
                throw Te.notBindable();
            return e
        }
    },
    controller: t => {
        var e, n;
        return new $a(t.document,{
            colorType: t.params.format.type,
            expanded: (e = t.params.expanded) !== null && e !== void 0 ? e : !1,
            formatter: t.params.stringifier,
            parser: Oi("int"),
            pickerLayout: (n = t.params.picker) !== null && n !== void 0 ? n : "popup",
            supportsAlpha: t.params.format.alpha,
            value: t.value,
            viewProps: t.viewProps
        })
    }
});
class ja {
    constructor(e) {
        this.components = e.components,
        this.asm_ = e.assembly
    }
    constrain(e) {
        const n = this.asm_.toComponents(e).map( (r, i) => {
            var s, o;
            return (o = (s = this.components[i]) === null || s === void 0 ? void 0 : s.constrain(r)) !== null && o !== void 0 ? o : r
        }
        );
        return this.asm_.fromComponents(n)
    }
}
const cc = ie("pndtxt");
class c_ {
    constructor(e, n) {
        this.textViews = n.textViews,
        this.element = e.createElement("div"),
        this.element.classList.add(cc()),
        this.textViews.forEach(r => {
            const i = e.createElement("div");
            i.classList.add(cc("a")),
            i.appendChild(r.element),
            this.element.appendChild(i)
        }
        )
    }
}
function u_(t, e, n) {
    return new Ei(t,{
        arrayPosition: n === 0 ? "fst" : n === e.axes.length - 1 ? "lst" : "mid",
        parser: e.parser,
        props: e.axes[n].textProps,
        value: ye(0, {
            constraint: e.axes[n].constraint
        }),
        viewProps: e.viewProps
    })
}
class Na {
    constructor(e, n) {
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.acs_ = n.axes.map( (r, i) => u_(e, n, i)),
        this.acs_.forEach( (r, i) => {
            xr({
                primary: this.value,
                secondary: r.value,
                forward: s => n.assembly.toComponents(s)[i],
                backward: (s, o) => {
                    const a = n.assembly.toComponents(s);
                    return a[i] = o,
                    n.assembly.fromComponents(a)
                }
            })
        }
        ),
        this.view = new c_(e,{
            textViews: this.acs_.map(r => r.view)
        })
    }
    get textControllers() {
        return this.acs_
    }
}
class d_ extends si {
    get max() {
        return this.controller.valueController.sliderController.props.get("max")
    }
    set max(e) {
        this.controller.valueController.sliderController.props.set("max", e)
    }
    get min() {
        return this.controller.valueController.sliderController.props.get("min")
    }
    set min(e) {
        this.controller.valueController.sliderController.props.set("min", e)
    }
}
function p_(t, e) {
    const n = []
      , r = Ld(t, e);
    r && n.push(r);
    const i = Fd(t);
    i && n.push(i);
    const s = Fa(t.options);
    return s && n.push(s),
    new wi(n)
}
const h_ = We({
    id: "input-number",
    type: "input",
    accept: (t, e) => {
        if (typeof t != "number")
            return null;
        const n = Ee(e, r => Object.assign(Object.assign({}, Id(r)), {
            options: r.optional.custom(Ci),
            readonly: r.optional.constant(!1)
        }));
        return n ? {
            initialValue: t,
            params: n
        } : null
    }
    ,
    binding: {
        reader: t => Ad,
        constraint: t => p_(t.params, t.initialValue),
        writer: t => Pi
    },
    controller: t => {
        const e = t.value
          , n = t.constraint
          , r = n && xs(n, xi);
        if (r)
            return new yn(t.document,{
                props: new Q({
                    options: r.values.value("options")
                }),
                value: e,
                viewProps: t.viewProps
            });
        const i = Rd(t.params, e.rawValue)
          , s = n && xs(n, bi);
        return s ? new Es(t.document,Object.assign(Object.assign({}, Qd(Object.assign(Object.assign({}, i), {
            keyScale: ye(i.keyScale),
            max: s.values.value("max"),
            min: s.values.value("min")
        }))), {
            parser: Xt,
            value: e,
            viewProps: t.viewProps
        })) : new Ei(t.document,{
            parser: Xt,
            props: Q.fromObject(i),
            value: e,
            viewProps: t.viewProps
        })
    }
    ,
    api(t) {
        return typeof t.controller.value.rawValue != "number" ? null : t.controller.valueController instanceof Es ? new d_(t.controller) : t.controller.valueController instanceof yn ? new Ma(t.controller) : null
    }
});
class gn {
    constructor(e=0, n=0) {
        this.x = e,
        this.y = n
    }
    getComponents() {
        return [this.x, this.y]
    }
    static isObject(e) {
        if (ge(e))
            return !1;
        const n = e.x
          , r = e.y;
        return !(typeof n != "number" || typeof r != "number")
    }
    static equals(e, n) {
        return e.x === n.x && e.y === n.y
    }
    toObject() {
        return {
            x: this.x,
            y: this.y
        }
    }
}
const xp = {
    toComponents: t => t.getComponents(),
    fromComponents: t => new gn(...t)
}
  , Qn = ie("p2d");
class f_ {
    constructor(e, n) {
        this.element = e.createElement("div"),
        this.element.classList.add(Qn()),
        n.viewProps.bindClassModifiers(this.element),
        Yt(n.expanded, _r(this.element, Qn(void 0, "expanded")));
        const r = e.createElement("div");
        r.classList.add(Qn("h")),
        this.element.appendChild(r);
        const i = e.createElement("button");
        i.classList.add(Qn("b")),
        i.appendChild(zs(e, "p2dpad")),
        n.viewProps.bindDisabled(i),
        r.appendChild(i),
        this.buttonElement = i;
        const s = e.createElement("div");
        if (s.classList.add(Qn("t")),
        r.appendChild(s),
        this.textElement = s,
        n.pickerLayout === "inline") {
            const o = e.createElement("div");
            o.classList.add(Qn("p")),
            this.element.appendChild(o),
            this.pickerElement = o
        } else
            this.pickerElement = null
    }
}
const ln = ie("p2dp");
class m_ {
    constructor(e, n) {
        this.onFoldableChange_ = this.onFoldableChange_.bind(this),
        this.onPropsChange_ = this.onPropsChange_.bind(this),
        this.onValueChange_ = this.onValueChange_.bind(this),
        this.props_ = n.props,
        this.props_.emitter.on("change", this.onPropsChange_),
        this.element = e.createElement("div"),
        this.element.classList.add(ln()),
        n.layout === "popup" && this.element.classList.add(ln(void 0, "p")),
        n.viewProps.bindClassModifiers(this.element);
        const r = e.createElement("div");
        r.classList.add(ln("p")),
        n.viewProps.bindTabIndex(r),
        this.element.appendChild(r),
        this.padElement = r;
        const i = e.createElementNS(kt, "svg");
        i.classList.add(ln("g")),
        this.padElement.appendChild(i),
        this.svgElem_ = i;
        const s = e.createElementNS(kt, "line");
        s.classList.add(ln("ax")),
        s.setAttributeNS(null, "x1", "0"),
        s.setAttributeNS(null, "y1", "50%"),
        s.setAttributeNS(null, "x2", "100%"),
        s.setAttributeNS(null, "y2", "50%"),
        this.svgElem_.appendChild(s);
        const o = e.createElementNS(kt, "line");
        o.classList.add(ln("ax")),
        o.setAttributeNS(null, "x1", "50%"),
        o.setAttributeNS(null, "y1", "0"),
        o.setAttributeNS(null, "x2", "50%"),
        o.setAttributeNS(null, "y2", "100%"),
        this.svgElem_.appendChild(o);
        const a = e.createElementNS(kt, "line");
        a.classList.add(ln("l")),
        a.setAttributeNS(null, "x1", "50%"),
        a.setAttributeNS(null, "y1", "50%"),
        this.svgElem_.appendChild(a),
        this.lineElem_ = a;
        const l = e.createElement("div");
        l.classList.add(ln("m")),
        this.padElement.appendChild(l),
        this.markerElem_ = l,
        n.value.emitter.on("change", this.onValueChange_),
        this.value = n.value,
        this.update_()
    }
    get allFocusableElements() {
        return [this.padElement]
    }
    update_() {
        const [e,n] = this.value.rawValue.getComponents()
          , r = this.props_.get("max")
          , i = ue(e, -r, +r, 0, 100)
          , s = ue(n, -r, +r, 0, 100)
          , o = this.props_.get("invertsY") ? 100 - s : s;
        this.lineElem_.setAttributeNS(null, "x2", `${i}%`),
        this.lineElem_.setAttributeNS(null, "y2", `${o}%`),
        this.markerElem_.style.left = `${i}%`,
        this.markerElem_.style.top = `${o}%`
    }
    onValueChange_() {
        this.update_()
    }
    onPropsChange_() {
        this.update_()
    }
    onFoldableChange_() {
        this.update_()
    }
}
function uc(t, e, n) {
    return [Xe(e[0], Qt(t)), Xe(e[1], ai(t)) * (n ? 1 : -1)]
}
class v_ {
    constructor(e, n) {
        this.onPadKeyDown_ = this.onPadKeyDown_.bind(this),
        this.onPadKeyUp_ = this.onPadKeyUp_.bind(this),
        this.onPointerDown_ = this.onPointerDown_.bind(this),
        this.onPointerMove_ = this.onPointerMove_.bind(this),
        this.onPointerUp_ = this.onPointerUp_.bind(this),
        this.props = n.props,
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.view = new m_(e,{
            layout: n.layout,
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
        }),
        this.ptHandler_ = new Gn(this.view.padElement),
        this.ptHandler_.emitter.on("down", this.onPointerDown_),
        this.ptHandler_.emitter.on("move", this.onPointerMove_),
        this.ptHandler_.emitter.on("up", this.onPointerUp_),
        this.view.padElement.addEventListener("keydown", this.onPadKeyDown_),
        this.view.padElement.addEventListener("keyup", this.onPadKeyUp_)
    }
    handlePointerEvent_(e, n) {
        if (!e.point)
            return;
        const r = this.props.get("max")
          , i = ue(e.point.x, 0, e.bounds.width, -r, +r)
          , s = ue(this.props.get("invertsY") ? e.bounds.height - e.point.y : e.point.y, 0, e.bounds.height, -r, +r);
        this.value.setRawValue(new gn(i,s), n)
    }
    onPointerDown_(e) {
        this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerMove_(e) {
        this.handlePointerEvent_(e.data, {
            forceEmit: !1,
            last: !1
        })
    }
    onPointerUp_(e) {
        this.handlePointerEvent_(e.data, {
            forceEmit: !0,
            last: !0
        })
    }
    onPadKeyDown_(e) {
        Xd(e.key) && e.preventDefault();
        const [n,r] = uc(e, [this.props.get("xKeyScale"), this.props.get("yKeyScale")], this.props.get("invertsY"));
        n === 0 && r === 0 || this.value.setRawValue(new gn(this.value.rawValue.x + n,this.value.rawValue.y + r), {
            forceEmit: !1,
            last: !1
        })
    }
    onPadKeyUp_(e) {
        const [n,r] = uc(e, [this.props.get("xKeyScale"), this.props.get("yKeyScale")], this.props.get("invertsY"));
        n === 0 && r === 0 || this.value.setRawValue(this.value.rawValue, {
            forceEmit: !0,
            last: !0
        })
    }
}
class g_ {
    constructor(e, n) {
        var r, i;
        this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this),
        this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this),
        this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this),
        this.onPadButtonClick_ = this.onPadButtonClick_.bind(this),
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.foldable_ = yi.create(n.expanded),
        this.popC_ = n.pickerLayout === "popup" ? new Wd(e,{
            viewProps: this.viewProps
        }) : null;
        const s = new v_(e,{
            layout: n.pickerLayout,
            props: new Q({
                invertsY: ye(n.invertsY),
                max: ye(n.max),
                xKeyScale: n.axes[0].textProps.value("keyScale"),
                yKeyScale: n.axes[1].textProps.value("keyScale")
            }),
            value: this.value,
            viewProps: this.viewProps
        });
        s.view.allFocusableElements.forEach(o => {
            o.addEventListener("blur", this.onPopupChildBlur_),
            o.addEventListener("keydown", this.onPopupChildKeydown_)
        }
        ),
        this.pickerC_ = s,
        this.textC_ = new Na(e,{
            assembly: xp,
            axes: n.axes,
            parser: n.parser,
            value: this.value,
            viewProps: this.viewProps
        }),
        this.view = new f_(e,{
            expanded: this.foldable_.value("expanded"),
            pickerLayout: n.pickerLayout,
            viewProps: this.viewProps
        }),
        this.view.textElement.appendChild(this.textC_.view.element),
        (r = this.view.buttonElement) === null || r === void 0 || r.addEventListener("blur", this.onPadButtonBlur_),
        (i = this.view.buttonElement) === null || i === void 0 || i.addEventListener("click", this.onPadButtonClick_),
        this.popC_ ? (this.view.element.appendChild(this.popC_.view.element),
        this.popC_.view.element.appendChild(this.pickerC_.view.element),
        xr({
            primary: this.foldable_.value("expanded"),
            secondary: this.popC_.shows,
            forward: o => o,
            backward: (o, a) => a
        })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element),
        ka(this.foldable_, this.view.pickerElement))
    }
    get textController() {
        return this.textC_
    }
    onPadButtonBlur_(e) {
        if (!this.popC_)
            return;
        const n = this.view.element
          , r = e.relatedTarget;
        (!r || !n.contains(r)) && (this.popC_.shows.rawValue = !1)
    }
    onPadButtonClick_() {
        this.foldable_.set("expanded", !this.foldable_.get("expanded")),
        this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
    }
    onPopupChildBlur_(e) {
        if (!this.popC_)
            return;
        const n = this.popC_.view.element
          , r = $d(e);
        r && n.contains(r) || r && r === this.view.buttonElement && !Ea(n.ownerDocument) || (this.popC_.shows.rawValue = !1)
    }
    onPopupChildKeydown_(e) {
        this.popC_ ? e.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && e.key === "Escape" && this.view.buttonElement.focus()
    }
}
function b_(t) {
    return gn.isObject(t) ? new gn(t.x,t.y) : new gn
}
function __(t, e) {
    t.writeProperty("x", e.x),
    t.writeProperty("y", e.y)
}
function y_(t, e) {
    return new ja({
        assembly: xp,
        components: [qt(Object.assign(Object.assign({}, t), t.x), e.x), qt(Object.assign(Object.assign({}, t), t.y), e.y)]
    })
}
function dc(t, e) {
    var n, r;
    if (!ge(t.min) || !ge(t.max))
        return Math.max(Math.abs((n = t.min) !== null && n !== void 0 ? n : 0), Math.abs((r = t.max) !== null && r !== void 0 ? r : 0));
    const i = kd(t);
    return Math.max(Math.abs(i) * 10, Math.abs(e) * 10)
}
function w_(t, e) {
    var n, r;
    const i = dc(Bn(t, (n = t.x) !== null && n !== void 0 ? n : {}), e.x)
      , s = dc(Bn(t, (r = t.y) !== null && r !== void 0 ? r : {}), e.y);
    return Math.max(i, s)
}
function x_(t) {
    if (!("y"in t))
        return !1;
    const e = t.y;
    return e && "inverted"in e ? !!e.inverted : !1
}
const C_ = We({
    id: "input-point2d",
    type: "input",
    accept: (t, e) => {
        if (!gn.isObject(t))
            return null;
        const n = Ee(e, r => Object.assign(Object.assign({}, li(r)), {
            expanded: r.optional.boolean,
            picker: r.optional.custom(ep),
            readonly: r.optional.constant(!1),
            x: r.optional.custom(fn),
            y: r.optional.object(Object.assign(Object.assign({}, li(r)), {
                inverted: r.optional.boolean
            }))
        }));
        return n ? {
            initialValue: t,
            params: n
        } : null
    }
    ,
    binding: {
        reader: () => b_,
        constraint: t => y_(t.params, t.initialValue),
        equals: gn.equals,
        writer: () => __
    },
    controller: t => {
        var e, n;
        const r = t.document
          , i = t.value
          , s = t.constraint
          , o = [t.params.x, t.params.y];
        return new g_(r,{
            axes: i.rawValue.getComponents().map( (a, l) => {
                var c;
                return Ca({
                    constraint: s.components[l],
                    initialValue: a,
                    params: Bn(t.params, (c = o[l]) !== null && c !== void 0 ? c : {})
                })
            }
            ),
            expanded: (e = t.params.expanded) !== null && e !== void 0 ? e : !1,
            invertsY: x_(t.params),
            max: w_(t.params, i.rawValue),
            parser: Xt,
            pickerLayout: (n = t.params.picker) !== null && n !== void 0 ? n : "popup",
            value: i,
            viewProps: t.viewProps
        })
    }
});
class or {
    constructor(e=0, n=0, r=0) {
        this.x = e,
        this.y = n,
        this.z = r
    }
    getComponents() {
        return [this.x, this.y, this.z]
    }
    static isObject(e) {
        if (ge(e))
            return !1;
        const n = e.x
          , r = e.y
          , i = e.z;
        return !(typeof n != "number" || typeof r != "number" || typeof i != "number")
    }
    static equals(e, n) {
        return e.x === n.x && e.y === n.y && e.z === n.z
    }
    toObject() {
        return {
            x: this.x,
            y: this.y,
            z: this.z
        }
    }
}
const Cp = {
    toComponents: t => t.getComponents(),
    fromComponents: t => new or(...t)
};
function E_(t) {
    return or.isObject(t) ? new or(t.x,t.y,t.z) : new or
}
function P_(t, e) {
    t.writeProperty("x", e.x),
    t.writeProperty("y", e.y),
    t.writeProperty("z", e.z)
}
function O_(t, e) {
    return new ja({
        assembly: Cp,
        components: [qt(Object.assign(Object.assign({}, t), t.x), e.x), qt(Object.assign(Object.assign({}, t), t.y), e.y), qt(Object.assign(Object.assign({}, t), t.z), e.z)]
    })
}
const T_ = We({
    id: "input-point3d",
    type: "input",
    accept: (t, e) => {
        if (!or.isObject(t))
            return null;
        const n = Ee(e, r => Object.assign(Object.assign({}, li(r)), {
            readonly: r.optional.constant(!1),
            x: r.optional.custom(fn),
            y: r.optional.custom(fn),
            z: r.optional.custom(fn)
        }));
        return n ? {
            initialValue: t,
            params: n
        } : null
    }
    ,
    binding: {
        reader: t => E_,
        constraint: t => O_(t.params, t.initialValue),
        equals: or.equals,
        writer: t => P_
    },
    controller: t => {
        const e = t.value
          , n = t.constraint
          , r = [t.params.x, t.params.y, t.params.z];
        return new Na(t.document,{
            assembly: Cp,
            axes: e.rawValue.getComponents().map( (i, s) => {
                var o;
                return Ca({
                    constraint: n.components[s],
                    initialValue: i,
                    params: Bn(t.params, (o = r[s]) !== null && o !== void 0 ? o : {})
                })
            }
            ),
            parser: Xt,
            value: e,
            viewProps: t.viewProps
        })
    }
});
class ar {
    constructor(e=0, n=0, r=0, i=0) {
        this.x = e,
        this.y = n,
        this.z = r,
        this.w = i
    }
    getComponents() {
        return [this.x, this.y, this.z, this.w]
    }
    static isObject(e) {
        if (ge(e))
            return !1;
        const n = e.x
          , r = e.y
          , i = e.z
          , s = e.w;
        return !(typeof n != "number" || typeof r != "number" || typeof i != "number" || typeof s != "number")
    }
    static equals(e, n) {
        return e.x === n.x && e.y === n.y && e.z === n.z && e.w === n.w
    }
    toObject() {
        return {
            x: this.x,
            y: this.y,
            z: this.z,
            w: this.w
        }
    }
}
const Ep = {
    toComponents: t => t.getComponents(),
    fromComponents: t => new ar(...t)
};
function A_(t) {
    return ar.isObject(t) ? new ar(t.x,t.y,t.z,t.w) : new ar
}
function S_(t, e) {
    t.writeProperty("x", e.x),
    t.writeProperty("y", e.y),
    t.writeProperty("z", e.z),
    t.writeProperty("w", e.w)
}
function k_(t, e) {
    return new ja({
        assembly: Ep,
        components: [qt(Object.assign(Object.assign({}, t), t.x), e.x), qt(Object.assign(Object.assign({}, t), t.y), e.y), qt(Object.assign(Object.assign({}, t), t.z), e.z), qt(Object.assign(Object.assign({}, t), t.w), e.w)]
    })
}
const M_ = We({
    id: "input-point4d",
    type: "input",
    accept: (t, e) => {
        if (!ar.isObject(t))
            return null;
        const n = Ee(e, r => Object.assign(Object.assign({}, li(r)), {
            readonly: r.optional.constant(!1),
            w: r.optional.custom(fn),
            x: r.optional.custom(fn),
            y: r.optional.custom(fn),
            z: r.optional.custom(fn)
        }));
        return n ? {
            initialValue: t,
            params: n
        } : null
    }
    ,
    binding: {
        reader: t => A_,
        constraint: t => k_(t.params, t.initialValue),
        equals: ar.equals,
        writer: t => S_
    },
    controller: t => {
        const e = t.value
          , n = t.constraint
          , r = [t.params.x, t.params.y, t.params.z, t.params.w];
        return new Na(t.document,{
            assembly: Ep,
            axes: e.rawValue.getComponents().map( (i, s) => {
                var o;
                return Ca({
                    constraint: n.components[s],
                    initialValue: i,
                    params: Bn(t.params, (o = r[s]) !== null && o !== void 0 ? o : {})
                })
            }
            ),
            parser: Xt,
            value: e,
            viewProps: t.viewProps
        })
    }
});
function L_(t) {
    const e = []
      , n = Fa(t.options);
    return n && e.push(n),
    new wi(e)
}
const F_ = We({
    id: "input-string",
    type: "input",
    accept: (t, e) => {
        if (typeof t != "string")
            return null;
        const n = Ee(e, r => ({
            readonly: r.optional.constant(!1),
            options: r.optional.custom(Ci)
        }));
        return n ? {
            initialValue: t,
            params: n
        } : null
    }
    ,
    binding: {
        reader: t => Zd,
        constraint: t => L_(t.params),
        writer: t => Pi
    },
    controller: t => {
        const e = t.document
          , n = t.value
          , r = t.constraint
          , i = r && xs(r, xi);
        return i ? new yn(e,{
            props: new Q({
                options: i.values.value("options")
            }),
            value: n,
            viewProps: t.viewProps
        }) : new oi(e,{
            parser: s => s,
            props: Q.fromObject({
                formatter: zo
            }),
            value: n,
            viewProps: t.viewProps
        })
    }
    ,
    api(t) {
        return typeof t.controller.value.rawValue != "string" ? null : t.controller.valueController instanceof yn ? new Ma(t.controller) : null
    }
})
  , Ti = {
    monitor: {
        defaultInterval: 200,
        defaultRows: 3
    }
}
  , pc = ie("mll");
class R_ {
    constructor(e, n) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this),
        this.formatter_ = n.formatter,
        this.element = e.createElement("div"),
        this.element.classList.add(pc()),
        n.viewProps.bindClassModifiers(this.element);
        const r = e.createElement("textarea");
        r.classList.add(pc("i")),
        r.style.height = `calc(var(${Jd("containerUnitSize")}) * ${n.rows})`,
        r.readOnly = !0,
        n.viewProps.bindDisabled(r),
        this.element.appendChild(r),
        this.textareaElem_ = r,
        n.value.emitter.on("change", this.onValueUpdate_),
        this.value = n.value,
        this.update_()
    }
    update_() {
        const e = this.textareaElem_
          , n = e.scrollTop === e.scrollHeight - e.clientHeight
          , r = [];
        this.value.rawValue.forEach(i => {
            i !== void 0 && r.push(this.formatter_(i))
        }
        ),
        e.textContent = r.join(`
`),
        n && (e.scrollTop = e.scrollHeight)
    }
    onValueUpdate_() {
        this.update_()
    }
}
class za {
    constructor(e, n) {
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.view = new R_(e,{
            formatter: n.formatter,
            rows: n.rows,
            value: this.value,
            viewProps: this.viewProps
        })
    }
}
const hc = ie("sgl");
class I_ {
    constructor(e, n) {
        this.onValueUpdate_ = this.onValueUpdate_.bind(this),
        this.formatter_ = n.formatter,
        this.element = e.createElement("div"),
        this.element.classList.add(hc()),
        n.viewProps.bindClassModifiers(this.element);
        const r = e.createElement("input");
        r.classList.add(hc("i")),
        r.readOnly = !0,
        r.type = "text",
        n.viewProps.bindDisabled(r),
        this.element.appendChild(r),
        this.inputElement = r,
        n.value.emitter.on("change", this.onValueUpdate_),
        this.value = n.value,
        this.update_()
    }
    update_() {
        const e = this.value.rawValue
          , n = e[e.length - 1];
        this.inputElement.value = n !== void 0 ? this.formatter_(n) : ""
    }
    onValueUpdate_() {
        this.update_()
    }
}
class Ha {
    constructor(e, n) {
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.view = new I_(e,{
            formatter: n.formatter,
            value: this.value,
            viewProps: this.viewProps
        })
    }
}
const V_ = We({
    id: "monitor-bool",
    type: "monitor",
    accept: (t, e) => {
        if (typeof t != "boolean")
            return null;
        const n = Ee(e, r => ({
            readonly: r.required.constant(!0),
            rows: r.optional.number
        }));
        return n ? {
            initialValue: t,
            params: n
        } : null
    }
    ,
    binding: {
        reader: t => Yd
    },
    controller: t => {
        var e;
        return t.value.rawValue.length === 1 ? new Ha(t.document,{
            formatter: sc,
            value: t.value,
            viewProps: t.viewProps
        }) : new za(t.document,{
            formatter: sc,
            rows: (e = t.params.rows) !== null && e !== void 0 ? e : Ti.monitor.defaultRows,
            value: t.value,
            viewProps: t.viewProps
        })
    }
});
class D_ extends si {
    get max() {
        return this.controller.valueController.props.get("max")
    }
    set max(e) {
        this.controller.valueController.props.set("max", e)
    }
    get min() {
        return this.controller.valueController.props.get("min")
    }
    set min(e) {
        this.controller.valueController.props.set("min", e)
    }
}
const cn = ie("grl");
class B_ {
    constructor(e, n) {
        this.onCursorChange_ = this.onCursorChange_.bind(this),
        this.onValueUpdate_ = this.onValueUpdate_.bind(this),
        this.element = e.createElement("div"),
        this.element.classList.add(cn()),
        n.viewProps.bindClassModifiers(this.element),
        this.formatter_ = n.formatter,
        this.props_ = n.props,
        this.cursor_ = n.cursor,
        this.cursor_.emitter.on("change", this.onCursorChange_);
        const r = e.createElementNS(kt, "svg");
        r.classList.add(cn("g")),
        r.style.height = `calc(var(${Jd("containerUnitSize")}) * ${n.rows})`,
        this.element.appendChild(r),
        this.svgElem_ = r;
        const i = e.createElementNS(kt, "polyline");
        this.svgElem_.appendChild(i),
        this.lineElem_ = i;
        const s = e.createElement("div");
        s.classList.add(cn("t"), ie("tt")()),
        this.element.appendChild(s),
        this.tooltipElem_ = s,
        n.value.emitter.on("change", this.onValueUpdate_),
        this.value = n.value,
        this.update_()
    }
    get graphElement() {
        return this.svgElem_
    }
    update_() {
        const {clientWidth: e, clientHeight: n} = this.element
          , r = this.value.rawValue.length - 1
          , i = this.props_.get("min")
          , s = this.props_.get("max")
          , o = [];
        this.value.rawValue.forEach( (d, m) => {
            if (d === void 0)
                return;
            const g = ue(m, 0, r, 0, e)
              , f = ue(d, i, s, n, 0);
            o.push([g, f].join(","))
        }
        ),
        this.lineElem_.setAttributeNS(null, "points", o.join(" "));
        const a = this.tooltipElem_
          , l = this.value.rawValue[this.cursor_.rawValue];
        if (l === void 0) {
            a.classList.remove(cn("t", "a"));
            return
        }
        const c = ue(this.cursor_.rawValue, 0, r, 0, e)
          , u = ue(l, i, s, n, 0);
        a.style.left = `${c}px`,
        a.style.top = `${u}px`,
        a.textContent = `${this.formatter_(l)}`,
        a.classList.contains(cn("t", "a")) || (a.classList.add(cn("t", "a"), cn("t", "in")),
        ws(a),
        a.classList.remove(cn("t", "in")))
    }
    onValueUpdate_() {
        this.update_()
    }
    onCursorChange_() {
        this.update_()
    }
}
class Pp {
    constructor(e, n) {
        if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this),
        this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this),
        this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this),
        this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this),
        this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this),
        this.props = n.props,
        this.value = n.value,
        this.viewProps = n.viewProps,
        this.cursor_ = ye(-1),
        this.view = new B_(e,{
            cursor: this.cursor_,
            formatter: n.formatter,
            rows: n.rows,
            props: this.props,
            value: this.value,
            viewProps: this.viewProps
        }),
        !Ea(e))
            this.view.element.addEventListener("mousemove", this.onGraphMouseMove_),
            this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
        else {
            const r = new Gn(this.view.element);
            r.emitter.on("down", this.onGraphPointerDown_),
            r.emitter.on("move", this.onGraphPointerMove_),
            r.emitter.on("up", this.onGraphPointerUp_)
        }
    }
    importProps(e) {
        return rt(e, null, n => ({
            max: n.required.number,
            min: n.required.number
        }), n => (this.props.set("max", n.max),
        this.props.set("min", n.min),
        !0))
    }
    exportProps() {
        return it(null, {
            max: this.props.get("max"),
            min: this.props.get("min")
        })
    }
    onGraphMouseLeave_() {
        this.cursor_.rawValue = -1
    }
    onGraphMouseMove_(e) {
        const {clientWidth: n} = this.view.element;
        this.cursor_.rawValue = Math.floor(ue(e.offsetX, 0, n, 0, this.value.rawValue.length))
    }
    onGraphPointerDown_(e) {
        this.onGraphPointerMove_(e)
    }
    onGraphPointerMove_(e) {
        if (!e.data.point) {
            this.cursor_.rawValue = -1;
            return
        }
        this.cursor_.rawValue = Math.floor(ue(e.data.point.x, 0, e.data.bounds.width, 0, this.value.rawValue.length))
    }
    onGraphPointerUp_() {
        this.cursor_.rawValue = -1
    }
}
function Ho(t) {
    return ge(t.format) ? et(2) : t.format
}
function $_(t) {
    var e;
    return t.value.rawValue.length === 1 ? new Ha(t.document,{
        formatter: Ho(t.params),
        value: t.value,
        viewProps: t.viewProps
    }) : new za(t.document,{
        formatter: Ho(t.params),
        rows: (e = t.params.rows) !== null && e !== void 0 ? e : Ti.monitor.defaultRows,
        value: t.value,
        viewProps: t.viewProps
    })
}
function U_(t) {
    var e, n, r;
    return new Pp(t.document,{
        formatter: Ho(t.params),
        rows: (e = t.params.rows) !== null && e !== void 0 ? e : Ti.monitor.defaultRows,
        props: Q.fromObject({
            max: (n = t.params.max) !== null && n !== void 0 ? n : 100,
            min: (r = t.params.min) !== null && r !== void 0 ? r : 0
        }),
        value: t.value,
        viewProps: t.viewProps
    })
}
function fc(t) {
    return t.view === "graph"
}
const j_ = We({
    id: "monitor-number",
    type: "monitor",
    accept: (t, e) => {
        if (typeof t != "number")
            return null;
        const n = Ee(e, r => ({
            format: r.optional.function,
            max: r.optional.number,
            min: r.optional.number,
            readonly: r.required.constant(!0),
            rows: r.optional.number,
            view: r.optional.string
        }));
        return n ? {
            initialValue: t,
            params: n
        } : null
    }
    ,
    binding: {
        defaultBufferSize: t => fc(t) ? 64 : 1,
        reader: t => Ad
    },
    controller: t => fc(t.params) ? U_(t) : $_(t),
    api: t => t.controller.valueController instanceof Pp ? new D_(t.controller) : null
})
  , N_ = We({
    id: "monitor-string",
    type: "monitor",
    accept: (t, e) => {
        if (typeof t != "string")
            return null;
        const n = Ee(e, r => ({
            multiline: r.optional.boolean,
            readonly: r.required.constant(!0),
            rows: r.optional.number
        }));
        return n ? {
            initialValue: t,
            params: n
        } : null
    }
    ,
    binding: {
        reader: t => Zd
    },
    controller: t => {
        var e;
        const n = t.value;
        return n.rawValue.length > 1 || t.params.multiline ? new za(t.document,{
            formatter: zo,
            rows: (e = t.params.rows) !== null && e !== void 0 ? e : Ti.monitor.defaultRows,
            value: n,
            viewProps: t.viewProps
        }) : new Ha(t.document,{
            formatter: zo,
            value: n,
            viewProps: t.viewProps
        })
    }
});
class z_ {
    constructor() {
        this.map_ = new Map
    }
    get(e) {
        var n;
        return (n = this.map_.get(e)) !== null && n !== void 0 ? n : null
    }
    has(e) {
        return this.map_.has(e)
    }
    add(e, n) {
        return this.map_.set(e, n),
        e.viewProps.handleDispose( () => {
            this.map_.delete(e)
        }
        ),
        n
    }
}
class H_ {
    constructor(e) {
        this.target = e.target,
        this.reader_ = e.reader,
        this.writer_ = e.writer
    }
    read() {
        return this.reader_(this.target.read())
    }
    write(e) {
        this.writer_(this.target, e)
    }
    inject(e) {
        this.write(this.reader_(e))
    }
}
function K_(t, e) {
    var n;
    const r = t.accept(e.target.read(), e.params);
    if (ge(r))
        return null;
    const i = {
        target: e.target,
        initialValue: r.initialValue,
        params: r.params
    }
      , s = Ee(e.params, d => ({
        disabled: d.optional.boolean,
        hidden: d.optional.boolean,
        label: d.optional.string,
        tag: d.optional.string
    }))
      , o = t.binding.reader(i)
      , a = t.binding.constraint ? t.binding.constraint(i) : void 0
      , l = new H_({
        reader: o,
        target: e.target,
        writer: t.binding.writer(i)
    })
      , c = new Av(ye(o(r.initialValue), {
        constraint: a,
        equals: t.binding.equals
    }),l)
      , u = t.controller({
        constraint: a,
        document: e.document,
        initialValue: r.initialValue,
        params: r.params,
        value: c,
        viewProps: tn.create({
            disabled: s == null ? void 0 : s.disabled,
            hidden: s == null ? void 0 : s.hidden
        })
    });
    return new zv(e.document,{
        blade: wr(),
        props: Q.fromObject({
            label: "label"in e.params ? (n = s == null ? void 0 : s.label) !== null && n !== void 0 ? n : null : e.target.key
        }),
        tag: s == null ? void 0 : s.tag,
        value: c,
        valueController: u
    })
}
class G_ {
    constructor(e) {
        this.target = e.target,
        this.reader_ = e.reader
    }
    read() {
        return this.reader_(this.target.read())
    }
}
function q_(t, e) {
    return e === 0 ? new Pg : new Og(t,e ?? Ti.monitor.defaultInterval)
}
function W_(t, e) {
    var n, r, i;
    const s = t.accept(e.target.read(), e.params);
    if (ge(s))
        return null;
    const o = {
        target: e.target,
        initialValue: s.initialValue,
        params: s.params
    }
      , a = Ee(e.params, m => ({
        bufferSize: m.optional.number,
        disabled: m.optional.boolean,
        hidden: m.optional.boolean,
        interval: m.optional.number,
        label: m.optional.string
    }))
      , l = t.binding.reader(o)
      , c = (r = (n = a == null ? void 0 : a.bufferSize) !== null && n !== void 0 ? n : t.binding.defaultBufferSize && t.binding.defaultBufferSize(s.params)) !== null && r !== void 0 ? r : 1
      , u = new Wv({
        binding: new G_({
            reader: l,
            target: e.target
        }),
        bufferSize: c,
        ticker: q_(e.document, a == null ? void 0 : a.interval)
    })
      , d = t.controller({
        document: e.document,
        params: s.params,
        value: u,
        viewProps: tn.create({
            disabled: a == null ? void 0 : a.disabled,
            hidden: a == null ? void 0 : a.hidden
        })
    });
    return d.viewProps.bindDisabled(u.ticker),
    d.viewProps.handleDispose( () => {
        u.ticker.dispose()
    }
    ),
    new Zv(e.document,{
        blade: wr(),
        props: Q.fromObject({
            label: "label"in e.params ? (i = a == null ? void 0 : a.label) !== null && i !== void 0 ? i : null : e.target.key
        }),
        value: u,
        valueController: d
    })
}
class Y_ {
    constructor(e) {
        this.pluginsMap_ = {
            blades: [],
            inputs: [],
            monitors: []
        },
        this.apiCache_ = e
    }
    getAll() {
        return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors]
    }
    register(e, n) {
        if (!$g(n.core))
            throw Te.notCompatible(e, n.id);
        n.type === "blade" ? this.pluginsMap_.blades.unshift(n) : n.type === "input" ? this.pluginsMap_.inputs.unshift(n) : n.type === "monitor" && this.pluginsMap_.monitors.unshift(n)
    }
    createInput_(e, n, r) {
        return this.pluginsMap_.inputs.reduce( (i, s) => i ?? K_(s, {
            document: e,
            target: n,
            params: r
        }), null)
    }
    createMonitor_(e, n, r) {
        return this.pluginsMap_.monitors.reduce( (i, s) => i ?? W_(s, {
            document: e,
            params: r,
            target: n
        }), null)
    }
    createBinding(e, n, r) {
        const i = n.read();
        if (ge(i))
            throw new Te({
                context: {
                    key: n.key
                },
                type: "nomatchingcontroller"
            });
        const s = this.createInput_(e, n, r);
        if (s)
            return s;
        const o = this.createMonitor_(e, n, r);
        if (o)
            return o;
        throw new Te({
            context: {
                key: n.key
            },
            type: "nomatchingcontroller"
        })
    }
    createBlade(e, n) {
        const r = this.pluginsMap_.blades.reduce( (i, s) => i ?? Eg(s, {
            document: e,
            params: n
        }), null);
        if (!r)
            throw new Te({
                type: "nomatchingview",
                context: {
                    params: n
                }
            });
        return r
    }
    createInputBindingApi_(e) {
        const n = this.pluginsMap_.inputs.reduce( (r, i) => {
            var s, o;
            return r || ((o = (s = i.api) === null || s === void 0 ? void 0 : s.call(i, {
                controller: e
            })) !== null && o !== void 0 ? o : null)
        }
        , null);
        return this.apiCache_.add(e, n ?? new si(e))
    }
    createMonitorBindingApi_(e) {
        const n = this.pluginsMap_.monitors.reduce( (r, i) => {
            var s, o;
            return r || ((o = (s = i.api) === null || s === void 0 ? void 0 : s.call(i, {
                controller: e
            })) !== null && o !== void 0 ? o : null)
        }
        , null);
        return this.apiCache_.add(e, n ?? new si(e))
    }
    createBindingApi(e) {
        if (this.apiCache_.has(e))
            return this.apiCache_.get(e);
        if (Hv(e))
            return this.createInputBindingApi_(e);
        if (Xv(e))
            return this.createMonitorBindingApi_(e);
        throw Te.shouldNeverHappen()
    }
    createApi(e) {
        if (this.apiCache_.has(e))
            return this.apiCache_.get(e);
        if (Nv(e))
            return this.createBindingApi(e);
        const n = this.pluginsMap_.blades.reduce( (r, i) => r ?? i.api({
            controller: e,
            pool: this
        }), null);
        if (!n)
            throw Te.shouldNeverHappen();
        return this.apiCache_.add(e, n)
    }
}
const Z_ = new z_;
function X_() {
    const t = new Y_(Z_);
    return [C_, T_, M_, F_, h_, l_, a_, n_, zg, V_, N_, j_, ng, mg, qd].forEach(e => {
        t.register("core", e)
    }
    ),
    t
}
class Q_ extends Kn {
    constructor(e) {
        super(e),
        this.emitter_ = new Me,
        this.controller.value.emitter.on("change", n => {
            this.emitter_.emit("change", new _i(this,n.rawValue))
        }
        )
    }
    get label() {
        return this.controller.labelController.props.get("label")
    }
    set label(e) {
        this.controller.labelController.props.set("label", e)
    }
    get options() {
        return this.controller.valueController.props.get("options")
    }
    set options(e) {
        this.controller.valueController.props.set("options", e)
    }
    get value() {
        return this.controller.value.rawValue
    }
    set value(e) {
        this.controller.value.rawValue = e
    }
    on(e, n) {
        const r = n.bind(this);
        return this.emitter_.on(e, i => {
            r(i)
        }
        , {
            key: n
        }),
        this
    }
    off(e, n) {
        return this.emitter_.off(e, n),
        this
    }
}
class J_ extends Kn {
}
class e0 extends Kn {
    constructor(e) {
        super(e),
        this.emitter_ = new Me,
        this.controller.value.emitter.on("change", n => {
            this.emitter_.emit("change", new _i(this,n.rawValue))
        }
        )
    }
    get label() {
        return this.controller.labelController.props.get("label")
    }
    set label(e) {
        this.controller.labelController.props.set("label", e)
    }
    get max() {
        return this.controller.valueController.sliderController.props.get("max")
    }
    set max(e) {
        this.controller.valueController.sliderController.props.set("max", e)
    }
    get min() {
        return this.controller.valueController.sliderController.props.get("min")
    }
    set min(e) {
        this.controller.valueController.sliderController.props.set("min", e)
    }
    get value() {
        return this.controller.value.rawValue
    }
    set value(e) {
        this.controller.value.rawValue = e
    }
    on(e, n) {
        const r = n.bind(this);
        return this.emitter_.on(e, i => {
            r(i)
        }
        , {
            key: n
        }),
        this
    }
    off(e, n) {
        return this.emitter_.off(e, n),
        this
    }
}
class t0 extends Kn {
    constructor(e) {
        super(e),
        this.emitter_ = new Me,
        this.controller.value.emitter.on("change", n => {
            this.emitter_.emit("change", new _i(this,n.rawValue))
        }
        )
    }
    get label() {
        return this.controller.labelController.props.get("label")
    }
    set label(e) {
        this.controller.labelController.props.set("label", e)
    }
    get formatter() {
        return this.controller.valueController.props.get("formatter")
    }
    set formatter(e) {
        this.controller.valueController.props.set("formatter", e)
    }
    get value() {
        return this.controller.value.rawValue
    }
    set value(e) {
        this.controller.value.rawValue = e
    }
    on(e, n) {
        const r = n.bind(this);
        return this.emitter_.on(e, i => {
            r(i)
        }
        , {
            key: n
        }),
        this
    }
    off(e, n) {
        return this.emitter_.off(e, n),
        this
    }
}
const n0 = function() {
    return {
        id: "list",
        type: "blade",
        core: yr,
        accept(t) {
            const e = Ee(t, n => ({
                options: n.required.custom(Ci),
                value: n.required.raw,
                view: n.required.constant("list"),
                label: n.optional.string
            }));
            return e ? {
                params: e
            } : null
        },
        controller(t) {
            const e = new xi(La(t.params.options))
              , n = ye(t.params.value, {
                constraint: e
            })
              , r = new yn(t.document,{
                props: new Q({
                    options: e.values.value("options")
                }),
                value: n,
                viewProps: t.viewProps
            });
            return new $n(t.document,{
                blade: t.blade,
                props: Q.fromObject({
                    label: t.params.label
                }),
                value: n,
                valueController: r
            })
        },
        api(t) {
            return !(t.controller instanceof $n) || !(t.controller.valueController instanceof yn) ? null : new Q_(t.controller)
        }
    }
}();
class r0 extends Kd {
    constructor(e, n) {
        super(e, n)
    }
    get element() {
        return this.controller.view.element
    }
}
class i0 extends jo {
    constructor(e, n) {
        super(e, {
            expanded: n.expanded,
            blade: n.blade,
            props: n.props,
            root: !0,
            viewProps: n.viewProps
        })
    }
}
const mc = ie("spr");
class s0 {
    constructor(e, n) {
        this.element = e.createElement("div"),
        this.element.classList.add(mc()),
        n.viewProps.bindClassModifiers(this.element);
        const r = e.createElement("hr");
        r.classList.add(mc("r")),
        this.element.appendChild(r)
    }
}
class vc extends Hs {
    constructor(e, n) {
        super(Object.assign(Object.assign({}, n), {
            view: new s0(e,{
                viewProps: n.viewProps
            })
        }))
    }
}
const o0 = {
    id: "separator",
    type: "blade",
    core: yr,
    accept(t) {
        const e = Ee(t, n => ({
            view: n.required.constant("separator")
        }));
        return e ? {
            params: e
        } : null
    },
    controller(t) {
        return new vc(t.document,{
            blade: t.blade,
            viewProps: t.viewProps
        })
    },
    api(t) {
        return t.controller instanceof vc ? new J_(t.controller) : null
    }
}
  , a0 = {
    id: "slider",
    type: "blade",
    core: yr,
    accept(t) {
        const e = Ee(t, n => ({
            max: n.required.number,
            min: n.required.number,
            view: n.required.constant("slider"),
            format: n.optional.function,
            label: n.optional.string,
            value: n.optional.number
        }));
        return e ? {
            params: e
        } : null
    },
    controller(t) {
        var e, n;
        const r = (e = t.params.value) !== null && e !== void 0 ? e : 0
          , i = new bi({
            max: t.params.max,
            min: t.params.min
        })
          , s = ye(r, {
            constraint: i
        })
          , o = new Es(t.document,Object.assign(Object.assign({}, Qd({
            formatter: (n = t.params.format) !== null && n !== void 0 ? n : Cv,
            keyScale: ye(1),
            max: i.values.value("max"),
            min: i.values.value("min"),
            pointerScale: Md(t.params, r)
        })), {
            parser: Xt,
            value: s,
            viewProps: t.viewProps
        }));
        return new $n(t.document,{
            blade: t.blade,
            props: Q.fromObject({
                label: t.params.label
            }),
            value: s,
            valueController: o
        })
    },
    api(t) {
        return !(t.controller instanceof $n) || !(t.controller.valueController instanceof Es) ? null : new e0(t.controller)
    }
}
  , l0 = function() {
    return {
        id: "text",
        type: "blade",
        core: yr,
        accept(t) {
            const e = Ee(t, n => ({
                parse: n.required.function,
                value: n.required.raw,
                view: n.required.constant("text"),
                format: n.optional.function,
                label: n.optional.string
            }));
            return e ? {
                params: e
            } : null
        },
        controller(t) {
            var e;
            const n = ye(t.params.value)
              , r = new oi(t.document,{
                parser: t.params.parse,
                props: Q.fromObject({
                    formatter: (e = t.params.format) !== null && e !== void 0 ? e : i => String(i)
                }),
                value: n,
                viewProps: t.viewProps
            });
            return new $n(t.document,{
                blade: t.blade,
                props: Q.fromObject({
                    label: t.params.label
                }),
                value: n,
                valueController: r
            })
        },
        api(t) {
            return !(t.controller instanceof $n) || !(t.controller.valueController instanceof oi) ? null : new t0(t.controller)
        }
    }
}();
function c0(t) {
    const e = t.createElement("div");
    return e.classList.add(ie("dfw")()),
    t.body && t.body.appendChild(e),
    e
}
function u0(t, e, n) {
    if (t.querySelector(`style[data-tp-style=${e}]`))
        return;
    const r = t.createElement("style");
    r.dataset.tpStyle = e,
    r.textContent = n,
    t.head.appendChild(r)
}
class Op extends r0 {
    constructor(e) {
        var n, r;
        const i = e ?? {}
          , s = (n = i.document) !== null && n !== void 0 ? n : Iv()
          , o = X_()
          , a = new i0(s,{
            expanded: i.expanded,
            blade: wr(),
            props: Q.fromObject({
                title: i.title
            }),
            viewProps: tn.create()
        });
        super(a, o),
        this.pool_ = o,
        this.containerElem_ = (r = i.container) !== null && r !== void 0 ? r : c0(s),
        this.containerElem_.appendChild(this.element),
        this.doc_ = s,
        this.usesDefaultWrapper_ = !i.container,
        this.setUpDefaultPlugins_()
    }
    get document() {
        if (!this.doc_)
            throw Te.alreadyDisposed();
        return this.doc_
    }
    dispose() {
        const e = this.containerElem_;
        if (!e)
            throw Te.alreadyDisposed();
        if (this.usesDefaultWrapper_) {
            const n = e.parentElement;
            n && n.removeChild(e)
        }
        this.containerElem_ = null,
        this.doc_ = null,
        super.dispose()
    }
    registerPlugin(e) {
        e.css && u0(this.document, `plugin-${e.id}`, e.css),
        ("plugin"in e ? [e.plugin] : "plugins"in e ? e.plugins : []).forEach(r => {
            this.pool_.register(e.id, r)
        }
        )
    }
    setUpDefaultPlugins_() {
        this.registerPlugin({
            id: "default",
            css: '.tp-tbiv_b,.tp-coltxtv_ms,.tp-colswv_b,.tp-ckbv_i,.tp-sglv_i,.tp-mllv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-rotv_b,.tp-fldv_b,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--bld-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--cnt-usz);line-height:var(--cnt-usz);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tbpv_c>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-vp))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tbpv_c>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--cnt-usp)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tbpv_c>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tbpv_c>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tbpv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tbpv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tbpv_c>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tbpv_c>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--bld-br);border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tbpv_c .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tbpv_c>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tbpv_c>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--bld-br)}.tp-tbpv_c .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--bld-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);overflow:hidden;padding-left:var(--cnt-hp);padding-right:calc(4px + var(--cnt-usz) + var(--cnt-hp));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-hp) + (var(--cnt-usz) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-vp);padding-top:var(--cnt-vp);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--cnt-usz);line-height:var(--cnt-usz);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-sglv_i,.tp-mllv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--mo-fg);height:var(--cnt-usz);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-sglv_i::-webkit-scrollbar,.tp-mllv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-sglv_i::-webkit-scrollbar-corner,.tp-mllv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-sglv_i::-webkit-scrollbar-thumb,.tp-mllv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-rotv{--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-br: var(--tp-base-border-radius, 6px);--bs-ff: var(--tp-base-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--bld-br: var(--tp-blade-border-radius, 2px);--bld-hp: var(--tp-blade-horizontal-padding, 4px);--bld-vw: var(--tp-blade-value-width, 160px);--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--cnt-hp: var(--tp-container-horizontal-padding, 4px);--cnt-vp: var(--tp-container-vertical-padding, 4px);--cnt-usp: var(--tp-container-unit-spacing, 4px);--cnt-usz: var(--tp-container-unit-size, 20px);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--bld-br);cursor:pointer;display:block;height:var(--cnt-usz);position:relative;width:var(--cnt-usz)}.tp-ckbv_w svg{display:block;height:16px;inset:0;margin:auto;opacity:0;position:absolute;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--cnt-usz)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--cnt-usp);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-hp));right:calc(-1*var(--cnt-hp));top:var(--cnt-usz)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--cnt-usp)}.tp-colpv_rgb{display:flex;margin-top:var(--cnt-usp);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-vp);padding-top:calc(var(--cnt-vp) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-hp));position:absolute;right:calc(-1*var(--cnt-hp));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--bld-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--cnt-usz)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{inset:0;position:absolute}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--bld-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;inset:0;position:absolute}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--bld-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{cursor:pointer;display:block;height:var(--cnt-usz);left:0;position:absolute;top:0;width:var(--cnt-usz)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--bld-br);content:"";display:block;inset:0;position:absolute}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--bld-br);color:var(--lbl-fg);cursor:pointer;height:var(--cnt-usz);line-height:var(--cnt-usz);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--cnt-usz)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-hp);padding-right:var(--cnt-hp)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:var(--bld-vw)}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 var(--bld-hp);width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--cnt-usz)*3);line-height:var(--cnt-usz);padding-left:var(--bld-hp);padding-right:var(--bld-hp);resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--cnt-usz);margin-right:4px;position:relative;width:var(--cnt-usz)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--cnt-usp);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-hp));right:calc(-1*var(--cnt-hp));top:var(--cnt-usz)}.tp-p2dpv{padding-left:calc(var(--cnt-usz) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:var(--bld-vw);padding:var(--cnt-vp) var(--cnt-hp);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--cnt-usz);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";display:block;height:2px;inset:0;margin:auto;position:absolute}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;content:"";display:block;height:2px;inset:0;margin-bottom:auto;margin-top:auto;position:absolute}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--bld-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--cnt-usz) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-hp) + 4px);padding-right:calc(var(--cnt-hp) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);content:"";inset:0 0 2px;pointer-events:none;position:absolute}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);opacity:.5;overflow:hidden;position:relative;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-tbpv_c{padding-bottom:var(--cnt-vp);padding-left:4px;padding-top:var(--cnt-vp)}.tp-txtv{position:relative}.tp-txtv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:calc(var(--bld-hp) - 5px);position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--cnt-usz) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--bld-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--bs-ff);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--cnt-usz) + var(--cnt-hp));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0;transition-delay:0s;transition-duration:0s}.tp-rotv.tp-rotv-not>.tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst.tp-fldv-expanded>.tp-fldv_b{transition-delay:0s;transition-duration:0s}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}',
            plugins: [n0, o0, a0, qd, l0]
        })
    }
}
new Hd("4.0.4");
let zi;
class d0 extends Nm {
    constructor({container: e, canvas: n, cssEL: r, options: i={}}={}) {
        super({
            container: e,
            canvas: n,
            cssEL: r,
            options: i
        }),
        zi = this.stats = new Yr,
        zi.domElement.style.top = "unset",
        zi.domElement.style.bottom = "0",
        e.appendChild(zi.domElement);
        const s = this.pane = new Op({
            title: "Debug",
            container: e
        });
        s.element.style.position = "absolute",
        s.element.style.zIndex = "1000",
        s.element.style.right = "5px",
        s.element.style.top = "5px",
        s.element.style.width = "auto",
        s.element.style.minWidth = "200px",
        s.element.style.maxHeight = "95%",
        s.element.style.overflowY = "auto",
        s.element.style.overflowX = "hidden",
        this.lightPane = s.addFolder({
            title: "LightHelper"
        }),
        this.lightHelperGroup = new $s,
        this.lightHelperGroup.name = "lightHelperGroup",
        this.scene.add(this.lightHelperGroup)
    }
    createDLight(e, n) {
        const r = () => {
            s.shadow.camera.updateProjectionMatrix(),
            o.update(),
            o.visible = this.renderer.shadowMap.enabled && s.castShadow,
            a.update()
        }
          , i = () => {
            l.title = `DirectionalLight-${s.name}-${s.id}`,
            this.lightPane.refresh()
        }
          , {light: s} = super.createDLight(e, n)
          , o = new Ll(s.shadow.camera);
        this.lightHelperGroup.add(o);
        const a = new Sf(s,5,s.color);
        this.lightHelperGroup.add(a);
        const l = this.lightPane.addFolder({
            title: "DirectionalLight"
        });
        return l.addBinding(s, "position").on("change", r),
        l.addBinding(s, "color", {
            color: {
                type: "float"
            }
        }).on("change", r),
        l.addBinding(s, "intensity", {
            min: 0
        }).on("change", r),
        l.addBinding(s, "castShadow").on("change", r),
        l.addBinding(s.shadow.camera, "top").on("change", r),
        l.addBinding(s.shadow.camera, "bottom").on("change", r),
        l.addBinding(s.shadow.camera, "left").on("change", r),
        l.addBinding(s.shadow.camera, "right").on("change", r),
        l.addBinding(s.shadow.camera, "near").on("change", r),
        l.addBinding(s.shadow.camera, "far").on("change", r),
        l.addBinding(s.shadow, "bias", {
            step: .01
        }).on("change", r),
        l.addBinding(s.shadow, "blurSamples", {
            step: .1
        }).on("change", r),
        l.addBinding(s.shadow, "intensity").on("change", r),
        l.addBinding(s.shadow, "normalBias").on("change", r),
        l.addBinding(s.shadow, "radius").on("change", r),
        r(),
        i(),
        {
            light: s,
            helper: a,
            cameraHelper: o,
            updateHelper: r,
            updatePane: i
        }
    }
    createPLight(e, n) {
        const r = () => {
            o.update()
        }
          , i = () => {
            a.title = `PointLight-${s.name}-${s.id}`,
            this.lightPane.refresh()
        }
          , {light: s} = super.createPLight(e, n)
          , o = new kf(s,1,s.color);
        this.lightHelperGroup.add(o);
        const a = this.lightPane.addFolder({
            title: "PointLight"
        });
        return a.addBinding(s, "position").on("change", r),
        a.addBinding(s, "color", {
            color: {
                type: "float"
            }
        }).on("change", r),
        a.addBinding(s, "intensity", {
            min: 0
        }).on("change", r),
        a.addBinding(s, "decay", {
            min: 0
        }).on("change", r),
        a.addBinding(s, "distance").on("change", r),
        a.addBinding(s, "power").on("change", r),
        a.addBinding(s, "castShadow").on("change", r),
        a.addBinding(s.shadow, "bias", {
            step: .01
        }).on("change", r),
        a.addBinding(s.shadow, "blurSamples", {
            step: .1
        }).on("change", r),
        a.addBinding(s.shadow, "intensity").on("change", r),
        a.addBinding(s.shadow, "normalBias").on("change", r),
        a.addBinding(s.shadow, "radius").on("change", r),
        r(),
        i(),
        {
            light: s,
            helper: o,
            updateHelper: r,
            updatePane: i
        }
    }
    createSLight(e, n) {
        const r = () => {
            s.shadow.camera.updateProjectionMatrix(),
            a.update(),
            a.visible = this.renderer.shadowMap.enabled && s.castShadow,
            o.update()
        }
          , i = () => {
            l.title = `SpotLight-${s.name}-${s.id}`,
            this.lightPane.refresh()
        }
          , {light: s} = super.createSLight(e, n)
          , o = new Mf(s,s.color);
        this.scene.add(o),
        this.lightHelperGroup.add(o);
        const a = new Ll(s.shadow.camera);
        this.lightHelperGroup.add(a);
        const l = this.lightPane.addFolder({
            title: "SpotLight"
        });
        return l.addBinding(s, "position").on("change", r),
        l.addBinding(s, "color", {
            color: {
                type: "float"
            }
        }).on("change", r),
        l.addBinding(s, "intensity", {
            min: 0
        }).on("change", r),
        l.addBinding(s, "distance", {
            min: 0
        }).on("change", r),
        l.addBinding(s, "angle", {
            min: 0,
            max: Math.PI / 2
        }).on("change", r),
        l.addBinding(s, "penumbra", {
            min: 0,
            max: Math.PI * 2
        }).on("change", r),
        l.addBinding(s, "decay", {
            min: 0
        }).on("change", r),
        l.addBinding(s, "power", {
            min: 0
        }).on("change", r),
        l.addBinding(s.target, "position", {
            label: "target"
        }).on("change", r),
        l.addBinding(s, "castShadow").on("change", r),
        l.addBinding(s.shadow.camera, "near").on("change", r),
        l.addBinding(s.shadow.camera, "far", {
            min: 0
        }).on("change", r),
        l.addBinding(s.shadow, "normalBias", {
            min: 0,
            step: .1
        }).on("change", r),
        l.addBinding(s.shadow, "radius", {
            min: 0,
            step: .1
        }).on("change", r),
        r(),
        i(),
        {
            light: s,
            cameraHelper: a,
            helper: o,
            updateHelper: r,
            updatePane: i
        }
    }
    createAmbientLight(e, n) {
        const r = () => {
            l.position.copy(s.position),
            a.color.copy(s.color)
        }
          , i = () => {
            c.title = `AmbientLight-${s.name}-${s.id}`,
            this.lightPane.refresh()
        }
          , {light: s} = super.createAmbientLight(e, n)
          , o = new Lf
          , a = new va({
            color: s.color,
            wireframe: !0
        })
          , l = new kn(o,a);
        this.lightHelperGroup.add(l);
        const c = this.lightPane.addFolder({
            title: "AmbientLight"
        });
        return c.addBinding(s, "position").on("change", r),
        c.addBinding(s, "color", {
            color: {
                type: "float"
            }
        }).on("change", r),
        c.addBinding(s, "intensity", {
            min: 0
        }).on("change", r),
        r(),
        i(),
        {
            light: s,
            helper: l,
            updateHelper: r,
            updatePane: i
        }
    }
    createHLight(e, n, r) {
        const i = () => {
            a.update()
        }
          , s = () => {
            l.title = `HemisphereLight-${o.name}-${o.id}`,
            this.lightPane.refresh()
        }
          , {light: o} = super.createHLight(e, n, r)
          , a = new Ff(o,1);
        this.lightHelperGroup.add(a);
        const l = this.lightPane.addFolder({
            title: "HemisphereLight"
        });
        return l.addBinding(o, "position").on("change", i),
        l.addBinding(o, "color", {
            color: {
                type: "float"
            }
        }).on("change", i),
        l.addBinding(o, "groundColor", {
            color: {
                type: "float"
            }
        }).on("change", i),
        l.addBinding(o, "intensity", {
            min: 0
        }).on("change", i),
        i(),
        s(),
        {
            light: o,
            helper: a,
            updateHelper: i,
            updatePane: s
        }
    }
    showDebug(e=!1, n=!1) {
        if (!this.pane.containerElem_)
            return console.warn("glViewDebug has been destroyed");
        if (n)
            return this.pane.dispose(),
            this.lightHelperGroup.removeFromParent(),
            this.stats.dom.remove(),
            console.warn("glViewDebug has been destroyed");
        e ? (this.pane.hidden = !1,
        this.scene.add(this.lightHelperGroup),
        this.container.appendChild(this.stats.dom)) : (this.pane.hidden = !0,
        this.lightHelperGroup.visible = !1,
        this.stats.dom.remove())
    }
    render() {
        super.render(),
        this.stats.update()
    }
    renderComposer() {
        super.renderComposer(),
        this.stats.update()
    }
}
/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const Ce = {
    LEFT: 1,
    RIGHT: 2,
    MIDDLE: 4
}
  , O = Object.freeze({
    NONE: 0,
    ROTATE: 1,
    TRUCK: 2,
    OFFSET: 4,
    DOLLY: 8,
    ZOOM: 16,
    TOUCH_ROTATE: 32,
    TOUCH_TRUCK: 64,
    TOUCH_OFFSET: 128,
    TOUCH_DOLLY: 256,
    TOUCH_ZOOM: 512,
    TOUCH_DOLLY_TRUCK: 1024,
    TOUCH_DOLLY_OFFSET: 2048,
    TOUCH_DOLLY_ROTATE: 4096,
    TOUCH_ZOOM_TRUCK: 8192,
    TOUCH_ZOOM_OFFSET: 16384,
    TOUCH_ZOOM_ROTATE: 32768
})
  , Jn = {
    NONE: 0,
    IN: 1,
    OUT: -1
};
function Pn(t) {
    return t.isPerspectiveCamera
}
function dn(t) {
    return t.isOrthographicCamera
}
const er = Math.PI * 2
  , gc = Math.PI / 2
  , Tp = 1e-5
  , Vr = Math.PI / 180;
function mt(t, e, n) {
    return Math.max(e, Math.min(n, t))
}
function me(t, e=Tp) {
    return Math.abs(t) < e
}
function ce(t, e, n=Tp) {
    return me(t - e, n)
}
function bc(t, e) {
    return Math.round(t / e) * e
}
function Dr(t) {
    return isFinite(t) ? t : t < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE
}
function Br(t) {
    return Math.abs(t) < Number.MAX_VALUE ? t : t * (1 / 0)
}
function Hi(t, e, n, r, i=1 / 0, s) {
    r = Math.max(1e-4, r);
    const o = 2 / r
      , a = o * s
      , l = 1 / (1 + a + .48 * a * a + .235 * a * a * a);
    let c = t - e;
    const u = e
      , d = i * r;
    c = mt(c, -d, d),
    e = t - c;
    const m = (n.value + o * c) * s;
    n.value = (n.value - o * m) * l;
    let g = e + (c + m) * l;
    return u - t > 0 == g > u && (g = u,
    n.value = (g - u) / s),
    g
}
function _c(t, e, n, r, i=1 / 0, s, o) {
    r = Math.max(1e-4, r);
    const a = 2 / r
      , l = a * s
      , c = 1 / (1 + l + .48 * l * l + .235 * l * l * l);
    let u = e.x
      , d = e.y
      , m = e.z
      , g = t.x - u
      , f = t.y - d
      , h = t.z - m;
    const _ = u
      , p = d
      , b = m
      , y = i * r
      , w = y * y
      , x = g * g + f * f + h * h;
    if (x > w) {
        const K = Math.sqrt(x);
        g = g / K * y,
        f = f / K * y,
        h = h / K * y
    }
    u = t.x - g,
    d = t.y - f,
    m = t.z - h;
    const C = (n.x + a * g) * s
      , P = (n.y + a * f) * s
      , T = (n.z + a * h) * s;
    n.x = (n.x - a * C) * c,
    n.y = (n.y - a * P) * c,
    n.z = (n.z - a * T) * c,
    o.x = u + (g + C) * c,
    o.y = d + (f + P) * c,
    o.z = m + (h + T) * c;
    const L = _ - t.x
      , I = p - t.y
      , U = b - t.z
      , B = o.x - _
      , V = o.y - p
      , z = o.z - b;
    return L * B + I * V + U * z > 0 && (o.x = _,
    o.y = p,
    o.z = b,
    n.x = (o.x - _) / s,
    n.y = (o.y - p) / s,
    n.z = (o.z - b) / s),
    o
}
function go(t, e) {
    e.set(0, 0),
    t.forEach(n => {
        e.x += n.clientX,
        e.y += n.clientY
    }
    ),
    e.x /= t.length,
    e.y /= t.length
}
function bo(t, e) {
    return dn(t) ? (console.warn(`${e} is not supported in OrthographicCamera`),
    !0) : !1
}
class Ap {
    constructor() {
        this._listeners = {}
    }
    addEventListener(e, n) {
        const r = this._listeners;
        r[e] === void 0 && (r[e] = []),
        r[e].indexOf(n) === -1 && r[e].push(n)
    }
    hasEventListener(e, n) {
        const r = this._listeners;
        return r[e] !== void 0 && r[e].indexOf(n) !== -1
    }
    removeEventListener(e, n) {
        const i = this._listeners[e];
        if (i !== void 0) {
            const s = i.indexOf(n);
            s !== -1 && i.splice(s, 1)
        }
    }
    removeAllEventListeners(e) {
        if (!e) {
            this._listeners = {};
            return
        }
        Array.isArray(this._listeners[e]) && (this._listeners[e].length = 0)
    }
    dispatchEvent(e) {
        const r = this._listeners[e.type];
        if (r !== void 0) {
            e.target = this;
            const i = r.slice(0);
            for (let s = 0, o = i.length; s < o; s++)
                i[s].call(this, e)
        }
    }
}
var _o;
const p0 = "2.9.0"
  , Ki = 1 / 8
  , h0 = /Mac/.test((_o = globalThis == null ? void 0 : globalThis.navigator) === null || _o === void 0 ? void 0 : _o.platform);
let q, yc, Gi, yo, Ye, Z, se, tr, $r, Tt, At, On, wc, xc, ot, Ur, nr, Cc, wo, Ec, xo, Co, qi;
class pr extends Ap {
    static install(e) {
        q = e.THREE,
        yc = Object.freeze(new q.Vector3(0,0,0)),
        Gi = Object.freeze(new q.Vector3(0,1,0)),
        yo = Object.freeze(new q.Vector3(0,0,1)),
        Ye = new q.Vector2,
        Z = new q.Vector3,
        se = new q.Vector3,
        tr = new q.Vector3,
        $r = new q.Vector3,
        Tt = new q.Vector3,
        At = new q.Vector3,
        On = new q.Vector3,
        wc = new q.Vector3,
        xc = new q.Vector3,
        ot = new q.Spherical,
        Ur = new q.Spherical,
        nr = new q.Box3,
        Cc = new q.Box3,
        wo = new q.Sphere,
        Ec = new q.Quaternion,
        xo = new q.Quaternion,
        Co = new q.Matrix4,
        qi = new q.Raycaster
    }
    static get ACTION() {
        return O
    }
    constructor(e, n) {
        super(),
        this.minPolarAngle = 0,
        this.maxPolarAngle = Math.PI,
        this.minAzimuthAngle = -1 / 0,
        this.maxAzimuthAngle = 1 / 0,
        this.minDistance = Number.EPSILON,
        this.maxDistance = 1 / 0,
        this.infinityDolly = !1,
        this.minZoom = .01,
        this.maxZoom = 1 / 0,
        this.smoothTime = .25,
        this.draggingSmoothTime = .125,
        this.maxSpeed = 1 / 0,
        this.azimuthRotateSpeed = 1,
        this.polarRotateSpeed = 1,
        this.dollySpeed = 1,
        this.dollyDragInverted = !1,
        this.truckSpeed = 2,
        this.dollyToCursor = !1,
        this.dragToOffset = !1,
        this.verticalDragToForward = !1,
        this.boundaryFriction = 0,
        this.restThreshold = .01,
        this.colliderMeshes = [],
        this.cancel = () => {}
        ,
        this._enabled = !0,
        this._state = O.NONE,
        this._viewport = null,
        this._changedDolly = 0,
        this._changedZoom = 0,
        this._hasRested = !0,
        this._boundaryEnclosesCamera = !1,
        this._needsUpdate = !0,
        this._updatedLastTime = !1,
        this._elementRect = new DOMRect,
        this._isDragging = !1,
        this._dragNeedsUpdate = !0,
        this._activePointers = [],
        this._lockedPointer = null,
        this._interactiveArea = new DOMRect(0,0,1,1),
        this._isUserControllingRotate = !1,
        this._isUserControllingDolly = !1,
        this._isUserControllingTruck = !1,
        this._isUserControllingOffset = !1,
        this._isUserControllingZoom = !1,
        this._lastDollyDirection = Jn.NONE,
        this._thetaVelocity = {
            value: 0
        },
        this._phiVelocity = {
            value: 0
        },
        this._radiusVelocity = {
            value: 0
        },
        this._targetVelocity = new q.Vector3,
        this._focalOffsetVelocity = new q.Vector3,
        this._zoomVelocity = {
            value: 0
        },
        this._truckInternal = (p, b, y) => {
            let w, x;
            if (Pn(this._camera)) {
                const C = Z.copy(this._camera.position).sub(this._target)
                  , P = this._camera.getEffectiveFOV() * Vr
                  , T = C.length() * Math.tan(P * .5);
                w = this.truckSpeed * p * T / this._elementRect.height,
                x = this.truckSpeed * b * T / this._elementRect.height
            } else if (dn(this._camera)) {
                const C = this._camera;
                w = p * (C.right - C.left) / C.zoom / this._elementRect.width,
                x = b * (C.top - C.bottom) / C.zoom / this._elementRect.height
            } else
                return;
            this.verticalDragToForward ? (y ? this.setFocalOffset(this._focalOffsetEnd.x + w, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(w, 0, !0),
            this.forward(-x, !0)) : y ? this.setFocalOffset(this._focalOffsetEnd.x + w, this._focalOffsetEnd.y + x, this._focalOffsetEnd.z, !0) : this.truck(w, x, !0)
        }
        ,
        this._rotateInternal = (p, b) => {
            const y = er * this.azimuthRotateSpeed * p / this._elementRect.height
              , w = er * this.polarRotateSpeed * b / this._elementRect.height;
            this.rotate(y, w, !0)
        }
        ,
        this._dollyInternal = (p, b, y) => {
            const w = Math.pow(.95, -p * this.dollySpeed)
              , x = this._sphericalEnd.radius
              , C = this._sphericalEnd.radius * w
              , P = mt(C, this.minDistance, this.maxDistance)
              , T = P - C;
            this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(C, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(T, !0),
            this._dollyToNoClamp(P, !0)) : this._dollyToNoClamp(P, !0),
            this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? C : P) - x,
            this._dollyControlCoord.set(b, y)),
            this._lastDollyDirection = Math.sign(-p)
        }
        ,
        this._zoomInternal = (p, b, y) => {
            const w = Math.pow(.95, p * this.dollySpeed)
              , x = this._zoom
              , C = this._zoom * w;
            this.zoomTo(C, !0),
            this.dollyToCursor && (this._changedZoom += C - x,
            this._dollyControlCoord.set(b, y))
        }
        ,
        typeof q > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."),
        this._camera = e,
        this._yAxisUpSpace = new q.Quaternion().setFromUnitVectors(this._camera.up, Gi),
        this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(),
        this._state = O.NONE,
        this._target = new q.Vector3,
        this._targetEnd = this._target.clone(),
        this._focalOffset = new q.Vector3,
        this._focalOffsetEnd = this._focalOffset.clone(),
        this._spherical = new q.Spherical().setFromVector3(Z.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)),
        this._sphericalEnd = this._spherical.clone(),
        this._lastDistance = this._spherical.radius,
        this._zoom = this._camera.zoom,
        this._zoomEnd = this._zoom,
        this._lastZoom = this._zoom,
        this._nearPlaneCorners = [new q.Vector3, new q.Vector3, new q.Vector3, new q.Vector3],
        this._updateNearPlaneCorners(),
        this._boundary = new q.Box3(new q.Vector3(-1 / 0,-1 / 0,-1 / 0),new q.Vector3(1 / 0,1 / 0,1 / 0)),
        this._cameraUp0 = this._camera.up.clone(),
        this._target0 = this._target.clone(),
        this._position0 = this._camera.position.clone(),
        this._zoom0 = this._zoom,
        this._focalOffset0 = this._focalOffset.clone(),
        this._dollyControlCoord = new q.Vector2,
        this.mouseButtons = {
            left: O.ROTATE,
            middle: O.DOLLY,
            right: O.TRUCK,
            wheel: Pn(this._camera) ? O.DOLLY : dn(this._camera) ? O.ZOOM : O.NONE
        },
        this.touches = {
            one: O.TOUCH_ROTATE,
            two: Pn(this._camera) ? O.TOUCH_DOLLY_TRUCK : dn(this._camera) ? O.TOUCH_ZOOM_TRUCK : O.NONE,
            three: O.TOUCH_TRUCK
        };
        const r = new q.Vector2
          , i = new q.Vector2
          , s = new q.Vector2
          , o = p => {
            if (!this._enabled || !this._domElement)
                return;
            if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
                const w = this._domElement.getBoundingClientRect()
                  , x = p.clientX / w.width
                  , C = p.clientY / w.height;
                if (x < this._interactiveArea.left || x > this._interactiveArea.right || C < this._interactiveArea.top || C > this._interactiveArea.bottom)
                    return
            }
            const b = p.pointerType !== "mouse" ? null : (p.buttons & Ce.LEFT) === Ce.LEFT ? Ce.LEFT : (p.buttons & Ce.MIDDLE) === Ce.MIDDLE ? Ce.MIDDLE : (p.buttons & Ce.RIGHT) === Ce.RIGHT ? Ce.RIGHT : null;
            if (b !== null) {
                const w = this._findPointerByMouseButton(b);
                w && this._disposePointer(w)
            }
            if ((p.buttons & Ce.LEFT) === Ce.LEFT && this._lockedPointer)
                return;
            const y = {
                pointerId: p.pointerId,
                clientX: p.clientX,
                clientY: p.clientY,
                deltaX: 0,
                deltaY: 0,
                mouseButton: b
            };
            this._activePointers.push(y),
            this._domElement.ownerDocument.removeEventListener("pointermove", a, {
                passive: !1
            }),
            this._domElement.ownerDocument.removeEventListener("pointerup", l),
            this._domElement.ownerDocument.addEventListener("pointermove", a, {
                passive: !1
            }),
            this._domElement.ownerDocument.addEventListener("pointerup", l),
            this._isDragging = !0,
            m(p)
        }
          , a = p => {
            p.cancelable && p.preventDefault();
            const b = p.pointerId
              , y = this._lockedPointer || this._findPointerById(b);
            if (y) {
                if (y.clientX = p.clientX,
                y.clientY = p.clientY,
                y.deltaX = p.movementX,
                y.deltaY = p.movementY,
                this._state = 0,
                p.pointerType === "touch")
                    switch (this._activePointers.length) {
                    case 1:
                        this._state = this.touches.one;
                        break;
                    case 2:
                        this._state = this.touches.two;
                        break;
                    case 3:
                        this._state = this.touches.three;
                        break
                    }
                else
                    (!this._isDragging && this._lockedPointer || this._isDragging && (p.buttons & Ce.LEFT) === Ce.LEFT) && (this._state = this._state | this.mouseButtons.left),
                    this._isDragging && (p.buttons & Ce.MIDDLE) === Ce.MIDDLE && (this._state = this._state | this.mouseButtons.middle),
                    this._isDragging && (p.buttons & Ce.RIGHT) === Ce.RIGHT && (this._state = this._state | this.mouseButtons.right);
                g()
            }
        }
          , l = p => {
            const b = this._findPointerById(p.pointerId);
            if (!(b && b === this._lockedPointer)) {
                if (b && this._disposePointer(b),
                p.pointerType === "touch")
                    switch (this._activePointers.length) {
                    case 0:
                        this._state = O.NONE;
                        break;
                    case 1:
                        this._state = this.touches.one;
                        break;
                    case 2:
                        this._state = this.touches.two;
                        break;
                    case 3:
                        this._state = this.touches.three;
                        break
                    }
                else
                    this._state = O.NONE;
                f()
            }
        }
        ;
        let c = -1;
        const u = p => {
            if (!this._domElement || !this._enabled || this.mouseButtons.wheel === O.NONE)
                return;
            if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
                const C = this._domElement.getBoundingClientRect()
                  , P = p.clientX / C.width
                  , T = p.clientY / C.height;
                if (P < this._interactiveArea.left || P > this._interactiveArea.right || T < this._interactiveArea.top || T > this._interactiveArea.bottom)
                    return
            }
            if (p.preventDefault(),
            this.dollyToCursor || this.mouseButtons.wheel === O.ROTATE || this.mouseButtons.wheel === O.TRUCK) {
                const C = performance.now();
                c - C < 1e3 && this._getClientRect(this._elementRect),
                c = C
            }
            const b = h0 ? -1 : -3
              , y = p.deltaMode === 1 ? p.deltaY / b : p.deltaY / (b * 10)
              , w = this.dollyToCursor ? (p.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0
              , x = this.dollyToCursor ? (p.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
            switch (this.mouseButtons.wheel) {
            case O.ROTATE:
                {
                    this._rotateInternal(p.deltaX, p.deltaY),
                    this._isUserControllingRotate = !0;
                    break
                }
            case O.TRUCK:
                {
                    this._truckInternal(p.deltaX, p.deltaY, !1),
                    this._isUserControllingTruck = !0;
                    break
                }
            case O.OFFSET:
                {
                    this._truckInternal(p.deltaX, p.deltaY, !0),
                    this._isUserControllingOffset = !0;
                    break
                }
            case O.DOLLY:
                {
                    this._dollyInternal(-y, w, x),
                    this._isUserControllingDolly = !0;
                    break
                }
            case O.ZOOM:
                {
                    this._zoomInternal(-y, w, x),
                    this._isUserControllingZoom = !0;
                    break
                }
            }
            this.dispatchEvent({
                type: "control"
            })
        }
          , d = p => {
            if (!(!this._domElement || !this._enabled)) {
                if (this.mouseButtons.right === pr.ACTION.NONE) {
                    const b = p instanceof PointerEvent ? p.pointerId : 0
                      , y = this._findPointerById(b);
                    y && this._disposePointer(y),
                    this._domElement.ownerDocument.removeEventListener("pointermove", a, {
                        passive: !1
                    }),
                    this._domElement.ownerDocument.removeEventListener("pointerup", l);
                    return
                }
                p.preventDefault()
            }
        }
          , m = p => {
            if (!this._enabled)
                return;
            if (go(this._activePointers, Ye),
            this._getClientRect(this._elementRect),
            r.copy(Ye),
            i.copy(Ye),
            this._activePointers.length >= 2) {
                const y = Ye.x - this._activePointers[1].clientX
                  , w = Ye.y - this._activePointers[1].clientY
                  , x = Math.sqrt(y * y + w * w);
                s.set(0, x);
                const C = (this._activePointers[0].clientX + this._activePointers[1].clientX) * .5
                  , P = (this._activePointers[0].clientY + this._activePointers[1].clientY) * .5;
                i.set(C, P)
            }
            if (this._state = 0,
            !p)
                this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
            else if ("pointerType"in p && p.pointerType === "touch")
                switch (this._activePointers.length) {
                case 1:
                    this._state = this.touches.one;
                    break;
                case 2:
                    this._state = this.touches.two;
                    break;
                case 3:
                    this._state = this.touches.three;
                    break
                }
            else
                !this._lockedPointer && (p.buttons & Ce.LEFT) === Ce.LEFT && (this._state = this._state | this.mouseButtons.left),
                (p.buttons & Ce.MIDDLE) === Ce.MIDDLE && (this._state = this._state | this.mouseButtons.middle),
                (p.buttons & Ce.RIGHT) === Ce.RIGHT && (this._state = this._state | this.mouseButtons.right);
            ((this._state & O.ROTATE) === O.ROTATE || (this._state & O.TOUCH_ROTATE) === O.TOUCH_ROTATE || (this._state & O.TOUCH_DOLLY_ROTATE) === O.TOUCH_DOLLY_ROTATE || (this._state & O.TOUCH_ZOOM_ROTATE) === O.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta,
            this._sphericalEnd.phi = this._spherical.phi,
            this._thetaVelocity.value = 0,
            this._phiVelocity.value = 0),
            ((this._state & O.TRUCK) === O.TRUCK || (this._state & O.TOUCH_TRUCK) === O.TOUCH_TRUCK || (this._state & O.TOUCH_DOLLY_TRUCK) === O.TOUCH_DOLLY_TRUCK || (this._state & O.TOUCH_ZOOM_TRUCK) === O.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target),
            this._targetVelocity.set(0, 0, 0)),
            ((this._state & O.DOLLY) === O.DOLLY || (this._state & O.TOUCH_DOLLY) === O.TOUCH_DOLLY || (this._state & O.TOUCH_DOLLY_TRUCK) === O.TOUCH_DOLLY_TRUCK || (this._state & O.TOUCH_DOLLY_OFFSET) === O.TOUCH_DOLLY_OFFSET || (this._state & O.TOUCH_DOLLY_ROTATE) === O.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius,
            this._radiusVelocity.value = 0),
            ((this._state & O.ZOOM) === O.ZOOM || (this._state & O.TOUCH_ZOOM) === O.TOUCH_ZOOM || (this._state & O.TOUCH_ZOOM_TRUCK) === O.TOUCH_ZOOM_TRUCK || (this._state & O.TOUCH_ZOOM_OFFSET) === O.TOUCH_ZOOM_OFFSET || (this._state & O.TOUCH_ZOOM_ROTATE) === O.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom,
            this._zoomVelocity.value = 0),
            ((this._state & O.OFFSET) === O.OFFSET || (this._state & O.TOUCH_OFFSET) === O.TOUCH_OFFSET || (this._state & O.TOUCH_DOLLY_OFFSET) === O.TOUCH_DOLLY_OFFSET || (this._state & O.TOUCH_ZOOM_OFFSET) === O.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset),
            this._focalOffsetVelocity.set(0, 0, 0)),
            this.dispatchEvent({
                type: "controlstart"
            })
        }
          , g = () => {
            if (!this._enabled || !this._dragNeedsUpdate)
                return;
            this._dragNeedsUpdate = !1,
            go(this._activePointers, Ye);
            const b = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null
              , y = b ? -b.deltaX : i.x - Ye.x
              , w = b ? -b.deltaY : i.y - Ye.y;
            if (i.copy(Ye),
            ((this._state & O.ROTATE) === O.ROTATE || (this._state & O.TOUCH_ROTATE) === O.TOUCH_ROTATE || (this._state & O.TOUCH_DOLLY_ROTATE) === O.TOUCH_DOLLY_ROTATE || (this._state & O.TOUCH_ZOOM_ROTATE) === O.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(y, w),
            this._isUserControllingRotate = !0),
            (this._state & O.DOLLY) === O.DOLLY || (this._state & O.ZOOM) === O.ZOOM) {
                const x = this.dollyToCursor ? (r.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0
                  , C = this.dollyToCursor ? (r.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0
                  , P = this.dollyDragInverted ? -1 : 1;
                (this._state & O.DOLLY) === O.DOLLY ? (this._dollyInternal(P * w * Ki, x, C),
                this._isUserControllingDolly = !0) : (this._zoomInternal(P * w * Ki, x, C),
                this._isUserControllingZoom = !0)
            }
            if ((this._state & O.TOUCH_DOLLY) === O.TOUCH_DOLLY || (this._state & O.TOUCH_ZOOM) === O.TOUCH_ZOOM || (this._state & O.TOUCH_DOLLY_TRUCK) === O.TOUCH_DOLLY_TRUCK || (this._state & O.TOUCH_ZOOM_TRUCK) === O.TOUCH_ZOOM_TRUCK || (this._state & O.TOUCH_DOLLY_OFFSET) === O.TOUCH_DOLLY_OFFSET || (this._state & O.TOUCH_ZOOM_OFFSET) === O.TOUCH_ZOOM_OFFSET || (this._state & O.TOUCH_DOLLY_ROTATE) === O.TOUCH_DOLLY_ROTATE || (this._state & O.TOUCH_ZOOM_ROTATE) === O.TOUCH_ZOOM_ROTATE) {
                const x = Ye.x - this._activePointers[1].clientX
                  , C = Ye.y - this._activePointers[1].clientY
                  , P = Math.sqrt(x * x + C * C)
                  , T = s.y - P;
                s.set(0, P);
                const L = this.dollyToCursor ? (i.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0
                  , I = this.dollyToCursor ? (i.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
                (this._state & O.TOUCH_DOLLY) === O.TOUCH_DOLLY || (this._state & O.TOUCH_DOLLY_ROTATE) === O.TOUCH_DOLLY_ROTATE || (this._state & O.TOUCH_DOLLY_TRUCK) === O.TOUCH_DOLLY_TRUCK || (this._state & O.TOUCH_DOLLY_OFFSET) === O.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(T * Ki, L, I),
                this._isUserControllingDolly = !0) : (this._zoomInternal(T * Ki, L, I),
                this._isUserControllingZoom = !0)
            }
            ((this._state & O.TRUCK) === O.TRUCK || (this._state & O.TOUCH_TRUCK) === O.TOUCH_TRUCK || (this._state & O.TOUCH_DOLLY_TRUCK) === O.TOUCH_DOLLY_TRUCK || (this._state & O.TOUCH_ZOOM_TRUCK) === O.TOUCH_ZOOM_TRUCK) && (this._truckInternal(y, w, !1),
            this._isUserControllingTruck = !0),
            ((this._state & O.OFFSET) === O.OFFSET || (this._state & O.TOUCH_OFFSET) === O.TOUCH_OFFSET || (this._state & O.TOUCH_DOLLY_OFFSET) === O.TOUCH_DOLLY_OFFSET || (this._state & O.TOUCH_ZOOM_OFFSET) === O.TOUCH_ZOOM_OFFSET) && (this._truckInternal(y, w, !0),
            this._isUserControllingOffset = !0),
            this.dispatchEvent({
                type: "control"
            })
        }
          , f = () => {
            go(this._activePointers, Ye),
            i.copy(Ye),
            this._dragNeedsUpdate = !1,
            (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1),
            this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", a, {
                passive: !1
            }),
            this._domElement.ownerDocument.removeEventListener("pointerup", l),
            this.dispatchEvent({
                type: "controlend"
            }))
        }
        ;
        this.lockPointer = () => {
            !this._enabled || !this._domElement || (this.cancel(),
            this._lockedPointer = {
                pointerId: -1,
                clientX: 0,
                clientY: 0,
                deltaX: 0,
                deltaY: 0,
                mouseButton: null
            },
            this._activePointers.push(this._lockedPointer),
            this._domElement.ownerDocument.removeEventListener("pointermove", a, {
                passive: !1
            }),
            this._domElement.ownerDocument.removeEventListener("pointerup", l),
            this._domElement.requestPointerLock(),
            this._domElement.ownerDocument.addEventListener("pointerlockchange", h),
            this._domElement.ownerDocument.addEventListener("pointerlockerror", _),
            this._domElement.ownerDocument.addEventListener("pointermove", a, {
                passive: !1
            }),
            this._domElement.ownerDocument.addEventListener("pointerup", l),
            m())
        }
        ,
        this.unlockPointer = () => {
            var p, b, y;
            this._lockedPointer !== null && (this._disposePointer(this._lockedPointer),
            this._lockedPointer = null),
            (p = this._domElement) === null || p === void 0 || p.ownerDocument.exitPointerLock(),
            (b = this._domElement) === null || b === void 0 || b.ownerDocument.removeEventListener("pointerlockchange", h),
            (y = this._domElement) === null || y === void 0 || y.ownerDocument.removeEventListener("pointerlockerror", _),
            this.cancel()
        }
        ;
        const h = () => {
            this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer()
        }
          , _ = () => {
            this.unlockPointer()
        }
        ;
        this._addAllEventListeners = p => {
            this._domElement = p,
            this._domElement.style.touchAction = "none",
            this._domElement.style.userSelect = "none",
            this._domElement.style.webkitUserSelect = "none",
            this._domElement.addEventListener("pointerdown", o),
            this._domElement.addEventListener("pointercancel", l),
            this._domElement.addEventListener("wheel", u, {
                passive: !1
            }),
            this._domElement.addEventListener("contextmenu", d)
        }
        ,
        this._removeAllEventListeners = () => {
            this._domElement && (this._domElement.style.touchAction = "",
            this._domElement.style.userSelect = "",
            this._domElement.style.webkitUserSelect = "",
            this._domElement.removeEventListener("pointerdown", o),
            this._domElement.removeEventListener("pointercancel", l),
            this._domElement.removeEventListener("wheel", u, {
                passive: !1
            }),
            this._domElement.removeEventListener("contextmenu", d),
            this._domElement.ownerDocument.removeEventListener("pointermove", a, {
                passive: !1
            }),
            this._domElement.ownerDocument.removeEventListener("pointerup", l),
            this._domElement.ownerDocument.removeEventListener("pointerlockchange", h),
            this._domElement.ownerDocument.removeEventListener("pointerlockerror", _))
        }
        ,
        this.cancel = () => {
            this._state !== O.NONE && (this._state = O.NONE,
            this._activePointers.length = 0,
            f())
        }
        ,
        n && this.connect(n),
        this.update(0)
    }
    get camera() {
        return this._camera
    }
    set camera(e) {
        this._camera = e,
        this.updateCameraUp(),
        this._camera.updateProjectionMatrix(),
        this._updateNearPlaneCorners(),
        this._needsUpdate = !0
    }
    get enabled() {
        return this._enabled
    }
    set enabled(e) {
        this._enabled = e,
        this._domElement && (e ? (this._domElement.style.touchAction = "none",
        this._domElement.style.userSelect = "none",
        this._domElement.style.webkitUserSelect = "none") : (this.cancel(),
        this._domElement.style.touchAction = "",
        this._domElement.style.userSelect = "",
        this._domElement.style.webkitUserSelect = ""))
    }
    get active() {
        return !this._hasRested
    }
    get currentAction() {
        return this._state
    }
    get distance() {
        return this._spherical.radius
    }
    set distance(e) {
        this._spherical.radius === e && this._sphericalEnd.radius === e || (this._spherical.radius = e,
        this._sphericalEnd.radius = e,
        this._needsUpdate = !0)
    }
    get azimuthAngle() {
        return this._spherical.theta
    }
    set azimuthAngle(e) {
        this._spherical.theta === e && this._sphericalEnd.theta === e || (this._spherical.theta = e,
        this._sphericalEnd.theta = e,
        this._needsUpdate = !0)
    }
    get polarAngle() {
        return this._spherical.phi
    }
    set polarAngle(e) {
        this._spherical.phi === e && this._sphericalEnd.phi === e || (this._spherical.phi = e,
        this._sphericalEnd.phi = e,
        this._needsUpdate = !0)
    }
    get boundaryEnclosesCamera() {
        return this._boundaryEnclosesCamera
    }
    set boundaryEnclosesCamera(e) {
        this._boundaryEnclosesCamera = e,
        this._needsUpdate = !0
    }
    set interactiveArea(e) {
        this._interactiveArea.width = mt(e.width, 0, 1),
        this._interactiveArea.height = mt(e.height, 0, 1),
        this._interactiveArea.x = mt(e.x, 0, 1 - this._interactiveArea.width),
        this._interactiveArea.y = mt(e.y, 0, 1 - this._interactiveArea.height)
    }
    addEventListener(e, n) {
        super.addEventListener(e, n)
    }
    removeEventListener(e, n) {
        super.removeEventListener(e, n)
    }
    rotate(e, n, r=!1) {
        return this.rotateTo(this._sphericalEnd.theta + e, this._sphericalEnd.phi + n, r)
    }
    rotateAzimuthTo(e, n=!1) {
        return this.rotateTo(e, this._sphericalEnd.phi, n)
    }
    rotatePolarTo(e, n=!1) {
        return this.rotateTo(this._sphericalEnd.theta, e, n)
    }
    rotateTo(e, n, r=!1) {
        this._isUserControllingRotate = !1;
        const i = mt(e, this.minAzimuthAngle, this.maxAzimuthAngle)
          , s = mt(n, this.minPolarAngle, this.maxPolarAngle);
        this._sphericalEnd.theta = i,
        this._sphericalEnd.phi = s,
        this._sphericalEnd.makeSafe(),
        this._needsUpdate = !0,
        r || (this._spherical.theta = this._sphericalEnd.theta,
        this._spherical.phi = this._sphericalEnd.phi);
        const o = !r || ce(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ce(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
        return this._createOnRestPromise(o)
    }
    dolly(e, n=!1) {
        return this.dollyTo(this._sphericalEnd.radius - e, n)
    }
    dollyTo(e, n=!1) {
        return this._isUserControllingDolly = !1,
        this._lastDollyDirection = Jn.NONE,
        this._changedDolly = 0,
        this._dollyToNoClamp(mt(e, this.minDistance, this.maxDistance), n)
    }
    _dollyToNoClamp(e, n=!1) {
        const r = this._sphericalEnd.radius;
        if (this.colliderMeshes.length >= 1) {
            const o = this._collisionTest()
              , a = ce(o, this._spherical.radius);
            if (!(r > e) && a)
                return Promise.resolve();
            this._sphericalEnd.radius = Math.min(e, o)
        } else
            this._sphericalEnd.radius = e;
        this._needsUpdate = !0,
        n || (this._spherical.radius = this._sphericalEnd.radius);
        const s = !n || ce(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
        return this._createOnRestPromise(s)
    }
    dollyInFixed(e, n=!1) {
        this._targetEnd.add(this._getCameraDirection($r).multiplyScalar(e)),
        n || this._target.copy(this._targetEnd);
        const r = !n || ce(this._target.x, this._targetEnd.x, this.restThreshold) && ce(this._target.y, this._targetEnd.y, this.restThreshold) && ce(this._target.z, this._targetEnd.z, this.restThreshold);
        return this._createOnRestPromise(r)
    }
    zoom(e, n=!1) {
        return this.zoomTo(this._zoomEnd + e, n)
    }
    zoomTo(e, n=!1) {
        this._isUserControllingZoom = !1,
        this._zoomEnd = mt(e, this.minZoom, this.maxZoom),
        this._needsUpdate = !0,
        n || (this._zoom = this._zoomEnd);
        const r = !n || ce(this._zoom, this._zoomEnd, this.restThreshold);
        return this._changedZoom = 0,
        this._createOnRestPromise(r)
    }
    pan(e, n, r=!1) {
        return console.warn("`pan` has been renamed to `truck`"),
        this.truck(e, n, r)
    }
    truck(e, n, r=!1) {
        this._camera.updateMatrix(),
        Tt.setFromMatrixColumn(this._camera.matrix, 0),
        At.setFromMatrixColumn(this._camera.matrix, 1),
        Tt.multiplyScalar(e),
        At.multiplyScalar(-n);
        const i = Z.copy(Tt).add(At)
          , s = se.copy(this._targetEnd).add(i);
        return this.moveTo(s.x, s.y, s.z, r)
    }
    forward(e, n=!1) {
        Z.setFromMatrixColumn(this._camera.matrix, 0),
        Z.crossVectors(this._camera.up, Z),
        Z.multiplyScalar(e);
        const r = se.copy(this._targetEnd).add(Z);
        return this.moveTo(r.x, r.y, r.z, n)
    }
    elevate(e, n=!1) {
        return Z.copy(this._camera.up).multiplyScalar(e),
        this.moveTo(this._targetEnd.x + Z.x, this._targetEnd.y + Z.y, this._targetEnd.z + Z.z, n)
    }
    moveTo(e, n, r, i=!1) {
        this._isUserControllingTruck = !1;
        const s = Z.set(e, n, r).sub(this._targetEnd);
        this._encloseToBoundary(this._targetEnd, s, this.boundaryFriction),
        this._needsUpdate = !0,
        i || this._target.copy(this._targetEnd);
        const o = !i || ce(this._target.x, this._targetEnd.x, this.restThreshold) && ce(this._target.y, this._targetEnd.y, this.restThreshold) && ce(this._target.z, this._targetEnd.z, this.restThreshold);
        return this._createOnRestPromise(o)
    }
    lookInDirectionOf(e, n, r, i=!1) {
        const a = Z.set(e, n, r).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
        return this.setPosition(a.x, a.y, a.z, i)
    }
    fitToBox(e, n, {cover: r=!1, paddingLeft: i=0, paddingRight: s=0, paddingBottom: o=0, paddingTop: a=0}={}) {
        const l = []
          , c = e.isBox3 ? nr.copy(e) : nr.setFromObject(e);
        c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"),
        Promise.resolve());
        const u = bc(this._sphericalEnd.theta, gc)
          , d = bc(this._sphericalEnd.phi, gc);
        l.push(this.rotateTo(u, d, n));
        const m = Z.setFromSpherical(this._sphericalEnd).normalize()
          , g = Ec.setFromUnitVectors(m, yo)
          , f = ce(Math.abs(m.y), 1);
        f && g.multiply(xo.setFromAxisAngle(Gi, u)),
        g.multiply(this._yAxisUpSpaceInverse);
        const h = Cc.makeEmpty();
        se.copy(c.min).applyQuaternion(g),
        h.expandByPoint(se),
        se.copy(c.min).setX(c.max.x).applyQuaternion(g),
        h.expandByPoint(se),
        se.copy(c.min).setY(c.max.y).applyQuaternion(g),
        h.expandByPoint(se),
        se.copy(c.max).setZ(c.min.z).applyQuaternion(g),
        h.expandByPoint(se),
        se.copy(c.min).setZ(c.max.z).applyQuaternion(g),
        h.expandByPoint(se),
        se.copy(c.max).setY(c.min.y).applyQuaternion(g),
        h.expandByPoint(se),
        se.copy(c.max).setX(c.min.x).applyQuaternion(g),
        h.expandByPoint(se),
        se.copy(c.max).applyQuaternion(g),
        h.expandByPoint(se),
        h.min.x -= i,
        h.min.y -= o,
        h.max.x += s,
        h.max.y += a,
        g.setFromUnitVectors(yo, m),
        f && g.premultiply(xo.invert()),
        g.premultiply(this._yAxisUpSpace);
        const _ = h.getSize(Z)
          , p = h.getCenter(se).applyQuaternion(g);
        if (Pn(this._camera)) {
            const b = this.getDistanceToFitBox(_.x, _.y, _.z, r);
            l.push(this.moveTo(p.x, p.y, p.z, n)),
            l.push(this.dollyTo(b, n)),
            l.push(this.setFocalOffset(0, 0, 0, n))
        } else if (dn(this._camera)) {
            const b = this._camera
              , y = b.right - b.left
              , w = b.top - b.bottom
              , x = r ? Math.max(y / _.x, w / _.y) : Math.min(y / _.x, w / _.y);
            l.push(this.moveTo(p.x, p.y, p.z, n)),
            l.push(this.zoomTo(x, n)),
            l.push(this.setFocalOffset(0, 0, 0, n))
        }
        return Promise.all(l)
    }
    fitToSphere(e, n) {
        const r = []
          , s = "isObject3D"in e ? pr.createBoundingSphere(e, wo) : wo.copy(e);
        if (r.push(this.moveTo(s.center.x, s.center.y, s.center.z, n)),
        Pn(this._camera)) {
            const o = this.getDistanceToFitSphere(s.radius);
            r.push(this.dollyTo(o, n))
        } else if (dn(this._camera)) {
            const o = this._camera.right - this._camera.left
              , a = this._camera.top - this._camera.bottom
              , l = 2 * s.radius
              , c = Math.min(o / l, a / l);
            r.push(this.zoomTo(c, n))
        }
        return r.push(this.setFocalOffset(0, 0, 0, n)),
        Promise.all(r)
    }
    setLookAt(e, n, r, i, s, o, a=!1) {
        this._isUserControllingRotate = !1,
        this._isUserControllingDolly = !1,
        this._isUserControllingTruck = !1,
        this._lastDollyDirection = Jn.NONE,
        this._changedDolly = 0;
        const l = se.set(i, s, o)
          , c = Z.set(e, n, r);
        this._targetEnd.copy(l),
        this._sphericalEnd.setFromVector3(c.sub(l).applyQuaternion(this._yAxisUpSpace)),
        this.normalizeRotations(),
        this._needsUpdate = !0,
        a || (this._target.copy(this._targetEnd),
        this._spherical.copy(this._sphericalEnd));
        const u = !a || ce(this._target.x, this._targetEnd.x, this.restThreshold) && ce(this._target.y, this._targetEnd.y, this.restThreshold) && ce(this._target.z, this._targetEnd.z, this.restThreshold) && ce(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ce(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && ce(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
        return this._createOnRestPromise(u)
    }
    lerpLookAt(e, n, r, i, s, o, a, l, c, u, d, m, g, f=!1) {
        this._isUserControllingRotate = !1,
        this._isUserControllingDolly = !1,
        this._isUserControllingTruck = !1,
        this._lastDollyDirection = Jn.NONE,
        this._changedDolly = 0;
        const h = Z.set(i, s, o)
          , _ = se.set(e, n, r);
        ot.setFromVector3(_.sub(h).applyQuaternion(this._yAxisUpSpace));
        const p = tr.set(u, d, m)
          , b = se.set(a, l, c);
        Ur.setFromVector3(b.sub(p).applyQuaternion(this._yAxisUpSpace)),
        this._targetEnd.copy(h.lerp(p, g));
        const y = Ur.theta - ot.theta
          , w = Ur.phi - ot.phi
          , x = Ur.radius - ot.radius;
        this._sphericalEnd.set(ot.radius + x * g, ot.phi + w * g, ot.theta + y * g),
        this.normalizeRotations(),
        this._needsUpdate = !0,
        f || (this._target.copy(this._targetEnd),
        this._spherical.copy(this._sphericalEnd));
        const C = !f || ce(this._target.x, this._targetEnd.x, this.restThreshold) && ce(this._target.y, this._targetEnd.y, this.restThreshold) && ce(this._target.z, this._targetEnd.z, this.restThreshold) && ce(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && ce(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && ce(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
        return this._createOnRestPromise(C)
    }
    setPosition(e, n, r, i=!1) {
        return this.setLookAt(e, n, r, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, i)
    }
    setTarget(e, n, r, i=!1) {
        const s = this.getPosition(Z)
          , o = this.setLookAt(s.x, s.y, s.z, e, n, r, i);
        return this._sphericalEnd.phi = mt(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle),
        o
    }
    setFocalOffset(e, n, r, i=!1) {
        this._isUserControllingOffset = !1,
        this._focalOffsetEnd.set(e, n, r),
        this._needsUpdate = !0,
        i || this._focalOffset.copy(this._focalOffsetEnd);
        const s = !i || ce(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && ce(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && ce(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
        return this._createOnRestPromise(s)
    }
    setOrbitPoint(e, n, r) {
        this._camera.updateMatrixWorld(),
        Tt.setFromMatrixColumn(this._camera.matrixWorldInverse, 0),
        At.setFromMatrixColumn(this._camera.matrixWorldInverse, 1),
        On.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
        const i = Z.set(e, n, r)
          , s = i.distanceTo(this._camera.position)
          , o = i.sub(this._camera.position);
        Tt.multiplyScalar(o.x),
        At.multiplyScalar(o.y),
        On.multiplyScalar(o.z),
        Z.copy(Tt).add(At).add(On),
        Z.z = Z.z + s,
        this.dollyTo(s, !1),
        this.setFocalOffset(-Z.x, Z.y, -Z.z, !1),
        this.moveTo(e, n, r, !1)
    }
    setBoundary(e) {
        if (!e) {
            this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0),
            this._boundary.max.set(1 / 0, 1 / 0, 1 / 0),
            this._needsUpdate = !0;
            return
        }
        this._boundary.copy(e),
        this._boundary.clampPoint(this._targetEnd, this._targetEnd),
        this._needsUpdate = !0
    }
    setViewport(e, n, r, i) {
        if (e === null) {
            this._viewport = null;
            return
        }
        this._viewport = this._viewport || new q.Vector4,
        typeof e == "number" ? this._viewport.set(e, n, r, i) : this._viewport.copy(e)
    }
    getDistanceToFitBox(e, n, r, i=!1) {
        if (bo(this._camera, "getDistanceToFitBox"))
            return this._spherical.radius;
        const s = e / n
          , o = this._camera.getEffectiveFOV() * Vr
          , a = this._camera.aspect;
        return ((i ? s > a : s < a) ? n : e / a) * .5 / Math.tan(o * .5) + r * .5
    }
    getDistanceToFitSphere(e) {
        if (bo(this._camera, "getDistanceToFitSphere"))
            return this._spherical.radius;
        const n = this._camera.getEffectiveFOV() * Vr
          , r = Math.atan(Math.tan(n * .5) * this._camera.aspect) * 2
          , i = 1 < this._camera.aspect ? n : r;
        return e / Math.sin(i * .5)
    }
    getTarget(e, n=!0) {
        return (e && e.isVector3 ? e : new q.Vector3).copy(n ? this._targetEnd : this._target)
    }
    getPosition(e, n=!0) {
        return (e && e.isVector3 ? e : new q.Vector3).setFromSpherical(n ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(n ? this._targetEnd : this._target)
    }
    getSpherical(e, n=!0) {
        return (e || new q.Spherical).copy(n ? this._sphericalEnd : this._spherical)
    }
    getFocalOffset(e, n=!0) {
        return (e && e.isVector3 ? e : new q.Vector3).copy(n ? this._focalOffsetEnd : this._focalOffset)
    }
    normalizeRotations() {
        this._sphericalEnd.theta = this._sphericalEnd.theta % er,
        this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += er),
        this._spherical.theta += er * Math.round((this._sphericalEnd.theta - this._spherical.theta) / er)
    }
    stop() {
        this._focalOffset.copy(this._focalOffsetEnd),
        this._target.copy(this._targetEnd),
        this._spherical.copy(this._sphericalEnd),
        this._zoom = this._zoomEnd
    }
    reset(e=!1) {
        if (!ce(this._camera.up.x, this._cameraUp0.x) || !ce(this._camera.up.y, this._cameraUp0.y) || !ce(this._camera.up.z, this._cameraUp0.z)) {
            this._camera.up.copy(this._cameraUp0);
            const r = this.getPosition(Z);
            this.updateCameraUp(),
            this.setPosition(r.x, r.y, r.z)
        }
        const n = [this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, e), this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, e), this.zoomTo(this._zoom0, e)];
        return Promise.all(n)
    }
    saveState() {
        this._cameraUp0.copy(this._camera.up),
        this.getTarget(this._target0),
        this.getPosition(this._position0),
        this._zoom0 = this._zoom,
        this._focalOffset0.copy(this._focalOffset)
    }
    updateCameraUp() {
        this._yAxisUpSpace.setFromUnitVectors(this._camera.up, Gi),
        this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert()
    }
    applyCameraUp() {
        const e = Z.subVectors(this._target, this._camera.position).normalize()
          , n = se.crossVectors(e, this._camera.up);
        this._camera.up.crossVectors(n, e).normalize(),
        this._camera.updateMatrixWorld();
        const r = this.getPosition(Z);
        this.updateCameraUp(),
        this.setPosition(r.x, r.y, r.z)
    }
    update(e) {
        const n = this._sphericalEnd.theta - this._spherical.theta
          , r = this._sphericalEnd.phi - this._spherical.phi
          , i = this._sphericalEnd.radius - this._spherical.radius
          , s = wc.subVectors(this._targetEnd, this._target)
          , o = xc.subVectors(this._focalOffsetEnd, this._focalOffset)
          , a = this._zoomEnd - this._zoom;
        if (me(n))
            this._thetaVelocity.value = 0,
            this._spherical.theta = this._sphericalEnd.theta;
        else {
            const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
            this._spherical.theta = Hi(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, d, 1 / 0, e),
            this._needsUpdate = !0
        }
        if (me(r))
            this._phiVelocity.value = 0,
            this._spherical.phi = this._sphericalEnd.phi;
        else {
            const d = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
            this._spherical.phi = Hi(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, d, 1 / 0, e),
            this._needsUpdate = !0
        }
        if (me(i))
            this._radiusVelocity.value = 0,
            this._spherical.radius = this._sphericalEnd.radius;
        else {
            const d = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
            this._spherical.radius = Hi(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, d, this.maxSpeed, e),
            this._needsUpdate = !0
        }
        if (me(s.x) && me(s.y) && me(s.z))
            this._targetVelocity.set(0, 0, 0),
            this._target.copy(this._targetEnd);
        else {
            const d = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
            _c(this._target, this._targetEnd, this._targetVelocity, d, this.maxSpeed, e, this._target),
            this._needsUpdate = !0
        }
        if (me(o.x) && me(o.y) && me(o.z))
            this._focalOffsetVelocity.set(0, 0, 0),
            this._focalOffset.copy(this._focalOffsetEnd);
        else {
            const d = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
            _c(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, d, this.maxSpeed, e, this._focalOffset),
            this._needsUpdate = !0
        }
        if (me(a))
            this._zoomVelocity.value = 0,
            this._zoom = this._zoomEnd;
        else {
            const d = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
            this._zoom = Hi(this._zoom, this._zoomEnd, this._zoomVelocity, d, 1 / 0, e)
        }
        if (this.dollyToCursor) {
            if (Pn(this._camera) && this._changedDolly !== 0) {
                const d = this._spherical.radius - this._lastDistance
                  , m = this._camera
                  , g = this._getCameraDirection($r)
                  , f = Z.copy(g).cross(m.up).normalize();
                f.lengthSq() === 0 && (f.x = 1);
                const h = se.crossVectors(f, g)
                  , _ = this._sphericalEnd.radius * Math.tan(m.getEffectiveFOV() * Vr * .5)
                  , b = (this._sphericalEnd.radius - d - this._sphericalEnd.radius) / this._sphericalEnd.radius
                  , y = tr.copy(this._targetEnd).add(f.multiplyScalar(this._dollyControlCoord.x * _ * m.aspect)).add(h.multiplyScalar(this._dollyControlCoord.y * _))
                  , w = Z.copy(this._targetEnd).lerp(y, b)
                  , x = this._lastDollyDirection === Jn.IN && this._spherical.radius <= this.minDistance
                  , C = this._lastDollyDirection === Jn.OUT && this.maxDistance <= this._spherical.radius;
                if (this.infinityDolly && (x || C)) {
                    this._sphericalEnd.radius -= d,
                    this._spherical.radius -= d;
                    const T = se.copy(g).multiplyScalar(-d);
                    w.add(T)
                }
                this._boundary.clampPoint(w, w);
                const P = se.subVectors(w, this._targetEnd);
                this._targetEnd.copy(w),
                this._target.add(P),
                this._changedDolly -= d,
                me(this._changedDolly) && (this._changedDolly = 0)
            } else if (dn(this._camera) && this._changedZoom !== 0) {
                const d = this._zoom - this._lastZoom
                  , m = this._camera
                  , g = Z.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (m.near + m.far) / (m.near - m.far)).unproject(m)
                  , f = se.set(0, 0, -1).applyQuaternion(m.quaternion)
                  , h = tr.copy(g).add(f.multiplyScalar(-g.dot(m.up)))
                  , p = -(this._zoom - d - this._zoom) / this._zoom
                  , b = this._getCameraDirection($r)
                  , y = this._targetEnd.dot(b)
                  , w = Z.copy(this._targetEnd).lerp(h, p)
                  , x = w.dot(b)
                  , C = b.multiplyScalar(x - y);
                w.sub(C),
                this._boundary.clampPoint(w, w);
                const P = se.subVectors(w, this._targetEnd);
                this._targetEnd.copy(w),
                this._target.add(P),
                this._changedZoom -= d,
                me(this._changedZoom) && (this._changedZoom = 0)
            }
        }
        this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom,
        this._camera.updateProjectionMatrix(),
        this._updateNearPlaneCorners(),
        this._needsUpdate = !0),
        this._dragNeedsUpdate = !0;
        const l = this._collisionTest();
        this._spherical.radius = Math.min(this._spherical.radius, l),
        this._spherical.makeSafe(),
        this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),
        this._camera.lookAt(this._target),
        (!me(this._focalOffset.x) || !me(this._focalOffset.y) || !me(this._focalOffset.z)) && (this._camera.updateMatrixWorld(),
        Tt.setFromMatrixColumn(this._camera.matrix, 0),
        At.setFromMatrixColumn(this._camera.matrix, 1),
        On.setFromMatrixColumn(this._camera.matrix, 2),
        Tt.multiplyScalar(this._focalOffset.x),
        At.multiplyScalar(-this._focalOffset.y),
        On.multiplyScalar(this._focalOffset.z),
        Z.copy(Tt).add(At).add(On),
        this._camera.position.add(Z)),
        this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), Z.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
        const u = this._needsUpdate;
        return u && !this._updatedLastTime ? (this._hasRested = !1,
        this.dispatchEvent({
            type: "wake"
        }),
        this.dispatchEvent({
            type: "update"
        })) : u ? (this.dispatchEvent({
            type: "update"
        }),
        me(n, this.restThreshold) && me(r, this.restThreshold) && me(i, this.restThreshold) && me(s.x, this.restThreshold) && me(s.y, this.restThreshold) && me(s.z, this.restThreshold) && me(o.x, this.restThreshold) && me(o.y, this.restThreshold) && me(o.z, this.restThreshold) && me(a, this.restThreshold) && !this._hasRested && (this._hasRested = !0,
        this.dispatchEvent({
            type: "rest"
        }))) : !u && this._updatedLastTime && this.dispatchEvent({
            type: "sleep"
        }),
        this._lastDistance = this._spherical.radius,
        this._lastZoom = this._zoom,
        this._updatedLastTime = u,
        this._needsUpdate = !1,
        u
    }
    toJSON() {
        return JSON.stringify({
            enabled: this._enabled,
            minDistance: this.minDistance,
            maxDistance: Dr(this.maxDistance),
            minZoom: this.minZoom,
            maxZoom: Dr(this.maxZoom),
            minPolarAngle: this.minPolarAngle,
            maxPolarAngle: Dr(this.maxPolarAngle),
            minAzimuthAngle: Dr(this.minAzimuthAngle),
            maxAzimuthAngle: Dr(this.maxAzimuthAngle),
            smoothTime: this.smoothTime,
            draggingSmoothTime: this.draggingSmoothTime,
            dollySpeed: this.dollySpeed,
            truckSpeed: this.truckSpeed,
            dollyToCursor: this.dollyToCursor,
            verticalDragToForward: this.verticalDragToForward,
            target: this._targetEnd.toArray(),
            position: Z.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
            zoom: this._zoomEnd,
            focalOffset: this._focalOffsetEnd.toArray(),
            target0: this._target0.toArray(),
            position0: this._position0.toArray(),
            zoom0: this._zoom0,
            focalOffset0: this._focalOffset0.toArray()
        })
    }
    fromJSON(e, n=!1) {
        const r = JSON.parse(e);
        this.enabled = r.enabled,
        this.minDistance = r.minDistance,
        this.maxDistance = Br(r.maxDistance),
        this.minZoom = r.minZoom,
        this.maxZoom = Br(r.maxZoom),
        this.minPolarAngle = r.minPolarAngle,
        this.maxPolarAngle = Br(r.maxPolarAngle),
        this.minAzimuthAngle = Br(r.minAzimuthAngle),
        this.maxAzimuthAngle = Br(r.maxAzimuthAngle),
        this.smoothTime = r.smoothTime,
        this.draggingSmoothTime = r.draggingSmoothTime,
        this.dollySpeed = r.dollySpeed,
        this.truckSpeed = r.truckSpeed,
        this.dollyToCursor = r.dollyToCursor,
        this.verticalDragToForward = r.verticalDragToForward,
        this._target0.fromArray(r.target0),
        this._position0.fromArray(r.position0),
        this._zoom0 = r.zoom0,
        this._focalOffset0.fromArray(r.focalOffset0),
        this.moveTo(r.target[0], r.target[1], r.target[2], n),
        ot.setFromVector3(Z.fromArray(r.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),
        this.rotateTo(ot.theta, ot.phi, n),
        this.dollyTo(ot.radius, n),
        this.zoomTo(r.zoom, n),
        this.setFocalOffset(r.focalOffset[0], r.focalOffset[1], r.focalOffset[2], n),
        this._needsUpdate = !0
    }
    connect(e) {
        if (this._domElement) {
            console.warn("camera-controls is already connected.");
            return
        }
        e.setAttribute("data-camera-controls-version", p0),
        this._addAllEventListeners(e),
        this._getClientRect(this._elementRect)
    }
    disconnect() {
        this.cancel(),
        this._removeAllEventListeners(),
        this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"),
        this._domElement = void 0)
    }
    dispose() {
        this.removeAllEventListeners(),
        this.disconnect()
    }
    _getTargetDirection(e) {
        return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse)
    }
    _getCameraDirection(e) {
        return this._getTargetDirection(e).negate()
    }
    _findPointerById(e) {
        return this._activePointers.find(n => n.pointerId === e)
    }
    _findPointerByMouseButton(e) {
        return this._activePointers.find(n => n.mouseButton === e)
    }
    _disposePointer(e) {
        this._activePointers.splice(this._activePointers.indexOf(e), 1)
    }
    _encloseToBoundary(e, n, r) {
        const i = n.lengthSq();
        if (i === 0)
            return e;
        const s = se.copy(n).add(e)
          , a = this._boundary.clampPoint(s, tr).sub(s)
          , l = a.lengthSq();
        if (l === 0)
            return e.add(n);
        if (l === i)
            return e;
        if (r === 0)
            return e.add(n).add(a);
        {
            const c = 1 + r * l / n.dot(a);
            return e.add(se.copy(n).multiplyScalar(c)).add(a.multiplyScalar(1 - r))
        }
    }
    _updateNearPlaneCorners() {
        if (Pn(this._camera)) {
            const e = this._camera
              , n = e.near
              , r = e.getEffectiveFOV() * Vr
              , i = Math.tan(r * .5) * n
              , s = i * e.aspect;
            this._nearPlaneCorners[0].set(-s, -i, 0),
            this._nearPlaneCorners[1].set(s, -i, 0),
            this._nearPlaneCorners[2].set(s, i, 0),
            this._nearPlaneCorners[3].set(-s, i, 0)
        } else if (dn(this._camera)) {
            const e = this._camera
              , n = 1 / e.zoom
              , r = e.left * n
              , i = e.right * n
              , s = e.top * n
              , o = e.bottom * n;
            this._nearPlaneCorners[0].set(r, s, 0),
            this._nearPlaneCorners[1].set(i, s, 0),
            this._nearPlaneCorners[2].set(i, o, 0),
            this._nearPlaneCorners[3].set(r, o, 0)
        }
    }
    _collisionTest() {
        let e = 1 / 0;
        if (!(this.colliderMeshes.length >= 1) || bo(this._camera, "_collisionTest"))
            return e;
        const r = this._getTargetDirection($r);
        Co.lookAt(yc, r, this._camera.up);
        for (let i = 0; i < 4; i++) {
            const s = se.copy(this._nearPlaneCorners[i]);
            s.applyMatrix4(Co);
            const o = tr.addVectors(this._target, s);
            qi.set(o, r),
            qi.far = this._spherical.radius + 1;
            const a = qi.intersectObjects(this.colliderMeshes);
            a.length !== 0 && a[0].distance < e && (e = a[0].distance)
        }
        return e
    }
    _getClientRect(e) {
        if (!this._domElement)
            return;
        const n = this._domElement.getBoundingClientRect();
        return e.x = n.left,
        e.y = n.top,
        this._viewport ? (e.x += this._viewport.x,
        e.y += n.height - this._viewport.w - this._viewport.y,
        e.width = this._viewport.z,
        e.height = this._viewport.w) : (e.width = n.width,
        e.height = n.height),
        e
    }
    _createOnRestPromise(e) {
        return e ? Promise.resolve() : (this._hasRested = !1,
        this.dispatchEvent({
            type: "transitionstart"
        }),
        new Promise(n => {
            const r = () => {
                this.removeEventListener("rest", r),
                n()
            }
            ;
            this.addEventListener("rest", r)
        }
        ))
    }
    _addAllEventListeners(e) {}
    _removeAllEventListeners() {}
    get dampingFactor() {
        return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."),
        0
    }
    set dampingFactor(e) {
        console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.")
    }
    get draggingDampingFactor() {
        return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."),
        0
    }
    set draggingDampingFactor(e) {
        console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.")
    }
    static createBoundingSphere(e, n=new q.Sphere) {
        const r = n
          , i = r.center;
        nr.makeEmpty(),
        e.traverseVisible(o => {
            o.isMesh && nr.expandByObject(o)
        }
        ),
        nr.getCenter(i);
        let s = 0;
        return e.traverseVisible(o => {
            if (!o.isMesh)
                return;
            const a = o
              , l = a.geometry.clone();
            l.applyMatrix4(a.matrixWorld);
            const u = l.attributes.position;
            for (let d = 0, m = u.count; d < m; d++)
                Z.fromBufferAttribute(u, d),
                s = Math.max(s, i.distanceToSquared(Z))
        }
        ),
        r.radius = Math.sqrt(s),
        r
    }
}
const f0 = Object.freeze(Object.defineProperty({
    __proto__: null,
    EventDispatcher: Ap,
    default: pr
}, Symbol.toStringTag, {
    value: "Module"
}));
new vd;
const Pc = {
    vector2Fixed(t=new vs, e=1) {
        return t.set(+t.x.toFixed(e), +t.y.toFixed(e)),
        t
    },
    vector3Fixed(t=new Se, e=1) {
        return t.set(+t.x.toFixed(e), +t.y.toFixed(e), +t.z.toFixed(e)),
        t
    },
    eulerFixed(t=new Rf, e=1) {
        return t.set(+t.x.toFixed(e), +t.y.toFixed(e), +t.z.toFixed(e), t.order),
        t
    },
    quaternionFixed(t=new If, e=1) {
        return t.set(+t.x.toFixed(e), +t.y.toFixed(e), +t.z.toFixed(e), +t.w.toFixed(e)),
        t
    }
};
function Sp(t, e, n, r=!1) {
    for (const i in e) {
        if (i.indexOf(n) !== 0)
            continue;
        const s = i.replace(n, "").split("/");
        if (s.length > 1) {
            const o = s[0];
            t[o] || (t[o] = {}),
            Sp(t[o], e, n + o + "/")
        } else if (s.length === 1) {
            let o = s[0];
            r || (o = o.substring(0, o.lastIndexOf(".")));
            const a = e[i].default;
            a.indexOf("http") === 0 ? t[o] = a.replace(/.+\/assets\//, "./assets/") : t[o] = e[i].default
        }
    }
}
const zt = (t, e, {checkForDefaultPrevented: n=!0}={}) => i => {
    const s = t == null ? void 0 : t(i);
    if (n === !1 || !s)
        return e == null ? void 0 : e(i)
}
;
var Oc;
const He = typeof window < "u"
  , m0 = t => typeof t == "string"
  , Ps = () => {}
  , v0 = He && ((Oc = window == null ? void 0 : window.navigator) == null ? void 0 : Oc.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function Os(t) {
    return typeof t == "function" ? t() : v(t)
}
function g0(t, e) {
    function n(...r) {
        return new Promise( (i, s) => {
            Promise.resolve(t( () => e.apply(this, r), {
                fn: e,
                thisArg: this,
                args: r
            })).then(i).catch(s)
        }
        )
    }
    return n
}
function b0(t, e={}) {
    let n, r, i = Ps;
    const s = a => {
        clearTimeout(a),
        i(),
        i = Ps
    }
    ;
    return a => {
        const l = Os(t)
          , c = Os(e.maxWait);
        return n && s(n),
        l <= 0 || c !== void 0 && c <= 0 ? (r && (s(r),
        r = null),
        Promise.resolve(a())) : new Promise( (u, d) => {
            i = e.rejectOnCancel ? d : u,
            c && !r && (r = setTimeout( () => {
                n && s(n),
                r = null,
                u(a())
            }
            , c)),
            n = setTimeout( () => {
                r && s(r),
                r = null,
                u(a())
            }
            , l)
        }
        )
    }
}
function _0(t) {
    return t
}
function Ka(t) {
    return Vf() ? (Df(t),
    !0) : !1
}
function y0(t, e=200, n={}) {
    return g0(b0(e, n), t)
}
function w0(t, e=200, n={}) {
    const r = M(t.value)
      , i = y0( () => {
        r.value = t.value
    }
    , e, n);
    return W(t, () => i()),
    r
}
function x0(t, e=!0) {
    Ve() ? De(t) : e ? t() : ke(t)
}
function mn(t) {
    var e;
    const n = Os(t);
    return (e = n == null ? void 0 : n.$el) != null ? e : n
}
const Ga = He ? window : void 0;
function lr(...t) {
    let e, n, r, i;
    if (m0(t[0]) || Array.isArray(t[0]) ? ([n,r,i] = t,
    e = Ga) : [e,n,r,i] = t,
    !e)
        return Ps;
    Array.isArray(n) || (n = [n]),
    Array.isArray(r) || (r = [r]);
    const s = []
      , o = () => {
        s.forEach(u => u()),
        s.length = 0
    }
      , a = (u, d, m, g) => (u.addEventListener(d, m, g),
    () => u.removeEventListener(d, m, g))
      , l = W( () => [mn(e), Os(i)], ([u,d]) => {
        o(),
        u && s.push(...n.flatMap(m => r.map(g => a(u, m, g, d))))
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , c = () => {
        l(),
        o()
    }
    ;
    return Ka(c),
    c
}
let Tc = !1;
function C0(t, e, n={}) {
    const {window: r=Ga, ignore: i=[], capture: s=!0, detectIframe: o=!1} = n;
    if (!r)
        return;
    v0 && !Tc && (Tc = !0,
    Array.from(r.document.body.children).forEach(m => m.addEventListener("click", Ps)));
    let a = !0;
    const l = m => i.some(g => {
        if (typeof g == "string")
            return Array.from(r.document.querySelectorAll(g)).some(f => f === m.target || m.composedPath().includes(f));
        {
            const f = mn(g);
            return f && (m.target === f || m.composedPath().includes(f))
        }
    }
    )
      , u = [lr(r, "click", m => {
        const g = mn(t);
        if (!(!g || g === m.target || m.composedPath().includes(g))) {
            if (m.detail === 0 && (a = !l(m)),
            !a) {
                a = !0;
                return
            }
            e(m)
        }
    }
    , {
        passive: !0,
        capture: s
    }), lr(r, "pointerdown", m => {
        const g = mn(t);
        g && (a = !m.composedPath().includes(g) && !l(m))
    }
    , {
        passive: !0
    }), o && lr(r, "blur", m => {
        var g;
        const f = mn(t);
        ((g = r.document.activeElement) == null ? void 0 : g.tagName) === "IFRAME" && !(f != null && f.contains(r.document.activeElement)) && e(m)
    }
    )].filter(Boolean);
    return () => u.forEach(m => m())
}
function E0(t, e=!1) {
    const n = M()
      , r = () => n.value = !!t();
    return r(),
    x0(r, e),
    n
}
const Ac = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , Sc = "__vueuse_ssr_handlers__";
Ac[Sc] = Ac[Sc] || {};
var kc = Object.getOwnPropertySymbols
  , P0 = Object.prototype.hasOwnProperty
  , O0 = Object.prototype.propertyIsEnumerable
  , T0 = (t, e) => {
    var n = {};
    for (var r in t)
        P0.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && kc)
        for (var r of kc(t))
            e.indexOf(r) < 0 && O0.call(t, r) && (n[r] = t[r]);
    return n
}
;
function kp(t, e, n={}) {
    const r = n
      , {window: i=Ga} = r
      , s = T0(r, ["window"]);
    let o;
    const a = E0( () => i && "ResizeObserver"in i)
      , l = () => {
        o && (o.disconnect(),
        o = void 0)
    }
      , c = W( () => mn(t), d => {
        l(),
        a.value && i && d && (o = new ResizeObserver(e),
        o.observe(d, s))
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , u = () => {
        l(),
        c()
    }
    ;
    return Ka(u),
    {
        isSupported: a,
        stop: u
    }
}
var Mc;
(function(t) {
    t.UP = "UP",
    t.RIGHT = "RIGHT",
    t.DOWN = "DOWN",
    t.LEFT = "LEFT",
    t.NONE = "NONE"
}
)(Mc || (Mc = {}));
var A0 = Object.defineProperty
  , Lc = Object.getOwnPropertySymbols
  , S0 = Object.prototype.hasOwnProperty
  , k0 = Object.prototype.propertyIsEnumerable
  , Fc = (t, e, n) => e in t ? A0(t, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: n
}) : t[e] = n
  , M0 = (t, e) => {
    for (var n in e || (e = {}))
        S0.call(e, n) && Fc(t, n, e[n]);
    if (Lc)
        for (var n of Lc(e))
            k0.call(e, n) && Fc(t, n, e[n]);
    return t
}
;
const L0 = {
    easeInSine: [.12, 0, .39, 0],
    easeOutSine: [.61, 1, .88, 1],
    easeInOutSine: [.37, 0, .63, 1],
    easeInQuad: [.11, 0, .5, 0],
    easeOutQuad: [.5, 1, .89, 1],
    easeInOutQuad: [.45, 0, .55, 1],
    easeInCubic: [.32, 0, .67, 0],
    easeOutCubic: [.33, 1, .68, 1],
    easeInOutCubic: [.65, 0, .35, 1],
    easeInQuart: [.5, 0, .75, 0],
    easeOutQuart: [.25, 1, .5, 1],
    easeInOutQuart: [.76, 0, .24, 1],
    easeInQuint: [.64, 0, .78, 0],
    easeOutQuint: [.22, 1, .36, 1],
    easeInOutQuint: [.83, 0, .17, 1],
    easeInExpo: [.7, 0, .84, 0],
    easeOutExpo: [.16, 1, .3, 1],
    easeInOutExpo: [.87, 0, .13, 1],
    easeInCirc: [.55, 0, 1, .45],
    easeOutCirc: [0, .55, .45, 1],
    easeInOutCirc: [.85, 0, .15, 1],
    easeInBack: [.36, 0, .66, -.56],
    easeOutBack: [.34, 1.56, .64, 1],
    easeInOutBack: [.68, -.6, .32, 1.6]
};
M0({
    linear: _0
}, L0);
const F0 = () => He && /firefox/i.test(window.navigator.userAgent)
  , qa = t => {
    let e, n;
    return t.type === "touchend" ? (n = t.changedTouches[0].clientY,
    e = t.changedTouches[0].clientX) : t.type.startsWith("touch") ? (n = t.touches[0].clientY,
    e = t.touches[0].clientX) : (n = t.clientY,
    e = t.clientX),
    {
        clientX: e,
        clientY: n
    }
}
;
var Mp = typeof global == "object" && global && global.Object === Object && global
  , R0 = typeof self == "object" && self && self.Object === Object && self
  , Et = Mp || R0 || Function("return this")()
  , dt = Et.Symbol
  , Lp = Object.prototype
  , I0 = Lp.hasOwnProperty
  , V0 = Lp.toString
  , jr = dt ? dt.toStringTag : void 0;
function D0(t) {
    var e = I0.call(t, jr)
      , n = t[jr];
    try {
        t[jr] = void 0;
        var r = !0
    } catch {}
    var i = V0.call(t);
    return r && (e ? t[jr] = n : delete t[jr]),
    i
}
var B0 = Object.prototype
  , $0 = B0.toString;
function U0(t) {
    return $0.call(t)
}
var j0 = "[object Null]"
  , N0 = "[object Undefined]"
  , Rc = dt ? dt.toStringTag : void 0;
function Cr(t) {
    return t == null ? t === void 0 ? N0 : j0 : Rc && Rc in Object(t) ? D0(t) : U0(t)
}
function wn(t) {
    return t != null && typeof t == "object"
}
var z0 = "[object Symbol]";
function Gs(t) {
    return typeof t == "symbol" || wn(t) && Cr(t) == z0
}
function H0(t, e) {
    for (var n = -1, r = t == null ? 0 : t.length, i = Array(r); ++n < r; )
        i[n] = e(t[n], n, t);
    return i
}
var Ct = Array.isArray
  , K0 = 1 / 0
  , Ic = dt ? dt.prototype : void 0
  , Vc = Ic ? Ic.toString : void 0;
function Fp(t) {
    if (typeof t == "string")
        return t;
    if (Ct(t))
        return H0(t, Fp) + "";
    if (Gs(t))
        return Vc ? Vc.call(t) : "";
    var e = t + "";
    return e == "0" && 1 / t == -K0 ? "-0" : e
}
var G0 = /\s/;
function q0(t) {
    for (var e = t.length; e-- && G0.test(t.charAt(e)); )
        ;
    return e
}
var W0 = /^\s+/;
function Y0(t) {
    return t && t.slice(0, q0(t) + 1).replace(W0, "")
}
function It(t) {
    var e = typeof t;
    return t != null && (e == "object" || e == "function")
}
var Dc = NaN
  , Z0 = /^[-+]0x[0-9a-f]+$/i
  , X0 = /^0b[01]+$/i
  , Q0 = /^0o[0-7]+$/i
  , J0 = parseInt;
function Bc(t) {
    if (typeof t == "number")
        return t;
    if (Gs(t))
        return Dc;
    if (It(t)) {
        var e = typeof t.valueOf == "function" ? t.valueOf() : t;
        t = It(e) ? e + "" : e
    }
    if (typeof t != "string")
        return t === 0 ? t : +t;
    t = Y0(t);
    var n = X0.test(t);
    return n || Q0.test(t) ? J0(t.slice(2), n ? 2 : 8) : Z0.test(t) ? Dc : +t
}
function ey(t) {
    return t
}
var ty = "[object AsyncFunction]"
  , ny = "[object Function]"
  , ry = "[object GeneratorFunction]"
  , iy = "[object Proxy]";
function Rp(t) {
    if (!It(t))
        return !1;
    var e = Cr(t);
    return e == ny || e == ry || e == ty || e == iy
}
var Eo = Et["__core-js_shared__"]
  , $c = function() {
    var t = /[^.]+$/.exec(Eo && Eo.keys && Eo.keys.IE_PROTO || "");
    return t ? "Symbol(src)_1." + t : ""
}();
function sy(t) {
    return !!$c && $c in t
}
var oy = Function.prototype
  , ay = oy.toString;
function qn(t) {
    if (t != null) {
        try {
            return ay.call(t)
        } catch {}
        try {
            return t + ""
        } catch {}
    }
    return ""
}
var ly = /[\\^$.*+?()[\]{}|]/g
  , cy = /^\[object .+?Constructor\]$/
  , uy = Function.prototype
  , dy = Object.prototype
  , py = uy.toString
  , hy = dy.hasOwnProperty
  , fy = RegExp("^" + py.call(hy).replace(ly, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function my(t) {
    if (!It(t) || sy(t))
        return !1;
    var e = Rp(t) ? fy : cy;
    return e.test(qn(t))
}
function vy(t, e) {
    return t == null ? void 0 : t[e]
}
function Wn(t, e) {
    var n = vy(t, e);
    return my(n) ? n : void 0
}
var Ko = Wn(Et, "WeakMap")
  , Uc = Object.create
  , gy = function() {
    function t() {}
    return function(e) {
        if (!It(e))
            return {};
        if (Uc)
            return Uc(e);
        t.prototype = e;
        var n = new t;
        return t.prototype = void 0,
        n
    }
}();
function by(t, e, n) {
    switch (n.length) {
    case 0:
        return t.call(e);
    case 1:
        return t.call(e, n[0]);
    case 2:
        return t.call(e, n[0], n[1]);
    case 3:
        return t.call(e, n[0], n[1], n[2])
    }
    return t.apply(e, n)
}
function _y(t, e) {
    var n = -1
      , r = t.length;
    for (e || (e = Array(r)); ++n < r; )
        e[n] = t[n];
    return e
}
var yy = 800
  , wy = 16
  , xy = Date.now;
function Cy(t) {
    var e = 0
      , n = 0;
    return function() {
        var r = xy()
          , i = wy - (r - n);
        if (n = r,
        i > 0) {
            if (++e >= yy)
                return arguments[0]
        } else
            e = 0;
        return t.apply(void 0, arguments)
    }
}
function Ey(t) {
    return function() {
        return t
    }
}
var Ts = function() {
    try {
        var t = Wn(Object, "defineProperty");
        return t({}, "", {}),
        t
    } catch {}
}()
  , Py = Ts ? function(t, e) {
    return Ts(t, "toString", {
        configurable: !0,
        enumerable: !1,
        value: Ey(e),
        writable: !0
    })
}
: ey
  , Oy = Cy(Py);
function Ty(t, e) {
    for (var n = -1, r = t == null ? 0 : t.length; ++n < r && e(t[n], n, t) !== !1; )
        ;
    return t
}
var Ay = 9007199254740991
  , Sy = /^(?:0|[1-9]\d*)$/;
function Wa(t, e) {
    var n = typeof t;
    return e = e ?? Ay,
    !!e && (n == "number" || n != "symbol" && Sy.test(t)) && t > -1 && t % 1 == 0 && t < e
}
function Ip(t, e, n) {
    e == "__proto__" && Ts ? Ts(t, e, {
        configurable: !0,
        enumerable: !0,
        value: n,
        writable: !0
    }) : t[e] = n
}
function Ya(t, e) {
    return t === e || t !== t && e !== e
}
var ky = Object.prototype
  , My = ky.hasOwnProperty;
function Za(t, e, n) {
    var r = t[e];
    (!(My.call(t, e) && Ya(r, n)) || n === void 0 && !(e in t)) && Ip(t, e, n)
}
function qs(t, e, n, r) {
    var i = !n;
    n || (n = {});
    for (var s = -1, o = e.length; ++s < o; ) {
        var a = e[s]
          , l = void 0;
        l === void 0 && (l = t[a]),
        i ? Ip(n, a, l) : Za(n, a, l)
    }
    return n
}
var jc = Math.max;
function Ly(t, e, n) {
    return e = jc(e === void 0 ? t.length - 1 : e, 0),
    function() {
        for (var r = arguments, i = -1, s = jc(r.length - e, 0), o = Array(s); ++i < s; )
            o[i] = r[e + i];
        i = -1;
        for (var a = Array(e + 1); ++i < e; )
            a[i] = r[i];
        return a[e] = n(o),
        by(t, this, a)
    }
}
var Fy = 9007199254740991;
function Xa(t) {
    return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Fy
}
function Vp(t) {
    return t != null && Xa(t.length) && !Rp(t)
}
var Ry = Object.prototype;
function Qa(t) {
    var e = t && t.constructor
      , n = typeof e == "function" && e.prototype || Ry;
    return t === n
}
function Iy(t, e) {
    for (var n = -1, r = Array(t); ++n < t; )
        r[n] = e(n);
    return r
}
var Vy = "[object Arguments]";
function Nc(t) {
    return wn(t) && Cr(t) == Vy
}
var Dp = Object.prototype
  , Dy = Dp.hasOwnProperty
  , By = Dp.propertyIsEnumerable
  , Ja = Nc(function() {
    return arguments
}()) ? Nc : function(t) {
    return wn(t) && Dy.call(t, "callee") && !By.call(t, "callee")
}
;
function $y() {
    return !1
}
var Bp = typeof exports == "object" && exports && !exports.nodeType && exports
  , zc = Bp && typeof module == "object" && module && !module.nodeType && module
  , Uy = zc && zc.exports === Bp
  , Hc = Uy ? Et.Buffer : void 0
  , jy = Hc ? Hc.isBuffer : void 0
  , As = jy || $y
  , Ny = "[object Arguments]"
  , zy = "[object Array]"
  , Hy = "[object Boolean]"
  , Ky = "[object Date]"
  , Gy = "[object Error]"
  , qy = "[object Function]"
  , Wy = "[object Map]"
  , Yy = "[object Number]"
  , Zy = "[object Object]"
  , Xy = "[object RegExp]"
  , Qy = "[object Set]"
  , Jy = "[object String]"
  , ew = "[object WeakMap]"
  , tw = "[object ArrayBuffer]"
  , nw = "[object DataView]"
  , rw = "[object Float32Array]"
  , iw = "[object Float64Array]"
  , sw = "[object Int8Array]"
  , ow = "[object Int16Array]"
  , aw = "[object Int32Array]"
  , lw = "[object Uint8Array]"
  , cw = "[object Uint8ClampedArray]"
  , uw = "[object Uint16Array]"
  , dw = "[object Uint32Array]"
  , be = {};
be[rw] = be[iw] = be[sw] = be[ow] = be[aw] = be[lw] = be[cw] = be[uw] = be[dw] = !0;
be[Ny] = be[zy] = be[tw] = be[Hy] = be[nw] = be[Ky] = be[Gy] = be[qy] = be[Wy] = be[Yy] = be[Zy] = be[Xy] = be[Qy] = be[Jy] = be[ew] = !1;
function pw(t) {
    return wn(t) && Xa(t.length) && !!be[Cr(t)]
}
function el(t) {
    return function(e) {
        return t(e)
    }
}
var $p = typeof exports == "object" && exports && !exports.nodeType && exports
  , Zr = $p && typeof module == "object" && module && !module.nodeType && module
  , hw = Zr && Zr.exports === $p
  , Po = hw && Mp.process
  , hr = function() {
    try {
        var t = Zr && Zr.require && Zr.require("util").types;
        return t || Po && Po.binding && Po.binding("util")
    } catch {}
}()
  , Kc = hr && hr.isTypedArray
  , Up = Kc ? el(Kc) : pw
  , fw = Object.prototype
  , mw = fw.hasOwnProperty;
function jp(t, e) {
    var n = Ct(t)
      , r = !n && Ja(t)
      , i = !n && !r && As(t)
      , s = !n && !r && !i && Up(t)
      , o = n || r || i || s
      , a = o ? Iy(t.length, String) : []
      , l = a.length;
    for (var c in t)
        (e || mw.call(t, c)) && !(o && (c == "length" || i && (c == "offset" || c == "parent") || s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || Wa(c, l))) && a.push(c);
    return a
}
function Np(t, e) {
    return function(n) {
        return t(e(n))
    }
}
var vw = Np(Object.keys, Object)
  , gw = Object.prototype
  , bw = gw.hasOwnProperty;
function _w(t) {
    if (!Qa(t))
        return vw(t);
    var e = [];
    for (var n in Object(t))
        bw.call(t, n) && n != "constructor" && e.push(n);
    return e
}
function tl(t) {
    return Vp(t) ? jp(t) : _w(t)
}
function yw(t) {
    var e = [];
    if (t != null)
        for (var n in Object(t))
            e.push(n);
    return e
}
var ww = Object.prototype
  , xw = ww.hasOwnProperty;
function Cw(t) {
    if (!It(t))
        return yw(t);
    var e = Qa(t)
      , n = [];
    for (var r in t)
        r == "constructor" && (e || !xw.call(t, r)) || n.push(r);
    return n
}
function nl(t) {
    return Vp(t) ? jp(t, !0) : Cw(t)
}
var Ew = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
  , Pw = /^\w*$/;
function Ow(t, e) {
    if (Ct(t))
        return !1;
    var n = typeof t;
    return n == "number" || n == "symbol" || n == "boolean" || t == null || Gs(t) ? !0 : Pw.test(t) || !Ew.test(t) || e != null && t in Object(e)
}
var ci = Wn(Object, "create");
function Tw() {
    this.__data__ = ci ? ci(null) : {},
    this.size = 0
}
function Aw(t) {
    var e = this.has(t) && delete this.__data__[t];
    return this.size -= e ? 1 : 0,
    e
}
var Sw = "__lodash_hash_undefined__"
  , kw = Object.prototype
  , Mw = kw.hasOwnProperty;
function Lw(t) {
    var e = this.__data__;
    if (ci) {
        var n = e[t];
        return n === Sw ? void 0 : n
    }
    return Mw.call(e, t) ? e[t] : void 0
}
var Fw = Object.prototype
  , Rw = Fw.hasOwnProperty;
function Iw(t) {
    var e = this.__data__;
    return ci ? e[t] !== void 0 : Rw.call(e, t)
}
var Vw = "__lodash_hash_undefined__";
function Dw(t, e) {
    var n = this.__data__;
    return this.size += this.has(t) ? 0 : 1,
    n[t] = ci && e === void 0 ? Vw : e,
    this
}
function jn(t) {
    var e = -1
      , n = t == null ? 0 : t.length;
    for (this.clear(); ++e < n; ) {
        var r = t[e];
        this.set(r[0], r[1])
    }
}
jn.prototype.clear = Tw;
jn.prototype.delete = Aw;
jn.prototype.get = Lw;
jn.prototype.has = Iw;
jn.prototype.set = Dw;
function Bw() {
    this.__data__ = [],
    this.size = 0
}
function Ws(t, e) {
    for (var n = t.length; n--; )
        if (Ya(t[n][0], e))
            return n;
    return -1
}
var $w = Array.prototype
  , Uw = $w.splice;
function jw(t) {
    var e = this.__data__
      , n = Ws(e, t);
    if (n < 0)
        return !1;
    var r = e.length - 1;
    return n == r ? e.pop() : Uw.call(e, n, 1),
    --this.size,
    !0
}
function Nw(t) {
    var e = this.__data__
      , n = Ws(e, t);
    return n < 0 ? void 0 : e[n][1]
}
function zw(t) {
    return Ws(this.__data__, t) > -1
}
function Hw(t, e) {
    var n = this.__data__
      , r = Ws(n, t);
    return r < 0 ? (++this.size,
    n.push([t, e])) : n[r][1] = e,
    this
}
function nn(t) {
    var e = -1
      , n = t == null ? 0 : t.length;
    for (this.clear(); ++e < n; ) {
        var r = t[e];
        this.set(r[0], r[1])
    }
}
nn.prototype.clear = Bw;
nn.prototype.delete = jw;
nn.prototype.get = Nw;
nn.prototype.has = zw;
nn.prototype.set = Hw;
var ui = Wn(Et, "Map");
function Kw() {
    this.size = 0,
    this.__data__ = {
        hash: new jn,
        map: new (ui || nn),
        string: new jn
    }
}
function Gw(t) {
    var e = typeof t;
    return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null
}
function Ys(t, e) {
    var n = t.__data__;
    return Gw(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map
}
function qw(t) {
    var e = Ys(this, t).delete(t);
    return this.size -= e ? 1 : 0,
    e
}
function Ww(t) {
    return Ys(this, t).get(t)
}
function Yw(t) {
    return Ys(this, t).has(t)
}
function Zw(t, e) {
    var n = Ys(this, t)
      , r = n.size;
    return n.set(t, e),
    this.size += n.size == r ? 0 : 1,
    this
}
function rn(t) {
    var e = -1
      , n = t == null ? 0 : t.length;
    for (this.clear(); ++e < n; ) {
        var r = t[e];
        this.set(r[0], r[1])
    }
}
rn.prototype.clear = Kw;
rn.prototype.delete = qw;
rn.prototype.get = Ww;
rn.prototype.has = Yw;
rn.prototype.set = Zw;
var Xw = "Expected a function";
function rl(t, e) {
    if (typeof t != "function" || e != null && typeof e != "function")
        throw new TypeError(Xw);
    var n = function() {
        var r = arguments
          , i = e ? e.apply(this, r) : r[0]
          , s = n.cache;
        if (s.has(i))
            return s.get(i);
        var o = t.apply(this, r);
        return n.cache = s.set(i, o) || s,
        o
    };
    return n.cache = new (rl.Cache || rn),
    n
}
rl.Cache = rn;
var Qw = 500;
function Jw(t) {
    var e = rl(t, function(r) {
        return n.size === Qw && n.clear(),
        r
    })
      , n = e.cache;
    return e
}
var e1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
  , t1 = /\\(\\)?/g
  , n1 = Jw(function(t) {
    var e = [];
    return t.charCodeAt(0) === 46 && e.push(""),
    t.replace(e1, function(n, r, i, s) {
        e.push(i ? s.replace(t1, "$1") : r || n)
    }),
    e
});
function r1(t) {
    return t == null ? "" : Fp(t)
}
function Zs(t, e) {
    return Ct(t) ? t : Ow(t, e) ? [t] : n1(r1(t))
}
var i1 = 1 / 0;
function il(t) {
    if (typeof t == "string" || Gs(t))
        return t;
    var e = t + "";
    return e == "0" && 1 / t == -i1 ? "-0" : e
}
function zp(t, e) {
    e = Zs(e, t);
    for (var n = 0, r = e.length; t != null && n < r; )
        t = t[il(e[n++])];
    return n && n == r ? t : void 0
}
function Hp(t, e, n) {
    var r = t == null ? void 0 : zp(t, e);
    return r === void 0 ? n : r
}
function sl(t, e) {
    for (var n = -1, r = e.length, i = t.length; ++n < r; )
        t[i + n] = e[n];
    return t
}
var Gc = dt ? dt.isConcatSpreadable : void 0;
function s1(t) {
    return Ct(t) || Ja(t) || !!(Gc && t && t[Gc])
}
function o1(t, e, n, r, i) {
    var s = -1
      , o = t.length;
    for (n || (n = s1),
    i || (i = []); ++s < o; ) {
        var a = t[s];
        n(a) ? sl(i, a) : i[i.length] = a
    }
    return i
}
function a1(t) {
    var e = t == null ? 0 : t.length;
    return e ? o1(t) : []
}
function l1(t) {
    return Oy(Ly(t, void 0, a1), t + "")
}
var Kp = Np(Object.getPrototypeOf, Object);
function Go() {
    if (!arguments.length)
        return [];
    var t = arguments[0];
    return Ct(t) ? t : [t]
}
function c1() {
    this.__data__ = new nn,
    this.size = 0
}
function u1(t) {
    var e = this.__data__
      , n = e.delete(t);
    return this.size = e.size,
    n
}
function d1(t) {
    return this.__data__.get(t)
}
function p1(t) {
    return this.__data__.has(t)
}
var h1 = 200;
function f1(t, e) {
    var n = this.__data__;
    if (n instanceof nn) {
        var r = n.__data__;
        if (!ui || r.length < h1 - 1)
            return r.push([t, e]),
            this.size = ++n.size,
            this;
        n = this.__data__ = new rn(r)
    }
    return n.set(t, e),
    this.size = n.size,
    this
}
function Zt(t) {
    var e = this.__data__ = new nn(t);
    this.size = e.size
}
Zt.prototype.clear = c1;
Zt.prototype.delete = u1;
Zt.prototype.get = d1;
Zt.prototype.has = p1;
Zt.prototype.set = f1;
function m1(t, e) {
    return t && qs(e, tl(e), t)
}
function v1(t, e) {
    return t && qs(e, nl(e), t)
}
var Gp = typeof exports == "object" && exports && !exports.nodeType && exports
  , qc = Gp && typeof module == "object" && module && !module.nodeType && module
  , g1 = qc && qc.exports === Gp
  , Wc = g1 ? Et.Buffer : void 0
  , Yc = Wc ? Wc.allocUnsafe : void 0;
function b1(t, e) {
    if (e)
        return t.slice();
    var n = t.length
      , r = Yc ? Yc(n) : new t.constructor(n);
    return t.copy(r),
    r
}
function _1(t, e) {
    for (var n = -1, r = t == null ? 0 : t.length, i = 0, s = []; ++n < r; ) {
        var o = t[n];
        e(o, n, t) && (s[i++] = o)
    }
    return s
}
function qp() {
    return []
}
var y1 = Object.prototype
  , w1 = y1.propertyIsEnumerable
  , Zc = Object.getOwnPropertySymbols
  , ol = Zc ? function(t) {
    return t == null ? [] : (t = Object(t),
    _1(Zc(t), function(e) {
        return w1.call(t, e)
    }))
}
: qp;
function x1(t, e) {
    return qs(t, ol(t), e)
}
var C1 = Object.getOwnPropertySymbols
  , Wp = C1 ? function(t) {
    for (var e = []; t; )
        sl(e, ol(t)),
        t = Kp(t);
    return e
}
: qp;
function E1(t, e) {
    return qs(t, Wp(t), e)
}
function Yp(t, e, n) {
    var r = e(t);
    return Ct(t) ? r : sl(r, n(t))
}
function qo(t) {
    return Yp(t, tl, ol)
}
function P1(t) {
    return Yp(t, nl, Wp)
}
var Wo = Wn(Et, "DataView")
  , Yo = Wn(Et, "Promise")
  , Zo = Wn(Et, "Set")
  , Xc = "[object Map]"
  , O1 = "[object Object]"
  , Qc = "[object Promise]"
  , Jc = "[object Set]"
  , eu = "[object WeakMap]"
  , tu = "[object DataView]"
  , T1 = qn(Wo)
  , A1 = qn(ui)
  , S1 = qn(Yo)
  , k1 = qn(Zo)
  , M1 = qn(Ko)
  , _t = Cr;
(Wo && _t(new Wo(new ArrayBuffer(1))) != tu || ui && _t(new ui) != Xc || Yo && _t(Yo.resolve()) != Qc || Zo && _t(new Zo) != Jc || Ko && _t(new Ko) != eu) && (_t = function(t) {
    var e = Cr(t)
      , n = e == O1 ? t.constructor : void 0
      , r = n ? qn(n) : "";
    if (r)
        switch (r) {
        case T1:
            return tu;
        case A1:
            return Xc;
        case S1:
            return Qc;
        case k1:
            return Jc;
        case M1:
            return eu
        }
    return e
}
);
var L1 = Object.prototype
  , F1 = L1.hasOwnProperty;
function R1(t) {
    var e = t.length
      , n = new t.constructor(e);
    return e && typeof t[0] == "string" && F1.call(t, "index") && (n.index = t.index,
    n.input = t.input),
    n
}
var Ss = Et.Uint8Array;
function al(t) {
    var e = new t.constructor(t.byteLength);
    return new Ss(e).set(new Ss(t)),
    e
}
function I1(t, e) {
    var n = e ? al(t.buffer) : t.buffer;
    return new t.constructor(n,t.byteOffset,t.byteLength)
}
var V1 = /\w*$/;
function D1(t) {
    var e = new t.constructor(t.source,V1.exec(t));
    return e.lastIndex = t.lastIndex,
    e
}
var nu = dt ? dt.prototype : void 0
  , ru = nu ? nu.valueOf : void 0;
function B1(t) {
    return ru ? Object(ru.call(t)) : {}
}
function $1(t, e) {
    var n = e ? al(t.buffer) : t.buffer;
    return new t.constructor(n,t.byteOffset,t.length)
}
var U1 = "[object Boolean]"
  , j1 = "[object Date]"
  , N1 = "[object Map]"
  , z1 = "[object Number]"
  , H1 = "[object RegExp]"
  , K1 = "[object Set]"
  , G1 = "[object String]"
  , q1 = "[object Symbol]"
  , W1 = "[object ArrayBuffer]"
  , Y1 = "[object DataView]"
  , Z1 = "[object Float32Array]"
  , X1 = "[object Float64Array]"
  , Q1 = "[object Int8Array]"
  , J1 = "[object Int16Array]"
  , ex = "[object Int32Array]"
  , tx = "[object Uint8Array]"
  , nx = "[object Uint8ClampedArray]"
  , rx = "[object Uint16Array]"
  , ix = "[object Uint32Array]";
function sx(t, e, n) {
    var r = t.constructor;
    switch (e) {
    case W1:
        return al(t);
    case U1:
    case j1:
        return new r(+t);
    case Y1:
        return I1(t, n);
    case Z1:
    case X1:
    case Q1:
    case J1:
    case ex:
    case tx:
    case nx:
    case rx:
    case ix:
        return $1(t, n);
    case N1:
        return new r;
    case z1:
    case G1:
        return new r(t);
    case H1:
        return D1(t);
    case K1:
        return new r;
    case q1:
        return B1(t)
    }
}
function ox(t) {
    return typeof t.constructor == "function" && !Qa(t) ? gy(Kp(t)) : {}
}
var ax = "[object Map]";
function lx(t) {
    return wn(t) && _t(t) == ax
}
var iu = hr && hr.isMap
  , cx = iu ? el(iu) : lx
  , ux = "[object Set]";
function dx(t) {
    return wn(t) && _t(t) == ux
}
var su = hr && hr.isSet
  , px = su ? el(su) : dx
  , hx = 1
  , fx = 2
  , mx = 4
  , Zp = "[object Arguments]"
  , vx = "[object Array]"
  , gx = "[object Boolean]"
  , bx = "[object Date]"
  , _x = "[object Error]"
  , Xp = "[object Function]"
  , yx = "[object GeneratorFunction]"
  , wx = "[object Map]"
  , xx = "[object Number]"
  , Qp = "[object Object]"
  , Cx = "[object RegExp]"
  , Ex = "[object Set]"
  , Px = "[object String]"
  , Ox = "[object Symbol]"
  , Tx = "[object WeakMap]"
  , Ax = "[object ArrayBuffer]"
  , Sx = "[object DataView]"
  , kx = "[object Float32Array]"
  , Mx = "[object Float64Array]"
  , Lx = "[object Int8Array]"
  , Fx = "[object Int16Array]"
  , Rx = "[object Int32Array]"
  , Ix = "[object Uint8Array]"
  , Vx = "[object Uint8ClampedArray]"
  , Dx = "[object Uint16Array]"
  , Bx = "[object Uint32Array]"
  , ve = {};
ve[Zp] = ve[vx] = ve[Ax] = ve[Sx] = ve[gx] = ve[bx] = ve[kx] = ve[Mx] = ve[Lx] = ve[Fx] = ve[Rx] = ve[wx] = ve[xx] = ve[Qp] = ve[Cx] = ve[Ex] = ve[Px] = ve[Ox] = ve[Ix] = ve[Vx] = ve[Dx] = ve[Bx] = !0;
ve[_x] = ve[Xp] = ve[Tx] = !1;
function as(t, e, n, r, i, s) {
    var o, a = e & hx, l = e & fx, c = e & mx;
    if (o !== void 0)
        return o;
    if (!It(t))
        return t;
    var u = Ct(t);
    if (u) {
        if (o = R1(t),
        !a)
            return _y(t, o)
    } else {
        var d = _t(t)
          , m = d == Xp || d == yx;
        if (As(t))
            return b1(t, a);
        if (d == Qp || d == Zp || m && !i) {
            if (o = l || m ? {} : ox(t),
            !a)
                return l ? E1(t, v1(o, t)) : x1(t, m1(o, t))
        } else {
            if (!ve[d])
                return i ? t : {};
            o = sx(t, d, a)
        }
    }
    s || (s = new Zt);
    var g = s.get(t);
    if (g)
        return g;
    s.set(t, o),
    px(t) ? t.forEach(function(_) {
        o.add(as(_, e, n, _, t, s))
    }) : cx(t) && t.forEach(function(_, p) {
        o.set(p, as(_, e, n, p, t, s))
    });
    var f = c ? l ? P1 : qo : l ? nl : tl
      , h = u ? void 0 : f(t);
    return Ty(h || t, function(_, p) {
        h && (p = _,
        _ = t[p]),
        Za(o, p, as(_, e, n, p, t, s))
    }),
    o
}
var $x = 4;
function ou(t) {
    return as(t, $x)
}
var Ux = "__lodash_hash_undefined__";
function jx(t) {
    return this.__data__.set(t, Ux),
    this
}
function Nx(t) {
    return this.__data__.has(t)
}
function ks(t) {
    var e = -1
      , n = t == null ? 0 : t.length;
    for (this.__data__ = new rn; ++e < n; )
        this.add(t[e])
}
ks.prototype.add = ks.prototype.push = jx;
ks.prototype.has = Nx;
function zx(t, e) {
    for (var n = -1, r = t == null ? 0 : t.length; ++n < r; )
        if (e(t[n], n, t))
            return !0;
    return !1
}
function Hx(t, e) {
    return t.has(e)
}
var Kx = 1
  , Gx = 2;
function Jp(t, e, n, r, i, s) {
    var o = n & Kx
      , a = t.length
      , l = e.length;
    if (a != l && !(o && l > a))
        return !1;
    var c = s.get(t)
      , u = s.get(e);
    if (c && u)
        return c == e && u == t;
    var d = -1
      , m = !0
      , g = n & Gx ? new ks : void 0;
    for (s.set(t, e),
    s.set(e, t); ++d < a; ) {
        var f = t[d]
          , h = e[d];
        if (r)
            var _ = o ? r(h, f, d, e, t, s) : r(f, h, d, t, e, s);
        if (_ !== void 0) {
            if (_)
                continue;
            m = !1;
            break
        }
        if (g) {
            if (!zx(e, function(p, b) {
                if (!Hx(g, b) && (f === p || i(f, p, n, r, s)))
                    return g.push(b)
            })) {
                m = !1;
                break
            }
        } else if (!(f === h || i(f, h, n, r, s))) {
            m = !1;
            break
        }
    }
    return s.delete(t),
    s.delete(e),
    m
}
function qx(t) {
    var e = -1
      , n = Array(t.size);
    return t.forEach(function(r, i) {
        n[++e] = [i, r]
    }),
    n
}
function Wx(t) {
    var e = -1
      , n = Array(t.size);
    return t.forEach(function(r) {
        n[++e] = r
    }),
    n
}
var Yx = 1
  , Zx = 2
  , Xx = "[object Boolean]"
  , Qx = "[object Date]"
  , Jx = "[object Error]"
  , eC = "[object Map]"
  , tC = "[object Number]"
  , nC = "[object RegExp]"
  , rC = "[object Set]"
  , iC = "[object String]"
  , sC = "[object Symbol]"
  , oC = "[object ArrayBuffer]"
  , aC = "[object DataView]"
  , au = dt ? dt.prototype : void 0
  , Oo = au ? au.valueOf : void 0;
function lC(t, e, n, r, i, s, o) {
    switch (n) {
    case aC:
        if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
            return !1;
        t = t.buffer,
        e = e.buffer;
    case oC:
        return !(t.byteLength != e.byteLength || !s(new Ss(t), new Ss(e)));
    case Xx:
    case Qx:
    case tC:
        return Ya(+t, +e);
    case Jx:
        return t.name == e.name && t.message == e.message;
    case nC:
    case iC:
        return t == e + "";
    case eC:
        var a = qx;
    case rC:
        var l = r & Yx;
        if (a || (a = Wx),
        t.size != e.size && !l)
            return !1;
        var c = o.get(t);
        if (c)
            return c == e;
        r |= Zx,
        o.set(t, e);
        var u = Jp(a(t), a(e), r, i, s, o);
        return o.delete(t),
        u;
    case sC:
        if (Oo)
            return Oo.call(t) == Oo.call(e)
    }
    return !1
}
var cC = 1
  , uC = Object.prototype
  , dC = uC.hasOwnProperty;
function pC(t, e, n, r, i, s) {
    var o = n & cC
      , a = qo(t)
      , l = a.length
      , c = qo(e)
      , u = c.length;
    if (l != u && !o)
        return !1;
    for (var d = l; d--; ) {
        var m = a[d];
        if (!(o ? m in e : dC.call(e, m)))
            return !1
    }
    var g = s.get(t)
      , f = s.get(e);
    if (g && f)
        return g == e && f == t;
    var h = !0;
    s.set(t, e),
    s.set(e, t);
    for (var _ = o; ++d < l; ) {
        m = a[d];
        var p = t[m]
          , b = e[m];
        if (r)
            var y = o ? r(b, p, m, e, t, s) : r(p, b, m, t, e, s);
        if (!(y === void 0 ? p === b || i(p, b, n, r, s) : y)) {
            h = !1;
            break
        }
        _ || (_ = m == "constructor")
    }
    if (h && !_) {
        var w = t.constructor
          , x = e.constructor;
        w != x && "constructor"in t && "constructor"in e && !(typeof w == "function" && w instanceof w && typeof x == "function" && x instanceof x) && (h = !1)
    }
    return s.delete(t),
    s.delete(e),
    h
}
var hC = 1
  , lu = "[object Arguments]"
  , cu = "[object Array]"
  , Wi = "[object Object]"
  , fC = Object.prototype
  , uu = fC.hasOwnProperty;
function mC(t, e, n, r, i, s) {
    var o = Ct(t)
      , a = Ct(e)
      , l = o ? cu : _t(t)
      , c = a ? cu : _t(e);
    l = l == lu ? Wi : l,
    c = c == lu ? Wi : c;
    var u = l == Wi
      , d = c == Wi
      , m = l == c;
    if (m && As(t)) {
        if (!As(e))
            return !1;
        o = !0,
        u = !1
    }
    if (m && !u)
        return s || (s = new Zt),
        o || Up(t) ? Jp(t, e, n, r, i, s) : lC(t, e, l, n, r, i, s);
    if (!(n & hC)) {
        var g = u && uu.call(t, "__wrapped__")
          , f = d && uu.call(e, "__wrapped__");
        if (g || f) {
            var h = g ? t.value() : t
              , _ = f ? e.value() : e;
            return s || (s = new Zt),
            i(h, _, n, r, s)
        }
    }
    return m ? (s || (s = new Zt),
    pC(t, e, n, r, i, s)) : !1
}
function eh(t, e, n, r, i) {
    return t === e ? !0 : t == null || e == null || !wn(t) && !wn(e) ? t !== t && e !== e : mC(t, e, n, r, eh, i)
}
function vC(t, e) {
    return t != null && e in Object(t)
}
function gC(t, e, n) {
    e = Zs(e, t);
    for (var r = -1, i = e.length, s = !1; ++r < i; ) {
        var o = il(e[r]);
        if (!(s = t != null && n(t, o)))
            break;
        t = t[o]
    }
    return s || ++r != i ? s : (i = t == null ? 0 : t.length,
    !!i && Xa(i) && Wa(o, i) && (Ct(t) || Ja(t)))
}
function bC(t, e) {
    return t != null && gC(t, e, vC)
}
var To = function() {
    return Et.Date.now()
}
  , _C = "Expected a function"
  , yC = Math.max
  , wC = Math.min;
function xC(t, e, n) {
    var r, i, s, o, a, l, c = 0, u = !1, d = !1, m = !0;
    if (typeof t != "function")
        throw new TypeError(_C);
    e = Bc(e) || 0,
    It(n) && (u = !!n.leading,
    d = "maxWait"in n,
    s = d ? yC(Bc(n.maxWait) || 0, e) : s,
    m = "trailing"in n ? !!n.trailing : m);
    function g(C) {
        var P = r
          , T = i;
        return r = i = void 0,
        c = C,
        o = t.apply(T, P),
        o
    }
    function f(C) {
        return c = C,
        a = setTimeout(p, e),
        u ? g(C) : o
    }
    function h(C) {
        var P = C - l
          , T = C - c
          , L = e - P;
        return d ? wC(L, s - T) : L
    }
    function _(C) {
        var P = C - l
          , T = C - c;
        return l === void 0 || P >= e || P < 0 || d && T >= s
    }
    function p() {
        var C = To();
        if (_(C))
            return b(C);
        a = setTimeout(p, h(C))
    }
    function b(C) {
        return a = void 0,
        m && r ? g(C) : (r = i = void 0,
        o)
    }
    function y() {
        a !== void 0 && clearTimeout(a),
        c = 0,
        r = l = i = a = void 0
    }
    function w() {
        return a === void 0 ? o : b(To())
    }
    function x() {
        var C = To()
          , P = _(C);
        if (r = arguments,
        i = this,
        l = C,
        P) {
            if (a === void 0)
                return f(l);
            if (d)
                return clearTimeout(a),
                a = setTimeout(p, e),
                g(l)
        }
        return a === void 0 && (a = setTimeout(p, e)),
        o
    }
    return x.cancel = y,
    x.flush = w,
    x
}
function Ms(t) {
    for (var e = -1, n = t == null ? 0 : t.length, r = {}; ++e < n; ) {
        var i = t[e];
        r[i[0]] = i[1]
    }
    return r
}
function CC(t, e) {
    return eh(t, e)
}
function bn(t) {
    return t == null
}
function EC(t) {
    return t === void 0
}
function th(t, e, n, r) {
    if (!It(t))
        return t;
    e = Zs(e, t);
    for (var i = -1, s = e.length, o = s - 1, a = t; a != null && ++i < s; ) {
        var l = il(e[i])
          , c = n;
        if (l === "__proto__" || l === "constructor" || l === "prototype")
            return t;
        if (i != o) {
            var u = a[l];
            c = void 0,
            c === void 0 && (c = It(u) ? u : Wa(e[i + 1]) ? [] : {})
        }
        Za(a, l, c),
        a = a[l]
    }
    return t
}
function PC(t, e, n) {
    for (var r = -1, i = e.length, s = {}; ++r < i; ) {
        var o = e[r]
          , a = zp(t, o);
        n(a, o) && th(s, Zs(o, t), a)
    }
    return s
}
function OC(t, e) {
    return PC(t, e, function(n, r) {
        return bC(t, r)
    })
}
var nh = l1(function(t, e) {
    return t == null ? {} : OC(t, e)
});
function TC(t, e, n) {
    return t == null ? t : th(t, e, n)
}
const di = t => t === void 0
  , Nn = t => typeof t == "boolean"
  , Jt = t => typeof t == "number"
  , cr = t => typeof Element > "u" ? !1 : t instanceof Element
  , Xo = t => bn(t)
  , AC = t => ze(t) ? !Number.isNaN(Number(t)) : !1
  , du = t => Object.keys(t)
  , Ao = (t, e, n) => ({
    get value() {
        return Hp(t, e, n)
    },
    set value(r) {
        TC(t, e, r)
    }
});
class SC extends Error {
    constructor(e) {
        super(e),
        this.name = "ElementPlusError"
    }
}
function kC(t, e) {
    throw new SC(`[${t}] ${e}`)
}
const rh = (t="") => t.split(" ").filter(e => !!e.trim())
  , pu = (t, e) => {
    !t || !e.trim() || t.classList.add(...rh(e))
}
  , Ls = (t, e) => {
    !t || !e.trim() || t.classList.remove(...rh(e))
}
  , Nr = (t, e) => {
    var n;
    if (!He || !t || !e)
        return "";
    let r = Bf(e);
    r === "float" && (r = "cssFloat");
    try {
        const i = t.style[r];
        if (i)
            return i;
        const s = (n = document.defaultView) == null ? void 0 : n.getComputedStyle(t, "");
        return s ? s[r] : ""
    } catch {
        return t.style[r]
    }
}
;
function pi(t, e="px") {
    if (!t)
        return "";
    if (Jt(t) || AC(t))
        return `${t}${e}`;
    if (ze(t))
        return t
}
/*! Element Plus Icons Vue v2.3.1 */
var MC = H({
    name: "ArrowDown",
    __name: "arrow-down",
    setup(t) {
        return (e, n) => (S(),
        j("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [$("path", {
            fill: "currentColor",
            d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
        })]))
    }
})
  , LC = MC
  , FC = H({
    name: "CircleCheck",
    __name: "circle-check",
    setup(t) {
        return (e, n) => (S(),
        j("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [$("path", {
            fill: "currentColor",
            d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
        }), $("path", {
            fill: "currentColor",
            d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
        })]))
    }
})
  , RC = FC
  , IC = H({
    name: "CircleClose",
    __name: "circle-close",
    setup(t) {
        return (e, n) => (S(),
        j("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [$("path", {
            fill: "currentColor",
            d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
        }), $("path", {
            fill: "currentColor",
            d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
        })]))
    }
})
  , ih = IC
  , VC = H({
    name: "Close",
    __name: "close",
    setup(t) {
        return (e, n) => (S(),
        j("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [$("path", {
            fill: "currentColor",
            d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
        })]))
    }
})
  , DC = VC
  , BC = H({
    name: "Hide",
    __name: "hide",
    setup(t) {
        return (e, n) => (S(),
        j("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [$("path", {
            fill: "currentColor",
            d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z"
        }), $("path", {
            fill: "currentColor",
            d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z"
        })]))
    }
})
  , $C = BC
  , UC = H({
    name: "Loading",
    __name: "loading",
    setup(t) {
        return (e, n) => (S(),
        j("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [$("path", {
            fill: "currentColor",
            d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
        })]))
    }
})
  , sh = UC
  , jC = H({
    name: "View",
    __name: "view",
    setup(t) {
        return (e, n) => (S(),
        j("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024"
        }, [$("path", {
            fill: "currentColor",
            d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
        })]))
    }
})
  , oh = jC;
const ah = "__epPropKey"
  , te = t => t
  , NC = t => _n(t) && !!t[ah]
  , Xs = (t, e) => {
    if (!_n(t) || NC(t))
        return t;
    const {values: n, required: r, default: i, type: s, validator: o} = t
      , l = {
        type: s,
        required: !!r,
        validator: n || o ? c => {
            let u = !1
              , d = [];
            if (n && (d = Array.from(n),
            gs(t, "default") && d.push(i),
            u || (u = d.includes(c))),
            o && (u || (u = o(c))),
            !u && d.length > 0) {
                const m = [...new Set(d)].map(g => JSON.stringify(g)).join(", ");
                $f(`Invalid prop: validation failed${e ? ` for prop "${e}"` : ""}. Expected one of [${m}], got value ${JSON.stringify(c)}.`)
            }
            return u
        }
        : void 0,
        [ah]: !0
    };
    return gs(t, "default") && (l.default = i),
    l
}
  , Ae = t => Ms(Object.entries(t).map( ([e,n]) => [e, Xs(n, e)]))
  , Fs = te([String, Object, Function])
  , zC = {
    validating: sh,
    success: RC,
    error: ih
}
  , Bt = (t, e) => {
    if (t.install = n => {
        for (const r of [t, ...Object.values(e ?? {})])
            n.component(r.name, r)
    }
    ,
    e)
        for (const [n,r] of Object.entries(e))
            t[n] = r;
    return t
}
  , Qs = t => (t.install = ti,
t)
  , wt = {
    tab: "Tab",
    enter: "Enter",
    space: "Space",
    left: "ArrowLeft",
    up: "ArrowUp",
    right: "ArrowRight",
    down: "ArrowDown",
    esc: "Escape",
    delete: "Delete",
    backspace: "Backspace",
    numpadEnter: "NumpadEnter",
    pageUp: "PageUp",
    pageDown: "PageDown",
    home: "Home",
    end: "End"
}
  , xt = "update:modelValue"
  , HC = "change"
  , Js = ["", "default", "small", "large"]
  , KC = t => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(t)
  , GC = t => t
  , qC = ["class", "style"]
  , WC = /^on[A-Z]/
  , YC = (t={}) => {
    const {excludeListeners: e=!1, excludeKeys: n} = t
      , r = E( () => ((n == null ? void 0 : n.value) || []).concat(qC))
      , i = Ve();
    return i ? E( () => {
        var s;
        return Ms(Object.entries((s = i.proxy) == null ? void 0 : s.$attrs).filter( ([o]) => !r.value.includes(o) && !(e && WC.test(o))))
    }
    ) : E( () => ({}))
}
  , ls = ({from: t, replacement: e, scope: n, version: r, ref: i, type: s="API"}, o) => {
    W( () => v(o), a => {}
    , {
        immediate: !0
    })
}
;
var ZC = {
    name: "en",
    el: {
        breadcrumb: {
            label: "Breadcrumb"
        },
        colorpicker: {
            confirm: "OK",
            clear: "Clear",
            defaultLabel: "color picker",
            description: "current color is {color}. press enter to select a new color.",
            alphaLabel: "pick alpha value"
        },
        datepicker: {
            now: "Now",
            today: "Today",
            cancel: "Cancel",
            clear: "Clear",
            confirm: "OK",
            dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
            monthTablePrompt: "Use the arrow keys and enter to select the month",
            yearTablePrompt: "Use the arrow keys and enter to select the year",
            selectedDate: "Selected date",
            selectDate: "Select date",
            selectTime: "Select time",
            startDate: "Start Date",
            startTime: "Start Time",
            endDate: "End Date",
            endTime: "End Time",
            prevYear: "Previous Year",
            nextYear: "Next Year",
            prevMonth: "Previous Month",
            nextMonth: "Next Month",
            year: "",
            month1: "January",
            month2: "February",
            month3: "March",
            month4: "April",
            month5: "May",
            month6: "June",
            month7: "July",
            month8: "August",
            month9: "September",
            month10: "October",
            month11: "November",
            month12: "December",
            week: "week",
            weeks: {
                sun: "Sun",
                mon: "Mon",
                tue: "Tue",
                wed: "Wed",
                thu: "Thu",
                fri: "Fri",
                sat: "Sat"
            },
            weeksFull: {
                sun: "Sunday",
                mon: "Monday",
                tue: "Tuesday",
                wed: "Wednesday",
                thu: "Thursday",
                fri: "Friday",
                sat: "Saturday"
            },
            months: {
                jan: "Jan",
                feb: "Feb",
                mar: "Mar",
                apr: "Apr",
                may: "May",
                jun: "Jun",
                jul: "Jul",
                aug: "Aug",
                sep: "Sep",
                oct: "Oct",
                nov: "Nov",
                dec: "Dec"
            }
        },
        inputNumber: {
            decrease: "decrease number",
            increase: "increase number"
        },
        select: {
            loading: "Loading",
            noMatch: "No matching data",
            noData: "No data",
            placeholder: "Select"
        },
        mention: {
            loading: "Loading"
        },
        dropdown: {
            toggleDropdown: "Toggle Dropdown"
        },
        cascader: {
            noMatch: "No matching data",
            loading: "Loading",
            placeholder: "Select",
            noData: "No data"
        },
        pagination: {
            goto: "Go to",
            pagesize: "/page",
            total: "Total {total}",
            pageClassifier: "",
            page: "Page",
            prev: "Go to previous page",
            next: "Go to next page",
            currentPage: "page {pager}",
            prevPages: "Previous {pager} pages",
            nextPages: "Next {pager} pages",
            deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
        },
        dialog: {
            close: "Close this dialog"
        },
        drawer: {
            close: "Close this dialog"
        },
        messagebox: {
            title: "Message",
            confirm: "OK",
            cancel: "Cancel",
            error: "Illegal input",
            close: "Close this dialog"
        },
        upload: {
            deleteTip: "press delete to remove",
            delete: "Delete",
            preview: "Preview",
            continue: "Continue"
        },
        slider: {
            defaultLabel: "slider between {min} and {max}",
            defaultRangeStartLabel: "pick start value",
            defaultRangeEndLabel: "pick end value"
        },
        table: {
            emptyText: "No Data",
            confirmFilter: "Confirm",
            resetFilter: "Reset",
            clearFilter: "All",
            sumText: "Sum"
        },
        tour: {
            next: "Next",
            previous: "Previous",
            finish: "Finish"
        },
        tree: {
            emptyText: "No Data"
        },
        transfer: {
            noMatch: "No matching data",
            noData: "No data",
            titles: ["List 1", "List 2"],
            filterPlaceholder: "Enter keyword",
            noCheckedFormat: "{total} items",
            hasCheckedFormat: "{checked}/{total} checked"
        },
        image: {
            error: "FAILED"
        },
        pageHeader: {
            title: "Back"
        },
        popconfirm: {
            confirmButtonText: "Yes",
            cancelButtonText: "No"
        },
        carousel: {
            leftArrow: "Carousel arrow left",
            rightArrow: "Carousel arrow right",
            indicator: "Carousel switch to index {index}"
        }
    }
};
const XC = t => (e, n) => QC(e, n, v(t))
  , QC = (t, e, n) => Hp(n, t, t).replace(/\{(\w+)\}/g, (r, i) => {
    var s;
    return `${(s = e == null ? void 0 : e[i]) != null ? s : `{${i}}`}`
}
)
  , JC = t => {
    const e = E( () => v(t).name)
      , n = Vn(t) ? t : M(t);
    return {
        lang: e,
        locale: n,
        t: XC(t)
    }
}
  , lh = Symbol("localeContextKey")
  , ll = t => {
    const e = t || le(lh, M());
    return JC(E( () => e.value || ZC))
}
  , cs = "el"
  , eE = "is-"
  , Tn = (t, e, n, r, i) => {
    let s = `${t}-${e}`;
    return n && (s += `-${n}`),
    r && (s += `__${r}`),
    i && (s += `--${i}`),
    s
}
  , ch = Symbol("namespaceContextKey")
  , cl = t => {
    const e = t || (Ve() ? le(ch, M(cs)) : M(cs));
    return E( () => v(e) || cs)
}
  , we = (t, e) => {
    const n = cl(e);
    return {
        namespace: n,
        b: (h="") => Tn(n.value, t, h, "", ""),
        e: h => h ? Tn(n.value, t, "", h, "") : "",
        m: h => h ? Tn(n.value, t, "", "", h) : "",
        be: (h, _) => h && _ ? Tn(n.value, t, h, _, "") : "",
        em: (h, _) => h && _ ? Tn(n.value, t, "", h, _) : "",
        bm: (h, _) => h && _ ? Tn(n.value, t, h, "", _) : "",
        bem: (h, _, p) => h && _ && p ? Tn(n.value, t, h, _, p) : "",
        is: (h, ..._) => {
            const p = _.length >= 1 ? _[0] : !0;
            return h && p ? `${eE}${h}` : ""
        }
        ,
        cssVar: h => {
            const _ = {};
            for (const p in h)
                h[p] && (_[`--${n.value}-${p}`] = h[p]);
            return _
        }
        ,
        cssVarName: h => `--${n.value}-${h}`,
        cssVarBlock: h => {
            const _ = {};
            for (const p in h)
                h[p] && (_[`--${n.value}-${t}-${p}`] = h[p]);
            return _
        }
        ,
        cssVarBlockName: h => `--${n.value}-${t}-${h}`
    }
}
  , tE = Xs({
    type: te(Boolean),
    default: null
})
  , nE = Xs({
    type: te(Function)
})
  , rE = t => {
    const e = `update:${t}`
      , n = `onUpdate:${t}`
      , r = [e]
      , i = {
        [t]: tE,
        [n]: nE
    };
    return {
        useModelToggle: ({indicator: o, toggleReason: a, shouldHideWhenRouteChanges: l, shouldProceed: c, onShow: u, onHide: d}) => {
            const m = Ve()
              , {emit: g} = m
              , f = m.props
              , h = E( () => Kt(f[n]))
              , _ = E( () => f[t] === null)
              , p = P => {
                o.value !== !0 && (o.value = !0,
                a && (a.value = P),
                Kt(u) && u(P))
            }
              , b = P => {
                o.value !== !1 && (o.value = !1,
                a && (a.value = P),
                Kt(d) && d(P))
            }
              , y = P => {
                if (f.disabled === !0 || Kt(c) && !c())
                    return;
                const T = h.value && He;
                T && g(e, !0),
                (_.value || !T) && p(P)
            }
              , w = P => {
                if (f.disabled === !0 || !He)
                    return;
                const T = h.value && He;
                T && g(e, !1),
                (_.value || !T) && b(P)
            }
              , x = P => {
                Nn(P) && (f.disabled && P ? h.value && g(e, !1) : o.value !== P && (P ? p() : b()))
            }
              , C = () => {
                o.value ? w() : y()
            }
            ;
            return W( () => f[t], x),
            l && m.appContext.config.globalProperties.$route !== void 0 && W( () => ({
                ...m.proxy.$route
            }), () => {
                l.value && o.value && w()
            }
            ),
            De( () => {
                x(f[t])
            }
            ),
            {
                hide: w,
                show: y,
                toggle: C,
                hasUpdateHandler: h
            }
        }
        ,
        useModelToggleProps: i,
        useModelToggleEmits: r
    }
}
  , uh = t => {
    const e = Ve();
    return E( () => {
        var n, r;
        return (r = (n = e == null ? void 0 : e.proxy) == null ? void 0 : n.$props) == null ? void 0 : r[t]
    }
    )
}
;
var Qe = "top"
  , pt = "bottom"
  , ht = "right"
  , Je = "left"
  , ul = "auto"
  , Ai = [Qe, pt, ht, Je]
  , fr = "start"
  , hi = "end"
  , iE = "clippingParents"
  , dh = "viewport"
  , zr = "popper"
  , sE = "reference"
  , hu = Ai.reduce(function(t, e) {
    return t.concat([e + "-" + fr, e + "-" + hi])
}, [])
  , dl = [].concat(Ai, [ul]).reduce(function(t, e) {
    return t.concat([e, e + "-" + fr, e + "-" + hi])
}, [])
  , oE = "beforeRead"
  , aE = "read"
  , lE = "afterRead"
  , cE = "beforeMain"
  , uE = "main"
  , dE = "afterMain"
  , pE = "beforeWrite"
  , hE = "write"
  , fE = "afterWrite"
  , mE = [oE, aE, lE, cE, uE, dE, pE, hE, fE];
function Vt(t) {
    return t ? (t.nodeName || "").toLowerCase() : null
}
function Pt(t) {
    if (t == null)
        return window;
    if (t.toString() !== "[object Window]") {
        var e = t.ownerDocument;
        return e && e.defaultView || window
    }
    return t
}
function mr(t) {
    var e = Pt(t).Element;
    return t instanceof e || t instanceof Element
}
function ct(t) {
    var e = Pt(t).HTMLElement;
    return t instanceof e || t instanceof HTMLElement
}
function pl(t) {
    if (typeof ShadowRoot > "u")
        return !1;
    var e = Pt(t).ShadowRoot;
    return t instanceof e || t instanceof ShadowRoot
}
function vE(t) {
    var e = t.state;
    Object.keys(e.elements).forEach(function(n) {
        var r = e.styles[n] || {}
          , i = e.attributes[n] || {}
          , s = e.elements[n];
        !ct(s) || !Vt(s) || (Object.assign(s.style, r),
        Object.keys(i).forEach(function(o) {
            var a = i[o];
            a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a)
        }))
    })
}
function gE(t) {
    var e = t.state
      , n = {
        popper: {
            position: e.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
        },
        arrow: {
            position: "absolute"
        },
        reference: {}
    };
    return Object.assign(e.elements.popper.style, n.popper),
    e.styles = n,
    e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
    function() {
        Object.keys(e.elements).forEach(function(r) {
            var i = e.elements[r]
              , s = e.attributes[r] || {}
              , o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r])
              , a = o.reduce(function(l, c) {
                return l[c] = "",
                l
            }, {});
            !ct(i) || !Vt(i) || (Object.assign(i.style, a),
            Object.keys(s).forEach(function(l) {
                i.removeAttribute(l)
            }))
        })
    }
}
var ph = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: vE,
    effect: gE,
    requires: ["computeStyles"]
};
function Lt(t) {
    return t.split("-")[0]
}
var In = Math.max
  , Rs = Math.min
  , vr = Math.round;
function gr(t, e) {
    e === void 0 && (e = !1);
    var n = t.getBoundingClientRect()
      , r = 1
      , i = 1;
    if (ct(t) && e) {
        var s = t.offsetHeight
          , o = t.offsetWidth;
        o > 0 && (r = vr(n.width) / o || 1),
        s > 0 && (i = vr(n.height) / s || 1)
    }
    return {
        width: n.width / r,
        height: n.height / i,
        top: n.top / i,
        right: n.right / r,
        bottom: n.bottom / i,
        left: n.left / r,
        x: n.left / r,
        y: n.top / i
    }
}
function hl(t) {
    var e = gr(t)
      , n = t.offsetWidth
      , r = t.offsetHeight;
    return Math.abs(e.width - n) <= 1 && (n = e.width),
    Math.abs(e.height - r) <= 1 && (r = e.height),
    {
        x: t.offsetLeft,
        y: t.offsetTop,
        width: n,
        height: r
    }
}
function hh(t, e) {
    var n = e.getRootNode && e.getRootNode();
    if (t.contains(e))
        return !0;
    if (n && pl(n)) {
        var r = e;
        do {
            if (r && t.isSameNode(r))
                return !0;
            r = r.parentNode || r.host
        } while (r)
    }
    return !1
}
function en(t) {
    return Pt(t).getComputedStyle(t)
}
function bE(t) {
    return ["table", "td", "th"].indexOf(Vt(t)) >= 0
}
function Cn(t) {
    return ((mr(t) ? t.ownerDocument : t.document) || window.document).documentElement
}
function eo(t) {
    return Vt(t) === "html" ? t : t.assignedSlot || t.parentNode || (pl(t) ? t.host : null) || Cn(t)
}
function fu(t) {
    return !ct(t) || en(t).position === "fixed" ? null : t.offsetParent
}
function _E(t) {
    var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1
      , n = navigator.userAgent.indexOf("Trident") !== -1;
    if (n && ct(t)) {
        var r = en(t);
        if (r.position === "fixed")
            return null
    }
    var i = eo(t);
    for (pl(i) && (i = i.host); ct(i) && ["html", "body"].indexOf(Vt(i)) < 0; ) {
        var s = en(i);
        if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none")
            return i;
        i = i.parentNode
    }
    return null
}
function Si(t) {
    for (var e = Pt(t), n = fu(t); n && bE(n) && en(n).position === "static"; )
        n = fu(n);
    return n && (Vt(n) === "html" || Vt(n) === "body" && en(n).position === "static") ? e : n || _E(t) || e
}
function fl(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
}
function Xr(t, e, n) {
    return In(t, Rs(e, n))
}
function yE(t, e, n) {
    var r = Xr(t, e, n);
    return r > n ? n : r
}
function fh() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }
}
function mh(t) {
    return Object.assign({}, fh(), t)
}
function vh(t, e) {
    return e.reduce(function(n, r) {
        return n[r] = t,
        n
    }, {})
}
var wE = function(t, e) {
    return t = typeof t == "function" ? t(Object.assign({}, e.rects, {
        placement: e.placement
    })) : t,
    mh(typeof t != "number" ? t : vh(t, Ai))
};
function xE(t) {
    var e, n = t.state, r = t.name, i = t.options, s = n.elements.arrow, o = n.modifiersData.popperOffsets, a = Lt(n.placement), l = fl(a), c = [Je, ht].indexOf(a) >= 0, u = c ? "height" : "width";
    if (!(!s || !o)) {
        var d = wE(i.padding, n)
          , m = hl(s)
          , g = l === "y" ? Qe : Je
          , f = l === "y" ? pt : ht
          , h = n.rects.reference[u] + n.rects.reference[l] - o[l] - n.rects.popper[u]
          , _ = o[l] - n.rects.reference[l]
          , p = Si(s)
          , b = p ? l === "y" ? p.clientHeight || 0 : p.clientWidth || 0 : 0
          , y = h / 2 - _ / 2
          , w = d[g]
          , x = b - m[u] - d[f]
          , C = b / 2 - m[u] / 2 + y
          , P = Xr(w, C, x)
          , T = l;
        n.modifiersData[r] = (e = {},
        e[T] = P,
        e.centerOffset = P - C,
        e)
    }
}
function CE(t) {
    var e = t.state
      , n = t.options
      , r = n.element
      , i = r === void 0 ? "[data-popper-arrow]" : r;
    i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i),
    !i) || !hh(e.elements.popper, i) || (e.elements.arrow = i))
}
var EE = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: xE,
    effect: CE,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
};
function br(t) {
    return t.split("-")[1]
}
var PE = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
};
function OE(t) {
    var e = t.x
      , n = t.y
      , r = window
      , i = r.devicePixelRatio || 1;
    return {
        x: vr(e * i) / i || 0,
        y: vr(n * i) / i || 0
    }
}
function mu(t) {
    var e, n = t.popper, r = t.popperRect, i = t.placement, s = t.variation, o = t.offsets, a = t.position, l = t.gpuAcceleration, c = t.adaptive, u = t.roundOffsets, d = t.isFixed, m = o.x, g = m === void 0 ? 0 : m, f = o.y, h = f === void 0 ? 0 : f, _ = typeof u == "function" ? u({
        x: g,
        y: h
    }) : {
        x: g,
        y: h
    };
    g = _.x,
    h = _.y;
    var p = o.hasOwnProperty("x")
      , b = o.hasOwnProperty("y")
      , y = Je
      , w = Qe
      , x = window;
    if (c) {
        var C = Si(n)
          , P = "clientHeight"
          , T = "clientWidth";
        if (C === Pt(n) && (C = Cn(n),
        en(C).position !== "static" && a === "absolute" && (P = "scrollHeight",
        T = "scrollWidth")),
        C = C,
        i === Qe || (i === Je || i === ht) && s === hi) {
            w = pt;
            var L = d && C === x && x.visualViewport ? x.visualViewport.height : C[P];
            h -= L - r.height,
            h *= l ? 1 : -1
        }
        if (i === Je || (i === Qe || i === pt) && s === hi) {
            y = ht;
            var I = d && C === x && x.visualViewport ? x.visualViewport.width : C[T];
            g -= I - r.width,
            g *= l ? 1 : -1
        }
    }
    var U = Object.assign({
        position: a
    }, c && PE)
      , B = u === !0 ? OE({
        x: g,
        y: h
    }) : {
        x: g,
        y: h
    };
    if (g = B.x,
    h = B.y,
    l) {
        var V;
        return Object.assign({}, U, (V = {},
        V[w] = b ? "0" : "",
        V[y] = p ? "0" : "",
        V.transform = (x.devicePixelRatio || 1) <= 1 ? "translate(" + g + "px, " + h + "px)" : "translate3d(" + g + "px, " + h + "px, 0)",
        V))
    }
    return Object.assign({}, U, (e = {},
    e[w] = b ? h + "px" : "",
    e[y] = p ? g + "px" : "",
    e.transform = "",
    e))
}
function TE(t) {
    var e = t.state
      , n = t.options
      , r = n.gpuAcceleration
      , i = r === void 0 ? !0 : r
      , s = n.adaptive
      , o = s === void 0 ? !0 : s
      , a = n.roundOffsets
      , l = a === void 0 ? !0 : a
      , c = {
        placement: Lt(e.placement),
        variation: br(e.placement),
        popper: e.elements.popper,
        popperRect: e.rects.popper,
        gpuAcceleration: i,
        isFixed: e.options.strategy === "fixed"
    };
    e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, mu(Object.assign({}, c, {
        offsets: e.modifiersData.popperOffsets,
        position: e.options.strategy,
        adaptive: o,
        roundOffsets: l
    })))),
    e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, mu(Object.assign({}, c, {
        offsets: e.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: l
    })))),
    e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement
    })
}
var gh = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: TE,
    data: {}
}
  , Yi = {
    passive: !0
};
function AE(t) {
    var e = t.state
      , n = t.instance
      , r = t.options
      , i = r.scroll
      , s = i === void 0 ? !0 : i
      , o = r.resize
      , a = o === void 0 ? !0 : o
      , l = Pt(e.elements.popper)
      , c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return s && c.forEach(function(u) {
        u.addEventListener("scroll", n.update, Yi)
    }),
    a && l.addEventListener("resize", n.update, Yi),
    function() {
        s && c.forEach(function(u) {
            u.removeEventListener("scroll", n.update, Yi)
        }),
        a && l.removeEventListener("resize", n.update, Yi)
    }
}
var bh = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function() {},
    effect: AE,
    data: {}
}
  , SE = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
function us(t) {
    return t.replace(/left|right|bottom|top/g, function(e) {
        return SE[e]
    })
}
var kE = {
    start: "end",
    end: "start"
};
function vu(t) {
    return t.replace(/start|end/g, function(e) {
        return kE[e]
    })
}
function ml(t) {
    var e = Pt(t)
      , n = e.pageXOffset
      , r = e.pageYOffset;
    return {
        scrollLeft: n,
        scrollTop: r
    }
}
function vl(t) {
    return gr(Cn(t)).left + ml(t).scrollLeft
}
function ME(t) {
    var e = Pt(t)
      , n = Cn(t)
      , r = e.visualViewport
      , i = n.clientWidth
      , s = n.clientHeight
      , o = 0
      , a = 0;
    return r && (i = r.width,
    s = r.height,
    /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = r.offsetLeft,
    a = r.offsetTop)),
    {
        width: i,
        height: s,
        x: o + vl(t),
        y: a
    }
}
function LE(t) {
    var e, n = Cn(t), r = ml(t), i = (e = t.ownerDocument) == null ? void 0 : e.body, s = In(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = In(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + vl(t), l = -r.scrollTop;
    return en(i || n).direction === "rtl" && (a += In(n.clientWidth, i ? i.clientWidth : 0) - s),
    {
        width: s,
        height: o,
        x: a,
        y: l
    }
}
function gl(t) {
    var e = en(t)
      , n = e.overflow
      , r = e.overflowX
      , i = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + i + r)
}
function _h(t) {
    return ["html", "body", "#document"].indexOf(Vt(t)) >= 0 ? t.ownerDocument.body : ct(t) && gl(t) ? t : _h(eo(t))
}
function Qr(t, e) {
    var n;
    e === void 0 && (e = []);
    var r = _h(t)
      , i = r === ((n = t.ownerDocument) == null ? void 0 : n.body)
      , s = Pt(r)
      , o = i ? [s].concat(s.visualViewport || [], gl(r) ? r : []) : r
      , a = e.concat(o);
    return i ? a : a.concat(Qr(eo(o)))
}
function Qo(t) {
    return Object.assign({}, t, {
        left: t.x,
        top: t.y,
        right: t.x + t.width,
        bottom: t.y + t.height
    })
}
function FE(t) {
    var e = gr(t);
    return e.top = e.top + t.clientTop,
    e.left = e.left + t.clientLeft,
    e.bottom = e.top + t.clientHeight,
    e.right = e.left + t.clientWidth,
    e.width = t.clientWidth,
    e.height = t.clientHeight,
    e.x = e.left,
    e.y = e.top,
    e
}
function gu(t, e) {
    return e === dh ? Qo(ME(t)) : mr(e) ? FE(e) : Qo(LE(Cn(t)))
}
function RE(t) {
    var e = Qr(eo(t))
      , n = ["absolute", "fixed"].indexOf(en(t).position) >= 0
      , r = n && ct(t) ? Si(t) : t;
    return mr(r) ? e.filter(function(i) {
        return mr(i) && hh(i, r) && Vt(i) !== "body"
    }) : []
}
function IE(t, e, n) {
    var r = e === "clippingParents" ? RE(t) : [].concat(e)
      , i = [].concat(r, [n])
      , s = i[0]
      , o = i.reduce(function(a, l) {
        var c = gu(t, l);
        return a.top = In(c.top, a.top),
        a.right = Rs(c.right, a.right),
        a.bottom = Rs(c.bottom, a.bottom),
        a.left = In(c.left, a.left),
        a
    }, gu(t, s));
    return o.width = o.right - o.left,
    o.height = o.bottom - o.top,
    o.x = o.left,
    o.y = o.top,
    o
}
function yh(t) {
    var e = t.reference, n = t.element, r = t.placement, i = r ? Lt(r) : null, s = r ? br(r) : null, o = e.x + e.width / 2 - n.width / 2, a = e.y + e.height / 2 - n.height / 2, l;
    switch (i) {
    case Qe:
        l = {
            x: o,
            y: e.y - n.height
        };
        break;
    case pt:
        l = {
            x: o,
            y: e.y + e.height
        };
        break;
    case ht:
        l = {
            x: e.x + e.width,
            y: a
        };
        break;
    case Je:
        l = {
            x: e.x - n.width,
            y: a
        };
        break;
    default:
        l = {
            x: e.x,
            y: e.y
        }
    }
    var c = i ? fl(i) : null;
    if (c != null) {
        var u = c === "y" ? "height" : "width";
        switch (s) {
        case fr:
            l[c] = l[c] - (e[u] / 2 - n[u] / 2);
            break;
        case hi:
            l[c] = l[c] + (e[u] / 2 - n[u] / 2);
            break
        }
    }
    return l
}
function fi(t, e) {
    e === void 0 && (e = {});
    var n = e
      , r = n.placement
      , i = r === void 0 ? t.placement : r
      , s = n.boundary
      , o = s === void 0 ? iE : s
      , a = n.rootBoundary
      , l = a === void 0 ? dh : a
      , c = n.elementContext
      , u = c === void 0 ? zr : c
      , d = n.altBoundary
      , m = d === void 0 ? !1 : d
      , g = n.padding
      , f = g === void 0 ? 0 : g
      , h = mh(typeof f != "number" ? f : vh(f, Ai))
      , _ = u === zr ? sE : zr
      , p = t.rects.popper
      , b = t.elements[m ? _ : u]
      , y = IE(mr(b) ? b : b.contextElement || Cn(t.elements.popper), o, l)
      , w = gr(t.elements.reference)
      , x = yh({
        reference: w,
        element: p,
        strategy: "absolute",
        placement: i
    })
      , C = Qo(Object.assign({}, p, x))
      , P = u === zr ? C : w
      , T = {
        top: y.top - P.top + h.top,
        bottom: P.bottom - y.bottom + h.bottom,
        left: y.left - P.left + h.left,
        right: P.right - y.right + h.right
    }
      , L = t.modifiersData.offset;
    if (u === zr && L) {
        var I = L[i];
        Object.keys(T).forEach(function(U) {
            var B = [ht, pt].indexOf(U) >= 0 ? 1 : -1
              , V = [Qe, pt].indexOf(U) >= 0 ? "y" : "x";
            T[U] += I[V] * B
        })
    }
    return T
}
function VE(t, e) {
    e === void 0 && (e = {});
    var n = e
      , r = n.placement
      , i = n.boundary
      , s = n.rootBoundary
      , o = n.padding
      , a = n.flipVariations
      , l = n.allowedAutoPlacements
      , c = l === void 0 ? dl : l
      , u = br(r)
      , d = u ? a ? hu : hu.filter(function(f) {
        return br(f) === u
    }) : Ai
      , m = d.filter(function(f) {
        return c.indexOf(f) >= 0
    });
    m.length === 0 && (m = d);
    var g = m.reduce(function(f, h) {
        return f[h] = fi(t, {
            placement: h,
            boundary: i,
            rootBoundary: s,
            padding: o
        })[Lt(h)],
        f
    }, {});
    return Object.keys(g).sort(function(f, h) {
        return g[f] - g[h]
    })
}
function DE(t) {
    if (Lt(t) === ul)
        return [];
    var e = us(t);
    return [vu(t), e, vu(e)]
}
function BE(t) {
    var e = t.state
      , n = t.options
      , r = t.name;
    if (!e.modifiersData[r]._skip) {
        for (var i = n.mainAxis, s = i === void 0 ? !0 : i, o = n.altAxis, a = o === void 0 ? !0 : o, l = n.fallbackPlacements, c = n.padding, u = n.boundary, d = n.rootBoundary, m = n.altBoundary, g = n.flipVariations, f = g === void 0 ? !0 : g, h = n.allowedAutoPlacements, _ = e.options.placement, p = Lt(_), b = p === _, y = l || (b || !f ? [us(_)] : DE(_)), w = [_].concat(y).reduce(function($e, Ne) {
            return $e.concat(Lt(Ne) === ul ? VE(e, {
                placement: Ne,
                boundary: u,
                rootBoundary: d,
                padding: c,
                flipVariations: f,
                allowedAutoPlacements: h
            }) : Ne)
        }, []), x = e.rects.reference, C = e.rects.popper, P = new Map, T = !0, L = w[0], I = 0; I < w.length; I++) {
            var U = w[I]
              , B = Lt(U)
              , V = br(U) === fr
              , z = [Qe, pt].indexOf(B) >= 0
              , K = z ? "width" : "height"
              , A = fi(e, {
                placement: U,
                boundary: u,
                rootBoundary: d,
                altBoundary: m,
                padding: c
            })
              , X = z ? V ? ht : Je : V ? pt : Qe;
            x[K] > C[K] && (X = us(X));
            var de = us(X)
              , pe = [];
            if (s && pe.push(A[B] <= 0),
            a && pe.push(A[X] <= 0, A[de] <= 0),
            pe.every(function($e) {
                return $e
            })) {
                L = U,
                T = !1;
                break
            }
            P.set(U, pe)
        }
        if (T)
            for (var Pe = f ? 3 : 1, Be = function($e) {
                var Ne = w.find(function(Ot) {
                    var Re = P.get(Ot);
                    if (Re)
                        return Re.slice(0, $e).every(function(N) {
                            return N
                        })
                });
                if (Ne)
                    return L = Ne,
                    "break"
            }, _e = Pe; _e > 0; _e--) {
                var Oe = Be(_e);
                if (Oe === "break")
                    break
            }
        e.placement !== L && (e.modifiersData[r]._skip = !0,
        e.placement = L,
        e.reset = !0)
    }
}
var $E = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: BE,
    requiresIfExists: ["offset"],
    data: {
        _skip: !1
    }
};
function bu(t, e, n) {
    return n === void 0 && (n = {
        x: 0,
        y: 0
    }),
    {
        top: t.top - e.height - n.y,
        right: t.right - e.width + n.x,
        bottom: t.bottom - e.height + n.y,
        left: t.left - e.width - n.x
    }
}
function _u(t) {
    return [Qe, ht, pt, Je].some(function(e) {
        return t[e] >= 0
    })
}
function UE(t) {
    var e = t.state
      , n = t.name
      , r = e.rects.reference
      , i = e.rects.popper
      , s = e.modifiersData.preventOverflow
      , o = fi(e, {
        elementContext: "reference"
    })
      , a = fi(e, {
        altBoundary: !0
    })
      , l = bu(o, r)
      , c = bu(a, i, s)
      , u = _u(l)
      , d = _u(c);
    e.modifiersData[n] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: c,
        isReferenceHidden: u,
        hasPopperEscaped: d
    },
    e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-reference-hidden": u,
        "data-popper-escaped": d
    })
}
var jE = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: UE
};
function NE(t, e, n) {
    var r = Lt(t)
      , i = [Je, Qe].indexOf(r) >= 0 ? -1 : 1
      , s = typeof n == "function" ? n(Object.assign({}, e, {
        placement: t
    })) : n
      , o = s[0]
      , a = s[1];
    return o = o || 0,
    a = (a || 0) * i,
    [Je, ht].indexOf(r) >= 0 ? {
        x: a,
        y: o
    } : {
        x: o,
        y: a
    }
}
function zE(t) {
    var e = t.state
      , n = t.options
      , r = t.name
      , i = n.offset
      , s = i === void 0 ? [0, 0] : i
      , o = dl.reduce(function(u, d) {
        return u[d] = NE(d, e.rects, s),
        u
    }, {})
      , a = o[e.placement]
      , l = a.x
      , c = a.y;
    e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l,
    e.modifiersData.popperOffsets.y += c),
    e.modifiersData[r] = o
}
var HE = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: zE
};
function KE(t) {
    var e = t.state
      , n = t.name;
    e.modifiersData[n] = yh({
        reference: e.rects.reference,
        element: e.rects.popper,
        strategy: "absolute",
        placement: e.placement
    })
}
var wh = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: KE,
    data: {}
};
function GE(t) {
    return t === "x" ? "y" : "x"
}
function qE(t) {
    var e = t.state
      , n = t.options
      , r = t.name
      , i = n.mainAxis
      , s = i === void 0 ? !0 : i
      , o = n.altAxis
      , a = o === void 0 ? !1 : o
      , l = n.boundary
      , c = n.rootBoundary
      , u = n.altBoundary
      , d = n.padding
      , m = n.tether
      , g = m === void 0 ? !0 : m
      , f = n.tetherOffset
      , h = f === void 0 ? 0 : f
      , _ = fi(e, {
        boundary: l,
        rootBoundary: c,
        padding: d,
        altBoundary: u
    })
      , p = Lt(e.placement)
      , b = br(e.placement)
      , y = !b
      , w = fl(p)
      , x = GE(w)
      , C = e.modifiersData.popperOffsets
      , P = e.rects.reference
      , T = e.rects.popper
      , L = typeof h == "function" ? h(Object.assign({}, e.rects, {
        placement: e.placement
    })) : h
      , I = typeof L == "number" ? {
        mainAxis: L,
        altAxis: L
    } : Object.assign({
        mainAxis: 0,
        altAxis: 0
    }, L)
      , U = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null
      , B = {
        x: 0,
        y: 0
    };
    if (C) {
        if (s) {
            var V, z = w === "y" ? Qe : Je, K = w === "y" ? pt : ht, A = w === "y" ? "height" : "width", X = C[w], de = X + _[z], pe = X - _[K], Pe = g ? -T[A] / 2 : 0, Be = b === fr ? P[A] : T[A], _e = b === fr ? -T[A] : -P[A], Oe = e.elements.arrow, $e = g && Oe ? hl(Oe) : {
                width: 0,
                height: 0
            }, Ne = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : fh(), Ot = Ne[z], Re = Ne[K], N = Xr(0, P[A], $e[A]), F = y ? P[A] / 2 - Pe - N - Ot - I.mainAxis : Be - N - Ot - I.mainAxis, ee = y ? -P[A] / 2 + Pe + N + Re + I.mainAxis : _e + N + Re + I.mainAxis, re = e.elements.arrow && Si(e.elements.arrow), Ie = re ? w === "y" ? re.clientTop || 0 : re.clientLeft || 0 : 0, Ke = (V = U == null ? void 0 : U[w]) != null ? V : 0, Ri = X + F - Ke - Ie, Ii = X + ee - Ke, Ar = Xr(g ? Rs(de, Ri) : de, X, g ? In(pe, Ii) : pe);
            C[w] = Ar,
            B[w] = Ar - X
        }
        if (a) {
            var Vi, Di = w === "x" ? Qe : Je, oo = w === "x" ? pt : ht, $t = C[x], Yn = x === "y" ? "height" : "width", Sr = $t + _[Di], Bi = $t - _[oo], Zn = [Qe, Je].indexOf(p) !== -1, k = (Vi = U == null ? void 0 : U[x]) != null ? Vi : 0, fe = Zn ? Sr : $t - P[Yn] - T[Yn] - k + I.altAxis, Ut = Zn ? $t + P[Yn] + T[Yn] - k - I.altAxis : Bi, kr = g && Zn ? yE(fe, $t, Ut) : Xr(g ? fe : Sr, $t, g ? Ut : Bi);
            C[x] = kr,
            B[x] = kr - $t
        }
        e.modifiersData[r] = B
    }
}
var WE = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: qE,
    requiresIfExists: ["offset"]
};
function YE(t) {
    return {
        scrollLeft: t.scrollLeft,
        scrollTop: t.scrollTop
    }
}
function ZE(t) {
    return t === Pt(t) || !ct(t) ? ml(t) : YE(t)
}
function XE(t) {
    var e = t.getBoundingClientRect()
      , n = vr(e.width) / t.offsetWidth || 1
      , r = vr(e.height) / t.offsetHeight || 1;
    return n !== 1 || r !== 1
}
function QE(t, e, n) {
    n === void 0 && (n = !1);
    var r = ct(e)
      , i = ct(e) && XE(e)
      , s = Cn(e)
      , o = gr(t, i)
      , a = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , l = {
        x: 0,
        y: 0
    };
    return (r || !r && !n) && ((Vt(e) !== "body" || gl(s)) && (a = ZE(e)),
    ct(e) ? (l = gr(e, !0),
    l.x += e.clientLeft,
    l.y += e.clientTop) : s && (l.x = vl(s))),
    {
        x: o.left + a.scrollLeft - l.x,
        y: o.top + a.scrollTop - l.y,
        width: o.width,
        height: o.height
    }
}
function JE(t) {
    var e = new Map
      , n = new Set
      , r = [];
    t.forEach(function(s) {
        e.set(s.name, s)
    });
    function i(s) {
        n.add(s.name);
        var o = [].concat(s.requires || [], s.requiresIfExists || []);
        o.forEach(function(a) {
            if (!n.has(a)) {
                var l = e.get(a);
                l && i(l)
            }
        }),
        r.push(s)
    }
    return t.forEach(function(s) {
        n.has(s.name) || i(s)
    }),
    r
}
function e2(t) {
    var e = JE(t);
    return mE.reduce(function(n, r) {
        return n.concat(e.filter(function(i) {
            return i.phase === r
        }))
    }, [])
}
function t2(t) {
    var e;
    return function() {
        return e || (e = new Promise(function(n) {
            Promise.resolve().then(function() {
                e = void 0,
                n(t())
            })
        }
        )),
        e
    }
}
function n2(t) {
    var e = t.reduce(function(n, r) {
        var i = n[r.name];
        return n[r.name] = i ? Object.assign({}, i, r, {
            options: Object.assign({}, i.options, r.options),
            data: Object.assign({}, i.data, r.data)
        }) : r,
        n
    }, {});
    return Object.keys(e).map(function(n) {
        return e[n]
    })
}
var yu = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};
function wu() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
        e[n] = arguments[n];
    return !e.some(function(r) {
        return !(r && typeof r.getBoundingClientRect == "function")
    })
}
function bl(t) {
    t === void 0 && (t = {});
    var e = t
      , n = e.defaultModifiers
      , r = n === void 0 ? [] : n
      , i = e.defaultOptions
      , s = i === void 0 ? yu : i;
    return function(o, a, l) {
        l === void 0 && (l = s);
        var c = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, yu, s),
            modifiersData: {},
            elements: {
                reference: o,
                popper: a
            },
            attributes: {},
            styles: {}
        }
          , u = []
          , d = !1
          , m = {
            state: c,
            setOptions: function(h) {
                var _ = typeof h == "function" ? h(c.options) : h;
                f(),
                c.options = Object.assign({}, s, c.options, _),
                c.scrollParents = {
                    reference: mr(o) ? Qr(o) : o.contextElement ? Qr(o.contextElement) : [],
                    popper: Qr(a)
                };
                var p = e2(n2([].concat(r, c.options.modifiers)));
                return c.orderedModifiers = p.filter(function(b) {
                    return b.enabled
                }),
                g(),
                m.update()
            },
            forceUpdate: function() {
                if (!d) {
                    var h = c.elements
                      , _ = h.reference
                      , p = h.popper;
                    if (wu(_, p)) {
                        c.rects = {
                            reference: QE(_, Si(p), c.options.strategy === "fixed"),
                            popper: hl(p)
                        },
                        c.reset = !1,
                        c.placement = c.options.placement,
                        c.orderedModifiers.forEach(function(T) {
                            return c.modifiersData[T.name] = Object.assign({}, T.data)
                        });
                        for (var b = 0; b < c.orderedModifiers.length; b++) {
                            if (c.reset === !0) {
                                c.reset = !1,
                                b = -1;
                                continue
                            }
                            var y = c.orderedModifiers[b]
                              , w = y.fn
                              , x = y.options
                              , C = x === void 0 ? {} : x
                              , P = y.name;
                            typeof w == "function" && (c = w({
                                state: c,
                                options: C,
                                name: P,
                                instance: m
                            }) || c)
                        }
                    }
                }
            },
            update: t2(function() {
                return new Promise(function(h) {
                    m.forceUpdate(),
                    h(c)
                }
                )
            }),
            destroy: function() {
                f(),
                d = !0
            }
        };
        if (!wu(o, a))
            return m;
        m.setOptions(l).then(function(h) {
            !d && l.onFirstUpdate && l.onFirstUpdate(h)
        });
        function g() {
            c.orderedModifiers.forEach(function(h) {
                var _ = h.name
                  , p = h.options
                  , b = p === void 0 ? {} : p
                  , y = h.effect;
                if (typeof y == "function") {
                    var w = y({
                        state: c,
                        name: _,
                        instance: m,
                        options: b
                    })
                      , x = function() {};
                    u.push(w || x)
                }
            })
        }
        function f() {
            u.forEach(function(h) {
                return h()
            }),
            u = []
        }
        return m
    }
}
bl();
var r2 = [bh, wh, gh, ph];
bl({
    defaultModifiers: r2
});
var i2 = [bh, wh, gh, ph, HE, $E, WE, EE, jE]
  , s2 = bl({
    defaultModifiers: i2
});
const o2 = (t, e, n={}) => {
    const r = {
        name: "updateState",
        enabled: !0,
        phase: "write",
        fn: ({state: l}) => {
            const c = a2(l);
            Object.assign(o.value, c)
        }
        ,
        requires: ["computeStyles"]
    }
      , i = E( () => {
        const {onFirstUpdate: l, placement: c, strategy: u, modifiers: d} = v(n);
        return {
            onFirstUpdate: l,
            placement: c || "bottom",
            strategy: u || "absolute",
            modifiers: [...d || [], r, {
                name: "applyStyles",
                enabled: !1
            }]
        }
    }
    )
      , s = Fn()
      , o = M({
        styles: {
            popper: {
                position: v(i).strategy,
                left: "0",
                top: "0"
            },
            arrow: {
                position: "absolute"
            }
        },
        attributes: {}
    })
      , a = () => {
        s.value && (s.value.destroy(),
        s.value = void 0)
    }
    ;
    return W(i, l => {
        const c = v(s);
        c && c.setOptions(l)
    }
    , {
        deep: !0
    }),
    W([t, e], ([l,c]) => {
        a(),
        !(!l || !c) && (s.value = s2(l, c, v(i)))
    }
    ),
    Dt( () => {
        a()
    }
    ),
    {
        state: E( () => {
            var l;
            return {
                ...((l = v(s)) == null ? void 0 : l.state) || {}
            }
        }
        ),
        styles: E( () => v(o).styles),
        attributes: E( () => v(o).attributes),
        update: () => {
            var l;
            return (l = v(s)) == null ? void 0 : l.update()
        }
        ,
        forceUpdate: () => {
            var l;
            return (l = v(s)) == null ? void 0 : l.forceUpdate()
        }
        ,
        instanceRef: E( () => v(s))
    }
}
;
function a2(t) {
    const e = Object.keys(t.elements)
      , n = Ms(e.map(i => [i, t.styles[i] || {}]))
      , r = Ms(e.map(i => [i, t.attributes[i]]));
    return {
        styles: n,
        attributes: r
    }
}
function xu() {
    let t;
    const e = (r, i) => {
        n(),
        t = window.setTimeout(r, i)
    }
      , n = () => window.clearTimeout(t);
    return Ka( () => n()),
    {
        registerTimeout: e,
        cancelTimeout: n
    }
}
const Cu = {
    prefix: Math.floor(Math.random() * 1e4),
    current: 0
}
  , l2 = Symbol("elIdInjection")
  , xh = () => Ve() ? le(l2, Cu) : Cu
  , _l = t => {
    const e = xh()
      , n = cl();
    return E( () => v(t) || `${n.value}-id-${e.prefix}-${e.current++}`)
}
;
let sr = [];
const Eu = t => {
    const e = t;
    e.key === wt.esc && sr.forEach(n => n(e))
}
  , c2 = t => {
    De( () => {
        sr.length === 0 && document.addEventListener("keydown", Eu),
        He && sr.push(t)
    }
    ),
    Dt( () => {
        sr = sr.filter(e => e !== t),
        sr.length === 0 && He && document.removeEventListener("keydown", Eu)
    }
    )
}
;
let Pu;
const Ch = () => {
    const t = cl()
      , e = xh()
      , n = E( () => `${t.value}-popper-container-${e.prefix}`)
      , r = E( () => `#${n.value}`);
    return {
        id: n,
        selector: r
    }
}
  , u2 = t => {
    const e = document.createElement("div");
    return e.id = t,
    document.body.appendChild(e),
    e
}
  , d2 = () => {
    const {id: t, selector: e} = Ch();
    return Uf( () => {
        He && (!Pu || !document.body.querySelector(e.value)) && (Pu = u2(t.value))
    }
    ),
    {
        id: t,
        selector: e
    }
}
  , p2 = Ae({
    showAfter: {
        type: Number,
        default: 0
    },
    hideAfter: {
        type: Number,
        default: 200
    },
    autoClose: {
        type: Number,
        default: 0
    }
})
  , h2 = ({showAfter: t, hideAfter: e, autoClose: n, open: r, close: i}) => {
    const {registerTimeout: s} = xu()
      , {registerTimeout: o, cancelTimeout: a} = xu();
    return {
        onOpen: u => {
            s( () => {
                r(u);
                const d = v(n);
                Jt(d) && d > 0 && o( () => {
                    i(u)
                }
                , d)
            }
            , v(t))
        }
        ,
        onClose: u => {
            a(),
            s( () => {
                i(u)
            }
            , v(e))
        }
    }
}
  , Eh = Symbol("elForwardRef")
  , f2 = t => {
    ut(Eh, {
        setForwardRef: n => {
            t.value = n
        }
    })
}
  , m2 = t => ({
    mounted(e) {
        t(e)
    },
    updated(e) {
        t(e)
    },
    unmounted() {
        t(null)
    }
})
  , Ou = {
    current: 0
}
  , Tu = M(0)
  , Ph = 2e3
  , Au = Symbol("elZIndexContextKey")
  , Oh = Symbol("zIndexContextKey")
  , Th = t => {
    const e = Ve() ? le(Au, Ou) : Ou
      , n = t || (Ve() ? le(Oh, void 0) : void 0)
      , r = E( () => {
        const o = v(n);
        return Jt(o) ? o : Ph
    }
    )
      , i = E( () => r.value + Tu.value)
      , s = () => (e.current++,
    Tu.value = e.current,
    i.value);
    return !He && le(Au),
    {
        initialZIndex: r,
        currentZIndex: i,
        nextZIndex: s
    }
}
;
function v2(t) {
    let e;
    function n() {
        if (t.value == null)
            return;
        const {selectionStart: i, selectionEnd: s, value: o} = t.value;
        if (i == null || s == null)
            return;
        const a = o.slice(0, Math.max(0, i))
          , l = o.slice(Math.max(0, s));
        e = {
            selectionStart: i,
            selectionEnd: s,
            value: o,
            beforeTxt: a,
            afterTxt: l
        }
    }
    function r() {
        if (t.value == null || e == null)
            return;
        const {value: i} = t.value
          , {beforeTxt: s, afterTxt: o, selectionStart: a} = e;
        if (s == null || o == null || a == null)
            return;
        let l = i.length;
        if (i.endsWith(o))
            l = i.length - o.length;
        else if (i.startsWith(s))
            l = s.length;
        else {
            const c = s[a - 1]
              , u = i.indexOf(c, a - 1);
            u !== -1 && (l = u + 1)
        }
        t.value.setSelectionRange(l, l)
    }
    return [n, r]
}
const ki = Xs({
    type: String,
    values: Js,
    required: !1
})
  , Ah = Symbol("size")
  , g2 = () => {
    const t = le(Ah, {});
    return E( () => v(t.size) || "")
}
;
function Sh(t, {beforeFocus: e, afterFocus: n, beforeBlur: r, afterBlur: i}={}) {
    const s = Ve()
      , {emit: o} = s
      , a = Fn()
      , l = M(!1)
      , c = m => {
        Kt(e) && e(m) || l.value || (l.value = !0,
        o("focus", m),
        n == null || n())
    }
      , u = m => {
        var g;
        Kt(r) && r(m) || m.relatedTarget && ((g = a.value) != null && g.contains(m.relatedTarget)) || (l.value = !1,
        o("blur", m),
        i == null || i())
    }
      , d = () => {
        var m, g;
        (m = a.value) != null && m.contains(document.activeElement) && a.value !== document.activeElement || (g = t.value) == null || g.focus()
    }
    ;
    return W(a, m => {
        m && m.setAttribute("tabindex", "-1")
    }
    ),
    lr(a, "focus", c, !0),
    lr(a, "blur", u, !0),
    lr(a, "click", d, !0),
    {
        isFocused: l,
        wrapperRef: a,
        handleFocus: c,
        handleBlur: u
    }
}
function b2({afterComposition: t, emit: e}) {
    const n = M(!1)
      , r = a => {
        e == null || e("compositionstart", a),
        n.value = !0
    }
      , i = a => {
        var l;
        e == null || e("compositionupdate", a);
        const c = (l = a.target) == null ? void 0 : l.value
          , u = c[c.length - 1] || "";
        n.value = !KC(u)
    }
      , s = a => {
        e == null || e("compositionend", a),
        n.value && (n.value = !1,
        ke( () => t(a)))
    }
    ;
    return {
        isComposing: n,
        handleComposition: a => {
            a.type === "compositionend" ? s(a) : i(a)
        }
        ,
        handleCompositionStart: r,
        handleCompositionUpdate: i,
        handleCompositionEnd: s
    }
}
const _2 = Symbol("emptyValuesContextKey");
Ae({
    emptyValues: Array,
    valueOnClear: {
        type: [String, Number, Boolean, Function],
        default: void 0,
        validator: t => Kt(t) ? !t() : !t
    }
});
const y2 = Ae({
    ariaLabel: String,
    ariaOrientation: {
        type: String,
        values: ["horizontal", "vertical", "undefined"]
    },
    ariaControls: String
})
  , Er = t => nh(y2, t)
  , kh = Symbol()
  , Is = M();
function yl(t, e=void 0) {
    const n = Ve() ? le(kh, Is) : Is;
    return t ? E( () => {
        var r, i;
        return (i = (r = n.value) == null ? void 0 : r[t]) != null ? i : e
    }
    ) : n
}
function w2(t, e) {
    const n = yl()
      , r = we(t, E( () => {
        var a;
        return ((a = n.value) == null ? void 0 : a.namespace) || cs
    }
    ))
      , i = ll(E( () => {
        var a;
        return (a = n.value) == null ? void 0 : a.locale
    }
    ))
      , s = Th(E( () => {
        var a;
        return ((a = n.value) == null ? void 0 : a.zIndex) || Ph
    }
    ))
      , o = E( () => {
        var a;
        return v(e) || ((a = n.value) == null ? void 0 : a.size) || ""
    }
    );
    return x2(E( () => v(n) || {})),
    {
        ns: r,
        locale: i,
        zIndex: s,
        size: o
    }
}
const x2 = (t, e, n=!1) => {
    var r;
    const i = !!Ve()
      , s = i ? yl() : void 0
      , o = (r = void 0) != null ? r : i ? ut : void 0;
    if (!o)
        return;
    const a = E( () => {
        const l = v(t);
        return s != null && s.value ? C2(s.value, l) : l
    }
    );
    return o(kh, a),
    o(lh, E( () => a.value.locale)),
    o(ch, E( () => a.value.namespace)),
    o(Oh, E( () => a.value.zIndex)),
    o(Ah, {
        size: E( () => a.value.size || "")
    }),
    o(_2, E( () => ({
        emptyValues: a.value.emptyValues,
        valueOnClear: a.value.valueOnClear
    }))),
    (n || !Is.value) && (Is.value = a.value),
    a
}
  , C2 = (t, e) => {
    const n = [...new Set([...du(t), ...du(e)])]
      , r = {};
    for (const i of n)
        r[i] = e[i] !== void 0 ? e[i] : t[i];
    return r
}
;
var xe = (t, e) => {
    const n = t.__vccOpts || t;
    for (const [r,i] of e)
        n[r] = i;
    return n
}
;
const E2 = Ae({
    size: {
        type: te([Number, String])
    },
    color: {
        type: String
    }
})
  , P2 = H({
    name: "ElIcon",
    inheritAttrs: !1
})
  , O2 = H({
    ...P2,
    props: E2,
    setup(t) {
        const e = t
          , n = we("icon")
          , r = E( () => {
            const {size: i, color: s} = e;
            return !i && !s ? {} : {
                fontSize: di(i) ? void 0 : pi(i),
                "--color": s
            }
        }
        );
        return (i, s) => (S(),
        j("i", Wt({
            class: v(n).b(),
            style: v(r)
        }, i.$attrs), [he(i.$slots, "default")], 16))
    }
});
var T2 = xe(O2, [["__file", "icon.vue"]]);
const St = Bt(T2)
  , Pr = Symbol("formContextKey")
  , zn = Symbol("formItemContextKey")
  , xn = (t, e={}) => {
    const n = M(void 0)
      , r = e.prop ? n : uh("size")
      , i = e.global ? n : g2()
      , s = e.form ? {
        size: void 0
    } : le(Pr, void 0)
      , o = e.formItem ? {
        size: void 0
    } : le(zn, void 0);
    return E( () => r.value || v(t) || (o == null ? void 0 : o.size) || (s == null ? void 0 : s.size) || i.value || "")
}
  , Mi = t => {
    const e = uh("disabled")
      , n = le(Pr, void 0);
    return E( () => e.value || v(t) || (n == null ? void 0 : n.disabled) || !1)
}
  , Or = () => {
    const t = le(Pr, void 0)
      , e = le(zn, void 0);
    return {
        form: t,
        formItem: e
    }
}
  , to = (t, {formItemContext: e, disableIdGeneration: n, disableIdManagement: r}) => {
    n || (n = M(!1)),
    r || (r = M(!1));
    const i = M();
    let s;
    const o = E( () => {
        var a;
        return !!(!(t.label || t.ariaLabel) && e && e.inputIds && ((a = e.inputIds) == null ? void 0 : a.length) <= 1)
    }
    );
    return De( () => {
        s = W([Gt(t, "id"), n], ([a,l]) => {
            const c = a ?? (l ? void 0 : _l().value);
            c !== i.value && (e != null && e.removeInputId && (i.value && e.removeInputId(i.value),
            !(r != null && r.value) && !l && c && e.addInputId(c)),
            i.value = c)
        }
        , {
            immediate: !0
        })
    }
    ),
    jf( () => {
        s && s(),
        e != null && e.removeInputId && i.value && e.removeInputId(i.value)
    }
    ),
    {
        isLabeledByFormItem: o,
        inputId: i
    }
}
  , A2 = Ae({
    size: {
        type: String,
        values: Js
    },
    disabled: Boolean
})
  , S2 = Ae({
    ...A2,
    model: Object,
    rules: {
        type: te(Object)
    },
    labelPosition: {
        type: String,
        values: ["left", "right", "top"],
        default: "right"
    },
    requireAsteriskPosition: {
        type: String,
        values: ["left", "right"],
        default: "left"
    },
    labelWidth: {
        type: [String, Number],
        default: ""
    },
    labelSuffix: {
        type: String,
        default: ""
    },
    inline: Boolean,
    inlineMessage: Boolean,
    statusIcon: Boolean,
    showMessage: {
        type: Boolean,
        default: !0
    },
    validateOnRuleChange: {
        type: Boolean,
        default: !0
    },
    hideRequiredAsterisk: Boolean,
    scrollToError: Boolean,
    scrollIntoViewOptions: {
        type: [Object, Boolean]
    }
})
  , k2 = {
    validate: (t, e, n) => (Dn(t) || ze(t)) && Nn(e) && ze(n)
};
function M2() {
    const t = M([])
      , e = E( () => {
        if (!t.value.length)
            return "0";
        const s = Math.max(...t.value);
        return s ? `${s}px` : ""
    }
    );
    function n(s) {
        const o = t.value.indexOf(s);
        return o === -1 && e.value,
        o
    }
    function r(s, o) {
        if (s && o) {
            const a = n(o);
            t.value.splice(a, 1, s)
        } else
            s && t.value.push(s)
    }
    function i(s) {
        const o = n(s);
        o > -1 && t.value.splice(o, 1)
    }
    return {
        autoLabelWidth: e,
        registerLabelWidth: r,
        deregisterLabelWidth: i
    }
}
const Zi = (t, e) => {
    const n = Go(e);
    return n.length > 0 ? t.filter(r => r.prop && n.includes(r.prop)) : t
}
  , L2 = "ElForm"
  , F2 = H({
    name: L2
})
  , R2 = H({
    ...F2,
    props: S2,
    emits: k2,
    setup(t, {expose: e, emit: n}) {
        const r = t
          , i = []
          , s = xn()
          , o = we("form")
          , a = E( () => {
            const {labelPosition: y, inline: w} = r;
            return [o.b(), o.m(s.value || "default"), {
                [o.m(`label-${y}`)]: y,
                [o.m("inline")]: w
            }]
        }
        )
          , l = y => i.find(w => w.prop === y)
          , c = y => {
            i.push(y)
        }
          , u = y => {
            y.prop && i.splice(i.indexOf(y), 1)
        }
          , d = (y=[]) => {
            r.model && Zi(i, y).forEach(w => w.resetField())
        }
          , m = (y=[]) => {
            Zi(i, y).forEach(w => w.clearValidate())
        }
          , g = E( () => !!r.model)
          , f = y => {
            if (i.length === 0)
                return [];
            const w = Zi(i, y);
            return w.length ? w : []
        }
          , h = async y => p(void 0, y)
          , _ = async (y=[]) => {
            if (!g.value)
                return !1;
            const w = f(y);
            if (w.length === 0)
                return !0;
            let x = {};
            for (const C of w)
                try {
                    await C.validate("")
                } catch (P) {
                    x = {
                        ...x,
                        ...P
                    }
                }
            return Object.keys(x).length === 0 ? !0 : Promise.reject(x)
        }
          , p = async (y=[], w) => {
            const x = !Kt(w);
            try {
                const C = await _(y);
                return C === !0 && await (w == null ? void 0 : w(C)),
                C
            } catch (C) {
                if (C instanceof Error)
                    throw C;
                const P = C;
                return r.scrollToError && b(Object.keys(P)[0]),
                await (w == null ? void 0 : w(!1, P)),
                x && Promise.reject(P)
            }
        }
          , b = y => {
            var w;
            const x = Zi(i, y)[0];
            x && ((w = x.$el) == null || w.scrollIntoView(r.scrollIntoViewOptions))
        }
        ;
        return W( () => r.rules, () => {
            r.validateOnRuleChange && h().catch(y => void 0)
        }
        , {
            deep: !0
        }),
        ut(Pr, Hn({
            ...Us(r),
            emit: n,
            resetFields: d,
            clearValidate: m,
            validateField: p,
            getField: l,
            addField: c,
            removeField: u,
            ...M2()
        })),
        e({
            validate: h,
            validateField: p,
            resetFields: d,
            clearValidate: m,
            scrollToField: b,
            fields: i
        }),
        (y, w) => (S(),
        j("form", {
            class: D(v(a))
        }, [he(y.$slots, "default")], 2))
    }
});
var I2 = xe(R2, [["__file", "form.vue"]]);
function Mn() {
    return Mn = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n)
                Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }
    ,
    Mn.apply(this, arguments)
}
function V2(t, e) {
    t.prototype = Object.create(e.prototype),
    t.prototype.constructor = t,
    mi(t, e)
}
function Jo(t) {
    return Jo = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
        return n.__proto__ || Object.getPrototypeOf(n)
    }
    ,
    Jo(t)
}
function mi(t, e) {
    return mi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
        return r.__proto__ = i,
        r
    }
    ,
    mi(t, e)
}
function D2() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return !1;
    if (typeof Proxy == "function")
        return !0;
    try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})),
        !0
    } catch {
        return !1
    }
}
function ds(t, e, n) {
    return D2() ? ds = Reflect.construct.bind() : ds = function(i, s, o) {
        var a = [null];
        a.push.apply(a, s);
        var l = Function.bind.apply(i, a)
          , c = new l;
        return o && mi(c, o.prototype),
        c
    }
    ,
    ds.apply(null, arguments)
}
function B2(t) {
    return Function.toString.call(t).indexOf("[native code]") !== -1
}
function ea(t) {
    var e = typeof Map == "function" ? new Map : void 0;
    return ea = function(r) {
        if (r === null || !B2(r))
            return r;
        if (typeof r != "function")
            throw new TypeError("Super expression must either be null or a function");
        if (typeof e < "u") {
            if (e.has(r))
                return e.get(r);
            e.set(r, i)
        }
        function i() {
            return ds(r, arguments, Jo(this).constructor)
        }
        return i.prototype = Object.create(r.prototype, {
            constructor: {
                value: i,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }),
        mi(i, r)
    }
    ,
    ea(t)
}
var $2 = /%[sdj%]/g
  , U2 = function() {};
function ta(t) {
    if (!t || !t.length)
        return null;
    var e = {};
    return t.forEach(function(n) {
        var r = n.field;
        e[r] = e[r] || [],
        e[r].push(n)
    }),
    e
}
function nt(t) {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
        n[r - 1] = arguments[r];
    var i = 0
      , s = n.length;
    if (typeof t == "function")
        return t.apply(null, n);
    if (typeof t == "string") {
        var o = t.replace($2, function(a) {
            if (a === "%%")
                return "%";
            if (i >= s)
                return a;
            switch (a) {
            case "%s":
                return String(n[i++]);
            case "%d":
                return Number(n[i++]);
            case "%j":
                try {
                    return JSON.stringify(n[i++])
                } catch {
                    return "[Circular]"
                }
                break;
            default:
                return a
            }
        });
        return o
    }
    return t
}
function j2(t) {
    return t === "string" || t === "url" || t === "hex" || t === "email" || t === "date" || t === "pattern"
}
function Fe(t, e) {
    return !!(t == null || e === "array" && Array.isArray(t) && !t.length || j2(e) && typeof t == "string" && !t)
}
function N2(t, e, n) {
    var r = []
      , i = 0
      , s = t.length;
    function o(a) {
        r.push.apply(r, a || []),
        i++,
        i === s && n(r)
    }
    t.forEach(function(a) {
        e(a, o)
    })
}
function Su(t, e, n) {
    var r = 0
      , i = t.length;
    function s(o) {
        if (o && o.length) {
            n(o);
            return
        }
        var a = r;
        r = r + 1,
        a < i ? e(t[a], s) : n([])
    }
    s([])
}
function z2(t) {
    var e = [];
    return Object.keys(t).forEach(function(n) {
        e.push.apply(e, t[n] || [])
    }),
    e
}
var ku = function(t) {
    V2(e, t);
    function e(n, r) {
        var i;
        return i = t.call(this, "Async Validation Error") || this,
        i.errors = n,
        i.fields = r,
        i
    }
    return e
}(ea(Error));
function H2(t, e, n, r, i) {
    if (e.first) {
        var s = new Promise(function(m, g) {
            var f = function(p) {
                return r(p),
                p.length ? g(new ku(p,ta(p))) : m(i)
            }
              , h = z2(t);
            Su(h, n, f)
        }
        );
        return s.catch(function(m) {
            return m
        }),
        s
    }
    var o = e.firstFields === !0 ? Object.keys(t) : e.firstFields || []
      , a = Object.keys(t)
      , l = a.length
      , c = 0
      , u = []
      , d = new Promise(function(m, g) {
        var f = function(_) {
            if (u.push.apply(u, _),
            c++,
            c === l)
                return r(u),
                u.length ? g(new ku(u,ta(u))) : m(i)
        };
        a.length || (r(u),
        m(i)),
        a.forEach(function(h) {
            var _ = t[h];
            o.indexOf(h) !== -1 ? Su(_, n, f) : N2(_, n, f)
        })
    }
    );
    return d.catch(function(m) {
        return m
    }),
    d
}
function K2(t) {
    return !!(t && t.message !== void 0)
}
function G2(t, e) {
    for (var n = t, r = 0; r < e.length; r++) {
        if (n == null)
            return n;
        n = n[e[r]]
    }
    return n
}
function Mu(t, e) {
    return function(n) {
        var r;
        return t.fullFields ? r = G2(e, t.fullFields) : r = e[n.field || t.fullField],
        K2(n) ? (n.field = n.field || t.fullField,
        n.fieldValue = r,
        n) : {
            message: typeof n == "function" ? n() : n,
            fieldValue: r,
            field: n.field || t.fullField
        }
    }
}
function Lu(t, e) {
    if (e) {
        for (var n in e)
            if (e.hasOwnProperty(n)) {
                var r = e[n];
                typeof r == "object" && typeof t[n] == "object" ? t[n] = Mn({}, t[n], r) : t[n] = r
            }
    }
    return t
}
var Mh = function(e, n, r, i, s, o) {
    e.required && (!r.hasOwnProperty(e.field) || Fe(n, o || e.type)) && i.push(nt(s.messages.required, e.fullField))
}, q2 = function(e, n, r, i, s) {
    (/^\s+$/.test(n) || n === "") && i.push(nt(s.messages.whitespace, e.fullField))
}, Xi, W2 = function() {
    if (Xi)
        return Xi;
    var t = "[a-fA-F\\d:]"
      , e = function(w) {
        return w && w.includeBoundaries ? "(?:(?<=\\s|^)(?=" + t + ")|(?<=" + t + ")(?=\\s|$))" : ""
    }
      , n = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}"
      , r = "[a-fA-F\\d]{1,4}"
      , i = (`
(?:
(?:` + r + ":){7}(?:" + r + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + r + ":){6}(?:" + n + "|:" + r + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + r + ":){5}(?::" + n + "|(?::" + r + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + r + ":){4}(?:(?::" + r + "){0,1}:" + n + "|(?::" + r + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + r + ":){3}(?:(?::" + r + "){0,2}:" + n + "|(?::" + r + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + r + ":){2}(?:(?::" + r + "){0,3}:" + n + "|(?::" + r + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + r + ":){1}(?:(?::" + r + "){0,4}:" + n + "|(?::" + r + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + r + "){0,5}:" + n + "|(?::" + r + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim()
      , s = new RegExp("(?:^" + n + "$)|(?:^" + i + "$)")
      , o = new RegExp("^" + n + "$")
      , a = new RegExp("^" + i + "$")
      , l = function(w) {
        return w && w.exact ? s : new RegExp("(?:" + e(w) + n + e(w) + ")|(?:" + e(w) + i + e(w) + ")","g")
    };
    l.v4 = function(y) {
        return y && y.exact ? o : new RegExp("" + e(y) + n + e(y),"g")
    }
    ,
    l.v6 = function(y) {
        return y && y.exact ? a : new RegExp("" + e(y) + i + e(y),"g")
    }
    ;
    var c = "(?:(?:[a-z]+:)?//)"
      , u = "(?:\\S+(?::\\S*)?@)?"
      , d = l.v4().source
      , m = l.v6().source
      , g = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)"
      , f = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*"
      , h = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))"
      , _ = "(?::\\d{2,5})?"
      , p = '(?:[/?#][^\\s"]*)?'
      , b = "(?:" + c + "|www\\.)" + u + "(?:localhost|" + d + "|" + m + "|" + g + f + h + ")" + _ + p;
    return Xi = new RegExp("(?:^" + b + "$)","i"),
    Xi
}, Fu = {
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, Gr = {
    integer: function(e) {
        return Gr.number(e) && parseInt(e, 10) === e
    },
    float: function(e) {
        return Gr.number(e) && !Gr.integer(e)
    },
    array: function(e) {
        return Array.isArray(e)
    },
    regexp: function(e) {
        if (e instanceof RegExp)
            return !0;
        try {
            return !!new RegExp(e)
        } catch {
            return !1
        }
    },
    date: function(e) {
        return typeof e.getTime == "function" && typeof e.getMonth == "function" && typeof e.getYear == "function" && !isNaN(e.getTime())
    },
    number: function(e) {
        return isNaN(e) ? !1 : typeof e == "number"
    },
    object: function(e) {
        return typeof e == "object" && !Gr.array(e)
    },
    method: function(e) {
        return typeof e == "function"
    },
    email: function(e) {
        return typeof e == "string" && e.length <= 320 && !!e.match(Fu.email)
    },
    url: function(e) {
        return typeof e == "string" && e.length <= 2048 && !!e.match(W2())
    },
    hex: function(e) {
        return typeof e == "string" && !!e.match(Fu.hex)
    }
}, Y2 = function(e, n, r, i, s) {
    if (e.required && n === void 0) {
        Mh(e, n, r, i, s);
        return
    }
    var o = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"]
      , a = e.type;
    o.indexOf(a) > -1 ? Gr[a](n) || i.push(nt(s.messages.types[a], e.fullField, e.type)) : a && typeof n !== e.type && i.push(nt(s.messages.types[a], e.fullField, e.type))
}, Z2 = function(e, n, r, i, s) {
    var o = typeof e.len == "number"
      , a = typeof e.min == "number"
      , l = typeof e.max == "number"
      , c = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g
      , u = n
      , d = null
      , m = typeof n == "number"
      , g = typeof n == "string"
      , f = Array.isArray(n);
    if (m ? d = "number" : g ? d = "string" : f && (d = "array"),
    !d)
        return !1;
    f && (u = n.length),
    g && (u = n.replace(c, "_").length),
    o ? u !== e.len && i.push(nt(s.messages[d].len, e.fullField, e.len)) : a && !l && u < e.min ? i.push(nt(s.messages[d].min, e.fullField, e.min)) : l && !a && u > e.max ? i.push(nt(s.messages[d].max, e.fullField, e.max)) : a && l && (u < e.min || u > e.max) && i.push(nt(s.messages[d].range, e.fullField, e.min, e.max))
}, rr = "enum", X2 = function(e, n, r, i, s) {
    e[rr] = Array.isArray(e[rr]) ? e[rr] : [],
    e[rr].indexOf(n) === -1 && i.push(nt(s.messages[rr], e.fullField, e[rr].join(", ")))
}, Q2 = function(e, n, r, i, s) {
    if (e.pattern) {
        if (e.pattern instanceof RegExp)
            e.pattern.lastIndex = 0,
            e.pattern.test(n) || i.push(nt(s.messages.pattern.mismatch, e.fullField, n, e.pattern));
        else if (typeof e.pattern == "string") {
            var o = new RegExp(e.pattern);
            o.test(n) || i.push(nt(s.messages.pattern.mismatch, e.fullField, n, e.pattern))
        }
    }
}, ne = {
    required: Mh,
    whitespace: q2,
    type: Y2,
    range: Z2,
    enum: X2,
    pattern: Q2
}, J2 = function(e, n, r, i, s) {
    var o = []
      , a = e.required || !e.required && i.hasOwnProperty(e.field);
    if (a) {
        if (Fe(n, "string") && !e.required)
            return r();
        ne.required(e, n, i, o, s, "string"),
        Fe(n, "string") || (ne.type(e, n, i, o, s),
        ne.range(e, n, i, o, s),
        ne.pattern(e, n, i, o, s),
        e.whitespace === !0 && ne.whitespace(e, n, i, o, s))
    }
    r(o)
}, eP = function(e, n, r, i, s) {
    var o = []
      , a = e.required || !e.required && i.hasOwnProperty(e.field);
    if (a) {
        if (Fe(n) && !e.required)
            return r();
        ne.required(e, n, i, o, s),
        n !== void 0 && ne.type(e, n, i, o, s)
    }
    r(o)
}, tP = function(e, n, r, i, s) {
    var o = []
      , a = e.required || !e.required && i.hasOwnProperty(e.field);
    if (a) {
        if (n === "" && (n = void 0),
        Fe(n) && !e.required)
            return r();
        ne.required(e, n, i, o, s),
        n !== void 0 && (ne.type(e, n, i, o, s),
        ne.range(e, n, i, o, s))
    }
    r(o)
}, nP = function(e, n, r, i, s) {
    var o = []
      , a = e.required || !e.required && i.hasOwnProperty(e.field);
    if (a) {
        if (Fe(n) && !e.required)
            return r();
        ne.required(e, n, i, o, s),
        n !== void 0 && ne.type(e, n, i, o, s)
    }
    r(o)
}, rP = function(e, n, r, i, s) {
    var o = []
      , a = e.required || !e.required && i.hasOwnProperty(e.field);
    if (a) {
        if (Fe(n) && !e.required)
            return r();
        ne.required(e, n, i, o, s),
        Fe(n) || ne.type(e, n, i, o, s)
    }
    r(o)
}, iP = function(e, n, r, i, s) {
    var o = []
      , a = e.required || !e.required && i.hasOwnProperty(e.field);
    if (a) {
        if (Fe(n) && !e.required)
            return r();
        ne.required(e, n, i, o, s),
        n !== void 0 && (ne.type(e, n, i, o, s),
        ne.range(e, n, i, o, s))
    }
    r(o)
}, sP = function(e, n, r, i, s) {
    var o = []
      , a = e.required || !e.required && i.hasOwnProperty(e.field);
    if (a) {
        if (Fe(n) && !e.required)
            return r();
        ne.required(e, n, i, o, s),
        n !== void 0 && (ne.type(e, n, i, o, s),
        ne.range(e, n, i, o, s))
    }
    r(o)
}, oP = function(e, n, r, i, s) {
    var o = []
      , a = e.required || !e.required && i.hasOwnProperty(e.field);
    if (a) {
        if (n == null && !e.required)
            return r();
        ne.required(e, n, i, o, s, "array"),
        n != null && (ne.type(e, n, i, o, s),
        ne.range(e, n, i, o, s))
    }
    r(o)
}, aP = function(e, n, r, i, s) {
    var o = []
      , a = e.required || !e.required && i.hasOwnProperty(e.field);
    if (a) {
        if (Fe(n) && !e.required)
            return r();
        ne.required(e, n, i, o, s),
        n !== void 0 && ne.type(e, n, i, o, s)
    }
    r(o)
}, lP = "enum", cP = function(e, n, r, i, s) {
    var o = []
      , a = e.required || !e.required && i.hasOwnProperty(e.field);
    if (a) {
        if (Fe(n) && !e.required)
            return r();
        ne.required(e, n, i, o, s),
        n !== void 0 && ne[lP](e, n, i, o, s)
    }
    r(o)
}, uP = function(e, n, r, i, s) {
    var o = []
      , a = e.required || !e.required && i.hasOwnProperty(e.field);
    if (a) {
        if (Fe(n, "string") && !e.required)
            return r();
        ne.required(e, n, i, o, s),
        Fe(n, "string") || ne.pattern(e, n, i, o, s)
    }
    r(o)
}, dP = function(e, n, r, i, s) {
    var o = []
      , a = e.required || !e.required && i.hasOwnProperty(e.field);
    if (a) {
        if (Fe(n, "date") && !e.required)
            return r();
        if (ne.required(e, n, i, o, s),
        !Fe(n, "date")) {
            var l;
            n instanceof Date ? l = n : l = new Date(n),
            ne.type(e, l, i, o, s),
            l && ne.range(e, l.getTime(), i, o, s)
        }
    }
    r(o)
}, pP = function(e, n, r, i, s) {
    var o = []
      , a = Array.isArray(n) ? "array" : typeof n;
    ne.required(e, n, i, o, s, a),
    r(o)
}, So = function(e, n, r, i, s) {
    var o = e.type
      , a = []
      , l = e.required || !e.required && i.hasOwnProperty(e.field);
    if (l) {
        if (Fe(n, o) && !e.required)
            return r();
        ne.required(e, n, i, a, s, o),
        Fe(n, o) || ne.type(e, n, i, a, s)
    }
    r(a)
}, hP = function(e, n, r, i, s) {
    var o = []
      , a = e.required || !e.required && i.hasOwnProperty(e.field);
    if (a) {
        if (Fe(n) && !e.required)
            return r();
        ne.required(e, n, i, o, s)
    }
    r(o)
}, Jr = {
    string: J2,
    method: eP,
    number: tP,
    boolean: nP,
    regexp: rP,
    integer: iP,
    float: sP,
    array: oP,
    object: aP,
    enum: cP,
    pattern: uP,
    date: dP,
    url: So,
    hex: So,
    email: So,
    required: pP,
    any: hP
};
function na() {
    return {
        default: "Validation error on field %s",
        required: "%s is required",
        enum: "%s must be one of %s",
        whitespace: "%s cannot be empty",
        date: {
            format: "%s date %s is invalid for format %s",
            parse: "%s date could not be parsed, %s is invalid ",
            invalid: "%s date %s is invalid"
        },
        types: {
            string: "%s is not a %s",
            method: "%s is not a %s (function)",
            array: "%s is not an %s",
            object: "%s is not an %s",
            number: "%s is not a %s",
            date: "%s is not a %s",
            boolean: "%s is not a %s",
            integer: "%s is not an %s",
            float: "%s is not a %s",
            regexp: "%s is not a valid %s",
            email: "%s is not a valid %s",
            url: "%s is not a valid %s",
            hex: "%s is not a valid %s"
        },
        string: {
            len: "%s must be exactly %s characters",
            min: "%s must be at least %s characters",
            max: "%s cannot be longer than %s characters",
            range: "%s must be between %s and %s characters"
        },
        number: {
            len: "%s must equal %s",
            min: "%s cannot be less than %s",
            max: "%s cannot be greater than %s",
            range: "%s must be between %s and %s"
        },
        array: {
            len: "%s must be exactly %s in length",
            min: "%s cannot be less than %s in length",
            max: "%s cannot be greater than %s in length",
            range: "%s must be between %s and %s in length"
        },
        pattern: {
            mismatch: "%s value %s does not match pattern %s"
        },
        clone: function() {
            var e = JSON.parse(JSON.stringify(this));
            return e.clone = this.clone,
            e
        }
    }
}
var ra = na()
  , Li = function() {
    function t(n) {
        this.rules = null,
        this._messages = ra,
        this.define(n)
    }
    var e = t.prototype;
    return e.define = function(r) {
        var i = this;
        if (!r)
            throw new Error("Cannot configure a schema with no rules");
        if (typeof r != "object" || Array.isArray(r))
            throw new Error("Rules must be an object");
        this.rules = {},
        Object.keys(r).forEach(function(s) {
            var o = r[s];
            i.rules[s] = Array.isArray(o) ? o : [o]
        })
    }
    ,
    e.messages = function(r) {
        return r && (this._messages = Lu(na(), r)),
        this._messages
    }
    ,
    e.validate = function(r, i, s) {
        var o = this;
        i === void 0 && (i = {}),
        s === void 0 && (s = function() {}
        );
        var a = r
          , l = i
          , c = s;
        if (typeof l == "function" && (c = l,
        l = {}),
        !this.rules || Object.keys(this.rules).length === 0)
            return c && c(null, a),
            Promise.resolve(a);
        function u(h) {
            var _ = []
              , p = {};
            function b(w) {
                if (Array.isArray(w)) {
                    var x;
                    _ = (x = _).concat.apply(x, w)
                } else
                    _.push(w)
            }
            for (var y = 0; y < h.length; y++)
                b(h[y]);
            _.length ? (p = ta(_),
            c(_, p)) : c(null, a)
        }
        if (l.messages) {
            var d = this.messages();
            d === ra && (d = na()),
            Lu(d, l.messages),
            l.messages = d
        } else
            l.messages = this.messages();
        var m = {}
          , g = l.keys || Object.keys(this.rules);
        g.forEach(function(h) {
            var _ = o.rules[h]
              , p = a[h];
            _.forEach(function(b) {
                var y = b;
                typeof y.transform == "function" && (a === r && (a = Mn({}, a)),
                p = a[h] = y.transform(p)),
                typeof y == "function" ? y = {
                    validator: y
                } : y = Mn({}, y),
                y.validator = o.getValidationMethod(y),
                y.validator && (y.field = h,
                y.fullField = y.fullField || h,
                y.type = o.getType(y),
                m[h] = m[h] || [],
                m[h].push({
                    rule: y,
                    value: p,
                    source: a,
                    field: h
                }))
            })
        });
        var f = {};
        return H2(m, l, function(h, _) {
            var p = h.rule
              , b = (p.type === "object" || p.type === "array") && (typeof p.fields == "object" || typeof p.defaultField == "object");
            b = b && (p.required || !p.required && h.value),
            p.field = h.field;
            function y(C, P) {
                return Mn({}, P, {
                    fullField: p.fullField + "." + C,
                    fullFields: p.fullFields ? [].concat(p.fullFields, [C]) : [C]
                })
            }
            function w(C) {
                C === void 0 && (C = []);
                var P = Array.isArray(C) ? C : [C];
                !l.suppressWarning && P.length && t.warning("async-validator:", P),
                P.length && p.message !== void 0 && (P = [].concat(p.message));
                var T = P.map(Mu(p, a));
                if (l.first && T.length)
                    return f[p.field] = 1,
                    _(T);
                if (!b)
                    _(T);
                else {
                    if (p.required && !h.value)
                        return p.message !== void 0 ? T = [].concat(p.message).map(Mu(p, a)) : l.error && (T = [l.error(p, nt(l.messages.required, p.field))]),
                        _(T);
                    var L = {};
                    p.defaultField && Object.keys(h.value).map(function(B) {
                        L[B] = p.defaultField
                    }),
                    L = Mn({}, L, h.rule.fields);
                    var I = {};
                    Object.keys(L).forEach(function(B) {
                        var V = L[B]
                          , z = Array.isArray(V) ? V : [V];
                        I[B] = z.map(y.bind(null, B))
                    });
                    var U = new t(I);
                    U.messages(l.messages),
                    h.rule.options && (h.rule.options.messages = l.messages,
                    h.rule.options.error = l.error),
                    U.validate(h.value, h.rule.options || l, function(B) {
                        var V = [];
                        T && T.length && V.push.apply(V, T),
                        B && B.length && V.push.apply(V, B),
                        _(V.length ? V : null)
                    })
                }
            }
            var x;
            if (p.asyncValidator)
                x = p.asyncValidator(p, h.value, w, h.source, l);
            else if (p.validator) {
                try {
                    x = p.validator(p, h.value, w, h.source, l)
                } catch (C) {
                    console.error == null || console.error(C),
                    l.suppressValidatorError || setTimeout(function() {
                        throw C
                    }, 0),
                    w(C.message)
                }
                x === !0 ? w() : x === !1 ? w(typeof p.message == "function" ? p.message(p.fullField || p.field) : p.message || (p.fullField || p.field) + " fails") : x instanceof Array ? w(x) : x instanceof Error && w(x.message)
            }
            x && x.then && x.then(function() {
                return w()
            }, function(C) {
                return w(C)
            })
        }, function(h) {
            u(h)
        }, a)
    }
    ,
    e.getType = function(r) {
        if (r.type === void 0 && r.pattern instanceof RegExp && (r.type = "pattern"),
        typeof r.validator != "function" && r.type && !Jr.hasOwnProperty(r.type))
            throw new Error(nt("Unknown rule type %s", r.type));
        return r.type || "string"
    }
    ,
    e.getValidationMethod = function(r) {
        if (typeof r.validator == "function")
            return r.validator;
        var i = Object.keys(r)
          , s = i.indexOf("message");
        return s !== -1 && i.splice(s, 1),
        i.length === 1 && i[0] === "required" ? Jr.required : Jr[this.getType(r)] || void 0
    }
    ,
    t
}();
Li.register = function(e, n) {
    if (typeof n != "function")
        throw new Error("Cannot register a validator by type, validator is not a function");
    Jr[e] = n
}
;
Li.warning = U2;
Li.messages = ra;
Li.validators = Jr;
const fP = ["", "error", "validating", "success"]
  , mP = Ae({
    label: String,
    labelWidth: {
        type: [String, Number],
        default: ""
    },
    labelPosition: {
        type: String,
        values: ["left", "right", "top", ""],
        default: ""
    },
    prop: {
        type: te([String, Array])
    },
    required: {
        type: Boolean,
        default: void 0
    },
    rules: {
        type: te([Object, Array])
    },
    error: String,
    validateStatus: {
        type: String,
        values: fP
    },
    for: String,
    inlineMessage: {
        type: [String, Boolean],
        default: ""
    },
    showMessage: {
        type: Boolean,
        default: !0
    },
    size: {
        type: String,
        values: Js
    }
})
  , Ru = "ElLabelWrap";
var vP = H({
    name: Ru,
    props: {
        isAutoWidth: Boolean,
        updateAll: Boolean
    },
    setup(t, {slots: e}) {
        const n = le(Pr, void 0)
          , r = le(zn);
        r || kC(Ru, "usage: <el-form-item><label-wrap /></el-form-item>");
        const i = we("form")
          , s = M()
          , o = M(0)
          , a = () => {
            var u;
            if ((u = s.value) != null && u.firstElementChild) {
                const d = window.getComputedStyle(s.value.firstElementChild).width;
                return Math.ceil(Number.parseFloat(d))
            } else
                return 0
        }
          , l = (u="update") => {
            ke( () => {
                e.default && t.isAutoWidth && (u === "update" ? o.value = a() : u === "remove" && (n == null || n.deregisterLabelWidth(o.value)))
            }
            )
        }
          , c = () => l("update");
        return De( () => {
            c()
        }
        ),
        Dt( () => {
            l("remove")
        }
        ),
        Nf( () => c()),
        W(o, (u, d) => {
            t.updateAll && (n == null || n.registerLabelWidth(u, d))
        }
        ),
        kp(E( () => {
            var u, d;
            return (d = (u = s.value) == null ? void 0 : u.firstElementChild) != null ? d : null
        }
        ), c),
        () => {
            var u, d;
            if (!e)
                return null;
            const {isAutoWidth: m} = t;
            if (m) {
                const g = n == null ? void 0 : n.autoLabelWidth
                  , f = r == null ? void 0 : r.hasLabel
                  , h = {};
                if (f && g && g !== "auto") {
                    const _ = Math.max(0, Number.parseInt(g, 10) - o.value)
                      , b = (r.labelPosition || n.labelPosition) === "left" ? "marginRight" : "marginLeft";
                    _ && (h[b] = `${_}px`)
                }
                return Y("div", {
                    ref: s,
                    class: [i.be("item", "label-wrap")],
                    style: h
                }, [(u = e.default) == null ? void 0 : u.call(e)])
            } else
                return Y(Ze, {
                    ref: s
                }, [(d = e.default) == null ? void 0 : d.call(e)])
        }
    }
});
const gP = H({
    name: "ElFormItem"
})
  , bP = H({
    ...gP,
    props: mP,
    setup(t, {expose: e}) {
        const n = t
          , r = gi()
          , i = le(Pr, void 0)
          , s = le(zn, void 0)
          , o = xn(void 0, {
            formItem: !1
        })
          , a = we("form-item")
          , l = _l().value
          , c = M([])
          , u = M("")
          , d = w0(u, 100)
          , m = M("")
          , g = M();
        let f, h = !1;
        const _ = E( () => n.labelPosition || (i == null ? void 0 : i.labelPosition))
          , p = E( () => {
            if (_.value === "top")
                return {};
            const N = pi(n.labelWidth || (i == null ? void 0 : i.labelWidth) || "");
            return N ? {
                width: N
            } : {}
        }
        )
          , b = E( () => {
            if (_.value === "top" || i != null && i.inline)
                return {};
            if (!n.label && !n.labelWidth && I)
                return {};
            const N = pi(n.labelWidth || (i == null ? void 0 : i.labelWidth) || "");
            return !n.label && !r.label ? {
                marginLeft: N
            } : {}
        }
        )
          , y = E( () => [a.b(), a.m(o.value), a.is("error", u.value === "error"), a.is("validating", u.value === "validating"), a.is("success", u.value === "success"), a.is("required", K.value || n.required), a.is("no-asterisk", i == null ? void 0 : i.hideRequiredAsterisk), (i == null ? void 0 : i.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left", {
            [a.m("feedback")]: i == null ? void 0 : i.statusIcon,
            [a.m(`label-${_.value}`)]: _.value
        }])
          , w = E( () => Nn(n.inlineMessage) ? n.inlineMessage : (i == null ? void 0 : i.inlineMessage) || !1)
          , x = E( () => [a.e("error"), {
            [a.em("error", "inline")]: w.value
        }])
          , C = E( () => n.prop ? ze(n.prop) ? n.prop : n.prop.join(".") : "")
          , P = E( () => !!(n.label || r.label))
          , T = E( () => n.for || (c.value.length === 1 ? c.value[0] : void 0))
          , L = E( () => !T.value && P.value)
          , I = !!s
          , U = E( () => {
            const N = i == null ? void 0 : i.model;
            if (!(!N || !n.prop))
                return Ao(N, n.prop).value
        }
        )
          , B = E( () => {
            const {required: N} = n
              , F = [];
            n.rules && F.push(...Go(n.rules));
            const ee = i == null ? void 0 : i.rules;
            if (ee && n.prop) {
                const re = Ao(ee, n.prop).value;
                re && F.push(...Go(re))
            }
            if (N !== void 0) {
                const re = F.map( (Ie, Ke) => [Ie, Ke]).filter( ([Ie]) => Object.keys(Ie).includes("required"));
                if (re.length > 0)
                    for (const [Ie,Ke] of re)
                        Ie.required !== N && (F[Ke] = {
                            ...Ie,
                            required: N
                        });
                else
                    F.push({
                        required: N
                    })
            }
            return F
        }
        )
          , V = E( () => B.value.length > 0)
          , z = N => B.value.filter(ee => !ee.trigger || !N ? !0 : Array.isArray(ee.trigger) ? ee.trigger.includes(N) : ee.trigger === N).map( ({trigger: ee, ...re}) => re)
          , K = E( () => B.value.some(N => N.required))
          , A = E( () => {
            var N;
            return d.value === "error" && n.showMessage && ((N = i == null ? void 0 : i.showMessage) != null ? N : !0)
        }
        )
          , X = E( () => `${n.label || ""}${(i == null ? void 0 : i.labelSuffix) || ""}`)
          , de = N => {
            u.value = N
        }
          , pe = N => {
            var F, ee;
            const {errors: re, fields: Ie} = N;
            (!re || !Ie) && console.error(N),
            de("error"),
            m.value = re ? (ee = (F = re == null ? void 0 : re[0]) == null ? void 0 : F.message) != null ? ee : `${n.prop} is required` : "",
            i == null || i.emit("validate", n.prop, !1, m.value)
        }
          , Pe = () => {
            de("success"),
            i == null || i.emit("validate", n.prop, !0, "")
        }
          , Be = async N => {
            const F = C.value;
            return new Li({
                [F]: N
            }).validate({
                [F]: U.value
            }, {
                firstFields: !0
            }).then( () => (Pe(),
            !0)).catch(re => (pe(re),
            Promise.reject(re)))
        }
          , _e = async (N, F) => {
            if (h || !n.prop)
                return !1;
            const ee = Kt(F);
            if (!V.value)
                return F == null || F(!1),
                !1;
            const re = z(N);
            return re.length === 0 ? (F == null || F(!0),
            !0) : (de("validating"),
            Be(re).then( () => (F == null || F(!0),
            !0)).catch(Ie => {
                const {fields: Ke} = Ie;
                return F == null || F(!1, Ke),
                ee ? !1 : Promise.reject(Ke)
            }
            ))
        }
          , Oe = () => {
            de(""),
            m.value = "",
            h = !1
        }
          , $e = async () => {
            const N = i == null ? void 0 : i.model;
            if (!N || !n.prop)
                return;
            const F = Ao(N, n.prop);
            h = !0,
            F.value = ou(f),
            await ke(),
            Oe(),
            h = !1
        }
          , Ne = N => {
            c.value.includes(N) || c.value.push(N)
        }
          , Ot = N => {
            c.value = c.value.filter(F => F !== N)
        }
        ;
        W( () => n.error, N => {
            m.value = N || "",
            de(N ? "error" : "")
        }
        , {
            immediate: !0
        }),
        W( () => n.validateStatus, N => de(N || ""));
        const Re = Hn({
            ...Us(n),
            $el: g,
            size: o,
            validateState: u,
            labelId: l,
            inputIds: c,
            isGroup: L,
            hasLabel: P,
            fieldValue: U,
            addInputId: Ne,
            removeInputId: Ot,
            resetField: $e,
            clearValidate: Oe,
            validate: _e
        });
        return ut(zn, Re),
        De( () => {
            n.prop && (i == null || i.addField(Re),
            f = ou(U.value))
        }
        ),
        Dt( () => {
            i == null || i.removeField(Re)
        }
        ),
        e({
            size: o,
            validateMessage: m,
            validateState: u,
            validate: _e,
            clearValidate: Oe,
            resetField: $e
        }),
        (N, F) => {
            var ee;
            return S(),
            j("div", {
                ref_key: "formItemRef",
                ref: g,
                class: D(v(y)),
                role: v(L) ? "group" : void 0,
                "aria-labelledby": v(L) ? v(l) : void 0
            }, [Y(v(vP), {
                "is-auto-width": v(p).width === "auto",
                "update-all": ((ee = v(i)) == null ? void 0 : ee.labelWidth) === "auto"
            }, {
                default: G( () => [v(P) ? (S(),
                ae(yt(v(T) ? "label" : "div"), {
                    key: 0,
                    id: v(l),
                    for: v(T),
                    class: D(v(a).e("label")),
                    style: qe(v(p))
                }, {
                    default: G( () => [he(N.$slots, "label", {
                        label: v(X)
                    }, () => [bt(Ue(v(X)), 1)])]),
                    _: 3
                }, 8, ["id", "for", "class", "style"])) : J("v-if", !0)]),
                _: 3
            }, 8, ["is-auto-width", "update-all"]), $("div", {
                class: D(v(a).e("content")),
                style: qe(v(b))
            }, [he(N.$slots, "default"), Y(zf, {
                name: `${v(a).namespace.value}-zoom-in-top`
            }, {
                default: G( () => [v(A) ? he(N.$slots, "error", {
                    key: 0,
                    error: m.value
                }, () => [$("div", {
                    class: D(v(x))
                }, Ue(m.value), 3)]) : J("v-if", !0)]),
                _: 3
            }, 8, ["name"])], 6)], 10, ["role", "aria-labelledby"])
        }
    }
});
var Lh = xe(bP, [["__file", "form-item.vue"]]);
const _P = Bt(I2, {
    FormItem: Lh
})
  , yP = Qs(Lh);
let ft;
const wP = `
  height:0 !important;
  visibility:hidden !important;
  ${F0() ? "" : "overflow:hidden !important;"}
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`
  , xP = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing"];
function CP(t) {
    const e = window.getComputedStyle(t)
      , n = e.getPropertyValue("box-sizing")
      , r = Number.parseFloat(e.getPropertyValue("padding-bottom")) + Number.parseFloat(e.getPropertyValue("padding-top"))
      , i = Number.parseFloat(e.getPropertyValue("border-bottom-width")) + Number.parseFloat(e.getPropertyValue("border-top-width"));
    return {
        contextStyle: xP.map(o => `${o}:${e.getPropertyValue(o)}`).join(";"),
        paddingSize: r,
        borderSize: i,
        boxSizing: n
    }
}
function Iu(t, e=1, n) {
    var r;
    ft || (ft = document.createElement("textarea"),
    document.body.appendChild(ft));
    const {paddingSize: i, borderSize: s, boxSizing: o, contextStyle: a} = CP(t);
    ft.setAttribute("style", `${a};${wP}`),
    ft.value = t.value || t.placeholder || "";
    let l = ft.scrollHeight;
    const c = {};
    o === "border-box" ? l = l + s : o === "content-box" && (l = l - i),
    ft.value = "";
    const u = ft.scrollHeight - i;
    if (Jt(e)) {
        let d = u * e;
        o === "border-box" && (d = d + i + s),
        l = Math.max(d, l),
        c.minHeight = `${d}px`
    }
    if (Jt(n)) {
        let d = u * n;
        o === "border-box" && (d = d + i + s),
        l = Math.min(d, l)
    }
    return c.height = `${l}px`,
    (r = ft.parentNode) == null || r.removeChild(ft),
    ft = void 0,
    c
}
const EP = Ae({
    id: {
        type: String,
        default: void 0
    },
    size: ki,
    disabled: Boolean,
    modelValue: {
        type: te([String, Number, Object]),
        default: ""
    },
    maxlength: {
        type: [String, Number]
    },
    minlength: {
        type: [String, Number]
    },
    type: {
        type: String,
        default: "text"
    },
    resize: {
        type: String,
        values: ["none", "both", "horizontal", "vertical"]
    },
    autosize: {
        type: te([Boolean, Object]),
        default: !1
    },
    autocomplete: {
        type: String,
        default: "off"
    },
    formatter: {
        type: Function
    },
    parser: {
        type: Function
    },
    placeholder: {
        type: String
    },
    form: {
        type: String
    },
    readonly: Boolean,
    clearable: Boolean,
    showPassword: Boolean,
    showWordLimit: Boolean,
    suffixIcon: {
        type: Fs
    },
    prefixIcon: {
        type: Fs
    },
    containerRole: {
        type: String,
        default: void 0
    },
    tabindex: {
        type: [String, Number],
        default: 0
    },
    validateEvent: {
        type: Boolean,
        default: !0
    },
    inputStyle: {
        type: te([Object, Array, String]),
        default: () => GC({})
    },
    autofocus: Boolean,
    rows: {
        type: Number,
        default: 2
    },
    ...Er(["ariaLabel"])
})
  , PP = {
    [xt]: t => ze(t),
    input: t => ze(t),
    change: t => ze(t),
    focus: t => t instanceof FocusEvent,
    blur: t => t instanceof FocusEvent,
    clear: () => !0,
    mouseleave: t => t instanceof MouseEvent,
    mouseenter: t => t instanceof MouseEvent,
    keydown: t => t instanceof Event,
    compositionstart: t => t instanceof CompositionEvent,
    compositionupdate: t => t instanceof CompositionEvent,
    compositionend: t => t instanceof CompositionEvent
}
  , OP = H({
    name: "ElInput",
    inheritAttrs: !1
})
  , TP = H({
    ...OP,
    props: EP,
    emits: PP,
    setup(t, {expose: e, emit: n}) {
        const r = t
          , i = Hf()
          , s = gi()
          , o = E( () => {
            const k = {};
            return r.containerRole === "combobox" && (k["aria-haspopup"] = i["aria-haspopup"],
            k["aria-owns"] = i["aria-owns"],
            k["aria-expanded"] = i["aria-expanded"]),
            k
        }
        )
          , a = E( () => [r.type === "textarea" ? _.b() : h.b(), h.m(g.value), h.is("disabled", f.value), h.is("exceed", Oe.value), {
            [h.b("group")]: s.prepend || s.append,
            [h.m("prefix")]: s.prefix || r.prefixIcon,
            [h.m("suffix")]: s.suffix || r.suffixIcon || r.clearable || r.showPassword,
            [h.bm("suffix", "password-clear")]: pe.value && Pe.value,
            [h.b("hidden")]: r.type === "hidden"
        }, i.class])
          , l = E( () => [h.e("wrapper"), h.is("focus", L.value)])
          , c = YC({
            excludeKeys: E( () => Object.keys(o.value))
        })
          , {form: u, formItem: d} = Or()
          , {inputId: m} = to(r, {
            formItemContext: d
        })
          , g = xn()
          , f = Mi()
          , h = we("input")
          , _ = we("textarea")
          , p = Fn()
          , b = Fn()
          , y = M(!1)
          , w = M(!1)
          , x = M()
          , C = Fn(r.inputStyle)
          , P = E( () => p.value || b.value)
          , {wrapperRef: T, isFocused: L, handleFocus: I, handleBlur: U} = Sh(P, {
            beforeFocus() {
                return f.value
            },
            afterBlur() {
                var k;
                r.validateEvent && ((k = d == null ? void 0 : d.validate) == null || k.call(d, "blur").catch(fe => void 0))
            }
        })
          , B = E( () => {
            var k;
            return (k = u == null ? void 0 : u.statusIcon) != null ? k : !1
        }
        )
          , V = E( () => (d == null ? void 0 : d.validateState) || "")
          , z = E( () => V.value && zC[V.value])
          , K = E( () => w.value ? oh : $C)
          , A = E( () => [i.style])
          , X = E( () => [r.inputStyle, C.value, {
            resize: r.resize
        }])
          , de = E( () => bn(r.modelValue) ? "" : String(r.modelValue))
          , pe = E( () => r.clearable && !f.value && !r.readonly && !!de.value && (L.value || y.value))
          , Pe = E( () => r.showPassword && !f.value && !r.readonly && !!de.value && (!!de.value || L.value))
          , Be = E( () => r.showWordLimit && !!r.maxlength && (r.type === "text" || r.type === "textarea") && !f.value && !r.readonly && !r.showPassword)
          , _e = E( () => de.value.length)
          , Oe = E( () => !!Be.value && _e.value > Number(r.maxlength))
          , $e = E( () => !!s.suffix || !!r.suffixIcon || pe.value || r.showPassword || Be.value || !!V.value && B.value)
          , [Ne,Ot] = v2(p);
        kp(b, k => {
            if (F(),
            !Be.value || r.resize !== "both")
                return;
            const fe = k[0]
              , {width: Ut} = fe.contentRect;
            x.value = {
                right: `calc(100% - ${Ut + 15 + 6}px)`
            }
        }
        );
        const Re = () => {
            const {type: k, autosize: fe} = r;
            if (!(!He || k !== "textarea" || !b.value))
                if (fe) {
                    const Ut = _n(fe) ? fe.minRows : void 0
                      , kr = _n(fe) ? fe.maxRows : void 0
                      , kl = Iu(b.value, Ut, kr);
                    C.value = {
                        overflowY: "hidden",
                        ...kl
                    },
                    ke( () => {
                        b.value.offsetHeight,
                        C.value = kl
                    }
                    )
                } else
                    C.value = {
                        minHeight: Iu(b.value).minHeight
                    }
        }
          , F = (k => {
            let fe = !1;
            return () => {
                var Ut;
                if (fe || !r.autosize)
                    return;
                ((Ut = b.value) == null ? void 0 : Ut.offsetParent) === null || (k(),
                fe = !0)
            }
        }
        )(Re)
          , ee = () => {
            const k = P.value
              , fe = r.formatter ? r.formatter(de.value) : de.value;
            !k || k.value === fe || (k.value = fe)
        }
          , re = async k => {
            Ne();
            let {value: fe} = k.target;
            if (r.formatter && (fe = r.parser ? r.parser(fe) : fe),
            !Ke.value) {
                if (fe === de.value) {
                    ee();
                    return
                }
                n(xt, fe),
                n("input", fe),
                await ke(),
                ee(),
                Ot()
            }
        }
          , Ie = k => {
            n("change", k.target.value)
        }
          , {isComposing: Ke, handleCompositionStart: Ri, handleCompositionUpdate: Ii, handleCompositionEnd: Ar} = b2({
            emit: n,
            afterComposition: re
        })
          , Vi = () => {
            w.value = !w.value,
            Di()
        }
          , Di = async () => {
            var k;
            await ke(),
            (k = P.value) == null || k.focus()
        }
          , oo = () => {
            var k;
            return (k = P.value) == null ? void 0 : k.blur()
        }
          , $t = k => {
            y.value = !1,
            n("mouseleave", k)
        }
          , Yn = k => {
            y.value = !0,
            n("mouseenter", k)
        }
          , Sr = k => {
            n("keydown", k)
        }
          , Bi = () => {
            var k;
            (k = P.value) == null || k.select()
        }
          , Zn = () => {
            n(xt, ""),
            n("change", ""),
            n("clear"),
            n("input", "")
        }
        ;
        return W( () => r.modelValue, () => {
            var k;
            ke( () => Re()),
            r.validateEvent && ((k = d == null ? void 0 : d.validate) == null || k.call(d, "change").catch(fe => void 0))
        }
        ),
        W(de, () => ee()),
        W( () => r.type, async () => {
            await ke(),
            ee(),
            Re()
        }
        ),
        De( () => {
            !r.formatter && r.parser,
            ee(),
            ke(Re)
        }
        ),
        e({
            input: p,
            textarea: b,
            ref: P,
            textareaStyle: X,
            autosize: Gt(r, "autosize"),
            isComposing: Ke,
            focus: Di,
            blur: oo,
            select: Bi,
            clear: Zn,
            resizeTextarea: Re
        }),
        (k, fe) => (S(),
        j("div", Wt(v(o), {
            class: [v(a), {
                [v(h).bm("group", "append")]: k.$slots.append,
                [v(h).bm("group", "prepend")]: k.$slots.prepend
            }],
            style: v(A),
            role: k.containerRole,
            onMouseenter: Yn,
            onMouseleave: $t
        }), [J(" input "), k.type !== "textarea" ? (S(),
        j(Ze, {
            key: 0
        }, [J(" prepend slot "), k.$slots.prepend ? (S(),
        j("div", {
            key: 0,
            class: D(v(h).be("group", "prepend"))
        }, [he(k.$slots, "prepend")], 2)) : J("v-if", !0), $("div", {
            ref_key: "wrapperRef",
            ref: T,
            class: D(v(l))
        }, [J(" prefix slot "), k.$slots.prefix || k.prefixIcon ? (S(),
        j("span", {
            key: 0,
            class: D(v(h).e("prefix"))
        }, [$("span", {
            class: D(v(h).e("prefix-inner"))
        }, [he(k.$slots, "prefix"), k.prefixIcon ? (S(),
        ae(v(St), {
            key: 0,
            class: D(v(h).e("icon"))
        }, {
            default: G( () => [(S(),
            ae(yt(k.prefixIcon)))]),
            _: 1
        }, 8, ["class"])) : J("v-if", !0)], 2)], 2)) : J("v-if", !0), $("input", Wt({
            id: v(m),
            ref_key: "input",
            ref: p,
            class: v(h).e("inner")
        }, v(c), {
            minlength: k.minlength,
            maxlength: k.maxlength,
            type: k.showPassword ? w.value ? "text" : "password" : k.type,
            disabled: v(f),
            readonly: k.readonly,
            autocomplete: k.autocomplete,
            tabindex: k.tabindex,
            "aria-label": k.ariaLabel,
            placeholder: k.placeholder,
            style: k.inputStyle,
            form: k.form,
            autofocus: k.autofocus,
            onCompositionstart: v(Ri),
            onCompositionupdate: v(Ii),
            onCompositionend: v(Ar),
            onInput: re,
            onChange: Ie,
            onKeydown: Sr
        }), null, 16, ["id", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus", "onCompositionstart", "onCompositionupdate", "onCompositionend"]), J(" suffix slot "), v($e) ? (S(),
        j("span", {
            key: 1,
            class: D(v(h).e("suffix"))
        }, [$("span", {
            class: D(v(h).e("suffix-inner"))
        }, [!v(pe) || !v(Pe) || !v(Be) ? (S(),
        j(Ze, {
            key: 0
        }, [he(k.$slots, "suffix"), k.suffixIcon ? (S(),
        ae(v(St), {
            key: 0,
            class: D(v(h).e("icon"))
        }, {
            default: G( () => [(S(),
            ae(yt(k.suffixIcon)))]),
            _: 1
        }, 8, ["class"])) : J("v-if", !0)], 64)) : J("v-if", !0), v(pe) ? (S(),
        ae(v(St), {
            key: 1,
            class: D([v(h).e("icon"), v(h).e("clear")]),
            onMousedown: ni(v(ti), ["prevent"]),
            onClick: Zn
        }, {
            default: G( () => [Y(v(ih))]),
            _: 1
        }, 8, ["class", "onMousedown"])) : J("v-if", !0), v(Pe) ? (S(),
        ae(v(St), {
            key: 2,
            class: D([v(h).e("icon"), v(h).e("password")]),
            onClick: Vi
        }, {
            default: G( () => [(S(),
            ae(yt(v(K))))]),
            _: 1
        }, 8, ["class"])) : J("v-if", !0), v(Be) ? (S(),
        j("span", {
            key: 3,
            class: D(v(h).e("count"))
        }, [$("span", {
            class: D(v(h).e("count-inner"))
        }, Ue(v(_e)) + " / " + Ue(k.maxlength), 3)], 2)) : J("v-if", !0), v(V) && v(z) && v(B) ? (S(),
        ae(v(St), {
            key: 4,
            class: D([v(h).e("icon"), v(h).e("validateIcon"), v(h).is("loading", v(V) === "validating")])
        }, {
            default: G( () => [(S(),
            ae(yt(v(z))))]),
            _: 1
        }, 8, ["class"])) : J("v-if", !0)], 2)], 2)) : J("v-if", !0)], 2), J(" append slot "), k.$slots.append ? (S(),
        j("div", {
            key: 1,
            class: D(v(h).be("group", "append"))
        }, [he(k.$slots, "append")], 2)) : J("v-if", !0)], 64)) : (S(),
        j(Ze, {
            key: 1
        }, [J(" textarea "), $("textarea", Wt({
            id: v(m),
            ref_key: "textarea",
            ref: b,
            class: [v(_).e("inner"), v(h).is("focus", v(L))]
        }, v(c), {
            minlength: k.minlength,
            maxlength: k.maxlength,
            tabindex: k.tabindex,
            disabled: v(f),
            readonly: k.readonly,
            autocomplete: k.autocomplete,
            style: v(X),
            "aria-label": k.ariaLabel,
            placeholder: k.placeholder,
            form: k.form,
            autofocus: k.autofocus,
            rows: k.rows,
            onCompositionstart: v(Ri),
            onCompositionupdate: v(Ii),
            onCompositionend: v(Ar),
            onInput: re,
            onFocus: v(I),
            onBlur: v(U),
            onChange: Ie,
            onKeydown: Sr
        }), null, 16, ["id", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus", "rows", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onFocus", "onBlur"]), v(Be) ? (S(),
        j("span", {
            key: 0,
            style: qe(x.value),
            class: D(v(h).e("count"))
        }, Ue(v(_e)) + " / " + Ue(k.maxlength), 7)) : J("v-if", !0)], 64))], 16, ["role"]))
    }
});
var AP = xe(TP, [["__file", "input.vue"]]);
const SP = Bt(AP)
  , wl = Symbol("popper")
  , Fh = Symbol("popperContent")
  , kP = ["dialog", "grid", "group", "listbox", "menu", "navigation", "tooltip", "tree"]
  , Rh = Ae({
    role: {
        type: String,
        values: kP,
        default: "tooltip"
    }
})
  , MP = H({
    name: "ElPopper",
    inheritAttrs: !1
})
  , LP = H({
    ...MP,
    props: Rh,
    setup(t, {expose: e}) {
        const n = t
          , r = M()
          , i = M()
          , s = M()
          , o = M()
          , a = E( () => n.role)
          , l = {
            triggerRef: r,
            popperInstanceRef: i,
            contentRef: s,
            referenceRef: o,
            role: a
        };
        return e(l),
        ut(wl, l),
        (c, u) => he(c.$slots, "default")
    }
});
var FP = xe(LP, [["__file", "popper.vue"]]);
const Ih = Ae({
    arrowOffset: {
        type: Number,
        default: 5
    }
})
  , RP = H({
    name: "ElPopperArrow",
    inheritAttrs: !1
})
  , IP = H({
    ...RP,
    props: Ih,
    setup(t, {expose: e}) {
        const n = t
          , r = we("popper")
          , {arrowOffset: i, arrowRef: s, arrowStyle: o} = le(Fh, void 0);
        return W( () => n.arrowOffset, a => {
            i.value = a
        }
        ),
        Dt( () => {
            s.value = void 0
        }
        ),
        e({
            arrowRef: s
        }),
        (a, l) => (S(),
        j("span", {
            ref_key: "arrowRef",
            ref: s,
            class: D(v(r).e("arrow")),
            style: qe(v(o)),
            "data-popper-arrow": ""
        }, null, 6))
    }
});
var VP = xe(IP, [["__file", "arrow.vue"]]);
const DP = "ElOnlyChild"
  , BP = H({
    name: DP,
    setup(t, {slots: e, attrs: n}) {
        var r;
        const i = le(Eh)
          , s = m2((r = i == null ? void 0 : i.setForwardRef) != null ? r : ti);
        return () => {
            var o;
            const a = (o = e.default) == null ? void 0 : o.call(e, n);
            if (!a || a.length > 1)
                return null;
            const l = Vh(a);
            return l ? Mt(Kf(l, n), [[s]]) : null
        }
    }
});
function Vh(t) {
    if (!t)
        return null;
    const e = t;
    for (const n of e) {
        if (_n(n))
            switch (n.type) {
            case Gf:
                continue;
            case gd:
            case "svg":
                return Vu(n);
            case Ze:
                return Vh(n.children);
            default:
                return n
            }
        return Vu(n)
    }
    return null
}
function Vu(t) {
    const e = we("only-child");
    return Y("span", {
        class: e.e("content")
    }, [t])
}
const Dh = Ae({
    virtualRef: {
        type: te(Object)
    },
    virtualTriggering: Boolean,
    onMouseenter: {
        type: te(Function)
    },
    onMouseleave: {
        type: te(Function)
    },
    onClick: {
        type: te(Function)
    },
    onKeydown: {
        type: te(Function)
    },
    onFocus: {
        type: te(Function)
    },
    onBlur: {
        type: te(Function)
    },
    onContextmenu: {
        type: te(Function)
    },
    id: String,
    open: Boolean
})
  , $P = H({
    name: "ElPopperTrigger",
    inheritAttrs: !1
})
  , UP = H({
    ...$P,
    props: Dh,
    setup(t, {expose: e}) {
        const n = t
          , {role: r, triggerRef: i} = le(wl, void 0);
        f2(i);
        const s = E( () => a.value ? n.id : void 0)
          , o = E( () => {
            if (r && r.value === "tooltip")
                return n.open && n.id ? n.id : void 0
        }
        )
          , a = E( () => {
            if (r && r.value !== "tooltip")
                return r.value
        }
        )
          , l = E( () => a.value ? `${n.open}` : void 0);
        let c;
        const u = ["onMouseenter", "onMouseleave", "onClick", "onKeydown", "onFocus", "onBlur", "onContextmenu"];
        return De( () => {
            W( () => n.virtualRef, d => {
                d && (i.value = mn(d))
            }
            , {
                immediate: !0
            }),
            W(i, (d, m) => {
                c == null || c(),
                c = void 0,
                cr(d) && (u.forEach(g => {
                    var f;
                    const h = n[g];
                    h && (d.addEventListener(g.slice(2).toLowerCase(), h),
                    (f = m == null ? void 0 : m.removeEventListener) == null || f.call(m, g.slice(2).toLowerCase(), h))
                }
                ),
                c = W([s, o, a, l], g => {
                    ["aria-controls", "aria-describedby", "aria-haspopup", "aria-expanded"].forEach( (f, h) => {
                        bn(g[h]) ? d.removeAttribute(f) : d.setAttribute(f, g[h])
                    }
                    )
                }
                , {
                    immediate: !0
                })),
                cr(m) && ["aria-controls", "aria-describedby", "aria-haspopup", "aria-expanded"].forEach(g => m.removeAttribute(g))
            }
            , {
                immediate: !0
            })
        }
        ),
        Dt( () => {
            if (c == null || c(),
            c = void 0,
            i.value && cr(i.value)) {
                const d = i.value;
                u.forEach(m => {
                    const g = n[m];
                    g && d.removeEventListener(m.slice(2).toLowerCase(), g)
                }
                ),
                i.value = void 0
            }
        }
        ),
        e({
            triggerRef: i
        }),
        (d, m) => d.virtualTriggering ? J("v-if", !0) : (S(),
        ae(v(BP), Wt({
            key: 0
        }, d.$attrs, {
            "aria-controls": v(s),
            "aria-describedby": v(o),
            "aria-expanded": v(l),
            "aria-haspopup": v(a)
        }), {
            default: G( () => [he(d.$slots, "default")]),
            _: 3
        }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]))
    }
});
var jP = xe(UP, [["__file", "trigger.vue"]]);
const ko = "focus-trap.focus-after-trapped"
  , Mo = "focus-trap.focus-after-released"
  , NP = "focus-trap.focusout-prevented"
  , Du = {
    cancelable: !0,
    bubbles: !1
}
  , zP = {
    cancelable: !0,
    bubbles: !1
}
  , Bu = "focusAfterTrapped"
  , $u = "focusAfterReleased"
  , HP = Symbol("elFocusTrap")
  , xl = M()
  , no = M(0)
  , Cl = M(0);
let Qi = 0;
const Bh = t => {
    const e = []
      , n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
        acceptNode: r => {
            const i = r.tagName === "INPUT" && r.type === "hidden";
            return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 || r === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; n.nextNode(); )
        e.push(n.currentNode);
    return e
}
  , Uu = (t, e) => {
    for (const n of t)
        if (!KP(n, e))
            return n
}
  , KP = (t, e) => {
    if (getComputedStyle(t).visibility === "hidden")
        return !0;
    for (; t; ) {
        if (e && t === e)
            return !1;
        if (getComputedStyle(t).display === "none")
            return !0;
        t = t.parentElement
    }
    return !1
}
  , GP = t => {
    const e = Bh(t)
      , n = Uu(e, t)
      , r = Uu(e.reverse(), t);
    return [n, r]
}
  , qP = t => t instanceof HTMLInputElement && "select"in t
  , pn = (t, e) => {
    if (t && t.focus) {
        const n = document.activeElement;
        t.focus({
            preventScroll: !0
        }),
        Cl.value = window.performance.now(),
        t !== n && qP(t) && e && t.select()
    }
}
;
function ju(t, e) {
    const n = [...t]
      , r = t.indexOf(e);
    return r !== -1 && n.splice(r, 1),
    n
}
const WP = () => {
    let t = [];
    return {
        push: r => {
            const i = t[0];
            i && r !== i && i.pause(),
            t = ju(t, r),
            t.unshift(r)
        }
        ,
        remove: r => {
            var i, s;
            t = ju(t, r),
            (s = (i = t[0]) == null ? void 0 : i.resume) == null || s.call(i)
        }
    }
}
  , YP = (t, e=!1) => {
    const n = document.activeElement;
    for (const r of t)
        if (pn(r, e),
        document.activeElement !== n)
            return
}
  , Nu = WP()
  , ZP = () => no.value > Cl.value
  , Ji = () => {
    xl.value = "pointer",
    no.value = window.performance.now()
}
  , zu = () => {
    xl.value = "keyboard",
    no.value = window.performance.now()
}
  , XP = () => (De( () => {
    Qi === 0 && (document.addEventListener("mousedown", Ji),
    document.addEventListener("touchstart", Ji),
    document.addEventListener("keydown", zu)),
    Qi++
}
),
Dt( () => {
    Qi--,
    Qi <= 0 && (document.removeEventListener("mousedown", Ji),
    document.removeEventListener("touchstart", Ji),
    document.removeEventListener("keydown", zu))
}
),
{
    focusReason: xl,
    lastUserFocusTimestamp: no,
    lastAutomatedFocusTimestamp: Cl
})
  , es = t => new CustomEvent(NP,{
    ...zP,
    detail: t
})
  , QP = H({
    name: "ElFocusTrap",
    inheritAttrs: !1,
    props: {
        loop: Boolean,
        trapped: Boolean,
        focusTrapEl: Object,
        focusStartEl: {
            type: [Object, String],
            default: "first"
        }
    },
    emits: [Bu, $u, "focusin", "focusout", "focusout-prevented", "release-requested"],
    setup(t, {emit: e}) {
        const n = M();
        let r, i;
        const {focusReason: s} = XP();
        c2(f => {
            t.trapped && !o.paused && e("release-requested", f)
        }
        );
        const o = {
            paused: !1,
            pause() {
                this.paused = !0
            },
            resume() {
                this.paused = !1
            }
        }
          , a = f => {
            if (!t.loop && !t.trapped || o.paused)
                return;
            const {key: h, altKey: _, ctrlKey: p, metaKey: b, currentTarget: y, shiftKey: w} = f
              , {loop: x} = t
              , C = h === wt.tab && !_ && !p && !b
              , P = document.activeElement;
            if (C && P) {
                const T = y
                  , [L,I] = GP(T);
                if (L && I) {
                    if (!w && P === I) {
                        const B = es({
                            focusReason: s.value
                        });
                        e("focusout-prevented", B),
                        B.defaultPrevented || (f.preventDefault(),
                        x && pn(L, !0))
                    } else if (w && [L, T].includes(P)) {
                        const B = es({
                            focusReason: s.value
                        });
                        e("focusout-prevented", B),
                        B.defaultPrevented || (f.preventDefault(),
                        x && pn(I, !0))
                    }
                } else if (P === T) {
                    const B = es({
                        focusReason: s.value
                    });
                    e("focusout-prevented", B),
                    B.defaultPrevented || f.preventDefault()
                }
            }
        }
        ;
        ut(HP, {
            focusTrapRef: n,
            onKeydown: a
        }),
        W( () => t.focusTrapEl, f => {
            f && (n.value = f)
        }
        , {
            immediate: !0
        }),
        W([n], ([f], [h]) => {
            f && (f.addEventListener("keydown", a),
            f.addEventListener("focusin", u),
            f.addEventListener("focusout", d)),
            h && (h.removeEventListener("keydown", a),
            h.removeEventListener("focusin", u),
            h.removeEventListener("focusout", d))
        }
        );
        const l = f => {
            e(Bu, f)
        }
          , c = f => e($u, f)
          , u = f => {
            const h = v(n);
            if (!h)
                return;
            const _ = f.target
              , p = f.relatedTarget
              , b = _ && h.contains(_);
            t.trapped || p && h.contains(p) || (r = p),
            b && e("focusin", f),
            !o.paused && t.trapped && (b ? i = _ : pn(i, !0))
        }
          , d = f => {
            const h = v(n);
            if (!(o.paused || !h))
                if (t.trapped) {
                    const _ = f.relatedTarget;
                    !bn(_) && !h.contains(_) && setTimeout( () => {
                        if (!o.paused && t.trapped) {
                            const p = es({
                                focusReason: s.value
                            });
                            e("focusout-prevented", p),
                            p.defaultPrevented || pn(i, !0)
                        }
                    }
                    , 0)
                } else {
                    const _ = f.target;
                    _ && h.contains(_) || e("focusout", f)
                }
        }
        ;
        async function m() {
            await ke();
            const f = v(n);
            if (f) {
                Nu.push(o);
                const h = f.contains(document.activeElement) ? r : document.activeElement;
                if (r = h,
                !f.contains(h)) {
                    const p = new Event(ko,Du);
                    f.addEventListener(ko, l),
                    f.dispatchEvent(p),
                    p.defaultPrevented || ke( () => {
                        let b = t.focusStartEl;
                        ze(b) || (pn(b),
                        document.activeElement !== b && (b = "first")),
                        b === "first" && YP(Bh(f), !0),
                        (document.activeElement === h || b === "container") && pn(f)
                    }
                    )
                }
            }
        }
        function g() {
            const f = v(n);
            if (f) {
                f.removeEventListener(ko, l);
                const h = new CustomEvent(Mo,{
                    ...Du,
                    detail: {
                        focusReason: s.value
                    }
                });
                f.addEventListener(Mo, c),
                f.dispatchEvent(h),
                !h.defaultPrevented && (s.value == "keyboard" || !ZP() || f.contains(document.activeElement)) && pn(r ?? document.body),
                f.removeEventListener(Mo, c),
                Nu.remove(o)
            }
        }
        return De( () => {
            t.trapped && m(),
            W( () => t.trapped, f => {
                f ? m() : g()
            }
            )
        }
        ),
        Dt( () => {
            t.trapped && g(),
            n.value && (n.value.removeEventListener("keydown", a),
            n.value.removeEventListener("focusin", u),
            n.value.removeEventListener("focusout", d),
            n.value = void 0)
        }
        ),
        {
            onKeydown: a
        }
    }
});
function JP(t, e, n, r, i, s) {
    return he(t.$slots, "default", {
        handleKeydown: t.onKeydown
    })
}
var eO = xe(QP, [["render", JP], ["__file", "focus-trap.vue"]]);
const tO = ["fixed", "absolute"]
  , nO = Ae({
    boundariesPadding: {
        type: Number,
        default: 0
    },
    fallbackPlacements: {
        type: te(Array),
        default: void 0
    },
    gpuAcceleration: {
        type: Boolean,
        default: !0
    },
    offset: {
        type: Number,
        default: 12
    },
    placement: {
        type: String,
        values: dl,
        default: "bottom"
    },
    popperOptions: {
        type: te(Object),
        default: () => ({})
    },
    strategy: {
        type: String,
        values: tO,
        default: "absolute"
    }
})
  , $h = Ae({
    ...nO,
    id: String,
    style: {
        type: te([String, Array, Object])
    },
    className: {
        type: te([String, Array, Object])
    },
    effect: {
        type: te(String),
        default: "dark"
    },
    visible: Boolean,
    enterable: {
        type: Boolean,
        default: !0
    },
    pure: Boolean,
    focusOnShow: {
        type: Boolean,
        default: !1
    },
    trapping: {
        type: Boolean,
        default: !1
    },
    popperClass: {
        type: te([String, Array, Object])
    },
    popperStyle: {
        type: te([String, Array, Object])
    },
    referenceEl: {
        type: te(Object)
    },
    triggerTargetEl: {
        type: te(Object)
    },
    stopPopperMouseEvent: {
        type: Boolean,
        default: !0
    },
    virtualTriggering: Boolean,
    zIndex: Number,
    ...Er(["ariaLabel"])
})
  , rO = {
    mouseenter: t => t instanceof MouseEvent,
    mouseleave: t => t instanceof MouseEvent,
    focus: () => !0,
    blur: () => !0,
    close: () => !0
}
  , iO = (t, e=[]) => {
    const {placement: n, strategy: r, popperOptions: i} = t
      , s = {
        placement: n,
        strategy: r,
        ...i,
        modifiers: [...oO(t), ...e]
    };
    return aO(s, i == null ? void 0 : i.modifiers),
    s
}
  , sO = t => {
    if (He)
        return mn(t)
}
;
function oO(t) {
    const {offset: e, gpuAcceleration: n, fallbackPlacements: r} = t;
    return [{
        name: "offset",
        options: {
            offset: [0, e ?? 12]
        }
    }, {
        name: "preventOverflow",
        options: {
            padding: {
                top: 2,
                bottom: 2,
                left: 5,
                right: 5
            }
        }
    }, {
        name: "flip",
        options: {
            padding: 5,
            fallbackPlacements: r
        }
    }, {
        name: "computeStyles",
        options: {
            gpuAcceleration: n
        }
    }]
}
function aO(t, e) {
    e && (t.modifiers = [...t.modifiers, ...e ?? []])
}
const lO = 0
  , cO = t => {
    const {popperInstanceRef: e, contentRef: n, triggerRef: r, role: i} = le(wl, void 0)
      , s = M()
      , o = M()
      , a = E( () => ({
        name: "eventListeners",
        enabled: !!t.visible
    }))
      , l = E( () => {
        var p;
        const b = v(s)
          , y = (p = v(o)) != null ? p : lO;
        return {
            name: "arrow",
            enabled: !EC(b),
            options: {
                element: b,
                padding: y
            }
        }
    }
    )
      , c = E( () => ({
        onFirstUpdate: () => {
            f()
        }
        ,
        ...iO(t, [v(l), v(a)])
    }))
      , u = E( () => sO(t.referenceEl) || v(r))
      , {attributes: d, state: m, styles: g, update: f, forceUpdate: h, instanceRef: _} = o2(u, n, c);
    return W(_, p => e.value = p),
    De( () => {
        W( () => {
            var p;
            return (p = v(u)) == null ? void 0 : p.getBoundingClientRect()
        }
        , () => {
            f()
        }
        )
    }
    ),
    {
        attributes: d,
        arrowRef: s,
        contentRef: n,
        instanceRef: _,
        state: m,
        styles: g,
        role: i,
        forceUpdate: h,
        update: f
    }
}
  , uO = (t, {attributes: e, styles: n, role: r}) => {
    const {nextZIndex: i} = Th()
      , s = we("popper")
      , o = E( () => v(e).popper)
      , a = M(Jt(t.zIndex) ? t.zIndex : i())
      , l = E( () => [s.b(), s.is("pure", t.pure), s.is(t.effect), t.popperClass])
      , c = E( () => [{
        zIndex: v(a)
    }, v(n).popper, t.popperStyle || {}])
      , u = E( () => r.value === "dialog" ? "false" : void 0)
      , d = E( () => v(n).arrow || {});
    return {
        ariaModal: u,
        arrowStyle: d,
        contentAttrs: o,
        contentClass: l,
        contentStyle: c,
        contentZIndex: a,
        updateZIndex: () => {
            a.value = Jt(t.zIndex) ? t.zIndex : i()
        }
    }
}
  , dO = (t, e) => {
    const n = M(!1)
      , r = M();
    return {
        focusStartRef: r,
        trapped: n,
        onFocusAfterReleased: c => {
            var u;
            ((u = c.detail) == null ? void 0 : u.focusReason) !== "pointer" && (r.value = "first",
            e("blur"))
        }
        ,
        onFocusAfterTrapped: () => {
            e("focus")
        }
        ,
        onFocusInTrap: c => {
            t.visible && !n.value && (c.target && (r.value = c.target),
            n.value = !0)
        }
        ,
        onFocusoutPrevented: c => {
            t.trapping || (c.detail.focusReason === "pointer" && c.preventDefault(),
            n.value = !1)
        }
        ,
        onReleaseRequested: () => {
            n.value = !1,
            e("close")
        }
    }
}
  , pO = H({
    name: "ElPopperContent"
})
  , hO = H({
    ...pO,
    props: $h,
    emits: rO,
    setup(t, {expose: e, emit: n}) {
        const r = t
          , {focusStartRef: i, trapped: s, onFocusAfterReleased: o, onFocusAfterTrapped: a, onFocusInTrap: l, onFocusoutPrevented: c, onReleaseRequested: u} = dO(r, n)
          , {attributes: d, arrowRef: m, contentRef: g, styles: f, instanceRef: h, role: _, update: p} = cO(r)
          , {ariaModal: b, arrowStyle: y, contentAttrs: w, contentClass: x, contentStyle: C, updateZIndex: P} = uO(r, {
            styles: f,
            attributes: d,
            role: _
        })
          , T = le(zn, void 0)
          , L = M();
        ut(Fh, {
            arrowStyle: y,
            arrowRef: m,
            arrowOffset: L
        }),
        T && ut(zn, {
            ...T,
            addInputId: ti,
            removeInputId: ti
        });
        let I;
        const U = (V=!0) => {
            p(),
            V && P()
        }
          , B = () => {
            U(!1),
            r.visible && r.focusOnShow ? s.value = !0 : r.visible === !1 && (s.value = !1)
        }
        ;
        return De( () => {
            W( () => r.triggerTargetEl, (V, z) => {
                I == null || I(),
                I = void 0;
                const K = v(V || g.value)
                  , A = v(z || g.value);
                cr(K) && (I = W([_, () => r.ariaLabel, b, () => r.id], X => {
                    ["role", "aria-label", "aria-modal", "id"].forEach( (de, pe) => {
                        bn(X[pe]) ? K.removeAttribute(de) : K.setAttribute(de, X[pe])
                    }
                    )
                }
                , {
                    immediate: !0
                })),
                A !== K && cr(A) && ["role", "aria-label", "aria-modal", "id"].forEach(X => {
                    A.removeAttribute(X)
                }
                )
            }
            , {
                immediate: !0
            }),
            W( () => r.visible, B, {
                immediate: !0
            })
        }
        ),
        Dt( () => {
            I == null || I(),
            I = void 0
        }
        ),
        e({
            popperContentRef: g,
            popperInstanceRef: h,
            updatePopper: U,
            contentStyle: C
        }),
        (V, z) => (S(),
        j("div", Wt({
            ref_key: "contentRef",
            ref: g
        }, v(w), {
            style: v(C),
            class: v(x),
            tabindex: "-1",
            onMouseenter: K => V.$emit("mouseenter", K),
            onMouseleave: K => V.$emit("mouseleave", K)
        }), [Y(v(eO), {
            trapped: v(s),
            "trap-on-focus-in": !0,
            "focus-trap-el": v(g),
            "focus-start-el": v(i),
            onFocusAfterTrapped: v(a),
            onFocusAfterReleased: v(o),
            onFocusin: v(l),
            onFocusoutPrevented: v(c),
            onReleaseRequested: v(u)
        }, {
            default: G( () => [he(V.$slots, "default")]),
            _: 3
        }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])], 16, ["onMouseenter", "onMouseleave"]))
    }
});
var fO = xe(hO, [["__file", "content.vue"]]);
const mO = Bt(FP)
  , El = Symbol("elTooltip")
  , Pl = Ae({
    ...p2,
    ...$h,
    appendTo: {
        type: te([String, Object])
    },
    content: {
        type: String,
        default: ""
    },
    rawContent: Boolean,
    persistent: Boolean,
    visible: {
        type: te(Boolean),
        default: null
    },
    transition: String,
    teleported: {
        type: Boolean,
        default: !0
    },
    disabled: Boolean,
    ...Er(["ariaLabel"])
})
  , Uh = Ae({
    ...Dh,
    disabled: Boolean,
    trigger: {
        type: te([String, Array]),
        default: "hover"
    },
    triggerKeys: {
        type: te(Array),
        default: () => [wt.enter, wt.space]
    }
})
  , {useModelToggleProps: vO, useModelToggleEmits: gO, useModelToggle: bO} = rE("visible")
  , _O = Ae({
    ...Rh,
    ...vO,
    ...Pl,
    ...Uh,
    ...Ih,
    showArrow: {
        type: Boolean,
        default: !0
    }
})
  , yO = [...gO, "before-show", "before-hide", "show", "hide", "open", "close"]
  , wO = (t, e) => Dn(t) ? t.includes(e) : t === e
  , ir = (t, e, n) => r => {
    wO(v(t), e) && n(r)
}
  , xO = H({
    name: "ElTooltipTrigger"
})
  , CO = H({
    ...xO,
    props: Uh,
    setup(t, {expose: e}) {
        const n = t
          , r = we("tooltip")
          , {controlled: i, id: s, open: o, onOpen: a, onClose: l, onToggle: c} = le(El, void 0)
          , u = M(null)
          , d = () => {
            if (v(i) || n.disabled)
                return !0
        }
          , m = Gt(n, "trigger")
          , g = zt(d, ir(m, "hover", a))
          , f = zt(d, ir(m, "hover", l))
          , h = zt(d, ir(m, "click", w => {
            w.button === 0 && c(w)
        }
        ))
          , _ = zt(d, ir(m, "focus", a))
          , p = zt(d, ir(m, "focus", l))
          , b = zt(d, ir(m, "contextmenu", w => {
            w.preventDefault(),
            c(w)
        }
        ))
          , y = zt(d, w => {
            const {code: x} = w;
            n.triggerKeys.includes(x) && (w.preventDefault(),
            c(w))
        }
        );
        return e({
            triggerRef: u
        }),
        (w, x) => (S(),
        ae(v(jP), {
            id: v(s),
            "virtual-ref": w.virtualRef,
            open: v(o),
            "virtual-triggering": w.virtualTriggering,
            class: D(v(r).e("trigger")),
            onBlur: v(p),
            onClick: v(h),
            onContextmenu: v(b),
            onFocus: v(_),
            onMouseenter: v(g),
            onMouseleave: v(f),
            onKeydown: v(y)
        }, {
            default: G( () => [he(w.$slots, "default")]),
            _: 3
        }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]))
    }
});
var EO = xe(CO, [["__file", "trigger.vue"]]);
const PO = Ae({
    to: {
        type: te([String, Object]),
        required: !0
    },
    disabled: Boolean
})
  , OO = H({
    __name: "teleport",
    props: PO,
    setup(t) {
        return (e, n) => e.disabled ? he(e.$slots, "default", {
            key: 0
        }) : (S(),
        ae(qf, {
            key: 1,
            to: e.to
        }, [he(e.$slots, "default")], 8, ["to"]))
    }
});
var TO = xe(OO, [["__file", "teleport.vue"]]);
const AO = Bt(TO)
  , SO = H({
    name: "ElTooltipContent",
    inheritAttrs: !1
})
  , kO = H({
    ...SO,
    props: Pl,
    setup(t, {expose: e}) {
        const n = t
          , {selector: r} = Ch()
          , i = we("tooltip")
          , s = M(null);
        let o;
        const {controlled: a, id: l, open: c, trigger: u, onClose: d, onOpen: m, onShow: g, onHide: f, onBeforeShow: h, onBeforeHide: _} = le(El, void 0)
          , p = E( () => n.transition || `${i.namespace.value}-fade-in-linear`)
          , b = E( () => n.persistent);
        Dt( () => {
            o == null || o()
        }
        );
        const y = E( () => v(b) ? !0 : v(c))
          , w = E( () => n.disabled ? !1 : v(c))
          , x = E( () => n.appendTo || r.value)
          , C = E( () => {
            var A;
            return (A = n.style) != null ? A : {}
        }
        )
          , P = M(!0)
          , T = () => {
            f(),
            P.value = !0
        }
          , L = () => {
            if (v(a))
                return !0
        }
          , I = zt(L, () => {
            n.enterable && v(u) === "hover" && m()
        }
        )
          , U = zt(L, () => {
            v(u) === "hover" && d()
        }
        )
          , B = () => {
            var A, X;
            (X = (A = s.value) == null ? void 0 : A.updatePopper) == null || X.call(A),
            h == null || h()
        }
          , V = () => {
            _ == null || _()
        }
          , z = () => {
            g(),
            o = C0(E( () => {
                var A;
                return (A = s.value) == null ? void 0 : A.popperContentRef
            }
            ), () => {
                if (v(a))
                    return;
                v(u) !== "hover" && d()
            }
            )
        }
          , K = () => {
            n.virtualTriggering || d()
        }
        ;
        return W( () => v(c), A => {
            A ? P.value = !1 : o == null || o()
        }
        , {
            flush: "post"
        }),
        W( () => n.content, () => {
            var A, X;
            (X = (A = s.value) == null ? void 0 : A.updatePopper) == null || X.call(A)
        }
        ),
        e({
            contentRef: s
        }),
        (A, X) => (S(),
        ae(v(AO), {
            disabled: !A.teleported,
            to: v(x)
        }, {
            default: G( () => [Y(Wr, {
                name: v(p),
                onAfterLeave: T,
                onBeforeEnter: B,
                onAfterEnter: z,
                onBeforeLeave: V
            }, {
                default: G( () => [v(y) ? Mt((S(),
                ae(v(fO), Wt({
                    key: 0,
                    id: v(l),
                    ref_key: "contentRef",
                    ref: s
                }, A.$attrs, {
                    "aria-label": A.ariaLabel,
                    "aria-hidden": P.value,
                    "boundaries-padding": A.boundariesPadding,
                    "fallback-placements": A.fallbackPlacements,
                    "gpu-acceleration": A.gpuAcceleration,
                    offset: A.offset,
                    placement: A.placement,
                    "popper-options": A.popperOptions,
                    strategy: A.strategy,
                    effect: A.effect,
                    enterable: A.enterable,
                    pure: A.pure,
                    "popper-class": A.popperClass,
                    "popper-style": [A.popperStyle, v(C)],
                    "reference-el": A.referenceEl,
                    "trigger-target-el": A.triggerTargetEl,
                    visible: v(w),
                    "z-index": A.zIndex,
                    onMouseenter: v(I),
                    onMouseleave: v(U),
                    onBlur: K,
                    onClose: v(d)
                }), {
                    default: G( () => [he(A.$slots, "default")]),
                    _: 3
                }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onClose"])), [[bs, v(w)]]) : J("v-if", !0)]),
                _: 3
            }, 8, ["name"])]),
            _: 3
        }, 8, ["disabled", "to"]))
    }
});
var MO = xe(kO, [["__file", "content.vue"]]);
const LO = H({
    name: "ElTooltip"
})
  , FO = H({
    ...LO,
    props: _O,
    emits: yO,
    setup(t, {expose: e, emit: n}) {
        const r = t;
        d2();
        const i = _l()
          , s = M()
          , o = M()
          , a = () => {
            var p;
            const b = v(s);
            b && ((p = b.popperInstanceRef) == null || p.update())
        }
          , l = M(!1)
          , c = M()
          , {show: u, hide: d, hasUpdateHandler: m} = bO({
            indicator: l,
            toggleReason: c
        })
          , {onOpen: g, onClose: f} = h2({
            showAfter: Gt(r, "showAfter"),
            hideAfter: Gt(r, "hideAfter"),
            autoClose: Gt(r, "autoClose"),
            open: u,
            close: d
        })
          , h = E( () => Nn(r.visible) && !m.value);
        ut(El, {
            controlled: h,
            id: i,
            open: Wf(l),
            trigger: Gt(r, "trigger"),
            onOpen: p => {
                g(p)
            }
            ,
            onClose: p => {
                f(p)
            }
            ,
            onToggle: p => {
                v(l) ? f(p) : g(p)
            }
            ,
            onShow: () => {
                n("show", c.value)
            }
            ,
            onHide: () => {
                n("hide", c.value)
            }
            ,
            onBeforeShow: () => {
                n("before-show", c.value)
            }
            ,
            onBeforeHide: () => {
                n("before-hide", c.value)
            }
            ,
            updatePopper: a
        }),
        W( () => r.disabled, p => {
            p && l.value && (l.value = !1)
        }
        );
        const _ = p => {
            var b, y;
            const w = (y = (b = o.value) == null ? void 0 : b.contentRef) == null ? void 0 : y.popperContentRef
              , x = (p == null ? void 0 : p.relatedTarget) || document.activeElement;
            return w && w.contains(x)
        }
        ;
        return Yf( () => l.value && d()),
        e({
            popperRef: s,
            contentRef: o,
            isFocusInsideContent: _,
            updatePopper: a,
            onOpen: g,
            onClose: f,
            hide: d
        }),
        (p, b) => (S(),
        ae(v(mO), {
            ref_key: "popperRef",
            ref: s,
            role: p.role
        }, {
            default: G( () => [Y(EO, {
                disabled: p.disabled,
                trigger: p.trigger,
                "trigger-keys": p.triggerKeys,
                "virtual-ref": p.virtualRef,
                "virtual-triggering": p.virtualTriggering
            }, {
                default: G( () => [p.$slots.default ? he(p.$slots, "default", {
                    key: 0
                }) : J("v-if", !0)]),
                _: 3
            }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]), Y(MO, {
                ref_key: "contentRef",
                ref: o,
                "aria-label": p.ariaLabel,
                "boundaries-padding": p.boundariesPadding,
                content: p.content,
                disabled: p.disabled,
                effect: p.effect,
                enterable: p.enterable,
                "fallback-placements": p.fallbackPlacements,
                "hide-after": p.hideAfter,
                "gpu-acceleration": p.gpuAcceleration,
                offset: p.offset,
                persistent: p.persistent,
                "popper-class": p.popperClass,
                "popper-style": p.popperStyle,
                placement: p.placement,
                "popper-options": p.popperOptions,
                pure: p.pure,
                "raw-content": p.rawContent,
                "reference-el": p.referenceEl,
                "trigger-target-el": p.triggerTargetEl,
                "show-after": p.showAfter,
                strategy: p.strategy,
                teleported: p.teleported,
                transition: p.transition,
                "virtual-triggering": p.virtualTriggering,
                "z-index": p.zIndex,
                "append-to": p.appendTo
            }, {
                default: G( () => [he(p.$slots, "content", {}, () => [p.rawContent ? (S(),
                j("span", {
                    key: 0,
                    innerHTML: p.content
                }, null, 8, ["innerHTML"])) : (S(),
                j("span", {
                    key: 1
                }, Ue(p.content), 1))]), p.showArrow ? (S(),
                ae(v(VP), {
                    key: 0,
                    "arrow-offset": p.arrowOffset
                }, null, 8, ["arrow-offset"])) : J("v-if", !0)]),
                _: 3
            }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])]),
            _: 3
        }, 8, ["role"]))
    }
});
var RO = xe(FO, [["__file", "tooltip.vue"]]);
const IO = Bt(RO)
  , jh = Symbol("buttonGroupContextKey")
  , VO = (t, e) => {
    ls({
        from: "type.text",
        replacement: "link",
        version: "3.0.0",
        scope: "props",
        ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
    }, E( () => t.type === "text"));
    const n = le(jh, void 0)
      , r = yl("button")
      , {form: i} = Or()
      , s = xn(E( () => n == null ? void 0 : n.size))
      , o = Mi()
      , a = M()
      , l = gi()
      , c = E( () => t.type || (n == null ? void 0 : n.type) || "")
      , u = E( () => {
        var f, h, _;
        return (_ = (h = t.autoInsertSpace) != null ? h : (f = r.value) == null ? void 0 : f.autoInsertSpace) != null ? _ : !1
    }
    )
      , d = E( () => t.tag === "button" ? {
        ariaDisabled: o.value || t.loading,
        disabled: o.value || t.loading,
        autofocus: t.autofocus,
        type: t.nativeType
    } : {})
      , m = E( () => {
        var f;
        const h = (f = l.default) == null ? void 0 : f.call(l);
        if (u.value && (h == null ? void 0 : h.length) === 1) {
            const _ = h[0];
            if ((_ == null ? void 0 : _.type) === gd) {
                const p = _.children;
                return new RegExp("^\\p{Unified_Ideograph}{2}$","u").test(p.trim())
            }
        }
        return !1
    }
    );
    return {
        _disabled: o,
        _size: s,
        _type: c,
        _ref: a,
        _props: d,
        shouldAddSpace: m,
        handleClick: f => {
            if (o.value || t.loading) {
                f.stopPropagation();
                return
            }
            t.nativeType === "reset" && (i == null || i.resetFields()),
            e("click", f)
        }
    }
}
  , DO = ["default", "primary", "success", "warning", "info", "danger", "text", ""]
  , BO = ["button", "submit", "reset"]
  , ia = Ae({
    size: ki,
    disabled: Boolean,
    type: {
        type: String,
        values: DO,
        default: ""
    },
    icon: {
        type: Fs
    },
    nativeType: {
        type: String,
        values: BO,
        default: "button"
    },
    loading: Boolean,
    loadingIcon: {
        type: Fs,
        default: () => sh
    },
    plain: Boolean,
    text: Boolean,
    link: Boolean,
    bg: Boolean,
    autofocus: Boolean,
    round: Boolean,
    circle: Boolean,
    color: String,
    dark: Boolean,
    autoInsertSpace: {
        type: Boolean,
        default: void 0
    },
    tag: {
        type: te([String, Object]),
        default: "button"
    }
})
  , $O = {
    click: t => t instanceof MouseEvent
};
function je(t, e) {
    UO(t) && (t = "100%");
    var n = jO(t);
    return t = e === 360 ? t : Math.min(e, Math.max(0, parseFloat(t))),
    n && (t = parseInt(String(t * e), 10) / 100),
    Math.abs(t - e) < 1e-6 ? 1 : (e === 360 ? t = (t < 0 ? t % e + e : t % e) / parseFloat(String(e)) : t = t % e / parseFloat(String(e)),
    t)
}
function ts(t) {
    return Math.min(1, Math.max(0, t))
}
function UO(t) {
    return typeof t == "string" && t.indexOf(".") !== -1 && parseFloat(t) === 1
}
function jO(t) {
    return typeof t == "string" && t.indexOf("%") !== -1
}
function Nh(t) {
    return t = parseFloat(t),
    (isNaN(t) || t < 0 || t > 1) && (t = 1),
    t
}
function ns(t) {
    return t <= 1 ? "".concat(Number(t) * 100, "%") : t
}
function Ln(t) {
    return t.length === 1 ? "0" + t : String(t)
}
function NO(t, e, n) {
    return {
        r: je(t, 255) * 255,
        g: je(e, 255) * 255,
        b: je(n, 255) * 255
    }
}
function Hu(t, e, n) {
    t = je(t, 255),
    e = je(e, 255),
    n = je(n, 255);
    var r = Math.max(t, e, n)
      , i = Math.min(t, e, n)
      , s = 0
      , o = 0
      , a = (r + i) / 2;
    if (r === i)
        o = 0,
        s = 0;
    else {
        var l = r - i;
        switch (o = a > .5 ? l / (2 - r - i) : l / (r + i),
        r) {
        case t:
            s = (e - n) / l + (e < n ? 6 : 0);
            break;
        case e:
            s = (n - t) / l + 2;
            break;
        case n:
            s = (t - e) / l + 4;
            break
        }
        s /= 6
    }
    return {
        h: s,
        s: o,
        l: a
    }
}
function Lo(t, e, n) {
    return n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? t + (e - t) * (6 * n) : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
}
function zO(t, e, n) {
    var r, i, s;
    if (t = je(t, 360),
    e = je(e, 100),
    n = je(n, 100),
    e === 0)
        i = n,
        s = n,
        r = n;
    else {
        var o = n < .5 ? n * (1 + e) : n + e - n * e
          , a = 2 * n - o;
        r = Lo(a, o, t + 1 / 3),
        i = Lo(a, o, t),
        s = Lo(a, o, t - 1 / 3)
    }
    return {
        r: r * 255,
        g: i * 255,
        b: s * 255
    }
}
function Ku(t, e, n) {
    t = je(t, 255),
    e = je(e, 255),
    n = je(n, 255);
    var r = Math.max(t, e, n)
      , i = Math.min(t, e, n)
      , s = 0
      , o = r
      , a = r - i
      , l = r === 0 ? 0 : a / r;
    if (r === i)
        s = 0;
    else {
        switch (r) {
        case t:
            s = (e - n) / a + (e < n ? 6 : 0);
            break;
        case e:
            s = (n - t) / a + 2;
            break;
        case n:
            s = (t - e) / a + 4;
            break
        }
        s /= 6
    }
    return {
        h: s,
        s: l,
        v: o
    }
}
function HO(t, e, n) {
    t = je(t, 360) * 6,
    e = je(e, 100),
    n = je(n, 100);
    var r = Math.floor(t)
      , i = t - r
      , s = n * (1 - e)
      , o = n * (1 - i * e)
      , a = n * (1 - (1 - i) * e)
      , l = r % 6
      , c = [n, o, s, s, a, n][l]
      , u = [a, n, n, o, s, s][l]
      , d = [s, s, a, n, n, o][l];
    return {
        r: c * 255,
        g: u * 255,
        b: d * 255
    }
}
function Gu(t, e, n, r) {
    var i = [Ln(Math.round(t).toString(16)), Ln(Math.round(e).toString(16)), Ln(Math.round(n).toString(16))];
    return r && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("")
}
function KO(t, e, n, r, i) {
    var s = [Ln(Math.round(t).toString(16)), Ln(Math.round(e).toString(16)), Ln(Math.round(n).toString(16)), Ln(GO(r))];
    return i && s[0].startsWith(s[0].charAt(1)) && s[1].startsWith(s[1].charAt(1)) && s[2].startsWith(s[2].charAt(1)) && s[3].startsWith(s[3].charAt(1)) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("")
}
function GO(t) {
    return Math.round(parseFloat(t) * 255).toString(16)
}
function qu(t) {
    return tt(t) / 255
}
function tt(t) {
    return parseInt(t, 16)
}
function qO(t) {
    return {
        r: t >> 16,
        g: (t & 65280) >> 8,
        b: t & 255
    }
}
var sa = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
};
function WO(t) {
    var e = {
        r: 0,
        g: 0,
        b: 0
    }
      , n = 1
      , r = null
      , i = null
      , s = null
      , o = !1
      , a = !1;
    return typeof t == "string" && (t = XO(t)),
    typeof t == "object" && (Nt(t.r) && Nt(t.g) && Nt(t.b) ? (e = NO(t.r, t.g, t.b),
    o = !0,
    a = String(t.r).substr(-1) === "%" ? "prgb" : "rgb") : Nt(t.h) && Nt(t.s) && Nt(t.v) ? (r = ns(t.s),
    i = ns(t.v),
    e = HO(t.h, r, i),
    o = !0,
    a = "hsv") : Nt(t.h) && Nt(t.s) && Nt(t.l) && (r = ns(t.s),
    s = ns(t.l),
    e = zO(t.h, r, s),
    o = !0,
    a = "hsl"),
    Object.prototype.hasOwnProperty.call(t, "a") && (n = t.a)),
    n = Nh(n),
    {
        ok: o,
        format: t.format || a,
        r: Math.min(255, Math.max(e.r, 0)),
        g: Math.min(255, Math.max(e.g, 0)),
        b: Math.min(255, Math.max(e.b, 0)),
        a: n
    }
}
var YO = "[-\\+]?\\d+%?"
  , ZO = "[-\\+]?\\d*\\.\\d+%?"
  , vn = "(?:".concat(ZO, ")|(?:").concat(YO, ")")
  , Fo = "[\\s|\\(]+(".concat(vn, ")[,|\\s]+(").concat(vn, ")[,|\\s]+(").concat(vn, ")\\s*\\)?")
  , Ro = "[\\s|\\(]+(".concat(vn, ")[,|\\s]+(").concat(vn, ")[,|\\s]+(").concat(vn, ")[,|\\s]+(").concat(vn, ")\\s*\\)?")
  , vt = {
    CSS_UNIT: new RegExp(vn),
    rgb: new RegExp("rgb" + Fo),
    rgba: new RegExp("rgba" + Ro),
    hsl: new RegExp("hsl" + Fo),
    hsla: new RegExp("hsla" + Ro),
    hsv: new RegExp("hsv" + Fo),
    hsva: new RegExp("hsva" + Ro),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function XO(t) {
    if (t = t.trim().toLowerCase(),
    t.length === 0)
        return !1;
    var e = !1;
    if (sa[t])
        t = sa[t],
        e = !0;
    else if (t === "transparent")
        return {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            format: "name"
        };
    var n = vt.rgb.exec(t);
    return n ? {
        r: n[1],
        g: n[2],
        b: n[3]
    } : (n = vt.rgba.exec(t),
    n ? {
        r: n[1],
        g: n[2],
        b: n[3],
        a: n[4]
    } : (n = vt.hsl.exec(t),
    n ? {
        h: n[1],
        s: n[2],
        l: n[3]
    } : (n = vt.hsla.exec(t),
    n ? {
        h: n[1],
        s: n[2],
        l: n[3],
        a: n[4]
    } : (n = vt.hsv.exec(t),
    n ? {
        h: n[1],
        s: n[2],
        v: n[3]
    } : (n = vt.hsva.exec(t),
    n ? {
        h: n[1],
        s: n[2],
        v: n[3],
        a: n[4]
    } : (n = vt.hex8.exec(t),
    n ? {
        r: tt(n[1]),
        g: tt(n[2]),
        b: tt(n[3]),
        a: qu(n[4]),
        format: e ? "name" : "hex8"
    } : (n = vt.hex6.exec(t),
    n ? {
        r: tt(n[1]),
        g: tt(n[2]),
        b: tt(n[3]),
        format: e ? "name" : "hex"
    } : (n = vt.hex4.exec(t),
    n ? {
        r: tt(n[1] + n[1]),
        g: tt(n[2] + n[2]),
        b: tt(n[3] + n[3]),
        a: qu(n[4] + n[4]),
        format: e ? "name" : "hex8"
    } : (n = vt.hex3.exec(t),
    n ? {
        r: tt(n[1] + n[1]),
        g: tt(n[2] + n[2]),
        b: tt(n[3] + n[3]),
        format: e ? "name" : "hex"
    } : !1)))))))))
}
function Nt(t) {
    return !!vt.CSS_UNIT.exec(String(t))
}
var QO = function() {
    function t(e, n) {
        e === void 0 && (e = ""),
        n === void 0 && (n = {});
        var r;
        if (e instanceof t)
            return e;
        typeof e == "number" && (e = qO(e)),
        this.originalInput = e;
        var i = WO(e);
        this.originalInput = e,
        this.r = i.r,
        this.g = i.g,
        this.b = i.b,
        this.a = i.a,
        this.roundA = Math.round(100 * this.a) / 100,
        this.format = (r = n.format) !== null && r !== void 0 ? r : i.format,
        this.gradientType = n.gradientType,
        this.r < 1 && (this.r = Math.round(this.r)),
        this.g < 1 && (this.g = Math.round(this.g)),
        this.b < 1 && (this.b = Math.round(this.b)),
        this.isValid = i.ok
    }
    return t.prototype.isDark = function() {
        return this.getBrightness() < 128
    }
    ,
    t.prototype.isLight = function() {
        return !this.isDark()
    }
    ,
    t.prototype.getBrightness = function() {
        var e = this.toRgb();
        return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3
    }
    ,
    t.prototype.getLuminance = function() {
        var e = this.toRgb(), n, r, i, s = e.r / 255, o = e.g / 255, a = e.b / 255;
        return s <= .03928 ? n = s / 12.92 : n = Math.pow((s + .055) / 1.055, 2.4),
        o <= .03928 ? r = o / 12.92 : r = Math.pow((o + .055) / 1.055, 2.4),
        a <= .03928 ? i = a / 12.92 : i = Math.pow((a + .055) / 1.055, 2.4),
        .2126 * n + .7152 * r + .0722 * i
    }
    ,
    t.prototype.getAlpha = function() {
        return this.a
    }
    ,
    t.prototype.setAlpha = function(e) {
        return this.a = Nh(e),
        this.roundA = Math.round(100 * this.a) / 100,
        this
    }
    ,
    t.prototype.isMonochrome = function() {
        var e = this.toHsl().s;
        return e === 0
    }
    ,
    t.prototype.toHsv = function() {
        var e = Ku(this.r, this.g, this.b);
        return {
            h: e.h * 360,
            s: e.s,
            v: e.v,
            a: this.a
        }
    }
    ,
    t.prototype.toHsvString = function() {
        var e = Ku(this.r, this.g, this.b)
          , n = Math.round(e.h * 360)
          , r = Math.round(e.s * 100)
          , i = Math.round(e.v * 100);
        return this.a === 1 ? "hsv(".concat(n, ", ").concat(r, "%, ").concat(i, "%)") : "hsva(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")")
    }
    ,
    t.prototype.toHsl = function() {
        var e = Hu(this.r, this.g, this.b);
        return {
            h: e.h * 360,
            s: e.s,
            l: e.l,
            a: this.a
        }
    }
    ,
    t.prototype.toHslString = function() {
        var e = Hu(this.r, this.g, this.b)
          , n = Math.round(e.h * 360)
          , r = Math.round(e.s * 100)
          , i = Math.round(e.l * 100);
        return this.a === 1 ? "hsl(".concat(n, ", ").concat(r, "%, ").concat(i, "%)") : "hsla(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")")
    }
    ,
    t.prototype.toHex = function(e) {
        return e === void 0 && (e = !1),
        Gu(this.r, this.g, this.b, e)
    }
    ,
    t.prototype.toHexString = function(e) {
        return e === void 0 && (e = !1),
        "#" + this.toHex(e)
    }
    ,
    t.prototype.toHex8 = function(e) {
        return e === void 0 && (e = !1),
        KO(this.r, this.g, this.b, this.a, e)
    }
    ,
    t.prototype.toHex8String = function(e) {
        return e === void 0 && (e = !1),
        "#" + this.toHex8(e)
    }
    ,
    t.prototype.toHexShortString = function(e) {
        return e === void 0 && (e = !1),
        this.a === 1 ? this.toHexString(e) : this.toHex8String(e)
    }
    ,
    t.prototype.toRgb = function() {
        return {
            r: Math.round(this.r),
            g: Math.round(this.g),
            b: Math.round(this.b),
            a: this.a
        }
    }
    ,
    t.prototype.toRgbString = function() {
        var e = Math.round(this.r)
          , n = Math.round(this.g)
          , r = Math.round(this.b);
        return this.a === 1 ? "rgb(".concat(e, ", ").concat(n, ", ").concat(r, ")") : "rgba(".concat(e, ", ").concat(n, ", ").concat(r, ", ").concat(this.roundA, ")")
    }
    ,
    t.prototype.toPercentageRgb = function() {
        var e = function(n) {
            return "".concat(Math.round(je(n, 255) * 100), "%")
        };
        return {
            r: e(this.r),
            g: e(this.g),
            b: e(this.b),
            a: this.a
        }
    }
    ,
    t.prototype.toPercentageRgbString = function() {
        var e = function(n) {
            return Math.round(je(n, 255) * 100)
        };
        return this.a === 1 ? "rgb(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%)") : "rgba(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%, ").concat(this.roundA, ")")
    }
    ,
    t.prototype.toName = function() {
        if (this.a === 0)
            return "transparent";
        if (this.a < 1)
            return !1;
        for (var e = "#" + Gu(this.r, this.g, this.b, !1), n = 0, r = Object.entries(sa); n < r.length; n++) {
            var i = r[n]
              , s = i[0]
              , o = i[1];
            if (e === o)
                return s
        }
        return !1
    }
    ,
    t.prototype.toString = function(e) {
        var n = !!e;
        e = e ?? this.format;
        var r = !1
          , i = this.a < 1 && this.a >= 0
          , s = !n && i && (e.startsWith("hex") || e === "name");
        return s ? e === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (r = this.toRgbString()),
        e === "prgb" && (r = this.toPercentageRgbString()),
        (e === "hex" || e === "hex6") && (r = this.toHexString()),
        e === "hex3" && (r = this.toHexString(!0)),
        e === "hex4" && (r = this.toHex8String(!0)),
        e === "hex8" && (r = this.toHex8String()),
        e === "name" && (r = this.toName()),
        e === "hsl" && (r = this.toHslString()),
        e === "hsv" && (r = this.toHsvString()),
        r || this.toHexString())
    }
    ,
    t.prototype.toNumber = function() {
        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b)
    }
    ,
    t.prototype.clone = function() {
        return new t(this.toString())
    }
    ,
    t.prototype.lighten = function(e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return n.l += e / 100,
        n.l = ts(n.l),
        new t(n)
    }
    ,
    t.prototype.brighten = function(e) {
        e === void 0 && (e = 10);
        var n = this.toRgb();
        return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(e / 100)))),
        n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(e / 100)))),
        n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(e / 100)))),
        new t(n)
    }
    ,
    t.prototype.darken = function(e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return n.l -= e / 100,
        n.l = ts(n.l),
        new t(n)
    }
    ,
    t.prototype.tint = function(e) {
        return e === void 0 && (e = 10),
        this.mix("white", e)
    }
    ,
    t.prototype.shade = function(e) {
        return e === void 0 && (e = 10),
        this.mix("black", e)
    }
    ,
    t.prototype.desaturate = function(e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return n.s -= e / 100,
        n.s = ts(n.s),
        new t(n)
    }
    ,
    t.prototype.saturate = function(e) {
        e === void 0 && (e = 10);
        var n = this.toHsl();
        return n.s += e / 100,
        n.s = ts(n.s),
        new t(n)
    }
    ,
    t.prototype.greyscale = function() {
        return this.desaturate(100)
    }
    ,
    t.prototype.spin = function(e) {
        var n = this.toHsl()
          , r = (n.h + e) % 360;
        return n.h = r < 0 ? 360 + r : r,
        new t(n)
    }
    ,
    t.prototype.mix = function(e, n) {
        n === void 0 && (n = 50);
        var r = this.toRgb()
          , i = new t(e).toRgb()
          , s = n / 100
          , o = {
            r: (i.r - r.r) * s + r.r,
            g: (i.g - r.g) * s + r.g,
            b: (i.b - r.b) * s + r.b,
            a: (i.a - r.a) * s + r.a
        };
        return new t(o)
    }
    ,
    t.prototype.analogous = function(e, n) {
        e === void 0 && (e = 6),
        n === void 0 && (n = 30);
        var r = this.toHsl()
          , i = 360 / n
          , s = [this];
        for (r.h = (r.h - (i * e >> 1) + 720) % 360; --e; )
            r.h = (r.h + i) % 360,
            s.push(new t(r));
        return s
    }
    ,
    t.prototype.complement = function() {
        var e = this.toHsl();
        return e.h = (e.h + 180) % 360,
        new t(e)
    }
    ,
    t.prototype.monochromatic = function(e) {
        e === void 0 && (e = 6);
        for (var n = this.toHsv(), r = n.h, i = n.s, s = n.v, o = [], a = 1 / e; e--; )
            o.push(new t({
                h: r,
                s: i,
                v: s
            })),
            s = (s + a) % 1;
        return o
    }
    ,
    t.prototype.splitcomplement = function() {
        var e = this.toHsl()
          , n = e.h;
        return [this, new t({
            h: (n + 72) % 360,
            s: e.s,
            l: e.l
        }), new t({
            h: (n + 216) % 360,
            s: e.s,
            l: e.l
        })]
    }
    ,
    t.prototype.onBackground = function(e) {
        var n = this.toRgb()
          , r = new t(e).toRgb()
          , i = n.a + r.a * (1 - n.a);
        return new t({
            r: (n.r * n.a + r.r * r.a * (1 - n.a)) / i,
            g: (n.g * n.a + r.g * r.a * (1 - n.a)) / i,
            b: (n.b * n.a + r.b * r.a * (1 - n.a)) / i,
            a: i
        })
    }
    ,
    t.prototype.triad = function() {
        return this.polyad(3)
    }
    ,
    t.prototype.tetrad = function() {
        return this.polyad(4)
    }
    ,
    t.prototype.polyad = function(e) {
        for (var n = this.toHsl(), r = n.h, i = [this], s = 360 / e, o = 1; o < e; o++)
            i.push(new t({
                h: (r + o * s) % 360,
                s: n.s,
                l: n.l
            }));
        return i
    }
    ,
    t.prototype.equals = function(e) {
        return this.toRgbString() === new t(e).toRgbString()
    }
    ,
    t
}();
function un(t, e=20) {
    return t.mix("#141414", e).toString()
}
function JO(t) {
    const e = Mi()
      , n = we("button");
    return E( () => {
        let r = {}
          , i = t.color;
        if (i) {
            const s = i.match(/var\((.*?)\)/);
            s && (i = window.getComputedStyle(window.document.documentElement).getPropertyValue(s[1]));
            const o = new QO(i)
              , a = t.dark ? o.tint(20).toString() : un(o, 20);
            if (t.plain)
                r = n.cssVarBlock({
                    "bg-color": t.dark ? un(o, 90) : o.tint(90).toString(),
                    "text-color": i,
                    "border-color": t.dark ? un(o, 50) : o.tint(50).toString(),
                    "hover-text-color": `var(${n.cssVarName("color-white")})`,
                    "hover-bg-color": i,
                    "hover-border-color": i,
                    "active-bg-color": a,
                    "active-text-color": `var(${n.cssVarName("color-white")})`,
                    "active-border-color": a
                }),
                e.value && (r[n.cssVarBlockName("disabled-bg-color")] = t.dark ? un(o, 90) : o.tint(90).toString(),
                r[n.cssVarBlockName("disabled-text-color")] = t.dark ? un(o, 50) : o.tint(50).toString(),
                r[n.cssVarBlockName("disabled-border-color")] = t.dark ? un(o, 80) : o.tint(80).toString());
            else {
                const l = t.dark ? un(o, 30) : o.tint(30).toString()
                  , c = o.isDark() ? `var(${n.cssVarName("color-white")})` : `var(${n.cssVarName("color-black")})`;
                if (r = n.cssVarBlock({
                    "bg-color": i,
                    "text-color": c,
                    "border-color": i,
                    "hover-bg-color": l,
                    "hover-text-color": c,
                    "hover-border-color": l,
                    "active-bg-color": a,
                    "active-border-color": a
                }),
                e.value) {
                    const u = t.dark ? un(o, 50) : o.tint(50).toString();
                    r[n.cssVarBlockName("disabled-bg-color")] = u,
                    r[n.cssVarBlockName("disabled-text-color")] = t.dark ? "rgba(255, 255, 255, 0.5)" : `var(${n.cssVarName("color-white")})`,
                    r[n.cssVarBlockName("disabled-border-color")] = u
                }
            }
        }
        return r
    }
    )
}
const eT = H({
    name: "ElButton"
})
  , tT = H({
    ...eT,
    props: ia,
    emits: $O,
    setup(t, {expose: e, emit: n}) {
        const r = t
          , i = JO(r)
          , s = we("button")
          , {_ref: o, _size: a, _type: l, _disabled: c, _props: u, shouldAddSpace: d, handleClick: m} = VO(r, n)
          , g = E( () => [s.b(), s.m(l.value), s.m(a.value), s.is("disabled", c.value), s.is("loading", r.loading), s.is("plain", r.plain), s.is("round", r.round), s.is("circle", r.circle), s.is("text", r.text), s.is("link", r.link), s.is("has-bg", r.bg)]);
        return e({
            ref: o,
            size: a,
            type: l,
            disabled: c,
            shouldAddSpace: d
        }),
        (f, h) => (S(),
        ae(yt(f.tag), Wt({
            ref_key: "_ref",
            ref: o
        }, v(u), {
            class: v(g),
            style: v(i),
            onClick: v(m)
        }), {
            default: G( () => [f.loading ? (S(),
            j(Ze, {
                key: 0
            }, [f.$slots.loading ? he(f.$slots, "loading", {
                key: 0
            }) : (S(),
            ae(v(St), {
                key: 1,
                class: D(v(s).is("loading"))
            }, {
                default: G( () => [(S(),
                ae(yt(f.loadingIcon)))]),
                _: 1
            }, 8, ["class"]))], 64)) : f.icon || f.$slots.icon ? (S(),
            ae(v(St), {
                key: 1
            }, {
                default: G( () => [f.icon ? (S(),
                ae(yt(f.icon), {
                    key: 0
                })) : he(f.$slots, "icon", {
                    key: 1
                })]),
                _: 3
            })) : J("v-if", !0), f.$slots.default ? (S(),
            j("span", {
                key: 2,
                class: D({
                    [v(s).em("text", "expand")]: v(d)
                })
            }, [he(f.$slots, "default")], 2)) : J("v-if", !0)]),
            _: 3
        }, 16, ["class", "style", "onClick"]))
    }
});
var nT = xe(tT, [["__file", "button.vue"]]);
const rT = {
    size: ia.size,
    type: ia.type
}
  , iT = H({
    name: "ElButtonGroup"
})
  , sT = H({
    ...iT,
    props: rT,
    setup(t) {
        const e = t;
        ut(jh, Hn({
            size: Gt(e, "size"),
            type: Gt(e, "type")
        }));
        const n = we("button");
        return (r, i) => (S(),
        j("div", {
            class: D(v(n).b("group"))
        }, [he(r.$slots, "default")], 2))
    }
});
var zh = xe(sT, [["__file", "button-group.vue"]]);
const oa = Bt(nT, {
    ButtonGroup: zh
});
Qs(zh);
const hn = new Map;
if (He) {
    let t;
    document.addEventListener("mousedown", e => t = e),
    document.addEventListener("mouseup", e => {
        if (t) {
            for (const n of hn.values())
                for (const {documentHandler: r} of n)
                    r(e, t);
            t = void 0
        }
    }
    )
}
function Wu(t, e) {
    let n = [];
    return Array.isArray(e.arg) ? n = e.arg : cr(e.arg) && n.push(e.arg),
    function(r, i) {
        const s = e.instance.popperRef
          , o = r.target
          , a = i == null ? void 0 : i.target
          , l = !e || !e.instance
          , c = !o || !a
          , u = t.contains(o) || t.contains(a)
          , d = t === o
          , m = n.length && n.some(f => f == null ? void 0 : f.contains(o)) || n.length && n.includes(a)
          , g = s && (s.contains(o) || s.contains(a));
        l || c || u || d || m || g || e.value(r, i)
    }
}
const oT = {
    beforeMount(t, e) {
        hn.has(t) || hn.set(t, []),
        hn.get(t).push({
            documentHandler: Wu(t, e),
            bindingFn: e.value
        })
    },
    updated(t, e) {
        hn.has(t) || hn.set(t, []);
        const n = hn.get(t)
          , r = n.findIndex(s => s.bindingFn === e.oldValue)
          , i = {
            documentHandler: Wu(t, e),
            bindingFn: e.value
        };
        r >= 0 ? n.splice(r, 1, i) : n.push(i)
    },
    unmounted(t) {
        hn.delete(t)
    }
}
  , Hh = {
    modelValue: {
        type: [Number, String, Boolean],
        default: void 0
    },
    label: {
        type: [String, Boolean, Number, Object],
        default: void 0
    },
    value: {
        type: [String, Boolean, Number, Object],
        default: void 0
    },
    indeterminate: Boolean,
    disabled: Boolean,
    checked: Boolean,
    name: {
        type: String,
        default: void 0
    },
    trueValue: {
        type: [String, Number],
        default: void 0
    },
    falseValue: {
        type: [String, Number],
        default: void 0
    },
    trueLabel: {
        type: [String, Number],
        default: void 0
    },
    falseLabel: {
        type: [String, Number],
        default: void 0
    },
    id: {
        type: String,
        default: void 0
    },
    border: Boolean,
    size: ki,
    tabindex: [String, Number],
    validateEvent: {
        type: Boolean,
        default: !0
    },
    ...Er(["ariaControls"])
}
  , Kh = {
    [xt]: t => ze(t) || Jt(t) || Nn(t),
    change: t => ze(t) || Jt(t) || Nn(t)
}
  , Tr = Symbol("checkboxGroupContextKey")
  , aT = ({model: t, isChecked: e}) => {
    const n = le(Tr, void 0)
      , r = E( () => {
        var s, o;
        const a = (s = n == null ? void 0 : n.max) == null ? void 0 : s.value
          , l = (o = n == null ? void 0 : n.min) == null ? void 0 : o.value;
        return !di(a) && t.value.length >= a && !e.value || !di(l) && t.value.length <= l && e.value
    }
    );
    return {
        isDisabled: Mi(E( () => (n == null ? void 0 : n.disabled.value) || r.value)),
        isLimitDisabled: r
    }
}
  , lT = (t, {model: e, isLimitExceeded: n, hasOwnLabel: r, isDisabled: i, isLabeledByFormItem: s}) => {
    const o = le(Tr, void 0)
      , {formItem: a} = Or()
      , {emit: l} = Ve();
    function c(f) {
        var h, _, p, b;
        return [!0, t.trueValue, t.trueLabel].includes(f) ? (_ = (h = t.trueValue) != null ? h : t.trueLabel) != null ? _ : !0 : (b = (p = t.falseValue) != null ? p : t.falseLabel) != null ? b : !1
    }
    function u(f, h) {
        l("change", c(f), h)
    }
    function d(f) {
        if (n.value)
            return;
        const h = f.target;
        l("change", c(h.checked), f)
    }
    async function m(f) {
        n.value || !r.value && !i.value && s.value && (f.composedPath().some(p => p.tagName === "LABEL") || (e.value = c([!1, t.falseValue, t.falseLabel].includes(e.value)),
        await ke(),
        u(e.value, f)))
    }
    const g = E( () => (o == null ? void 0 : o.validateEvent) || t.validateEvent);
    return W( () => t.modelValue, () => {
        g.value && (a == null || a.validate("change").catch(f => void 0))
    }
    ),
    {
        handleChange: d,
        onClickRoot: m
    }
}
  , cT = t => {
    const e = M(!1)
      , {emit: n} = Ve()
      , r = le(Tr, void 0)
      , i = E( () => di(r) === !1)
      , s = M(!1)
      , o = E({
        get() {
            var a, l;
            return i.value ? (a = r == null ? void 0 : r.modelValue) == null ? void 0 : a.value : (l = t.modelValue) != null ? l : e.value
        },
        set(a) {
            var l, c;
            i.value && Dn(a) ? (s.value = ((l = r == null ? void 0 : r.max) == null ? void 0 : l.value) !== void 0 && a.length > (r == null ? void 0 : r.max.value) && a.length > o.value.length,
            s.value === !1 && ((c = r == null ? void 0 : r.changeEvent) == null || c.call(r, a))) : (n(xt, a),
            e.value = a)
        }
    });
    return {
        model: o,
        isGroup: i,
        isLimitExceeded: s
    }
}
  , uT = (t, e, {model: n}) => {
    const r = le(Tr, void 0)
      , i = M(!1)
      , s = E( () => Xo(t.value) ? t.label : t.value)
      , o = E( () => {
        const u = n.value;
        return Nn(u) ? u : Dn(u) ? _n(s.value) ? u.map(Fl).some(d => CC(d, s.value)) : u.map(Fl).includes(s.value) : u != null ? u === t.trueValue || u === t.trueLabel : !!u
    }
    )
      , a = xn(E( () => {
        var u;
        return (u = r == null ? void 0 : r.size) == null ? void 0 : u.value
    }
    ), {
        prop: !0
    })
      , l = xn(E( () => {
        var u;
        return (u = r == null ? void 0 : r.size) == null ? void 0 : u.value
    }
    ))
      , c = E( () => !!e.default || !Xo(s.value));
    return {
        checkboxButtonSize: a,
        isChecked: o,
        isFocused: i,
        checkboxSize: l,
        hasOwnLabel: c,
        actualValue: s
    }
}
  , Gh = (t, e) => {
    const {formItem: n} = Or()
      , {model: r, isGroup: i, isLimitExceeded: s} = cT(t)
      , {isFocused: o, isChecked: a, checkboxButtonSize: l, checkboxSize: c, hasOwnLabel: u, actualValue: d} = uT(t, e, {
        model: r
    })
      , {isDisabled: m} = aT({
        model: r,
        isChecked: a
    })
      , {inputId: g, isLabeledByFormItem: f} = to(t, {
        formItemContext: n,
        disableIdGeneration: u,
        disableIdManagement: i
    })
      , {handleChange: h, onClickRoot: _} = lT(t, {
        model: r,
        isLimitExceeded: s,
        hasOwnLabel: u,
        isDisabled: m,
        isLabeledByFormItem: f
    });
    return ( () => {
        function b() {
            var y, w;
            Dn(r.value) && !r.value.includes(d.value) ? r.value.push(d.value) : r.value = (w = (y = t.trueValue) != null ? y : t.trueLabel) != null ? w : !0
        }
        t.checked && b()
    }
    )(),
    ls({
        from: "label act as value",
        replacement: "value",
        version: "3.0.0",
        scope: "el-checkbox",
        ref: "https://element-plus.org/en-US/component/checkbox.html"
    }, E( () => i.value && Xo(t.value))),
    ls({
        from: "true-label",
        replacement: "true-value",
        version: "3.0.0",
        scope: "el-checkbox",
        ref: "https://element-plus.org/en-US/component/checkbox.html"
    }, E( () => !!t.trueLabel)),
    ls({
        from: "false-label",
        replacement: "false-value",
        version: "3.0.0",
        scope: "el-checkbox",
        ref: "https://element-plus.org/en-US/component/checkbox.html"
    }, E( () => !!t.falseLabel)),
    {
        inputId: g,
        isLabeledByFormItem: f,
        isChecked: a,
        isDisabled: m,
        isFocused: o,
        checkboxButtonSize: l,
        checkboxSize: c,
        hasOwnLabel: u,
        model: r,
        actualValue: d,
        handleChange: h,
        onClickRoot: _
    }
}
  , dT = H({
    name: "ElCheckbox"
})
  , pT = H({
    ...dT,
    props: Hh,
    emits: Kh,
    setup(t) {
        const e = t
          , n = gi()
          , {inputId: r, isLabeledByFormItem: i, isChecked: s, isDisabled: o, isFocused: a, checkboxSize: l, hasOwnLabel: c, model: u, actualValue: d, handleChange: m, onClickRoot: g} = Gh(e, n)
          , f = we("checkbox")
          , h = E( () => [f.b(), f.m(l.value), f.is("disabled", o.value), f.is("bordered", e.border), f.is("checked", s.value)])
          , _ = E( () => [f.e("input"), f.is("disabled", o.value), f.is("checked", s.value), f.is("indeterminate", e.indeterminate), f.is("focus", a.value)]);
        return (p, b) => (S(),
        ae(yt(!v(c) && v(i) ? "span" : "label"), {
            class: D(v(h)),
            "aria-controls": p.indeterminate ? p.ariaControls : null,
            onClick: v(g)
        }, {
            default: G( () => {
                var y, w;
                return [$("span", {
                    class: D(v(_))
                }, [p.trueValue || p.falseValue || p.trueLabel || p.falseLabel ? Mt((S(),
                j("input", {
                    key: 0,
                    id: v(r),
                    "onUpdate:modelValue": x => Vn(u) ? u.value = x : null,
                    class: D(v(f).e("original")),
                    type: "checkbox",
                    indeterminate: p.indeterminate,
                    name: p.name,
                    tabindex: p.tabindex,
                    disabled: v(o),
                    "true-value": (y = p.trueValue) != null ? y : p.trueLabel,
                    "false-value": (w = p.falseValue) != null ? w : p.falseLabel,
                    onChange: v(m),
                    onFocus: x => a.value = !0,
                    onBlur: x => a.value = !1,
                    onClick: ni( () => {}
                    , ["stop"])
                }, null, 42, ["id", "onUpdate:modelValue", "indeterminate", "name", "tabindex", "disabled", "true-value", "false-value", "onChange", "onFocus", "onBlur", "onClick"])), [[_s, v(u)]]) : Mt((S(),
                j("input", {
                    key: 1,
                    id: v(r),
                    "onUpdate:modelValue": x => Vn(u) ? u.value = x : null,
                    class: D(v(f).e("original")),
                    type: "checkbox",
                    indeterminate: p.indeterminate,
                    disabled: v(o),
                    value: v(d),
                    name: p.name,
                    tabindex: p.tabindex,
                    onChange: v(m),
                    onFocus: x => a.value = !0,
                    onBlur: x => a.value = !1,
                    onClick: ni( () => {}
                    , ["stop"])
                }, null, 42, ["id", "onUpdate:modelValue", "indeterminate", "disabled", "value", "name", "tabindex", "onChange", "onFocus", "onBlur", "onClick"])), [[_s, v(u)]]), $("span", {
                    class: D(v(f).e("inner"))
                }, null, 2)], 2), v(c) ? (S(),
                j("span", {
                    key: 0,
                    class: D(v(f).e("label"))
                }, [he(p.$slots, "default"), p.$slots.default ? J("v-if", !0) : (S(),
                j(Ze, {
                    key: 0
                }, [bt(Ue(p.label), 1)], 64))], 2)) : J("v-if", !0)]
            }
            ),
            _: 3
        }, 8, ["class", "aria-controls", "onClick"]))
    }
});
var hT = xe(pT, [["__file", "checkbox.vue"]]);
const fT = H({
    name: "ElCheckboxButton"
})
  , mT = H({
    ...fT,
    props: Hh,
    emits: Kh,
    setup(t) {
        const e = t
          , n = gi()
          , {isFocused: r, isChecked: i, isDisabled: s, checkboxButtonSize: o, model: a, actualValue: l, handleChange: c} = Gh(e, n)
          , u = le(Tr, void 0)
          , d = we("checkbox")
          , m = E( () => {
            var f, h, _, p;
            const b = (h = (f = u == null ? void 0 : u.fill) == null ? void 0 : f.value) != null ? h : "";
            return {
                backgroundColor: b,
                borderColor: b,
                color: (p = (_ = u == null ? void 0 : u.textColor) == null ? void 0 : _.value) != null ? p : "",
                boxShadow: b ? `-1px 0 0 0 ${b}` : void 0
            }
        }
        )
          , g = E( () => [d.b("button"), d.bm("button", o.value), d.is("disabled", s.value), d.is("checked", i.value), d.is("focus", r.value)]);
        return (f, h) => {
            var _, p;
            return S(),
            j("label", {
                class: D(v(g))
            }, [f.trueValue || f.falseValue || f.trueLabel || f.falseLabel ? Mt((S(),
            j("input", {
                key: 0,
                "onUpdate:modelValue": b => Vn(a) ? a.value = b : null,
                class: D(v(d).be("button", "original")),
                type: "checkbox",
                name: f.name,
                tabindex: f.tabindex,
                disabled: v(s),
                "true-value": (_ = f.trueValue) != null ? _ : f.trueLabel,
                "false-value": (p = f.falseValue) != null ? p : f.falseLabel,
                onChange: v(c),
                onFocus: b => r.value = !0,
                onBlur: b => r.value = !1,
                onClick: ni( () => {}
                , ["stop"])
            }, null, 42, ["onUpdate:modelValue", "name", "tabindex", "disabled", "true-value", "false-value", "onChange", "onFocus", "onBlur", "onClick"])), [[_s, v(a)]]) : Mt((S(),
            j("input", {
                key: 1,
                "onUpdate:modelValue": b => Vn(a) ? a.value = b : null,
                class: D(v(d).be("button", "original")),
                type: "checkbox",
                name: f.name,
                tabindex: f.tabindex,
                disabled: v(s),
                value: v(l),
                onChange: v(c),
                onFocus: b => r.value = !0,
                onBlur: b => r.value = !1,
                onClick: ni( () => {}
                , ["stop"])
            }, null, 42, ["onUpdate:modelValue", "name", "tabindex", "disabled", "value", "onChange", "onFocus", "onBlur", "onClick"])), [[_s, v(a)]]), f.$slots.default || f.label ? (S(),
            j("span", {
                key: 2,
                class: D(v(d).be("button", "inner")),
                style: qe(v(i) ? v(m) : void 0)
            }, [he(f.$slots, "default", {}, () => [bt(Ue(f.label), 1)])], 6)) : J("v-if", !0)], 2)
        }
    }
});
var qh = xe(mT, [["__file", "checkbox-button.vue"]]);
const vT = Ae({
    modelValue: {
        type: te(Array),
        default: () => []
    },
    disabled: Boolean,
    min: Number,
    max: Number,
    size: ki,
    fill: String,
    textColor: String,
    tag: {
        type: String,
        default: "div"
    },
    validateEvent: {
        type: Boolean,
        default: !0
    },
    ...Er(["ariaLabel"])
})
  , gT = {
    [xt]: t => Dn(t),
    change: t => Dn(t)
}
  , bT = H({
    name: "ElCheckboxGroup"
})
  , _T = H({
    ...bT,
    props: vT,
    emits: gT,
    setup(t, {emit: e}) {
        const n = t
          , r = we("checkbox")
          , {formItem: i} = Or()
          , {inputId: s, isLabeledByFormItem: o} = to(n, {
            formItemContext: i
        })
          , a = async c => {
            e(xt, c),
            await ke(),
            e("change", c)
        }
          , l = E({
            get() {
                return n.modelValue
            },
            set(c) {
                a(c)
            }
        });
        return ut(Tr, {
            ...nh(Us(n), ["size", "min", "max", "disabled", "validateEvent", "fill", "textColor"]),
            modelValue: l,
            changeEvent: a
        }),
        W( () => n.modelValue, () => {
            n.validateEvent && (i == null || i.validate("change").catch(c => void 0))
        }
        ),
        (c, u) => {
            var d;
            return S(),
            ae(yt(c.tag), {
                id: v(s),
                class: D(v(r).b("group")),
                role: "group",
                "aria-label": v(o) ? void 0 : c.ariaLabel || "checkbox-group",
                "aria-labelledby": v(o) ? (d = v(i)) == null ? void 0 : d.labelId : void 0
            }, {
                default: G( () => [he(c.$slots, "default")]),
                _: 3
            }, 8, ["id", "class", "aria-label", "aria-labelledby"])
        }
    }
});
var Wh = xe(_T, [["__file", "checkbox-group.vue"]]);
const yT = Bt(hT, {
    CheckboxButton: qh,
    CheckboxGroup: Wh
});
Qs(qh);
Qs(Wh);
const wT = Ae({
    color: {
        type: te(Object),
        required: !0
    },
    vertical: {
        type: Boolean,
        default: !1
    }
});
let Io = !1;
function vi(t, e) {
    if (!He)
        return;
    const n = function(s) {
        var o;
        (o = e.drag) == null || o.call(e, s)
    }
      , r = function(s) {
        var o;
        document.removeEventListener("mousemove", n),
        document.removeEventListener("mouseup", r),
        document.removeEventListener("touchmove", n),
        document.removeEventListener("touchend", r),
        document.onselectstart = null,
        document.ondragstart = null,
        Io = !1,
        (o = e.end) == null || o.call(e, s)
    }
      , i = function(s) {
        var o;
        Io || (s.preventDefault(),
        document.onselectstart = () => !1,
        document.ondragstart = () => !1,
        document.addEventListener("mousemove", n),
        document.addEventListener("mouseup", r),
        document.addEventListener("touchmove", n),
        document.addEventListener("touchend", r),
        Io = !0,
        (o = e.start) == null || o.call(e, s))
    };
    t.addEventListener("mousedown", i),
    t.addEventListener("touchstart", i, {
        passive: !1
    })
}
const xT = t => {
    const e = Ve()
      , {t: n} = ll()
      , r = Fn()
      , i = Fn()
      , s = E( () => t.color.get("alpha"))
      , o = E( () => n("el.colorpicker.alphaLabel"));
    function a(d) {
        var m;
        d.target !== r.value && l(d),
        (m = r.value) == null || m.focus()
    }
    function l(d) {
        if (!i.value || !r.value)
            return;
        const g = e.vnode.el.getBoundingClientRect()
          , {clientX: f, clientY: h} = qa(d);
        if (t.vertical) {
            let _ = h - g.top;
            _ = Math.max(r.value.offsetHeight / 2, _),
            _ = Math.min(_, g.height - r.value.offsetHeight / 2),
            t.color.set("alpha", Math.round((_ - r.value.offsetHeight / 2) / (g.height - r.value.offsetHeight) * 100))
        } else {
            let _ = f - g.left;
            _ = Math.max(r.value.offsetWidth / 2, _),
            _ = Math.min(_, g.width - r.value.offsetWidth / 2),
            t.color.set("alpha", Math.round((_ - r.value.offsetWidth / 2) / (g.width - r.value.offsetWidth) * 100))
        }
    }
    function c(d) {
        const {code: m, shiftKey: g} = d
          , f = g ? 10 : 1;
        switch (m) {
        case wt.left:
        case wt.down:
            d.preventDefault(),
            d.stopPropagation(),
            u(-f);
            break;
        case wt.right:
        case wt.up:
            d.preventDefault(),
            d.stopPropagation(),
            u(f);
            break
        }
    }
    function u(d) {
        let m = s.value + d;
        m = m < 0 ? 0 : m > 100 ? 100 : m,
        t.color.set("alpha", m)
    }
    return {
        thumb: r,
        bar: i,
        alpha: s,
        alphaLabel: o,
        handleDrag: l,
        handleClick: a,
        handleKeydown: c
    }
}
  , CT = (t, {bar: e, thumb: n, handleDrag: r}) => {
    const i = Ve()
      , s = we("color-alpha-slider")
      , o = M(0)
      , a = M(0)
      , l = M();
    function c() {
        if (!n.value || t.vertical)
            return 0;
        const b = i.vnode.el
          , y = t.color.get("alpha");
        return b ? Math.round(y * (b.offsetWidth - n.value.offsetWidth / 2) / 100) : 0
    }
    function u() {
        if (!n.value)
            return 0;
        const b = i.vnode.el;
        if (!t.vertical)
            return 0;
        const y = t.color.get("alpha");
        return b ? Math.round(y * (b.offsetHeight - n.value.offsetHeight / 2) / 100) : 0
    }
    function d() {
        if (t.color && t.color.value) {
            const {r: b, g: y, b: w} = t.color.toRgb();
            return `linear-gradient(to right, rgba(${b}, ${y}, ${w}, 0) 0%, rgba(${b}, ${y}, ${w}, 1) 100%)`
        }
        return ""
    }
    function m() {
        o.value = c(),
        a.value = u(),
        l.value = d()
    }
    De( () => {
        if (!e.value || !n.value)
            return;
        const b = {
            drag: y => {
                r(y)
            }
            ,
            end: y => {
                r(y)
            }
        };
        vi(e.value, b),
        vi(n.value, b),
        m()
    }
    ),
    W( () => t.color.get("alpha"), () => m()),
    W( () => t.color.value, () => m());
    const g = E( () => [s.b(), s.is("vertical", t.vertical)])
      , f = E( () => s.e("bar"))
      , h = E( () => s.e("thumb"))
      , _ = E( () => ({
        background: l.value
    }))
      , p = E( () => ({
        left: pi(o.value),
        top: pi(a.value)
    }));
    return {
        rootKls: g,
        barKls: f,
        barStyle: _,
        thumbKls: h,
        thumbStyle: p,
        update: m
    }
}
  , ET = "ElColorAlphaSlider"
  , PT = H({
    name: ET
})
  , OT = H({
    ...PT,
    props: wT,
    setup(t, {expose: e}) {
        const n = t
          , {alpha: r, alphaLabel: i, bar: s, thumb: o, handleDrag: a, handleClick: l, handleKeydown: c} = xT(n)
          , {rootKls: u, barKls: d, barStyle: m, thumbKls: g, thumbStyle: f, update: h} = CT(n, {
            bar: s,
            thumb: o,
            handleDrag: a
        });
        return e({
            update: h,
            bar: s,
            thumb: o
        }),
        (_, p) => (S(),
        j("div", {
            class: D(v(u))
        }, [$("div", {
            ref_key: "bar",
            ref: s,
            class: D(v(d)),
            style: qe(v(m)),
            onClick: v(l)
        }, null, 14, ["onClick"]), $("div", {
            ref_key: "thumb",
            ref: o,
            class: D(v(g)),
            style: qe(v(f)),
            "aria-label": v(i),
            "aria-valuenow": v(r),
            "aria-orientation": _.vertical ? "vertical" : "horizontal",
            "aria-valuemin": "0",
            "aria-valuemax": "100",
            role: "slider",
            tabindex: "0",
            onKeydown: v(c)
        }, null, 46, ["aria-label", "aria-valuenow", "aria-orientation", "onKeydown"])], 2))
    }
});
var TT = xe(OT, [["__file", "alpha-slider.vue"]]);
const AT = H({
    name: "ElColorHueSlider",
    props: {
        color: {
            type: Object,
            required: !0
        },
        vertical: Boolean
    },
    setup(t) {
        const e = we("color-hue-slider")
          , n = Ve()
          , r = M()
          , i = M()
          , s = M(0)
          , o = M(0)
          , a = E( () => t.color.get("hue"));
        W( () => a.value, () => {
            m()
        }
        );
        function l(g) {
            g.target !== r.value && c(g)
        }
        function c(g) {
            if (!i.value || !r.value)
                return;
            const h = n.vnode.el.getBoundingClientRect()
              , {clientX: _, clientY: p} = qa(g);
            let b;
            if (t.vertical) {
                let y = p - h.top;
                y = Math.min(y, h.height - r.value.offsetHeight / 2),
                y = Math.max(r.value.offsetHeight / 2, y),
                b = Math.round((y - r.value.offsetHeight / 2) / (h.height - r.value.offsetHeight) * 360)
            } else {
                let y = _ - h.left;
                y = Math.min(y, h.width - r.value.offsetWidth / 2),
                y = Math.max(r.value.offsetWidth / 2, y),
                b = Math.round((y - r.value.offsetWidth / 2) / (h.width - r.value.offsetWidth) * 360)
            }
            t.color.set("hue", b)
        }
        function u() {
            if (!r.value)
                return 0;
            const g = n.vnode.el;
            if (t.vertical)
                return 0;
            const f = t.color.get("hue");
            return g ? Math.round(f * (g.offsetWidth - r.value.offsetWidth / 2) / 360) : 0
        }
        function d() {
            if (!r.value)
                return 0;
            const g = n.vnode.el;
            if (!t.vertical)
                return 0;
            const f = t.color.get("hue");
            return g ? Math.round(f * (g.offsetHeight - r.value.offsetHeight / 2) / 360) : 0
        }
        function m() {
            s.value = u(),
            o.value = d()
        }
        return De( () => {
            if (!i.value || !r.value)
                return;
            const g = {
                drag: f => {
                    c(f)
                }
                ,
                end: f => {
                    c(f)
                }
            };
            vi(i.value, g),
            vi(r.value, g),
            m()
        }
        ),
        {
            bar: i,
            thumb: r,
            thumbLeft: s,
            thumbTop: o,
            hueValue: a,
            handleClick: l,
            update: m,
            ns: e
        }
    }
});
function ST(t, e, n, r, i, s) {
    return S(),
    j("div", {
        class: D([t.ns.b(), t.ns.is("vertical", t.vertical)])
    }, [$("div", {
        ref: "bar",
        class: D(t.ns.e("bar")),
        onClick: t.handleClick
    }, null, 10, ["onClick"]), $("div", {
        ref: "thumb",
        class: D(t.ns.e("thumb")),
        style: qe({
            left: t.thumbLeft + "px",
            top: t.thumbTop + "px"
        })
    }, null, 6)], 2)
}
var kT = xe(AT, [["render", ST], ["__file", "hue-slider.vue"]]);
const MT = Ae({
    modelValue: String,
    id: String,
    showAlpha: Boolean,
    colorFormat: String,
    disabled: Boolean,
    size: ki,
    popperClass: {
        type: String,
        default: ""
    },
    tabindex: {
        type: [String, Number],
        default: 0
    },
    teleported: Pl.teleported,
    predefine: {
        type: te(Array)
    },
    validateEvent: {
        type: Boolean,
        default: !0
    },
    ...Er(["ariaLabel"])
})
  , LT = {
    [xt]: t => ze(t) || bn(t),
    [HC]: t => ze(t) || bn(t),
    activeChange: t => ze(t) || bn(t),
    focus: t => t instanceof FocusEvent,
    blur: t => t instanceof FocusEvent
}
  , Yh = Symbol("colorPickerContextKey")
  , Yu = function(t, e, n) {
    return [t, e * n / ((t = (2 - e) * n) < 1 ? t : 2 - t) || 0, t / 2]
}
  , FT = function(t) {
    return typeof t == "string" && t.includes(".") && Number.parseFloat(t) === 1
}
  , RT = function(t) {
    return typeof t == "string" && t.includes("%")
}
  , ur = function(t, e) {
    FT(t) && (t = "100%");
    const n = RT(t);
    return t = Math.min(e, Math.max(0, Number.parseFloat(`${t}`))),
    n && (t = Number.parseInt(`${t * e}`, 10) / 100),
    Math.abs(t - e) < 1e-6 ? 1 : t % e / Number.parseFloat(e)
}
  , Zu = {
    10: "A",
    11: "B",
    12: "C",
    13: "D",
    14: "E",
    15: "F"
}
  , ps = t => {
    t = Math.min(Math.round(t), 255);
    const e = Math.floor(t / 16)
      , n = t % 16;
    return `${Zu[e] || e}${Zu[n] || n}`
}
  , Xu = function({r: t, g: e, b: n}) {
    return Number.isNaN(+t) || Number.isNaN(+e) || Number.isNaN(+n) ? "" : `#${ps(t)}${ps(e)}${ps(n)}`
}
  , Vo = {
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15
}
  , An = function(t) {
    return t.length === 2 ? (Vo[t[0].toUpperCase()] || +t[0]) * 16 + (Vo[t[1].toUpperCase()] || +t[1]) : Vo[t[1].toUpperCase()] || +t[1]
}
  , IT = function(t, e, n) {
    e = e / 100,
    n = n / 100;
    let r = e;
    const i = Math.max(n, .01);
    n *= 2,
    e *= n <= 1 ? n : 2 - n,
    r *= i <= 1 ? i : 2 - i;
    const s = (n + e) / 2
      , o = n === 0 ? 2 * r / (i + r) : 2 * e / (n + e);
    return {
        h: t,
        s: o * 100,
        v: s * 100
    }
}
  , Qu = (t, e, n) => {
    t = ur(t, 255),
    e = ur(e, 255),
    n = ur(n, 255);
    const r = Math.max(t, e, n)
      , i = Math.min(t, e, n);
    let s;
    const o = r
      , a = r - i
      , l = r === 0 ? 0 : a / r;
    if (r === i)
        s = 0;
    else {
        switch (r) {
        case t:
            {
                s = (e - n) / a + (e < n ? 6 : 0);
                break
            }
        case e:
            {
                s = (n - t) / a + 2;
                break
            }
        case n:
            {
                s = (t - e) / a + 4;
                break
            }
        }
        s /= 6
    }
    return {
        h: s * 360,
        s: l * 100,
        v: o * 100
    }
}
  , Hr = function(t, e, n) {
    t = ur(t, 360) * 6,
    e = ur(e, 100),
    n = ur(n, 100);
    const r = Math.floor(t)
      , i = t - r
      , s = n * (1 - e)
      , o = n * (1 - i * e)
      , a = n * (1 - (1 - i) * e)
      , l = r % 6
      , c = [n, o, s, s, a, n][l]
      , u = [a, n, n, o, s, s][l]
      , d = [s, s, a, n, n, o][l];
    return {
        r: Math.round(c * 255),
        g: Math.round(u * 255),
        b: Math.round(d * 255)
    }
};
class ei {
    constructor(e={}) {
        this._hue = 0,
        this._saturation = 100,
        this._value = 100,
        this._alpha = 100,
        this.enableAlpha = !1,
        this.format = "hex",
        this.value = "";
        for (const n in e)
            gs(e, n) && (this[n] = e[n]);
        e.value ? this.fromString(e.value) : this.doOnChange()
    }
    set(e, n) {
        if (arguments.length === 1 && typeof e == "object") {
            for (const r in e)
                gs(e, r) && this.set(r, e[r]);
            return
        }
        this[`_${e}`] = n,
        this.doOnChange()
    }
    get(e) {
        return e === "alpha" ? Math.floor(this[`_${e}`]) : this[`_${e}`]
    }
    toRgb() {
        return Hr(this._hue, this._saturation, this._value)
    }
    fromString(e) {
        if (!e) {
            this._hue = 0,
            this._saturation = 100,
            this._value = 100,
            this.doOnChange();
            return
        }
        const n = (r, i, s) => {
            this._hue = Math.max(0, Math.min(360, r)),
            this._saturation = Math.max(0, Math.min(100, i)),
            this._value = Math.max(0, Math.min(100, s)),
            this.doOnChange()
        }
        ;
        if (e.includes("hsl")) {
            const r = e.replace(/hsla|hsl|\(|\)/gm, "").split(/\s|,/g).filter(i => i !== "").map( (i, s) => s > 2 ? Number.parseFloat(i) : Number.parseInt(i, 10));
            if (r.length === 4 ? this._alpha = Number.parseFloat(r[3]) * 100 : r.length === 3 && (this._alpha = 100),
            r.length >= 3) {
                const {h: i, s, v: o} = IT(r[0], r[1], r[2]);
                n(i, s, o)
            }
        } else if (e.includes("hsv")) {
            const r = e.replace(/hsva|hsv|\(|\)/gm, "").split(/\s|,/g).filter(i => i !== "").map( (i, s) => s > 2 ? Number.parseFloat(i) : Number.parseInt(i, 10));
            r.length === 4 ? this._alpha = Number.parseFloat(r[3]) * 100 : r.length === 3 && (this._alpha = 100),
            r.length >= 3 && n(r[0], r[1], r[2])
        } else if (e.includes("rgb")) {
            const r = e.replace(/rgba|rgb|\(|\)/gm, "").split(/\s|,/g).filter(i => i !== "").map( (i, s) => s > 2 ? Number.parseFloat(i) : Number.parseInt(i, 10));
            if (r.length === 4 ? this._alpha = Number.parseFloat(r[3]) * 100 : r.length === 3 && (this._alpha = 100),
            r.length >= 3) {
                const {h: i, s, v: o} = Qu(r[0], r[1], r[2]);
                n(i, s, o)
            }
        } else if (e.includes("#")) {
            const r = e.replace("#", "").trim();
            if (!/^[0-9a-fA-F]{3}$|^[0-9a-fA-F]{6}$|^[0-9a-fA-F]{8}$/.test(r))
                return;
            let i, s, o;
            r.length === 3 ? (i = An(r[0] + r[0]),
            s = An(r[1] + r[1]),
            o = An(r[2] + r[2])) : (r.length === 6 || r.length === 8) && (i = An(r.slice(0, 2)),
            s = An(r.slice(2, 4)),
            o = An(r.slice(4, 6))),
            r.length === 8 ? this._alpha = An(r.slice(6)) / 255 * 100 : (r.length === 3 || r.length === 6) && (this._alpha = 100);
            const {h: a, s: l, v: c} = Qu(i, s, o);
            n(a, l, c)
        }
    }
    compare(e) {
        return Math.abs(e._hue - this._hue) < 2 && Math.abs(e._saturation - this._saturation) < 1 && Math.abs(e._value - this._value) < 1 && Math.abs(e._alpha - this._alpha) < 1
    }
    doOnChange() {
        const {_hue: e, _saturation: n, _value: r, _alpha: i, format: s} = this;
        if (this.enableAlpha)
            switch (s) {
            case "hsl":
                {
                    const o = Yu(e, n / 100, r / 100);
                    this.value = `hsla(${e}, ${Math.round(o[1] * 100)}%, ${Math.round(o[2] * 100)}%, ${this.get("alpha") / 100})`;
                    break
                }
            case "hsv":
                {
                    this.value = `hsva(${e}, ${Math.round(n)}%, ${Math.round(r)}%, ${this.get("alpha") / 100})`;
                    break
                }
            case "hex":
                {
                    this.value = `${Xu(Hr(e, n, r))}${ps(i * 255 / 100)}`;
                    break
                }
            default:
                {
                    const {r: o, g: a, b: l} = Hr(e, n, r);
                    this.value = `rgba(${o}, ${a}, ${l}, ${this.get("alpha") / 100})`
                }
            }
        else
            switch (s) {
            case "hsl":
                {
                    const o = Yu(e, n / 100, r / 100);
                    this.value = `hsl(${e}, ${Math.round(o[1] * 100)}%, ${Math.round(o[2] * 100)}%)`;
                    break
                }
            case "hsv":
                {
                    this.value = `hsv(${e}, ${Math.round(n)}%, ${Math.round(r)}%)`;
                    break
                }
            case "rgb":
                {
                    const {r: o, g: a, b: l} = Hr(e, n, r);
                    this.value = `rgb(${o}, ${a}, ${l})`;
                    break
                }
            default:
                this.value = Xu(Hr(e, n, r))
            }
    }
}
const VT = H({
    props: {
        colors: {
            type: Array,
            required: !0
        },
        color: {
            type: Object,
            required: !0
        },
        enableAlpha: {
            type: Boolean,
            required: !0
        }
    },
    setup(t) {
        const e = we("color-predefine")
          , {currentColor: n} = le(Yh)
          , r = M(s(t.colors, t.color));
        W( () => n.value, o => {
            const a = new ei;
            a.fromString(o),
            r.value.forEach(l => {
                l.selected = a.compare(l)
            }
            )
        }
        ),
        Zf( () => {
            r.value = s(t.colors, t.color)
        }
        );
        function i(o) {
            t.color.fromString(t.colors[o])
        }
        function s(o, a) {
            return o.map(l => {
                const c = new ei;
                return c.enableAlpha = t.enableAlpha,
                c.format = "rgba",
                c.fromString(l),
                c.selected = c.value === a.value,
                c
            }
            )
        }
        return {
            rgbaColors: r,
            handleSelect: i,
            ns: e
        }
    }
});
function DT(t, e, n, r, i, s) {
    return S(),
    j("div", {
        class: D(t.ns.b())
    }, [$("div", {
        class: D(t.ns.e("colors"))
    }, [(S(!0),
    j(Ze, null, Sn(t.rgbaColors, (o, a) => (S(),
    j("div", {
        key: t.colors[a],
        class: D([t.ns.e("color-selector"), t.ns.is("alpha", o._alpha < 100), {
            selected: o.selected
        }]),
        onClick: l => t.handleSelect(a)
    }, [$("div", {
        style: qe({
            backgroundColor: o.value
        })
    }, null, 4)], 10, ["onClick"]))), 128))], 2)], 2)
}
var BT = xe(VT, [["render", DT], ["__file", "predefine.vue"]]);
const $T = H({
    name: "ElSlPanel",
    props: {
        color: {
            type: Object,
            required: !0
        }
    },
    setup(t) {
        const e = we("color-svpanel")
          , n = Ve()
          , r = M(0)
          , i = M(0)
          , s = M("hsl(0, 100%, 50%)")
          , o = E( () => {
            const c = t.color.get("hue")
              , u = t.color.get("value");
            return {
                hue: c,
                value: u
            }
        }
        );
        function a() {
            const c = t.color.get("saturation")
              , u = t.color.get("value")
              , d = n.vnode.el
              , {clientWidth: m, clientHeight: g} = d;
            i.value = c * m / 100,
            r.value = (100 - u) * g / 100,
            s.value = `hsl(${t.color.get("hue")}, 100%, 50%)`
        }
        function l(c) {
            const d = n.vnode.el.getBoundingClientRect()
              , {clientX: m, clientY: g} = qa(c);
            let f = m - d.left
              , h = g - d.top;
            f = Math.max(0, f),
            f = Math.min(f, d.width),
            h = Math.max(0, h),
            h = Math.min(h, d.height),
            i.value = f,
            r.value = h,
            t.color.set({
                saturation: f / d.width * 100,
                value: 100 - h / d.height * 100
            })
        }
        return W( () => o.value, () => {
            a()
        }
        ),
        De( () => {
            vi(n.vnode.el, {
                drag: c => {
                    l(c)
                }
                ,
                end: c => {
                    l(c)
                }
            }),
            a()
        }
        ),
        {
            cursorTop: r,
            cursorLeft: i,
            background: s,
            colorValue: o,
            handleDrag: l,
            update: a,
            ns: e
        }
    }
});
function UT(t, e, n, r, i, s) {
    return S(),
    j("div", {
        class: D(t.ns.b()),
        style: qe({
            backgroundColor: t.background
        })
    }, [$("div", {
        class: D(t.ns.e("white"))
    }, null, 2), $("div", {
        class: D(t.ns.e("black"))
    }, null, 2), $("div", {
        class: D(t.ns.e("cursor")),
        style: qe({
            top: t.cursorTop + "px",
            left: t.cursorLeft + "px"
        })
    }, [$("div")], 6)], 6)
}
var jT = xe($T, [["render", UT], ["__file", "sv-panel.vue"]]);
const NT = H({
    name: "ElColorPicker"
})
  , zT = H({
    ...NT,
    props: MT,
    emits: LT,
    setup(t, {expose: e, emit: n}) {
        const r = t
          , {t: i} = ll()
          , s = we("color")
          , {formItem: o} = Or()
          , a = xn()
          , l = Mi()
          , {inputId: c, isLabeledByFormItem: u} = to(r, {
            formItemContext: o
        })
          , d = M()
          , m = M()
          , g = M()
          , f = M()
          , h = M()
          , _ = M()
          , {isFocused: p, handleFocus: b, handleBlur: y} = Sh(h, {
            beforeFocus() {
                return l.value
            },
            beforeBlur(F) {
                var ee;
                return (ee = f.value) == null ? void 0 : ee.isFocusInsideContent(F)
            },
            afterBlur() {
                K(!1),
                pe()
            }
        });
        let w = !0;
        const x = Hn(new ei({
            enableAlpha: r.showAlpha,
            format: r.colorFormat || "",
            value: r.modelValue
        }))
          , C = M(!1)
          , P = M(!1)
          , T = M("")
          , L = E( () => !r.modelValue && !P.value ? "transparent" : z(x, r.showAlpha))
          , I = E( () => !r.modelValue && !P.value ? "" : x.value)
          , U = E( () => u.value ? void 0 : r.ariaLabel || i("el.colorpicker.defaultLabel"))
          , B = E( () => u.value ? o == null ? void 0 : o.labelId : void 0)
          , V = E( () => [s.b("picker"), s.is("disabled", l.value), s.bm("picker", a.value), s.is("focused", p.value)]);
        function z(F, ee) {
            if (!(F instanceof ei))
                throw new TypeError("color should be instance of _color Class");
            const {r: re, g: Ie, b: Ke} = F.toRgb();
            return ee ? `rgba(${re}, ${Ie}, ${Ke}, ${F.get("alpha") / 100})` : `rgb(${re}, ${Ie}, ${Ke})`
        }
        function K(F) {
            C.value = F
        }
        const A = xC(K, 100, {
            leading: !0
        });
        function X() {
            l.value || K(!0)
        }
        function de() {
            A(!1),
            pe()
        }
        function pe() {
            ke( () => {
                r.modelValue ? x.fromString(r.modelValue) : (x.value = "",
                ke( () => {
                    P.value = !1
                }
                ))
            }
            )
        }
        function Pe() {
            l.value || A(!C.value)
        }
        function Be() {
            x.fromString(T.value)
        }
        function _e() {
            const F = x.value;
            n(xt, F),
            n("change", F),
            r.validateEvent && (o == null || o.validate("change").catch(ee => void 0)),
            A(!1),
            ke( () => {
                const ee = new ei({
                    enableAlpha: r.showAlpha,
                    format: r.colorFormat || "",
                    value: r.modelValue
                });
                x.compare(ee) || pe()
            }
            )
        }
        function Oe() {
            A(!1),
            n(xt, null),
            n("change", null),
            r.modelValue !== null && r.validateEvent && (o == null || o.validate("change").catch(F => void 0)),
            pe()
        }
        function $e() {
            C.value && (de(),
            p.value && Re())
        }
        function Ne(F) {
            F.preventDefault(),
            F.stopPropagation(),
            K(!1),
            pe()
        }
        function Ot(F) {
            switch (F.code) {
            case wt.enter:
            case wt.space:
                F.preventDefault(),
                F.stopPropagation(),
                X(),
                _.value.focus();
                break;
            case wt.esc:
                Ne(F);
                break
            }
        }
        function Re() {
            h.value.focus()
        }
        function N() {
            h.value.blur()
        }
        return De( () => {
            r.modelValue && (T.value = I.value)
        }
        ),
        W( () => r.modelValue, F => {
            F ? F && F !== x.value && (w = !1,
            x.fromString(F)) : P.value = !1
        }
        ),
        W( () => r.colorFormat, () => {
            r.colorFormat && (x.format = r.colorFormat,
            x.doOnChange(),
            n(xt, x.value))
        }
        ),
        W( () => I.value, F => {
            T.value = F,
            w && n("activeChange", F),
            w = !0
        }
        ),
        W( () => x.value, () => {
            !r.modelValue && !P.value && (P.value = !0)
        }
        ),
        W( () => C.value, () => {
            ke( () => {
                var F, ee, re;
                (F = d.value) == null || F.update(),
                (ee = m.value) == null || ee.update(),
                (re = g.value) == null || re.update()
            }
            )
        }
        ),
        ut(Yh, {
            currentColor: I
        }),
        e({
            color: x,
            show: X,
            hide: de,
            focus: Re,
            blur: N
        }),
        (F, ee) => (S(),
        ae(v(IO), {
            ref_key: "popper",
            ref: f,
            visible: C.value,
            "show-arrow": !1,
            "fallback-placements": ["bottom", "top", "right", "left"],
            offset: 0,
            "gpu-acceleration": !1,
            "popper-class": [v(s).be("picker", "panel"), v(s).b("dropdown"), F.popperClass],
            "stop-popper-mouse-event": !1,
            effect: "light",
            trigger: "click",
            teleported: F.teleported,
            transition: `${v(s).namespace.value}-zoom-in-top`,
            persistent: "",
            onHide: re => K(!1)
        }, {
            content: G( () => [Mt((S(),
            j("div", {
                onKeydown: Rl(Ne, ["esc"])
            }, [$("div", {
                class: D(v(s).be("dropdown", "main-wrapper"))
            }, [Y(kT, {
                ref_key: "hue",
                ref: d,
                class: "hue-slider",
                color: v(x),
                vertical: ""
            }, null, 8, ["color"]), Y(jT, {
                ref_key: "sv",
                ref: m,
                color: v(x)
            }, null, 8, ["color"])], 2), F.showAlpha ? (S(),
            ae(TT, {
                key: 0,
                ref_key: "alpha",
                ref: g,
                color: v(x)
            }, null, 8, ["color"])) : J("v-if", !0), F.predefine ? (S(),
            ae(BT, {
                key: 1,
                ref: "predefine",
                "enable-alpha": F.showAlpha,
                color: v(x),
                colors: F.predefine
            }, null, 8, ["enable-alpha", "color", "colors"])) : J("v-if", !0), $("div", {
                class: D(v(s).be("dropdown", "btns"))
            }, [$("span", {
                class: D(v(s).be("dropdown", "value"))
            }, [Y(v(SP), {
                ref_key: "inputRef",
                ref: _,
                modelValue: T.value,
                "onUpdate:modelValue": re => T.value = re,
                "validate-event": !1,
                size: "small",
                onKeyup: Rl(Be, ["enter"]),
                onBlur: Be
            }, null, 8, ["modelValue", "onUpdate:modelValue", "onKeyup"])], 2), Y(v(oa), {
                class: D(v(s).be("dropdown", "link-btn")),
                text: "",
                size: "small",
                onClick: Oe
            }, {
                default: G( () => [bt(Ue(v(i)("el.colorpicker.clear")), 1)]),
                _: 1
            }, 8, ["class"]), Y(v(oa), {
                plain: "",
                size: "small",
                class: D(v(s).be("dropdown", "btn")),
                onClick: _e
            }, {
                default: G( () => [bt(Ue(v(i)("el.colorpicker.confirm")), 1)]),
                _: 1
            }, 8, ["class"])], 2)], 40, ["onKeydown"])), [[v(oT), $e]])]),
            default: G( () => [$("div", Wt({
                id: v(c),
                ref_key: "triggerRef",
                ref: h
            }, F.$attrs, {
                class: v(V),
                role: "button",
                "aria-label": v(U),
                "aria-labelledby": v(B),
                "aria-description": v(i)("el.colorpicker.description", {
                    color: F.modelValue || ""
                }),
                "aria-disabled": v(l),
                tabindex: v(l) ? -1 : F.tabindex,
                onKeydown: Ot,
                onFocus: v(b),
                onBlur: v(y)
            }), [v(l) ? (S(),
            j("div", {
                key: 0,
                class: D(v(s).be("picker", "mask"))
            }, null, 2)) : J("v-if", !0), $("div", {
                class: D(v(s).be("picker", "trigger")),
                onClick: Pe
            }, [$("span", {
                class: D([v(s).be("picker", "color"), v(s).is("alpha", F.showAlpha)])
            }, [$("span", {
                class: D(v(s).be("picker", "color-inner")),
                style: qe({
                    backgroundColor: v(L)
                })
            }, [Mt(Y(v(St), {
                class: D([v(s).be("picker", "icon"), v(s).is("icon-arrow-down")])
            }, {
                default: G( () => [Y(v(LC))]),
                _: 1
            }, 8, ["class"]), [[bs, F.modelValue || P.value]]), Mt(Y(v(St), {
                class: D([v(s).be("picker", "empty"), v(s).is("icon-close")])
            }, {
                default: G( () => [Y(v(DC))]),
                _: 1
            }, 8, ["class"]), [[bs, !F.modelValue && !P.value]])], 6)], 2)], 2)], 16, ["id", "aria-label", "aria-labelledby", "aria-description", "aria-disabled", "tabindex", "onFocus", "onBlur"])]),
            _: 1
        }, 8, ["visible", "popper-class", "teleported", "transition", "onHide"]))
    }
});
var HT = xe(zT, [["__file", "color-picker.vue"]]);
const KT = Bt(HT)
  , GT = Ae({
    type: {
        type: String,
        values: ["primary", "success", "info", "warning", "danger", ""],
        default: ""
    },
    size: {
        type: String,
        values: Js,
        default: ""
    },
    truncated: Boolean,
    lineClamp: {
        type: [String, Number]
    },
    tag: {
        type: String,
        default: "span"
    }
})
  , qT = H({
    name: "ElText"
})
  , WT = H({
    ...qT,
    props: GT,
    setup(t) {
        const e = t
          , n = xn()
          , r = we("text")
          , i = E( () => [r.b(), r.m(e.type), r.m(n.value), r.is("truncated", e.truncated), r.is("line-clamp", !di(e.lineClamp))]);
        return (s, o) => (S(),
        ae(yt(s.tag), {
            class: D(v(i)),
            style: qe({
                "-webkit-line-clamp": s.lineClamp
            })
        }, {
            default: G( () => [he(s.$slots, "default")]),
            _: 3
        }, 8, ["class", "style"]))
    }
});
var YT = xe(WT, [["__file", "text.vue"]]);
const ZT = Bt(YT);
function XT(t) {
    let e;
    const n = M(!1)
      , r = Hn({
        ...t,
        originalPosition: "",
        originalOverflow: "",
        visible: !1
    });
    function i(m) {
        r.text = m
    }
    function s() {
        const m = r.parent
          , g = d.ns;
        if (!m.vLoadingAddClassList) {
            let f = m.getAttribute("loading-number");
            f = Number.parseInt(f) - 1,
            f ? m.setAttribute("loading-number", f.toString()) : (Ls(m, g.bm("parent", "relative")),
            m.removeAttribute("loading-number")),
            Ls(m, g.bm("parent", "hidden"))
        }
        o(),
        u.unmount()
    }
    function o() {
        var m, g;
        (g = (m = d.$el) == null ? void 0 : m.parentNode) == null || g.removeChild(d.$el)
    }
    function a() {
        var m;
        t.beforeClose && !t.beforeClose() || (n.value = !0,
        clearTimeout(e),
        e = setTimeout(l, 400),
        r.visible = !1,
        (m = t.closed) == null || m.call(t))
    }
    function l() {
        if (!n.value)
            return;
        const m = r.parent;
        n.value = !1,
        m.vLoadingAddClassList = void 0,
        s()
    }
    const c = H({
        name: "ElLoading",
        setup(m, {expose: g}) {
            const {ns: f, zIndex: h} = w2("loading");
            return g({
                ns: f,
                zIndex: h
            }),
            () => {
                const _ = r.spinner || r.svg
                  , p = Mr("svg", {
                    class: "circular",
                    viewBox: r.svgViewBox ? r.svgViewBox : "0 0 50 50",
                    ..._ ? {
                        innerHTML: _
                    } : {}
                }, [Mr("circle", {
                    class: "path",
                    cx: "25",
                    cy: "25",
                    r: "20",
                    fill: "none"
                })])
                  , b = r.text ? Mr("p", {
                    class: f.b("text")
                }, [r.text]) : void 0;
                return Mr(Wr, {
                    name: f.b("fade"),
                    onAfterLeave: l
                }, {
                    default: G( () => [Mt(Y("div", {
                        style: {
                            backgroundColor: r.background || ""
                        },
                        class: [f.b("mask"), r.customClass, r.fullscreen ? "is-fullscreen" : ""]
                    }, [Mr("div", {
                        class: f.b("spinner")
                    }, [p, b])]), [[bs, r.visible]])])
                })
            }
        }
    })
      , u = Xf(c)
      , d = u.mount(document.createElement("div"));
    return {
        ...Us(r),
        setText: i,
        removeElLoadingChild: o,
        close: a,
        handleAfterLeave: l,
        vm: d,
        get $el() {
            return d.$el
        }
    }
}
let rs;
const aa = function(t={}) {
    if (!He)
        return;
    const e = QT(t);
    if (e.fullscreen && rs)
        return rs;
    const n = XT({
        ...e,
        closed: () => {
            var i;
            (i = e.closed) == null || i.call(e),
            e.fullscreen && (rs = void 0)
        }
    });
    JT(e, e.parent, n),
    Ju(e, e.parent, n),
    e.parent.vLoadingAddClassList = () => Ju(e, e.parent, n);
    let r = e.parent.getAttribute("loading-number");
    return r ? r = `${Number.parseInt(r) + 1}` : r = "1",
    e.parent.setAttribute("loading-number", r),
    e.parent.appendChild(n.$el),
    ke( () => n.visible.value = e.visible),
    e.fullscreen && (rs = n),
    n
}
  , QT = t => {
    var e, n, r, i;
    let s;
    return ze(t.target) ? s = (e = document.querySelector(t.target)) != null ? e : document.body : s = t.target || document.body,
    {
        parent: s === document.body || t.body ? document.body : s,
        background: t.background || "",
        svg: t.svg || "",
        svgViewBox: t.svgViewBox || "",
        spinner: t.spinner || !1,
        text: t.text || "",
        fullscreen: s === document.body && ((n = t.fullscreen) != null ? n : !0),
        lock: (r = t.lock) != null ? r : !1,
        customClass: t.customClass || "",
        visible: (i = t.visible) != null ? i : !0,
        beforeClose: t.beforeClose,
        closed: t.closed,
        target: s
    }
}
  , JT = async (t, e, n) => {
    const {nextZIndex: r} = n.vm.zIndex || n.vm._.exposed.zIndex
      , i = {};
    if (t.fullscreen)
        n.originalPosition.value = Nr(document.body, "position"),
        n.originalOverflow.value = Nr(document.body, "overflow"),
        i.zIndex = r();
    else if (t.parent === document.body) {
        n.originalPosition.value = Nr(document.body, "position"),
        await ke();
        for (const s of ["top", "left"]) {
            const o = s === "top" ? "scrollTop" : "scrollLeft";
            i[s] = `${t.target.getBoundingClientRect()[s] + document.body[o] + document.documentElement[o] - Number.parseInt(Nr(document.body, `margin-${s}`), 10)}px`
        }
        for (const s of ["height", "width"])
            i[s] = `${t.target.getBoundingClientRect()[s]}px`
    } else
        n.originalPosition.value = Nr(e, "position");
    for (const [s,o] of Object.entries(i))
        n.$el.style[s] = o
}
  , Ju = (t, e, n) => {
    const r = n.vm.ns || n.vm._.exposed.ns;
    ["absolute", "fixed", "sticky"].includes(n.originalPosition.value) ? Ls(e, r.bm("parent", "relative")) : pu(e, r.bm("parent", "relative")),
    t.fullscreen && t.lock ? pu(e, r.bm("parent", "hidden")) : Ls(e, r.bm("parent", "hidden"))
}
  , hs = Symbol("ElLoading")
  , ed = (t, e) => {
    var n, r, i, s;
    const o = e.instance
      , a = m => _n(e.value) ? e.value[m] : void 0
      , l = m => {
        const g = ze(m) && (o == null ? void 0 : o[m]) || m;
        return g && M(g)
    }
      , c = m => l(a(m) || t.getAttribute(`element-loading-${Qf(m)}`))
      , u = (n = a("fullscreen")) != null ? n : e.modifiers.fullscreen
      , d = {
        text: c("text"),
        svg: c("svg"),
        svgViewBox: c("svgViewBox"),
        spinner: c("spinner"),
        background: c("background"),
        customClass: c("customClass"),
        fullscreen: u,
        target: (r = a("target")) != null ? r : u ? void 0 : t,
        body: (i = a("body")) != null ? i : e.modifiers.body,
        lock: (s = a("lock")) != null ? s : e.modifiers.lock
    };
    t[hs] = {
        options: d,
        instance: aa(d)
    }
}
  , eA = (t, e) => {
    for (const n of Object.keys(e))
        Vn(e[n]) && (e[n].value = t[n])
}
  , td = {
    mounted(t, e) {
        e.value && ed(t, e)
    },
    updated(t, e) {
        const n = t[hs];
        e.oldValue !== e.value && (e.value && !e.oldValue ? ed(t, e) : e.value && e.oldValue ? _n(e.value) && eA(e.value, n.options) : n == null || n.instance.close())
    },
    unmounted(t) {
        var e;
        (e = t[hs]) == null || e.instance.close(),
        t[hs] = null
    }
}
  , tA = {
    install(t) {
        t.directive("loading", td),
        t.config.globalProperties.$loading = aa
    },
    directive: td,
    service: aa
}
  , nA = "" + new URL("../../assets/ImdcPod/models/POD.glb",import.meta.url).href;
function ro(t, e) {
    var n;
    (n = t.color) != null && n.isColor && e.color.copy(t.color),
    e.name = t.name,
    e.side = t.side,
    e.opacity = t.opacity,
    e.transparent = t.transparent,
    e.depthTest = t.depthTest,
    e.depthWrite = t.depthWrite,
    e.alphaTest = t.alphaTest,
    e.visible = t.visible,
    e.userData = JSON.parse(JSON.stringify(t.userData))
}
function Zh(t, e) {
    ro(t, e),
    t.roughness && (e.roughness = t.roughness),
    t.metalness && (e.metalness = t.metalness),
    t.wireframe && (e.wireframe = t.wireframe)
}
function rA(t, e) {
    var n;
    Zh(t, e),
    t.wireframe && (e.wireframe = t.wireframe),
    t.clearcoat && (e.clearcoat = t.clearcoat),
    t.clearcoatRoughness && (e.clearcoatRoughness = t.clearcoatRoughness),
    t.sheen && (e.sheen = t.sheen),
    (n = t.sheenColor) != null && n.isColor && e.sheenColor.copy(t.sheenColor),
    t.sheenRoughness && (e.sheenRoughness = t.sheenRoughness),
    t.transmission && (e.transmission = t.transmission)
}
function Fi(t, e) {
    for (let n in e)
        /(Map|map)$/.test(n) && t[n] && (e[n] = t[n])
}
function iA(t) {
    const e = new va;
    return Fi(t, e),
    ro(t, e),
    e
}
function sA(t) {
    const e = new qr;
    return Fi(t, e),
    ro(t, e),
    e
}
function oA(t) {
    const e = new bd;
    return Fi(t, e),
    ro(t, e),
    e
}
function aA(t) {
    const e = new Bs;
    return Fi(t, e),
    Zh(t, e),
    e
}
function lA(t) {
    const e = new _d;
    return Fi(t, e),
    rA(t, e),
    e
}
const cA = {
    toMeshBasicMaterial: iA,
    toLambertMaterial: sA,
    toPhongMaterial: oA,
    toMeshStandardMaterial: aA,
    toMeshPhysicalMaterial: lA
};
function Xh(t, e) {
    var n, r;
    e.name = t.name;
    for (let i in t)
        (n = t[i]) != null && n.isColor && ((r = e[i]) != null && r.isColor) && (e[i] = t[i].clone());
    t.map && (e.map = t.map),
    t.lightMap && (e.lightMap = t.lightMap),
    t.aoMap && (e.aoMap = t.aoMap),
    t.specularMap && (e.specularMap = t.specularMap),
    t.alphaMap && (e.alphaMap = t.alphaMap),
    t.envMap && (e.envMap = t.envMap),
    t.userData && (e.userData = t.userData)
}
function Qh(t, e) {
    Xh(t, e),
    t.emissiveMap && (e.emissiveMap = t.emissiveMap)
}
function Jh(t, e) {
    Qh(t, e),
    t.bumpMap && (e.bumpMap = t.bumpMap),
    t.normalMap && (e.normalMap = t.normalMap),
    t.displacementMap && (e.displacementMap = t.displacementMap)
}
function ef(t, e) {
    Jh(t, e),
    t.roughnessMap && (e.roughnessMap = t.roughnessMap),
    t.metalnessMap && (e.metalnessMap = t.metalnessMap)
}
function uA(t, e) {
    ef(t, e),
    t.clearcoatMap && (e.clearcoatMap = t.clearcoatMap),
    t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
    t.clearcoatNormalMap && (e.clearcoatNormalMap = t.clearcoatNormalMap),
    t.iridescenceMap && (e.iridescenceMap = t.iridescenceMap),
    t.iridescenceThicknessMap && (e.iridescenceThicknessMap = t.iridescenceThicknessMap),
    t.sheenColorMap && (e.sheenColorMap = t.sheenColorMap),
    t.sheenRoughnessMap && (e.sheenRoughnessMap = t.sheenRoughnessMap),
    t.transmissionMap && (e.transmissionMap = t.transmissionMap),
    t.thicknessMap && (e.thicknessMap = t.thicknessMap),
    t.specularIntensityMap && (e.specularIntensityMap = t.specularIntensityMap),
    t.specularColorMap && (e.specularColorMap = t.specularColorMap)
}
function dA(t, e) {
    return e || (e = new va),
    Xh(t, e),
    e
}
function pA(t, e) {
    return e || (e = new qr),
    Qh(t, e),
    e
}
function hA(t, e) {
    return e || (e = new bd),
    Jh(t, e),
    e
}
function fA(t, e) {
    return e || (e = new Bs),
    ef(t, e),
    e
}
function mA(t, e) {
    return e || (e = new _d),
    uA(t, e),
    e
}
const is = {
    MeshBasicMaterial: dA,
    MeshLambertMaterial: pA,
    MeshPhongMaterial: hA,
    MeshStandardMaterial: fA,
    MeshPhysicalMaterial: mA
};
function vA(t, e) {
    e.onpointerdown = n => {
        n.stopPropagation();
        const {offsetWidth: r, offsetHeight: i} = t.parentElement
          , {offsetLeft: s, offsetTop: o, offsetWidth: a, offsetHeight: l} = t
          , {offsetLeft: c, offsetTop: u, offsetWidth: d, offsetHeight: m} = e
          , {offsetX: g=0, offsetY: f=0} = n;
        let h = n.clientX - s
          , _ = n.clientY - o;
        document.onpointermove = p => {
            let b = Math.max(f - _, p.clientY - _)
              , y = Math.max(g - h, p.clientX - h);
            b = Math.min(i - m, b),
            y = Math.min(r - d, y),
            t.style.top = `${b}px`,
            t.style.left = `${y}px`
        }
    }
    ,
    document.onpointerover = () => e.style.cursor = "move",
    window.onpointerup = () => document.onpointermove = null
}
const io = {
    type: {
        view: "list",
        label: "type",
        options: [{
            text: "MeshBasicMaterial",
            value: "MeshBasicMaterial"
        }, {
            text: "MeshLambertMaterial",
            value: "MeshLambertMaterial"
        }, {
            text: "MeshPhongMaterial",
            value: "MeshPhongMaterial"
        }, {
            text: "MeshStandardMaterial",
            value: "MeshStandardMaterial"
        }, {
            text: "MeshPhysicalMaterial",
            value: "MeshPhysicalMaterial"
        }],
        value: ""
    },
    name: {
        readonly: !0
    },
    visible: {},
    color: {
        color: {
            type: "float"
        }
    },
    side: {
        min: 0,
        max: 2,
        step: 1
    },
    transparent: {},
    opacity: {
        min: 0,
        max: 1,
        step: .05,
        format: Ht
    },
    alphaTest: {
        min: 0,
        max: 1,
        step: .05,
        format: Ht
    },
    blending: {
        min: 0,
        max: 2,
        step: 1
    },
    depthTest: {},
    depthWrite: {},
    wireframe: {}
}
  , gA = {
    ...io
}
  , bA = {
    ...io
}
  , tf = {
    ...io,
    emissive: {
        color: {
            type: "float"
        }
    },
    flatShading: {},
    roughness: {
        min: 0,
        max: 1,
        step: .05,
        format: Ht
    },
    metalness: {
        min: 0,
        max: 1,
        step: .05,
        format: Ht
    }
}
  , _A = {
    ...tf,
    emissive: {
        color: {
            type: "float"
        }
    },
    flatShading: {},
    clearcoat: {
        min: 0,
        max: 1,
        step: .05,
        format: Ht
    },
    clearcoatRoughness: {
        min: 0,
        max: 1,
        step: .05,
        format: Ht
    },
    sheen: {
        min: 0,
        max: 1,
        step: .05,
        format: Ht
    },
    sheenRoughness: {
        min: 0,
        max: 1,
        step: .05,
        format: Ht
    },
    sheenColor: {
        color: {
            type: "float"
        }
    },
    transmission: {
        min: 0,
        max: 1,
        step: .05,
        format: Ht
    }
}
  , nd = {
    MeshBasicMaterial: io,
    MeshLambertMaterial: gA,
    MeshPhongMaterial: bA,
    MeshStandardMaterial: tf,
    MeshPhysicalMaterial: _A
};
function Ht(t) {
    return +(Math.round(t / .05) * .05).toFixed(2)
}
class yA {
    constructor({container: e, canvas: n, scene: r, camera: i, matConf: s, pane: o, pack: a}) {
        this.container = e,
        this.canvas = n,
        this.scene = r,
        this.camera = i,
        this.materials = {},
        this.materialsConf = {},
        this.nonExistentMat = [],
        this.updateMaterials(r, s),
        this.pane = null,
        o && this.initMaterialPane(e),
        this.packingReg = /.*/,
        this.packing = null,
        a && this.initPacking()
    }
    initMaterialPane(e=this.container) {
        this.title = "材质编辑器";
        const n = this.pane = new Op({
            title: this.title,
            container: e
        });
        n.element.style.position = "absolute",
        n.element.style.zIndex = "3001",
        n.element.style.left = "0%",
        n.element.style.top = "0%",
        n.element.style.width = "auto",
        n.element.style.minWidth = "240px",
        n.element.style.maxWidth = "400px",
        n.element.style.maxHeight = "95%",
        n.element.style.overflowY = "auto",
        n.element.style.overflowX = "auto";
        const i = n.element.children[0].getElementsByClassName("tp-rotv_t")[0];
        i.style.userSelect = "none",
        i.onclick = s => s.stopPropagation(),
        this.pane = n,
        vA(n.element, i),
        n.addButton({
            title: "点击保存材质,打印到控制台"
        }).on("click", () => {
            this.nonExistentMat.forEach(o => delete this.materialsConf[o]);
            for (let o in this.materialsConf) {
                const a = this.materialsConf[o].type;
                if (a)
                    for (let l in this.materialsConf[o])
                        nd[a][l] || delete this.materialsConf[o][l]
            }
            const s = JSON.stringify(this.materialsConf);
            navigator.clipboard.writeText(s),
            console.log(s)
        }
        ),
        this.addTab = n.addTab({
            pages: [{
                title: "材质列表"
            }, {
                title: "材质属性"
            }]
        })
    }
    updateMatPaneList() {
        if (this.pane)
            for (let e in this.materials) {
                const n = this.materials[e].material
                  , {name: r, id: i, uuid: s} = n;
                this.addTab.pages[0].addButton({
                    title: `${i}@${r || "未命名"}`
                }).on("click", () => {
                    this.updateMatAttrPane(n)
                }
                )
            }
    }
    updateMatAttrPane(e) {
        const n = this.addTab.pages[1];
        [...n.children].forEach(a => n.remove(a));
        const i = e.type
          , s = nd[i];
        if (!s) {
            n.addBlade({
                readonly: !0,
                view: "text",
                parse: a => String(a),
                value: `当前材质类型暂未使${i}`
            });
            return
        }
        const o = (a, l) => {
            let c = this.materialsConf[e.name];
            c || (c = this.materialsConf[e.name] = {}),
            c[a] = typeof l == "number" ? +l.toFixed(2) : l
        }
        ;
        for (let a in s)
            if (s[a])
                if (a === "type")
                    s[a].value = i,
                    n.addBlade(s[a]).on("change", ({value: c}) => {
                        const u = is[c](e);
                        this.replaceMatsData(e, u),
                        this.updateMatPaneList(),
                        this.updateMatAttrPane(u),
                        o(a, c)
                    }
                    );
                else {
                    const l = n.addBinding(e, a, s[a]);
                    s[a].readonly !== !0 && l.on("change", ({value: c}) => {
                        o(a, c)
                    }
                    )
                }
    }
    initPacking({camera: e=this.camera, canvas: n=this.canvas, scene: r=this.scene}={}) {
        const i = new Cd(e,n,r);
        return i.addEventListener("clickPoint2", ({button: s, intersects: o}) => {
            const [a] = o;
            if (s === 0 && a) {
                const {name: l, material: c} = a.object;
                this.packingReg.test(l) && (Array.isArray(c) || (this.pane.title = `${this.title} - 点击了(${l})`,
                this.updateMatAttrPane(c),
                console.log(l)))
            }
        }
        ),
        this.packing = i,
        i
    }
    updateMaterials(e=this.scene, n={}) {
        this.materials = {},
        this.updateMatMaterials(e),
        this.updateMatsByConf(n)
    }
    updateMatsByConf(e) {
        this.materialsConf = {
            ...e
        };
        for (let n in e) {
            const r = this.getMatByName(n);
            if (r) {
                const i = e[n];
                if (i.type && i.type !== r.type) {
                    const s = is[i.type](r);
                    this.replaceMatsData(r, s),
                    s.setValues({
                        ...i
                    })
                } else
                    r.setValues({
                        ...i
                    })
            } else
                this.nonExistentMat.push(n),
                console.warn("材质不存在，将被删除", n)
        }
    }
    updateMatsByConf2(e) {
        this.materialsConf = {
            ...e
        };
        for (let n in e) {
            const r = this.getMatsByName(n);
            if (r.length) {
                const i = e[n];
                r.forEach(s => {
                    if (i.type && i.type !== s.type) {
                        const o = is[i.type](s);
                        this.replaceMatsData(s, o),
                        o.setValues({
                            ...i
                        })
                    } else
                        s.setValues({
                            ...i
                        })
                }
                )
            } else
                this.nonExistentMat.push(n),
                console.warn("材质不存在，将被删除", n)
        }
    }
    saveMatsData(e, n, r) {
        let {uuid: i, name: s} = n;
        this.materials[i] || (this.materials[i] = {
            meshList: [],
            material: n,
            name: s
        }),
        this.materials[i].meshList.push({
            mesh: e,
            index: r
        })
    }
    updateMatMaterials(e) {
        e.traverse(n => {
            if (n.isMesh) {
                let r = n.material;
                Array.isArray(r) ? r.forEach( (i, s) => this.saveMatsData(n, i, s)) : this.saveMatsData(n, r)
            }
        }
        )
    }
    replaceMatsData(e, n) {
        const r = this.materials[e.uuid];
        r ? (r.meshList.forEach( ({mesh: i, index: s}) => {
            s !== void 0 ? i.material[s] = n : i.material = n
        }
        ),
        r.material = n,
        n.name = r.name,
        delete this.materials[e.uuid],
        this.materials[n.uuid] = r) : console.warn("需要被替换的材质不存在 oldMat", e)
    }
    updateMatsData(e, n) {
        const r = this.materials[e.uuid];
        if (r) {
            let i = r.material;
            n.type && n.type !== e.type && (i = is[n.type](n),
            this.replaceMatsData(e.material, i)),
            i.setValues(n)
        } else
            console.warn("需要被修改的材质不存在 oldMat", e)
    }
    getMatsByName(e) {
        const n = [];
        for (const r in this.materials)
            this.materials[r].name === e && n.push(this.materials[r].material);
        return n
    }
    getMatByName(e) {
        for (const n in this.materials)
            if (this.materials[n].name === e)
                return this.materials[n].material;
        return null
    }
}
const wA = {
    wang: {
        transparent: !0,
        alphaTest: .1
    }
}
  , xA = {
    list: [],
    enabled: !0,
    add(t) {
        this.list.push(t)
    },
    removeByKey(t) {
        const e = this.list.findIndex(n => n.key === t);
        e > -1 && this.list.splice(e, 1)
    },
    removeByName(t) {
        const e = this.list.findIndex(n => n.name === t);
        e > -1 && this.list.splice(e, 1)
    },
    some(t) {
        return this.list.some(e => e.name === t)
    },
    find(t) {
        return this.list.find(e => e.name === t)
    },
    update(t) {
        this.enabled && this.list.forEach(e => {
            e.enabled !== !1 && e.update(t)
        }
        )
    }
};
function CA(t) {
    return typeof t == "function" ? t() : v(t)
}
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const rd = () => {}
;
function EA(t, e) {
    function n(...r) {
        return new Promise( (i, s) => {
            Promise.resolve(t( () => e.apply(this, r), {
                fn: e,
                thisArg: this,
                args: r
            })).then(i).catch(s)
        }
        )
    }
    return n
}
const PA = t => t();
function OA(...t) {
    let e = 0, n, r = !0, i = rd, s, o, a, l, c;
    !Vn(t[0]) && typeof t[0] == "object" ? {delay: o, trailing: a=!0, leading: l=!0, rejectOnCancel: c=!1} = t[0] : [o,a=!0,l=!0,c=!1] = t;
    const u = () => {
        n && (clearTimeout(n),
        n = void 0,
        i(),
        i = rd)
    }
    ;
    return m => {
        const g = CA(o)
          , f = Date.now() - e
          , h = () => s = m();
        return u(),
        g <= 0 ? (e = Date.now(),
        h()) : (f > g && (l || !r) ? (e = Date.now(),
        h()) : a && (s = new Promise( (_, p) => {
            i = c ? p : _,
            n = setTimeout( () => {
                e = Date.now(),
                r = !0,
                _(h()),
                u()
            }
            , Math.max(0, g - f))
        }
        )),
        !l && !n && (n = setTimeout( () => r = !0, g)),
        r = !1,
        s)
    }
}
function TA(t, e, n={}) {
    const {eventFilter: r=PA, ...i} = n;
    return W(t, EA(r, e), i)
}
function id(t, e, n={}) {
    const {throttle: r=0, trailing: i=!0, leading: s=!0, ...o} = n;
    return TA(t, e, {
        ...o,
        eventFilter: OA(r, i, s)
    })
}
const sd = new vd
  , la = new Se;
function AA(t, e=la.clone()) {
    t.updateWorldMatrix(!0, !1),
    sd.setFromObject(t);
    const n = sd.getSize(la.clone());
    return n.set(0, n.y, 0).add(e),
    n
}
const SA = {
    list: {
        value: {
            key: "",
            pos: la.clone()
        }
    }
};
class kA {
    constructor(e=SA.list, n) {
        this.scene = n,
        this.hotSpotGroup = new $s,
        this.hotSpotGroup.name = "hotSpotGroup",
        n.add(this.hotSpotGroup),
        this.posVec3 = new Se,
        this.list = e,
        this.refs = Hn({}),
        this.objects = {},
        id(this.refs, () => {
            this.updateHotSpot()
        }
        , {
            throttle: 100
        }),
        id(this.list, () => {
            var r;
            ((r = this.list.value) == null ? void 0 : r.length) === 0 && this.updateHotSpot()
        }
        , {
            throttle: 100
        })
    }
    clear() {
        this.list.value = [],
        this.updateHotSpot()
    }
    itemRef(e) {
        if (this.hotSpotGroup.parent && e) {
            const n = e.getAttribute("data-hotspot-key");
            this.refs[n] = e
        }
    }
    getPos(e, n=this.posVec3) {
        return AA(e, n)
    }
    updateHotSpot() {
        var e;
        if (this.hotSpotGroup.parent) {
            for (let n in this.refs)
                this.list.value.some(i => i.key == n) || ((e = this.objects[n]) == null || e.removeFromParent(),
                delete this.objects[n],
                delete this.refs[n]);
            this.list.value.forEach(n => {
                const {key: r, pos: i} = n;
                if (this.objects[r])
                    i && this.objects[r].position.copy(i);
                else {
                    const s = this.refs[r];
                    if (!s)
                        return console.warn("element", s);
                    const o = new Ed(s);
                    if (o.name = r,
                    o.userData = {
                        key: r
                    },
                    this.objects[r] = o,
                    i)
                        o.position.copy(i),
                        this.hotSpotGroup.add(o);
                    else {
                        const a = this.scene.getObjectById(r);
                        a ? (o.position.copy(this.getPos(a)),
                        a.add(o)) : console.warn(`没有找到热点对象 key = ${r}`)
                    }
                }
            }
            )
        }
    }
    dispose() {
        this.list.value = [],
        this.objects = {},
        this.refs = {},
        this.hotSpotGroup.clear(),
        this.hotSpotGroup.removeFromParent()
    }
}
const Vs = M([]);
let Ds;
function MA() {
    Ds = new kA(Vs,R.scene),
    R.podHotSpot = Ds
}
const ca = !1
  , ua = {}
  , LA = Object.assign({
    "/src/assets/ImdcPod/textures/AO/ACDU_AO.jpg": nm,
    "/src/assets/ImdcPod/textures/AO/CDU_AO.jpg": im,
    "/src/assets/ImdcPod/textures/AO/UPS_AO.jpg": om,
    "/src/assets/ImdcPod/textures/AO/内部_AO.jpg": lm,
    "/src/assets/ImdcPod/textures/AO/前门_AO.jpg": um,
    "/src/assets/ImdcPod/textures/AO/后门_AO.jpg": pm,
    "/src/assets/ImdcPod/textures/AO/天窗_AO.jpg": fm,
    "/src/assets/ImdcPod/textures/AO/散热塔_AO.jpg": vm,
    "/src/assets/ImdcPod/textures/AO/机柜底座_AO.jpg": bm,
    "/src/assets/ImdcPod/textures/AO/母线_AO.jpg": ym,
    "/src/assets/ImdcPod/textures/AO/母线支架AO.jpg": xm,
    "/src/assets/ImdcPod/textures/AO/母线箱_AO.jpg": Em,
    "/src/assets/ImdcPod/textures/AO/水泵_AO.jpg": Om,
    "/src/assets/ImdcPod/textures/AO/水网_AO.jpg": Am,
    "/src/assets/ImdcPod/textures/AO/水网底座_AO.jpg": km,
    "/src/assets/ImdcPod/textures/AO/水网接口_AO.jpg": Lm,
    "/src/assets/ImdcPod/textures/AO/水网阀门_AO.jpg": Rm,
    "/src/assets/ImdcPod/textures/AO/空调_AO.jpg": Vm
});
Sp(ua, LA, "/src/assets/ImdcPod/textures/AO/");
const da = M(!1)
  , FA = M(!0);
let R, pa;
async function RA(t) {
    if (Jf(),
    pa = tA.service({
        lock: !0,
        text: "模型加载中...",
        background: "rgba(0, 0, 0, 0.7)"
    }),
    !!t)
        return R = new d0({
            container: t.refs["three-container"],
            canvas: t.refs["three-canvas"],
            cssEL: t.refs["three-css"]
        }),
        R.animations = xA,
        MA(),
        R.showDebug(ca),
        R.renderer.shadowMap.enabled = !0,
        R.renderer.shadowMap.type = fd,
        R.scene.background = new js("#000000"),
        await $A(),
        await R.enabledPostprocessing(),
        await VA(),
        IA(),
        da.value = !0,
        pa.close(),
        window.glView = R,
        window.THREE = md,
        R
}
function IA() {
    {
        const {light: t, updatePane: e, updateHelper: n} = R.createDLight("#ffffff", 1);
        t.position.set(5, 10, 5),
        t.castShadow = !0,
        t.shadow.camera.top = 10,
        t.shadow.camera.bottom = -10,
        t.shadow.camera.left = -10,
        t.shadow.camera.right = 10,
        t.shadow.camera.near = 0,
        t.shadow.camera.far = 20,
        t.shadow.mapSize.width = 1024,
        t.shadow.mapSize.height = 1024,
        t.shadow.intensity = 1,
        t.shadow.radius = 2,
        n(),
        e()
    }
    R.pane.expanded = !1
}
async function VA() {
    const {scene: t} = await R.loader.loaderGLTF({
        url: nA,
        onProgress(n) {
            pa.setText((n.loaded / n.total * 100).toFixed(0) + "%")
        }
    })
      , e = new $s;
    R.sceneGroup = e,
    e.add(t),
    R.scene.add(e),
    console.log("result", t),
    DA(t),
    BA()
}
function DA(t) {
    t.traverse(n => {
        if (n.isMesh) {
            if (n.castShadow = !0,
            n.receiveShadow = !0,
            n.name === "阴影")
                n.renderOrder = -1;
            else if (n.isMesh) {
                const r = n.material
                  , i = cA.toMeshStandardMaterial(r);
                i.copy(r),
                n.material = i
            }
        }
    }
    );
    const e = new yA({
        ...R,
        matConf: null,
        pane: ca,
        pack: ca
    });
    e.updateMatsByConf(wA),
    window.materialPane = e,
    R.materialPane = e
}
function BA() {
    function t(n, r) {
        n.traverse(i => {
            i.isMesh && (r.colorSpace = Do,
            r.flipY = !1,
            r.channel = 1,
            i.material.aoMap = r,
            i.material.aoMapIntensity = 1)
        }
        )
    }
    const e = [];
    for (let n in ua)
        e.push({
            name: n.replace("_AO", ""),
            textureUrl: ua[n]
        });
    e.forEach( ({name: n, textureUrl: r}) => {
        const i = R.scene.getObjectByName(n);
        if (i) {
            const s = R.loader.loaderGltfTexture(r);
            t(i, s)
        }
    }
    )
}
async function $A() {
    R.camera.near = .05,
    R.camera.updateProjectionMatrix(),
    await R.enabledCameraControls();
    const t = R.cameraControls
      , e = new Se(-.34,1.54,.03)
      , n = new Se(2.46,2.44,6.38);
    t.setTarget(...e.toArray()),
    t.setPosition(...n.toArray()),
    t.saveState(),
    t.minPolarAngle = Il.degToRad(0),
    t.maxPolarAngle = Il.degToRad(90),
    t.dollySpeed = window.innerWidth > 1e3 ? .3 : .5,
    t.minDistance = 1,
    t.maxDistance = 50,
    t.touches.two = pr.ACTION.TOUCH_DOLLY_TRUCK,
    t.mouseButtons.wheel = pr.ACTION.DOLLY,
    R.getTP = function() {
        const r = Pc.vector3Fixed(t.getPosition().clone(), 2).toArray()
          , i = Pc.vector3Fixed(t.getTarget().clone(), 2).toArray()
          , s = `
tarEnd: new THREE.Vector3(${i}),
posEnd: new THREE.Vector3(${r}),
const tarEnd = new THREE.Vector3(${i})
const posEnd = new THREE.Vector3(${r})
tarEnd = new THREE.Vector3(${i})
posEnd = new THREE.Vector3(${r})
`;
        console.log(s)
    }
}
function nf() {
    var t;
    requestAnimationFrame(nf),
    (t = R.animations) == null || t.update(R.clocks.delta),
    FA.value && R.render()
}
const UA = t => {
    t = t || {
        [0 / 40]: "#2a82e4",
        [15 / 40]: "#48c0f7",
        [20 / 40]: "#11d813",
        [25 / 40]: "#ffeb3b",
        [30 / 40]: "#ff8d1a",
        [35 / 40]: "#fe220b",
        [40 / 40]: "#fe220b"
    };
    const e = 256
      , n = 10
      , r = document.getElementById("paletteCanvas") || document.createElement("canvas");
    r.setAttribute("id", "paletteCanvas"),
    r.width = e,
    r.height = n,
    r.style.position = "absolute",
    r.style.top = "20px",
    r.style.left = `calc(50% - ${e / 2}px)`,
    r.style.zIndex = "5000";
    const i = r.getContext("2d")
      , s = i.createLinearGradient(0, 0, e, 0);
    for (const a in t)
        s.addColorStop(a, t[a]);
    i.fillStyle = s,
    i.fillRect(0, 0, e, n);
    const o = new yd(r);
    return o.minFilter = wd,
    o.needsUpdate = !0,
    o
}
  , jA = (t, e) => {
    let {x: n, y: r, radius: i, weight: s} = e;
    i = parseInt(i * s);
    const o = t.createRadialGradient(n, r, 0, n, r, i);
    o.addColorStop(0, "rgba(255, 0, 0, 1)"),
    o.addColorStop(1, "rgba(255, 0, 0, 0)"),
    t.fillStyle = o,
    t.globalAlpha = s,
    t.beginPath(),
    t.arc(n, r, i, 0, 2 * Math.PI),
    t.closePath(),
    t.fill()
}
  , NA = (t={
    heatData: [{
        x: 0,
        y: 0,
        radius: 5,
        weight: 1
    }],
    size: 20,
    pixelScale: 10
}) => {
    let {heatData: e=[], radius: n=5, size: r=20, pixelScale: i=10} = t || {};
    const s = r * i
      , o = n
      , a = document.getElementById("canvasMap") || document.createElement("canvas");
    a.setAttribute("id", "canvasMap"),
    a.width = s,
    a.height = s,
    a.style.position = "absolute",
    a.style.top = "40px",
    a.style.left = `calc(50% - ${r / 2}px)`,
    a.style.zIndex = "5000";
    const l = a.getContext("2d")
      , c = new yd(a);
    c.minFilter = wd,
    c.needsUpdate = !0;
    function u(d) {
        l.clearRect(0, 0, a.width, a.height),
        Array.isArray(d) && (d = d.map(m => {
            const {x: g, y: f, radius: h=5, weight: _} = m;
            return {
                x: (g / r + .5) * s,
                y: (f / r + .5) * s,
                radius: (h || o) * i,
                weight: _
            }
        }
        )),
        d.forEach(m => jA(l, m)),
        c.needsUpdate = !0
    }
    return u(e),
    {
        texture: c,
        update: u
    }
}
varying vec2 vUv;
, zA = `
  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`
  , HA = `
  varying vec2 vUv;
  uniform sampler2D alphaScaleMap;
  uniform sampler2D paletteMap;
  uniform vec4 colorBg;
  void main() {
    vec4 alphaColor = texture2D(alphaScaleMap, vUv);
    vec4 color = texture2D(paletteMap, vec2(alphaColor.a, 1.0));
    gl_FragColor = vec4(color.rgb, alphaColor.a);
	}
`;
function KA(t) {
    return new ga({
        side: 2,
        transparent: !0,
        vertexShader: zA,
        fragmentShader: HA,
        uniforms: t
    })
}
const Kr = 20;
function GA() {
    const t = NA({
        size: Kr,
        pixelScale: 20
    })
      , e = UA()
      , n = {
        alphaScaleMap: new at(t.texture),
        paletteMap: new at(e)
    }
      , r = KA(n);
    r.setValues({
        transparent: !0,
        depthTest: !1,
        depthWrite: !1
    });
    const i = new em(Kr,Kr,Kr,Kr)
      , s = new kn(i,r);
    return s.name = "plane",
    s.rotation.x = -Math.PI / 2,
    s.position.y = .01,
    s.renderOrder = 100,
    {
        plane: s,
        heatmapMaterial: r,
        uniforms: n,
        alphaScaleMap: t,
        paletteMap: e
    }
}
const qA = [{
    x: -3.37,
    y: 3.5,
    radius: 3.35,
    weight: .81
}, {
    x: -3.6,
    y: 1.06,
    radius: 3.45,
    weight: .58
}, {
    x: -3.55,
    y: -1.25,
    radius: 3.15,
    weight: .59
}, {
    x: -3.63,
    y: -3.65,
    radius: 3.05,
    weight: .75
}, {
    x: 3.21,
    y: 3.8,
    radius: 3.25,
    weight: .69
}, {
    x: 3.11,
    y: 1.31,
    radius: 3.2,
    weight: .7
}, {
    x: 3.01,
    y: -1.29,
    radius: 3.2,
    weight: .69
}, {
    x: 3.09,
    y: -3.71,
    radius: 3.1,
    weight: .8
}, {
    x: -.93,
    y: 4.96,
    radius: 3.15,
    weight: .69
}, {
    x: 1.16,
    y: 4.96,
    radius: 3.3,
    weight: .59
}, {
    x: -1.1,
    y: -5.07,
    radius: 3.3,
    weight: .7
}, {
    x: 1.04,
    y: -5.15,
    radius: 3.3,
    weight: .69
}, {
    x: -.67,
    y: 2.77,
    radius: 2.35,
    weight: .58
}, {
    x: -.67,
    y: 1.76,
    radius: 2.4,
    weight: .44
}, {
    x: -.66,
    y: 1.16,
    radius: 2.25,
    weight: .44
}, {
    x: -.68,
    y: .63,
    radius: 2.15,
    weight: .44
}, {
    x: -.7,
    y: .13,
    radius: 2.4,
    weight: .44
}, {
    x: -.71,
    y: -.47,
    radius: 2.2,
    weight: .44
}, {
    x: -.72,
    y: -1.1,
    radius: 2.15,
    weight: .44
}, {
    x: -.71,
    y: -1.68,
    radius: 2.2,
    weight: .44
}, {
    x: -.72,
    y: -2.27,
    radius: 2.2,
    weight: .44
}, {
    x: -.67,
    y: -3.31,
    radius: 2.2,
    weight: .58
}, {
    x: .67,
    y: 2.84,
    radius: 2,
    weight: .58
}, {
    x: .65,
    y: 1.82,
    radius: 2.1,
    weight: .43
}, {
    x: .65,
    y: 1.27,
    radius: 2.3,
    weight: .43
}, {
    x: .66,
    y: .62,
    radius: 2.35,
    weight: .44
}, {
    x: .65,
    y: .04,
    radius: 2.2,
    weight: .44
}, {
    x: .64,
    y: -.56,
    radius: 2.25,
    weight: .44
}, {
    x: .65,
    y: -1.11,
    radius: 2.5,
    weight: .44
}, {
    x: .67,
    y: -1.74,
    radius: 2.05,
    weight: .36
}, {
    x: .67,
    y: -2.35,
    radius: 2.1,
    weight: .36
}, {
    x: .71,
    y: -3.14,
    radius: 2.05,
    weight: .43
}];
function rf(t=!0) {
    if (t) {
        const e = new Se(-.07,1.54,-.03)
          , n = new Se(-.02,10.47,2.59);
        R.cameraControls.setTarget(...e.toArray(), !0),
        R.cameraControls.setPosition(...n.toArray(), !0)
    }
    WA.update(qA),
    od.visible = t,
    R.scene.add(od)
}

const {plane: od, alphaScaleMap: WA} = GA();
var sf = `uniform float uTime;\r
uniform sampler2D uAlphaMap;\r
attribute vec2 uv1;

varying vec2 vUv;\r
varying vec2 vUv1;\r

void main()\r
{\r
  vec3 newPosition = position;\r

  
  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);

  
  vUv = uv;\r
  vUv1 = uv1;\r
}`
  , of = `uniform float uTime;\r
uniform vec3 uColor;\r
uniform bool hasUMap;\r
uniform sampler2D uMap;\r
uniform sampler2D uAlphaMap;

varying vec2 vUv;\r
varying vec2 vUv1;

void main()\r
{\r
  
  vec2 smokeUv = vUv;\r
  
  smokeUv.y *= 2.5;\r
  smokeUv.x -= uTime * 0.2;

  vec3 color = uColor;\r
  if (hasUMap){\r
    color*=texture(uMap, vUv1).rgb;\r
  }

  
  float smoke = texture(uAlphaMap, smokeUv).r + .1;

  
  smoke = smoothstep(.2, .8, smoke);

  
  smoke *= smoothstep(0.0, .2, vUv1.x);\r
  smoke *= smoothstep(1.0, 0.8, vUv1.x);\r
  smoke *= smoothstep(0.0, .2, vUv1.y);\r
  smoke *= smoothstep(1.0, 0.8, vUv1.y);

  
  gl_FragColor = vec4(color, smoke);\r
  
  #include <tonemapping_fragment>\r
  #include <colorspace_fragment>\r
}`;
const YA = "" + new URL("../../assets/public/textures/perlin.png",import.meta.url).href;
function so(t, e=!0) {
    t.forEach(n => {
        const r = R.scene.getObjectByName(n);
        r == null || r.traverse(i => {
            i.isMesh && (i.material._transparent1 === void 0 && (i.material._transparent1 = i.material.transparent,
            i.material._opacity1 = i.material.opacity),
            i.material.transparent = e ? !0 : i.material._transparent1,
            i.material.opacity = e ? .1 : i.material._opacity1,
            i.material.needsUpdate = !0)
        }
        )
    }
    )
}
function Ol(t=!1) {
    if (t) {
        const i = new Se(-.07,1.54,-.03)
          , s = new Se(-.02,10.47,2.59);
        R.cameraControls.setTarget(...i.toArray(), !0),
        R.cameraControls.setPosition(...s.toArray(), !0)
    }
    const e = ["液冷巡检"]
      , n = ["Cube", "Cube_1", "Cube_2", "Cube_3", "液冷管路"];
    R.sceneGroup.traverse(function(i) {
        e.includes(i.name) ? i.visible = !t : n.includes(i.name) && (i.visible = t)
    }),
    so(["地板", "机柜底座", "前门", "后门", "天窗", "母线支架", "CDU", "桥架", "液冷巡检", "空调", "空调内部", "母线", "母线箱", "母线插头", "电线", "UPS", "UPS内部", "ACDU"], t),
    t && (ad("Cube", 1),
    ad("Cube_1", 1))
}
function ad(t, e=1) {
    const n = R.sceneGroup.getObjectByName(t);
    n.material.transparent = !0,
    n.renderOrder = -1,
    R.animations.find(t) || (n.material.alphaMap = n.material.map,
    n.material.map = null,
    R.animations.add({
        name: t,
        map: n.material.alphaMap,
        update(i) {
            this.map.offset.y += i * e
        }
    }))
}
const fs = {
    uTime: new at(0),
    uColor: new at(new js("#ffffff")),
    uMap: new at(null),
    hasUMap: new at(1),
    uAlphaMap: new at(null)
}
  , ha = {
    uTime: new at(0),
    uColor: new at(new js("#2a82e4")),
    uMap: new at(null),
    hasUMap: new at(0),
    uAlphaMap: new at(null)
}
  , ZA = new ga({
    side: 2,
    transparent: !0,
    alphaTest: .1,
    uniforms: fs,
    vertexShader: sf,
    fragmentShader: of,
    blending: xd,
    depthWrite: !1
})
  , ld = new ga({
    side: 2,
    transparent: !0,
    alphaTest: .1,
    uniforms: ha,
    vertexShader: sf,
    fragmentShader: of,
    blending: xd,
    depthWrite: !1
});
function Tl(t=!1) {
    if (t) {
        const s = new Se(-.07,1.54,-.03)
          , o = new Se(.05,4.47,6.32);
        R.cameraControls.setTarget(...s.toArray(), !0),
        R.cameraControls.setPosition(...o.toArray(), !0)
    }
    const e = R.sceneGroup.getObjectByName("气流")
      , n = R.sceneGroup.getObjectByName("内部气流")
      , r = R.sceneGroup.getObjectByName("冷气流");
    e.visible = t,
    n.visible = t,
    r.visible = t,
    so(["前门", "后门", "天窗", "桥架"], t),
    Vs.value = [],
    t && Vs.value.push({
        key: "光伏路灯",
        name: "微压差：5 Pa",
        pos: {
            x: 0,
            y: 3.5,
            z: 0
        }
    })
}
function XA() {
    const t = R.loader.loaderTexture(YA);
    t.wrapS = t.wrapT = Vl,
    fs.uAlphaMap.value = t,
    ha.uAlphaMap.value = t;
    const e = R.sceneGroup.getObjectByName("气流");
    e.castShadow = !1,
    e.receiveShadow = !1;
    const n = e.material;
    n.map.wrapS = n.map.wrapT = Vl,
    e.material = ZA,
    fs.uMap.value = n.map;
    const r = R.sceneGroup.getObjectByName("内部气流");
    r.castShadow = !1,
    r.receiveShadow = !1,
    r.material = ld;
    const i = R.sceneGroup.getObjectByName("冷气流");
    i.castShadow = !1,
    i.receiveShadow = !1,
    i.material = ld,
    Tl(!1),
    R.animations.add({
        name: "uniformsTime",
        uniforms: fs,
        uniforms2: ha,
        update(s) {
            this.uniforms.uTime.value -= s * 2,
            this.uniforms2.uTime.value -= s * 2
        }
    })
}
const QA = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/4QBCRXhpZgAATU0AKgAAAAgAAgESAAMAAAABAAEAAIdpAAQAAAABAAAAJgAAAAAAAaABAAMAAAAB//8AAAAAAAAAAP/bAEMAAwICAwICAwMDAwQDAwQFCAUFBAQFCgcHBggMCgwMCwoLCw0OEhANDhEOCwsQFhARExQVFRUMDxcYFhQYEhQVFP/bAEMBAwQEBQQFCQUFCRQNCw0UFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFP/AABEIAEAAQAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/ANXwT/qU+gr1HTf9SK8u8E/6lPoK9R03/Uiv4dzT+Iz+xs5/isg1T7rVwutfeNd1qn3TXC61941OB3M8t3RFpP3xXZaX0FcbpX3xXZaX0Fa4zc3x5qt92s27+8a0m+7Wbd/eNeVTPFo7ni3gf/j2i+gr1HTfuivLvA//AB7RfQV6jpv3RX1OafxGfaZz/FkbFQTVPUE1fOx3PlI7lRutWLb7wqu3Wp7f7wreXwm8tjYtf4a0F+6Kz7X+GtBfuivLqbnjVNzM1TvWJ/FW3qnesT+Ku6h8J6WH+Anh7VfgqhD2q/BSqCqFuPoKgvfu1PH0FQXv3a5o/EckPiMypo/61DU0ddkjvkeZ+HT8q13On/dFcN4d+6tdzp/3RXsY74me/mPxM14e1WVqtD2qyteCz5eYrVWmqy1VpqUdxQ3M276Vzeo966S76Vzeo969bD7nu4Tc/9k=";
function JA(t, e=!1) {
    const n = R.loader.loaderGltfTexture(QA);
    n.channel = 2;
    const r = new Bs({
        map: n,
        roughness: 1,
        metalness: 0
    });
    t.traverse(function(i) {
        i.oldMat || (i.newMat = r,
        i.oldMat = i.material),
        i.material = e ? i.newMat : i.oldMat
    })
}
function af(t=!1) {
    if (t) {
        const n = new Se(-.2,2.18,-.21)
          , r = new Se(3.68,5.76,2.17);
        R.cameraControls.setTarget(...n.toArray(), !0),
        R.cameraControls.setPosition(...r.toArray(), !0)
    }
    const e = R.scene.getObjectByName("母线");
    JA(e, t)
}
function eS(t, e=1) {
    const n = R.sceneGroup.getObjectByName(t);
    n.renderOrder = -1,
    R.animations.find(t) || R.animations.add({
        name: t,
        map: n.material.map,
        update(i) {
            this.map.offset.y += i * e
        }
    })
}
function Al(t=!1) {
    if (t) {
        const i = new Se(-.2,2.18,-.21)
          , s = new Se(3.68,5.76,2.17);
        R.cameraControls.setTarget(...i.toArray(), !0),
        R.cameraControls.setPosition(...s.toArray(), !0)
    }
    const e = []
      , n = ["电力管路"];
    R.sceneGroup.traverse(function(i) {
        e.includes(i.name) ? i.visible = !t : n.includes(i.name) && (i.visible = t)
    }),
    so(["前门", "后门", "天窗", "母线支架", "CDU", "桥架", "地板", "机柜底座", "桥架", "液冷巡检", "空调", "空调内部", "液冷管路", "UPS", "UPS内部", "ACDU", "内部", "水网管路", "水网接口", "水网阀门", "水网底座", "水网"], t),
    t && eS("电力管路", .5)
}
const tS = M([{
    label: "CDU漏水检测",
    value: .05
}, {
    label: "管路检测点1",
    value: .08
}, {
    label: "管路检测点2",
    value: .13
}, {
    label: "管路检测点3",
    value: .2
}, {
    label: "管路检测点4",
    value: .22
}, {
    label: "管路检测点5",
    value: .25
}, {
    label: "管路检测点6",
    value: .28
}, {
    label: "管路检测点7",
    value: .36
}, {
    label: "管路检测点8",
    value: .42
}, {
    label: "机柜漏水检测",
    value: .5
}])
  , fa = M(.3)
  , lf = M([{
    key: "yl_gl_xj",
    label: "管路巡检",
    class: "xunjian"
}])
  , Sl = M([{
    key: "sy",
    label: "首页",
    class: "shouye"
}, {
    key: "yl_gl",
    label: "液冷管路",
    class: "yeleng"
}, {
    key: "wd_yt",
    label: "温度云图",
    class: "relitu"
}, {
    key: "mx_wd",
    label: "母线温度",
    class: "wendu"
}, {
    key: "ql_mn",
    label: "气流模拟",
    class: "qiliu"
}, {
    key: "dl_cl_mn",
    label: "电力潮流模拟",
    class: "dianlui"
}])
  , ms = M(Sl.value[0])
  , ma = M({});
function cd(t) {
    ma.value = {},
    t.key === "yl_gl_xj" ? ma.value = t : (ms.value = t,
    Sl.value.forEach(e => e.show = t.key === e.key)),
    lf.value.forEach(e => e.show = t.key === e.key),
    rS(),
    t.key === "sy" || (t.key === "wd_yt" ? rf(t.show) : t.key === "mx_wd" ? af(t.show) : t.key === "ql_mn" ? Tl(!0) : t.key === "yl_gl" ? Ol(!0) : t.key === "dl_cl_mn" ? Al(!0) : t.key === "yl_gl_xj" && cf(!0))
}
function cf(t=!1) {
    if (t) {
        const i = new Se(-.07,1.54,-.03)
          , s = new Se(-.02,10.47,2.59);
        R.cameraControls.setTarget(...i.toArray(), !0),
        R.cameraControls.setPosition(...s.toArray(), !0)
    }
    const e = ["液冷管路"]
      , n = ["液冷巡检"];
    R.sceneGroup.traverse(function(i) {
        e.includes(i.name) ? i.visible = !t : n.includes(i.name) && (i.visible = t)
    }),
    so(["地板", "机柜底座", "前门", "后门", "天窗", "母线支架", "CDU", "桥架", "液冷管路", "空调", "空调内部", "母线", "母线箱", "母线插头", "电线", "UPS", "UPS内部", "ACDU"], t),
    t && nS("液冷巡检", .001)
}
function nS(t, e=1) {
    const n = R.sceneGroup.getObjectByName(t);
    n.material.map.offset.y = .03,
    n.renderOrder = -1,
    n.material.transparent = !0,
    R.animations.find(t) || R.animations.add({
        name: t,
        map: n.material.map,
        update(i) {
            fa.value = this.map.offset.y += e,
            this.map.offset.y >= .5 && R.animations.removeByName(t)
        }
    })
}
function rS(t) {
    rf(!1),
    af(!1),
    Tl(!1),
    Ol(!1),
    Al(!1),
    cf(!1),
    R.cameraControls.reset(!0)
}
function iS() {
    XA(),
    Ol(!1),
    Al(!1),
    ["地板"].forEach(e => {
        const n = R.scene.getObjectByName(e);
        n && (n.renderOrder = 1)
    }
    )
}
const sS = {
    class: "container-ui"
}
  , oS = {
    key: 0,
    class: "wdt-box"
}
  , aS = {
    class: "wdt"
}
  , lS = {
    class: "label"
}
  , cS = {
    key: 0,
    class: "wdt-box"
}
  , uS = {
    class: "wdt"
}
  , dS = {
    class: "label"
}
  , pS = {
    key: 0,
    class: "yl-gl-xj"
}
  , hS = {
    class: "item"
}
  , fS = {
    key: 0,
    class: "top"
}
  , mS = {
    class: "label",
    type: "info"
}
  , vS = {
    class: "scroll-bottom"
}
  , gS = {
    class: "bottom"
}
  , bS = {
    class: "label",
    type: "info"
}
  , _S = H({
    __name: "ThreeUi",
    setup(t) {
        const e = Hn({
            bgFloor: "#FFFFFF",
            floor: "#FFFFFF",
            bg: "#FFFFFF"
        });
        function n(c) {
            R.scene.background.set(c),
            R.scene.getObjectByName("阴影").material.color.set(c)
        }
        function r(c) {
            R.scene.background.set(c)
        }
        function i(c) {
            R.scene.getObjectByName("阴影").material.color.set(c)
        }
        function s(c, u) {
            c = c || "#3ecb58",
            u = u || c,
            R.scene.background = c === "#00000000" ? null : new js(c),
            R.scene.getObjectByName("阴影").material.color.set(u)
        }
        const o = M(!1)
          , a = {
            15: "#2a82e4",
            20: "#48c0f7",
            25: "#11d813",
            30: "#ffeb3b",
            35: "#ff8d1a",
            40: "#fe220b"
        }
          , l = {
            0: "#2a82e4",
            15: "#48c0f7",
            30: "#11d813",
            45: "#ffeb3b",
            60: "#ff8d1a",
            75: "#fe220b"
        };
        return De( () => {
            s("#000000", "#8d8d8d"),
            iS()
        }
        ),
        (c, u) => {
            const d = yT
              , m = St
              , g = oa
              , f = yP
              , h = KT
              , _ = _P
              , p = ZT;
            return S(),
            j("div", sS, [Y(Wr, null, {
                default: G( () => [/wd_yt|mx_wd/.test(v(ms).key) ? (S(),
                j("div", oS, [(S(),
                j(Ze, null, Sn(a, (b, y) => $("div", aS, [$("div", {
                    class: "color",
                    style: qe({
                        background: b
                    })
                }, null, 4), $("div", lS, Ue(y), 1)])), 64))])) : J("", !0)]),
                _: 1
            }), Y(Wr, null, {
                default: G( () => [/dl_cl_mn/.test(v(ms).key) ? (S(),
                j("div", cS, [(S(),
                j(Ze, null, Sn(l, (b, y) => $("div", uS, [$("div", {
                    class: "color",
                    style: qe({
                        background: b
                    })
                }, null, 4), $("div", dS, Ue(y), 1)])), 64))])) : J("", !0)]),
                _: 1
            }), /yl_gl_xj/.test(v(ma).key) ? (S(),
            j("div", pS, [(S(!0),
            j(Ze, null, Sn(v(tS), b => (S(),
            j("div", hS, [$("div", {
                class: D(["label", {
                    active: b.value < v(fa)
                }])
            }, Ue(b.label), 3), Y(d, {
                "model-value": b.value < v(fa),
                value: !0
            }, null, 8, ["model-value"])]))), 256))])) : J("", !0), $("div", {
                class: D([{
                    hide: v(o)
                }, "bg-color"])
            }, [Y(g, {
                circle: "",
                class: "hide",
                size: "small",
                type: "primary",
                onClick: u[0] || (u[0] = b => o.value = !v(o))
            }, {
                default: G( () => [Y(m, null, {
                    default: G( () => [Y(v(oh))]),
                    _: 1
                })]),
                _: 1
            }), Y(_, null, {
                default: G( () => [Y(f, {
                    label: "预制色"
                }, {
                    default: G( () => [Y(g, {
                        size: "small",
                        onClick: u[1] || (u[1] = b => s())
                    }, {
                        default: G( () => u[10] || (u[10] = [bt("绿色")])),
                        _: 1
                    }), Y(g, {
                        size: "small",
                        onClick: u[2] || (u[2] = b => s("#000000"))
                    }, {
                        default: G( () => u[11] || (u[11] = [bt("黑色")])),
                        _: 1
                    }), Y(g, {
                        size: "small",
                        onClick: u[3] || (u[3] = b => s("#FFFFFF"))
                    }, {
                        default: G( () => u[12] || (u[12] = [bt("白色")])),
                        _: 1
                    }), Y(g, {
                        size: "small",
                        onClick: u[4] || (u[4] = b => s("#000000", "#FFFFFF"))
                    }, {
                        default: G( () => u[13] || (u[13] = [bt("黑色/白色")])),
                        _: 1
                    }), Y(g, {
                        size: "small",
                        onClick: u[5] || (u[5] = b => s("#000000", "#8d8d8d"))
                    }, {
                        default: G( () => u[14] || (u[14] = [bt("黑色/灰色")])),
                        _: 1
                    }), Y(g, {
                        size: "small",
                        onClick: u[6] || (u[6] = b => s("#00000000", "#8d8d8d"))
                    }, {
                        default: G( () => u[15] || (u[15] = [bt("透明/灰色")])),
                        _: 1
                    })]),
                    _: 1
                }), Y(f, {
                    label: "背景+地面颜色"
                }, {
                    default: G( () => [Y(h, {
                        modelValue: v(e).bgFloor,
                        "onUpdate:modelValue": u[7] || (u[7] = b => v(e).bgFloor = b),
                        onActiveChange: n
                    }, null, 8, ["modelValue"])]),
                    _: 1
                }), Y(f, {
                    label: "背景颜色"
                }, {
                    default: G( () => [Y(h, {
                        modelValue: v(e).floor,
                        "onUpdate:modelValue": u[8] || (u[8] = b => v(e).floor = b),
                        onActiveChange: r
                    }, null, 8, ["modelValue"])]),
                    _: 1
                }), Y(f, {
                    label: "地面颜色"
                }, {
                    default: G( () => [Y(h, {
                        modelValue: v(e).bg,
                        "onUpdate:modelValue": u[9] || (u[9] = b => v(e).bg = b),
                        onActiveChange: i
                    }, null, 8, ["modelValue"])]),
                    _: 1
                })]),
                _: 1
            })], 2), Y(Wr, {
                name: "el-zoom-in-bottom",
                mode: "out-in"
            }, {
                default: G( () => [v(ms).key === "yl_gl" ? (S(),
                j("div", fS, [(S(!0),
                j(Ze, null, Sn(v(lf), b => (S(),
                ae(p, {
                    key: b.label,
                    class: D([{
                        active: b.show
                    }, "btn"]),
                    plain: "",
                    onClick: y => v(cd)(b)
                }, {
                    default: G( () => [$("i", {
                        class: D([`icon-${b.class}`, "icon iconfont"])
                    }, null, 2), $("div", mS, Ue(b.label), 1)]),
                    _: 2
                }, 1032, ["class", "onClick"]))), 128))])) : J("", !0)]),
                _: 1
            }), $("div", vS, [$("div", gS, [(S(!0),
            j(Ze, null, Sn(v(Sl), b => (S(),
            ae(p, {
                key: b.label,
                class: D([{
                    active: b.show
                }, "btn"]),
                plain: "",
                onClick: y => v(cd)(b)
            }, {
                default: G( () => [$("i", {
                    class: D([`icon-${b.class}`, "icon iconfont"])
                }, null, 2), $("div", bS, Ue(b.label), 1)]),
                _: 2
            }, 1032, ["class", "onClick"]))), 128))])])])
        }
    }
})
  , yS = ba(_S, [["__scopeId", "data-v-96a42d2f"]])
  , wS = {}
  , xS = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    width: "30",
    height: "30",
    fill: "currentColor"
};
function CS(t, e) {
    return S(),
    j("svg", xS, e[0] || (e[0] = [$("g", null, [$("g", null, [$("path", {
        d: `M416.2,876.5c-1.9,0-3.9-0.3-5.9-0.8c-39.2-11.1-76-28.5-109.4-51.7c-34.4-23.9-64.5-53.4-89.4-87.8\r
			c-29.4-40.6-49.9-85.8-61-134.2c-10.8-46.8-12.3-94.6-4.7-142.2c7.6-47.6,24.1-92.5,48.9-133.6c25.7-42.5,59.3-78.9,99.9-108.3\r
			c40.6-29.4,85.8-49.9,134.2-61.1c46.8-10.8,94.7-12.3,142.3-4.7c47.5,7.7,92.4,24.1,133.4,49c42.5,25.8,78.8,59.4,108.1,100\r
			c29.3,40.6,49.8,85.8,60.9,134.2c10.7,46.8,12.3,94.6,4.6,142.2c-7.6,47.6-24.1,92.5-49,133.6c-25.7,42.5-59.4,78.9-99.9,108.3\r
			c-34.8,25.2-73.2,43.9-113.9,55.7c-11.4,3.3-23.3-3.3-26.6-14.7c-3.3-11.4,3.3-23.3,14.7-26.6c36-10.4,69.9-27,100.7-49.3\r
			c71-51.4,117.7-127.3,131.6-213.9c13.9-86.5-6.7-173.3-58-244.4c-51.2-71-127.1-117.8-213.5-131.7\r
			c-86.6-13.9-173.4,6.7-244.4,58.1c-71,51.4-117.7,127.3-131.6,213.8C174.3,553.2,195,640,246.3,711c22,30.4,48.6,56.5,79.1,77.7\r
			c29.5,20.5,62,35.8,96.6,45.7c11.4,3.2,18.1,15.1,14.8,26.6C434.2,870.3,425.6,876.5,416.2,876.5z`
    })]), $("g", null, [$("path", {
        d: `M486.6,565.8c-5.9,0-11.8-2.4-16-7.2c-7.9-8.9-7.1-22.4,1.7-30.4l114.2-102c8.9-7.9,22.4-7.1,30.4,1.7\r
			c7.9,8.9,7.1,22.4-1.7,30.4l-114.2,102C496.8,564,491.7,565.8,486.6,565.8z`
    })]), $("path", {
        d: `M689.7,340.5C642.2,293,579.1,266.8,512,266.8S381.8,293,334.3,340.5c-47.5,47.5-73.6,110.7-73.6,177.8\r
		c0,83.7,41.4,161.6,110.8,208.5c8.3,5.6,19.4,4.7,26.7-2.1l54.7-51.2c8.7-8.1,9.1-21.7,1-30.4c-8.1-8.7-21.7-9.1-30.4-1l-41.7,39\r
		c-44.1-35.3-71.9-86.9-77.2-143h47.5c11.9,0,21.5-9.6,21.5-21.5s-9.6-21.5-21.5-21.5H305c10.8-96.9,88.1-173.9,185-184.1v46.8\r
		c0,11.9,9.6,21.5,21.5,21.5s21.5-9.6,21.5-21.5v-46.9c97.6,9.8,175.5,87.4,186.1,184.8h-48.6c-11.9,0-21.5,9.6-21.5,21.5\r
		s9.6,21.5,21.5,21.5h48.8c-5.5,55.8-33.2,107.1-77.1,142.4l-41.5-39c-8.7-8.1-22.3-7.7-30.4,1c-8.1,8.7-7.7,22.3,1,30.4l54.6,51.2\r
		c4.1,3.8,9.4,5.8,14.7,5.8c4.2,0,8.4-1.2,12.1-3.7c69.3-47,110.7-124.9,110.7-208.5C763.3,451.1,737.2,388,689.7,340.5z`
    })], -1)]))
}
const ES = ba(wS, [["render", CS]])
  , PS = {
    class: "container-ImdcPod"
}
  , OS = {
    ref: "three-container",
    class: "three-container"
}
  , TS = {
    ref: "three-canvas",
    class: "three-canvas"
}
  , AS = {
    ref: "three-css",
    class: "three-css"
}
  , SS = ["data-hotspot-key", "title"]
  , kS = {
    class: "hotspot-content ql-mn"
}
  , MS = {
    class: "label"
}
  , LS = H({
    __name: "index",
    setup(t) {
        return De( () => {
            const e = Ve();
            RA(e),
            nf()
        }
        ),
        (e, n) => (S(),
        j("div", PS, [$("div", OS, [$("canvas", TS, null, 512), $("div", AS, [v(da) ? (S(!0),
        j(Ze, {
            key: 0
        }, Sn(v(Vs), r => (S(),
        j("div", {
            key: r.key,
            ref_for: !0,
            ref: v(Ds).itemRef.bind(v(Ds)),
            "data-hotspot-key": r.key,
            title: r.name,
            class: "hotspot"
        }, [$("div", kS, [Y(ES, {
            class: "logo"
        }), $("div", MS, Ue(r.name), 1)])], 8, SS))), 128)) : J("", !0)], 512)], 512), v(da) ? (S(),
        ae(yS, {
            key: 0
        })) : J("", !0)]))
    }
})
  , IS = ba(LS, [["__scopeId", "data-v-1921e56b"]]);
export {IS as default};
