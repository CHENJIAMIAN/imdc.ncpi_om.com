(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
        i(r);
    new MutationObserver(r => {
        for (const s of r)
            if (s.type === "childList")
                for (const o of s.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && i(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(r) {
        const s = {};
        return r.integrity && (s.integrity = r.integrity),
        r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
        r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin",
        s
    }
    function i(r) {
        if (r.ep)
            return;
        r.ep = !0;
        const s = t(r);
        fetch(r.href, s)
    }
}
)();
var VM = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function HM(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}
var h0 = {
    exports: {}
};
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */
(function(n, e) {
    (function(t, i) {
        n.exports = i()
    }
    )(VM, function() {
        var t = {};
        t.version = "0.2.0";
        var i = t.settings = {
            minimum: .08,
            easing: "ease",
            positionUsing: "",
            speed: 200,
            trickle: !0,
            trickleRate: .02,
            trickleSpeed: 800,
            showSpinner: !0,
            barSelector: '[role="bar"]',
            spinnerSelector: '[role="spinner"]',
            parent: "body",
            template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
        };
        t.configure = function(p) {
            var v, g;
            for (v in p)
                g = p[v],
                g !== void 0 && p.hasOwnProperty(v) && (i[v] = g);
            return this
        }
        ,
        t.status = null,
        t.set = function(p) {
            var v = t.isStarted();
            p = r(p, i.minimum, 1),
            t.status = p === 1 ? null : p;
            var g = t.render(!v)
              , m = g.querySelector(i.barSelector)
              , y = i.speed
              , _ = i.easing;
            return g.offsetWidth,
            a(function(x) {
                i.positionUsing === "" && (i.positionUsing = t.getPositioningCSS()),
                l(m, o(p, y, _)),
                p === 1 ? (l(g, {
                    transition: "none",
                    opacity: 1
                }),
                g.offsetWidth,
                setTimeout(function() {
                    l(g, {
                        transition: "all " + y + "ms linear",
                        opacity: 0
                    }),
                    setTimeout(function() {
                        t.remove(),
                        x()
                    }, y)
                }, y)) : setTimeout(x, y)
            }),
            this
        }
        ,
        t.isStarted = function() {
            return typeof t.status == "number"
        }
        ,
        t.start = function() {
            t.status || t.set(0);
            var p = function() {
                setTimeout(function() {
                    t.status && (t.trickle(),
                    p())
                }, i.trickleSpeed)
            };
            return i.trickle && p(),
            this
        }
        ,
        t.done = function(p) {
            return !p && !t.status ? this : t.inc(.3 + .5 * Math.random()).set(1)
        }
        ,
        t.inc = function(p) {
            var v = t.status;
            return v ? (typeof p != "number" && (p = (1 - v) * r(Math.random() * v, .1, .95)),
            v = r(v + p, 0, .994),
            t.set(v)) : t.start()
        }
        ,
        t.trickle = function() {
            return t.inc(Math.random() * i.trickleRate)
        }
        ,
        function() {
            var p = 0
              , v = 0;
            t.promise = function(g) {
                return !g || g.state() === "resolved" ? this : (v === 0 && t.start(),
                p++,
                v++,
                g.always(function() {
                    v--,
                    v === 0 ? (p = 0,
                    t.done()) : t.set((p - v) / p)
                }),
                this)
            }
        }(),
        t.render = function(p) {
            if (t.isRendered())
                return document.getElementById("nprogress");
            u(document.documentElement, "nprogress-busy");
            var v = document.createElement("div");
            v.id = "nprogress",
            v.innerHTML = i.template;
            var g = v.querySelector(i.barSelector), m = p ? "-100" : s(t.status || 0), y = document.querySelector(i.parent), _;
            return l(g, {
                transition: "all 0 linear",
                transform: "translate3d(" + m + "%,0,0)"
            }),
            i.showSpinner || (_ = v.querySelector(i.spinnerSelector),
            _ && d(_)),
            y != document.body && u(y, "nprogress-custom-parent"),
            y.appendChild(v),
            v
        }
        ,
        t.remove = function() {
            h(document.documentElement, "nprogress-busy"),
            h(document.querySelector(i.parent), "nprogress-custom-parent");
            var p = document.getElementById("nprogress");
            p && d(p)
        }
        ,
        t.isRendered = function() {
            return !!document.getElementById("nprogress")
        }
        ,
        t.getPositioningCSS = function() {
            var p = document.body.style
              , v = "WebkitTransform"in p ? "Webkit" : "MozTransform"in p ? "Moz" : "msTransform"in p ? "ms" : "OTransform"in p ? "O" : "";
            return v + "Perspective"in p ? "translate3d" : v + "Transform"in p ? "translate" : "margin"
        }
        ;
        function r(p, v, g) {
            return p < v ? v : p > g ? g : p
        }
        function s(p) {
            return (-1 + p) * 100
        }
        function o(p, v, g) {
            var m;
            return i.positionUsing === "translate3d" ? m = {
                transform: "translate3d(" + s(p) + "%,0,0)"
            } : i.positionUsing === "translate" ? m = {
                transform: "translate(" + s(p) + "%,0)"
            } : m = {
                "margin-left": s(p) + "%"
            },
            m.transition = "all " + v + "ms " + g,
            m
        }
        var a = function() {
            var p = [];
            function v() {
                var g = p.shift();
                g && g(v)
            }
            return function(g) {
                p.push(g),
                p.length == 1 && v()
            }
        }()
          , l = function() {
            var p = ["Webkit", "O", "Moz", "ms"]
              , v = {};
            function g(x) {
                return x.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(C, w) {
                    return w.toUpperCase()
                })
            }
            function m(x) {
                var C = document.body.style;
                if (x in C)
                    return x;
                for (var w = p.length, E = x.charAt(0).toUpperCase() + x.slice(1), L; w--; )
                    if (L = p[w] + E,
                    L in C)
                        return L;
                return x
            }
            function y(x) {
                return x = g(x),
                v[x] || (v[x] = m(x))
            }
            function _(x, C, w) {
                C = y(C),
                x.style[C] = w
            }
            return function(x, C) {
                var w = arguments, E, L;
                if (w.length == 2)
                    for (E in C)
                        L = C[E],
                        L !== void 0 && C.hasOwnProperty(E) && _(x, E, L);
                else
                    _(x, w[1], w[2])
            }
        }();
        function c(p, v) {
            var g = typeof p == "string" ? p : f(p);
            return g.indexOf(" " + v + " ") >= 0
        }
        function u(p, v) {
            var g = f(p)
              , m = g + v;
            c(g, v) || (p.className = m.substring(1))
        }
        function h(p, v) {
            var g = f(p), m;
            c(p, v) && (m = g.replace(" " + v + " ", " "),
            p.className = m.substring(1, m.length - 1))
        }
        function f(p) {
            return (" " + (p.className || "") + " ").replace(/\s+/gi, " ")
        }
        function d(p) {
            p && p.parentNode && p.parentNode.removeChild(p)
        }
        return t
    })
}
)(h0);
var GM = h0.exports;
const Zd = HM(GM);
/**
* @vue/shared v3.5.8
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
function Jd(n) {
    const e = Object.create(null);
    for (const t of n.split(","))
        e[t] = 1;
    return t => t in e
}
const yt = {}
  , ao = []
  , ei = () => {}
  , WM = () => !1
  , zu = n => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && (n.charCodeAt(2) > 122 || n.charCodeAt(2) < 97)
  , Qd = n => n.startsWith("onUpdate:")
  , Wt = Object.assign
  , ep = (n, e) => {
    const t = n.indexOf(e);
    t > -1 && n.splice(t, 1)
}
  , XM = Object.prototype.hasOwnProperty
  , ht = (n, e) => XM.call(n, e)
  , Oe = Array.isArray
  , lo = n => Io(n) === "[object Map]"
  , ku = n => Io(n) === "[object Set]"
  , Rm = n => Io(n) === "[object Date]"
  , qM = n => Io(n) === "[object RegExp]"
  , qe = n => typeof n == "function"
  , wt = n => typeof n == "string"
  , xi = n => typeof n == "symbol"
  , mt = n => n !== null && typeof n == "object"
  , f0 = n => (mt(n) || qe(n)) && qe(n.then) && qe(n.catch)
  , d0 = Object.prototype.toString
  , Io = n => d0.call(n)
  , $M = n => Io(n).slice(8, -1)
  , p0 = n => Io(n) === "[object Object]"
  , tp = n => wt(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n
  , ca = Jd(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
  , Vu = n => {
    const e = Object.create(null);
    return t => e[t] || (e[t] = n(t))
}
  , YM = /-(\w)/g
  , ii = Vu(n => n.replace(YM, (e, t) => t ? t.toUpperCase() : ""))
  , jM = /\B([A-Z])/g
  , Tr = Vu(n => n.replace(jM, "-$1").toLowerCase())
  , Hu = Vu(n => n.charAt(0).toUpperCase() + n.slice(1))
  , Zh = Vu(n => n ? `on${Hu(n)}` : "")
  , Mr = (n, e) => !Object.is(n, e)
  , co = (n, ...e) => {
    for (let t = 0; t < n.length; t++)
        n[t](...e)
}
  , m0 = (n, e, t, i=!1) => {
    Object.defineProperty(n, e, {
        configurable: !0,
        enumerable: !1,
        writable: i,
        value: t
    })
}
  , KM = n => {
    const e = parseFloat(n);
    return isNaN(e) ? n : e
}
  , ZM = n => {
    const e = wt(n) ? Number(n) : NaN;
    return isNaN(e) ? n : e
}
;
let Pm;
const g0 = () => Pm || (Pm = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function Gu(n) {
    if (Oe(n)) {
        const e = {};
        for (let t = 0; t < n.length; t++) {
            const i = n[t]
              , r = wt(i) ? tS(i) : Gu(i);
            if (r)
                for (const s in r)
                    e[s] = r[s]
        }
        return e
    } else if (wt(n) || mt(n))
        return n
}
const JM = /;(?![^(]*\))/g
  , QM = /:([^]+)/
  , eS = /\/\*[^]*?\*\//g;
function tS(n) {
    const e = {};
    return n.replace(eS, "").split(JM).forEach(t => {
        if (t) {
            const i = t.split(QM);
            i.length > 1 && (e[i[0].trim()] = i[1].trim())
        }
    }
    ),
    e
}
function Wu(n) {
    let e = "";
    if (wt(n))
        e = n;
    else if (Oe(n))
        for (let t = 0; t < n.length; t++) {
            const i = Wu(n[t]);
            i && (e += i + " ")
        }
    else if (mt(n))
        for (const t in n)
            n[t] && (e += t + " ");
    return e.trim()
}
const nS = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
  , iS = Jd(nS);
function v0(n) {
    return !!n || n === ""
}
function rS(n, e) {
    if (n.length !== e.length)
        return !1;
    let t = !0;
    for (let i = 0; t && i < n.length; i++)
        t = Xu(n[i], e[i]);
    return t
}
function Xu(n, e) {
    if (n === e)
        return !0;
    let t = Rm(n)
      , i = Rm(e);
    if (t || i)
        return t && i ? n.getTime() === e.getTime() : !1;
    if (t = xi(n),
    i = xi(e),
    t || i)
        return n === e;
    if (t = Oe(n),
    i = Oe(e),
    t || i)
        return t && i ? rS(n, e) : !1;
    if (t = mt(n),
    i = mt(e),
    t || i) {
        if (!t || !i)
            return !1;
        const r = Object.keys(n).length
          , s = Object.keys(e).length;
        if (r !== s)
            return !1;
        for (const o in n) {
            const a = n.hasOwnProperty(o)
              , l = e.hasOwnProperty(o);
            if (a && !l || !a && l || !Xu(n[o], e[o]))
                return !1
        }
    }
    return String(n) === String(e)
}
function _0(n, e) {
    return n.findIndex(t => Xu(t, e))
}
const y0 = n => !!(n && n.__v_isRef === !0)
  , sS = n => wt(n) ? n : n == null ? "" : Oe(n) || mt(n) && (n.toString === d0 || !qe(n.toString)) ? y0(n) ? sS(n.value) : JSON.stringify(n, x0, 2) : String(n)
  , x0 = (n, e) => y0(e) ? x0(n, e.value) : lo(e) ? {
    [`Map(${e.size})`]: [...e.entries()].reduce( (t, [i,r], s) => (t[Jh(i, s) + " =>"] = r,
    t), {})
} : ku(e) ? {
    [`Set(${e.size})`]: [...e.values()].map(t => Jh(t))
} : xi(e) ? Jh(e) : mt(e) && !Oe(e) && !p0(e) ? String(e) : e
  , Jh = (n, e="") => {
    var t;
    return xi(n) ? `Symbol(${(t = n.description) != null ? t : e})` : n
}
;
/**
* @vue/reactivity v3.5.8
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let dn;
class b0 {
    constructor(e=!1) {
        this.detached = e,
        this._active = !0,
        this.effects = [],
        this.cleanups = [],
        this._isPaused = !1,
        this.parent = dn,
        !e && dn && (this.index = (dn.scopes || (dn.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    pause() {
        if (this._active) {
            this._isPaused = !0;
            let e, t;
            if (this.scopes)
                for (e = 0,
                t = this.scopes.length; e < t; e++)
                    this.scopes[e].pause();
            for (e = 0,
            t = this.effects.length; e < t; e++)
                this.effects[e].pause()
        }
    }
    resume() {
        if (this._active && this._isPaused) {
            this._isPaused = !1;
            let e, t;
            if (this.scopes)
                for (e = 0,
                t = this.scopes.length; e < t; e++)
                    this.scopes[e].resume();
            for (e = 0,
            t = this.effects.length; e < t; e++)
                this.effects[e].resume()
        }
    }
    run(e) {
        if (this._active) {
            const t = dn;
            try {
                return dn = this,
                e()
            } finally {
                dn = t
            }
        }
    }
    on() {
        dn = this
    }
    off() {
        dn = this.parent
    }
    stop(e) {
        if (this._active) {
            let t, i;
            for (t = 0,
            i = this.effects.length; t < i; t++)
                this.effects[t].stop();
            for (t = 0,
            i = this.cleanups.length; t < i; t++)
                this.cleanups[t]();
            if (this.scopes)
                for (t = 0,
                i = this.scopes.length; t < i; t++)
                    this.scopes[t].stop(!0);
            if (!this.detached && this.parent && !e) {
                const r = this.parent.scopes.pop();
                r && r !== this && (this.parent.scopes[this.index] = r,
                r.index = this.index)
            }
            this.parent = void 0,
            this._active = !1
        }
    }
}
function oS(n) {
    return new b0(n)
}
function M0() {
    return dn
}
function aS(n, e=!1) {
    dn && dn.cleanups.push(n)
}
let gt;
const Qh = new WeakSet;
class S0 {
    constructor(e) {
        this.fn = e,
        this.deps = void 0,
        this.depsTail = void 0,
        this.flags = 5,
        this.next = void 0,
        this.cleanup = void 0,
        this.scheduler = void 0,
        dn && dn.active && dn.effects.push(this)
    }
    pause() {
        this.flags |= 64
    }
    resume() {
        this.flags & 64 && (this.flags &= -65,
        Qh.has(this) && (Qh.delete(this),
        this.trigger()))
    }
    notify() {
        this.flags & 2 && !(this.flags & 32) || this.flags & 8 || E0(this)
    }
    run() {
        if (!(this.flags & 1))
            return this.fn();
        this.flags |= 2,
        Im(this),
        A0(this);
        const e = gt
          , t = ti;
        gt = this,
        ti = !0;
        try {
            return this.fn()
        } finally {
            T0(this),
            gt = e,
            ti = t,
            this.flags &= -3
        }
    }
    stop() {
        if (this.flags & 1) {
            for (let e = this.deps; e; e = e.nextDep)
                rp(e);
            this.deps = this.depsTail = void 0,
            Im(this),
            this.onStop && this.onStop(),
            this.flags &= -2
        }
    }
    trigger() {
        this.flags & 64 ? Qh.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
    }
    runIfDirty() {
        ld(this) && this.run()
    }
    get dirty() {
        return ld(this)
    }
}
let w0 = 0, ua;
function E0(n) {
    n.flags |= 8,
    n.next = ua,
    ua = n
}
function np() {
    w0++
}
function ip() {
    if (--w0 > 0)
        return;
    let n;
    for (; ua; ) {
        let e = ua;
        for (ua = void 0; e; ) {
            const t = e.next;
            if (e.next = void 0,
            e.flags &= -9,
            e.flags & 1)
                try {
                    e.trigger()
                } catch (i) {
                    n || (n = i)
                }
            e = t
        }
    }
    if (n)
        throw n
}
function A0(n) {
    for (let e = n.deps; e; e = e.nextDep)
        e.version = -1,
        e.prevActiveLink = e.dep.activeLink,
        e.dep.activeLink = e
}
function T0(n, e=!1) {
    let t, i = n.depsTail, r = i;
    for (; r; ) {
        const s = r.prevDep;
        r.version === -1 ? (r === i && (i = s),
        rp(r, e),
        lS(r)) : t = r,
        r.dep.activeLink = r.prevActiveLink,
        r.prevActiveLink = void 0,
        r = s
    }
    n.deps = t,
    n.depsTail = i
}
function ld(n) {
    for (let e = n.deps; e; e = e.nextDep)
        if (e.dep.version !== e.version || e.dep.computed && (C0(e.dep.computed) || e.dep.version !== e.version))
            return !0;
    return !!n._dirty
}
function C0(n) {
    if (n.flags & 4 && !(n.flags & 16) || (n.flags &= -17,
    n.globalVersion === Ra))
        return;
    n.globalVersion = Ra;
    const e = n.dep;
    if (n.flags |= 2,
    e.version > 0 && !n.isSSR && n.deps && !ld(n)) {
        n.flags &= -3;
        return
    }
    const t = gt
      , i = ti;
    gt = n,
    ti = !0;
    try {
        A0(n);
        const r = n.fn(n._value);
        (e.version === 0 || Mr(r, n._value)) && (n._value = r,
        e.version++)
    } catch (r) {
        throw e.version++,
        r
    } finally {
        gt = t,
        ti = i,
        T0(n, !0),
        n.flags &= -3
    }
}
function rp(n, e=!1) {
    const {dep: t, prevSub: i, nextSub: r} = n;
    if (i && (i.nextSub = r,
    n.prevSub = void 0),
    r && (r.prevSub = i,
    n.nextSub = void 0),
    t.subs === n && (t.subs = i),
    !t.subs)
        if (t.computed) {
            t.computed.flags &= -5;
            for (let s = t.computed.deps; s; s = s.nextDep)
                rp(s, !0)
        } else
            t.map && !e && (t.map.delete(t.key),
            t.map.size || Pa.delete(t.target))
}
function lS(n) {
    const {prevDep: e, nextDep: t} = n;
    e && (e.nextDep = t,
    n.prevDep = void 0),
    t && (t.prevDep = e,
    n.nextDep = void 0)
}
let ti = !0;
const R0 = [];
function Cr() {
    R0.push(ti),
    ti = !1
}
function Rr() {
    const n = R0.pop();
    ti = n === void 0 ? !0 : n
}
function Im(n) {
    const {cleanup: e} = n;
    if (n.cleanup = void 0,
    e) {
        const t = gt;
        gt = void 0;
        try {
            e()
        } finally {
            gt = t
        }
    }
}
let Ra = 0;
class cS {
    constructor(e, t) {
        this.sub = e,
        this.dep = t,
        this.version = t.version,
        this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
    }
}
class qu {
    constructor(e) {
        this.computed = e,
        this.version = 0,
        this.activeLink = void 0,
        this.subs = void 0,
        this.target = void 0,
        this.map = void 0,
        this.key = void 0
    }
    track(e) {
        if (!gt || !ti || gt === this.computed)
            return;
        let t = this.activeLink;
        if (t === void 0 || t.sub !== gt)
            t = this.activeLink = new cS(gt,this),
            gt.deps ? (t.prevDep = gt.depsTail,
            gt.depsTail.nextDep = t,
            gt.depsTail = t) : gt.deps = gt.depsTail = t,
            gt.flags & 4 && P0(t);
        else if (t.version === -1 && (t.version = this.version,
        t.nextDep)) {
            const i = t.nextDep;
            i.prevDep = t.prevDep,
            t.prevDep && (t.prevDep.nextDep = i),
            t.prevDep = gt.depsTail,
            t.nextDep = void 0,
            gt.depsTail.nextDep = t,
            gt.depsTail = t,
            gt.deps === t && (gt.deps = i)
        }
        return t
    }
    trigger(e) {
        this.version++,
        Ra++,
        this.notify(e)
    }
    notify(e) {
        np();
        try {
            for (let t = this.subs; t; t = t.prevSub)
                t.sub.notify() && t.sub.dep.notify()
        } finally {
            ip()
        }
    }
}
function P0(n) {
    const e = n.dep.computed;
    if (e && !n.dep.subs) {
        e.flags |= 20;
        for (let i = e.deps; i; i = i.nextDep)
            P0(i)
    }
    const t = n.dep.subs;
    t !== n && (n.prevSub = t,
    t && (t.nextSub = n)),
    n.dep.subs = n
}
const Pa = new WeakMap
  , os = Symbol("")
  , cd = Symbol("")
  , Ia = Symbol("");
function ln(n, e, t) {
    if (ti && gt) {
        let i = Pa.get(n);
        i || Pa.set(n, i = new Map);
        let r = i.get(t);
        r || (i.set(t, r = new qu),
        r.target = n,
        r.map = i,
        r.key = t),
        r.track()
    }
}
function ki(n, e, t, i, r, s) {
    const o = Pa.get(n);
    if (!o) {
        Ra++;
        return
    }
    const a = l => {
        l && l.trigger()
    }
    ;
    if (np(),
    e === "clear")
        o.forEach(a);
    else {
        const l = Oe(n)
          , c = l && tp(t);
        if (l && t === "length") {
            const u = Number(i);
            o.forEach( (h, f) => {
                (f === "length" || f === Ia || !xi(f) && f >= u) && a(h)
            }
            )
        } else
            switch (t !== void 0 && a(o.get(t)),
            c && a(o.get(Ia)),
            e) {
            case "add":
                l ? c && a(o.get("length")) : (a(o.get(os)),
                lo(n) && a(o.get(cd)));
                break;
            case "delete":
                l || (a(o.get(os)),
                lo(n) && a(o.get(cd)));
                break;
            case "set":
                lo(n) && a(o.get(os));
                break
            }
    }
    ip()
}
function uS(n, e) {
    var t;
    return (t = Pa.get(n)) == null ? void 0 : t.get(e)
}
function Ts(n) {
    const e = rt(n);
    return e === n ? e : (ln(e, "iterate", Ia),
    Wn(n) ? e : e.map(rn))
}
function $u(n) {
    return ln(n = rt(n), "iterate", Ia),
    n
}
const hS = {
    __proto__: null,
    [Symbol.iterator]() {
        return ef(this, Symbol.iterator, rn)
    },
    concat(...n) {
        return Ts(this).concat(...n.map(e => Oe(e) ? Ts(e) : e))
    },
    entries() {
        return ef(this, "entries", n => (n[1] = rn(n[1]),
        n))
    },
    every(n, e) {
        return Ai(this, "every", n, e, void 0, arguments)
    },
    filter(n, e) {
        return Ai(this, "filter", n, e, t => t.map(rn), arguments)
    },
    find(n, e) {
        return Ai(this, "find", n, e, rn, arguments)
    },
    findIndex(n, e) {
        return Ai(this, "findIndex", n, e, void 0, arguments)
    },
    findLast(n, e) {
        return Ai(this, "findLast", n, e, rn, arguments)
    },
    findLastIndex(n, e) {
        return Ai(this, "findLastIndex", n, e, void 0, arguments)
    },
    forEach(n, e) {
        return Ai(this, "forEach", n, e, void 0, arguments)
    },
    includes(...n) {
        return tf(this, "includes", n)
    },
    indexOf(...n) {
        return tf(this, "indexOf", n)
    },
    join(n) {
        return Ts(this).join(n)
    },
    lastIndexOf(...n) {
        return tf(this, "lastIndexOf", n)
    },
    map(n, e) {
        return Ai(this, "map", n, e, void 0, arguments)
    },
    pop() {
        return Bo(this, "pop")
    },
    push(...n) {
        return Bo(this, "push", n)
    },
    reduce(n, ...e) {
        return Lm(this, "reduce", n, e)
    },
    reduceRight(n, ...e) {
        return Lm(this, "reduceRight", n, e)
    },
    shift() {
        return Bo(this, "shift")
    },
    some(n, e) {
        return Ai(this, "some", n, e, void 0, arguments)
    },
    splice(...n) {
        return Bo(this, "splice", n)
    },
    toReversed() {
        return Ts(this).toReversed()
    },
    toSorted(n) {
        return Ts(this).toSorted(n)
    },
    toSpliced(...n) {
        return Ts(this).toSpliced(...n)
    },
    unshift(...n) {
        return Bo(this, "unshift", n)
    },
    values() {
        return ef(this, "values", rn)
    }
};
function ef(n, e, t) {
    const i = $u(n)
      , r = i[e]();
    return i !== n && !Wn(n) && (r._next = r.next,
    r.next = () => {
        const s = r._next();
        return s.value && (s.value = t(s.value)),
        s
    }
    ),
    r
}
const fS = Array.prototype;
function Ai(n, e, t, i, r, s) {
    const o = $u(n)
      , a = o !== n && !Wn(n)
      , l = o[e];
    if (l !== fS[e]) {
        const h = l.apply(n, s);
        return a ? rn(h) : h
    }
    let c = t;
    o !== n && (a ? c = function(h, f) {
        return t.call(this, rn(h), f, n)
    }
    : t.length > 2 && (c = function(h, f) {
        return t.call(this, h, f, n)
    }
    ));
    const u = l.call(o, c, i);
    return a && r ? r(u) : u
}
function Lm(n, e, t, i) {
    const r = $u(n);
    let s = t;
    return r !== n && (Wn(n) ? t.length > 3 && (s = function(o, a, l) {
        return t.call(this, o, a, l, n)
    }
    ) : s = function(o, a, l) {
        return t.call(this, o, rn(a), l, n)
    }
    ),
    r[e](s, ...i)
}
function tf(n, e, t) {
    const i = rt(n);
    ln(i, "iterate", Ia);
    const r = i[e](...t);
    return (r === -1 || r === !1) && lp(t[0]) ? (t[0] = rt(t[0]),
    i[e](...t)) : r
}
function Bo(n, e, t=[]) {
    Cr(),
    np();
    const i = rt(n)[e].apply(n, t);
    return ip(),
    Rr(),
    i
}
const dS = Jd("__proto__,__v_isRef,__isVue")
  , I0 = new Set(Object.getOwnPropertyNames(Symbol).filter(n => n !== "arguments" && n !== "caller").map(n => Symbol[n]).filter(xi));
function pS(n) {
    xi(n) || (n = String(n));
    const e = rt(this);
    return ln(e, "has", n),
    e.hasOwnProperty(n)
}
class L0 {
    constructor(e=!1, t=!1) {
        this._isReadonly = e,
        this._isShallow = t
    }
    get(e, t, i) {
        const r = this._isReadonly
          , s = this._isShallow;
        if (t === "__v_isReactive")
            return !r;
        if (t === "__v_isReadonly")
            return r;
        if (t === "__v_isShallow")
            return s;
        if (t === "__v_raw")
            return i === (r ? s ? TS : O0 : s ? U0 : N0).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(i) ? e : void 0;
        const o = Oe(e);
        if (!r) {
            let l;
            if (o && (l = hS[t]))
                return l;
            if (t === "hasOwnProperty")
                return pS
        }
        const a = Reflect.get(e, t, Ft(e) ? e : i);
        return (xi(t) ? I0.has(t) : dS(t)) || (r || ln(e, "get", t),
        s) ? a : Ft(a) ? o && tp(t) ? a : a.value : mt(a) ? r ? yo(a) : hl(a) : a
    }
}
class D0 extends L0 {
    constructor(e=!1) {
        super(!1, e)
    }
    set(e, t, i, r) {
        let s = e[t];
        if (!this._isShallow) {
            const l = ms(s);
            if (!Wn(i) && !ms(i) && (s = rt(s),
            i = rt(i)),
            !Oe(e) && Ft(s) && !Ft(i))
                return l ? !1 : (s.value = i,
                !0)
        }
        const o = Oe(e) && tp(t) ? Number(t) < e.length : ht(e, t)
          , a = Reflect.set(e, t, i, Ft(e) ? e : r);
        return e === rt(r) && (o ? Mr(i, s) && ki(e, "set", t, i) : ki(e, "add", t, i)),
        a
    }
    deleteProperty(e, t) {
        const i = ht(e, t);
        e[t];
        const r = Reflect.deleteProperty(e, t);
        return r && i && ki(e, "delete", t, void 0),
        r
    }
    has(e, t) {
        const i = Reflect.has(e, t);
        return (!xi(t) || !I0.has(t)) && ln(e, "has", t),
        i
    }
    ownKeys(e) {
        return ln(e, "iterate", Oe(e) ? "length" : os),
        Reflect.ownKeys(e)
    }
}
class mS extends L0 {
    constructor(e=!1) {
        super(!0, e)
    }
    set(e, t) {
        return !0
    }
    deleteProperty(e, t) {
        return !0
    }
}
const gS = new D0
  , vS = new mS
  , _S = new D0(!0);
const sp = n => n
  , Yu = n => Reflect.getPrototypeOf(n);
function Rl(n, e, t=!1, i=!1) {
    n = n.__v_raw;
    const r = rt(n)
      , s = rt(e);
    t || (Mr(e, s) && ln(r, "get", e),
    ln(r, "get", s));
    const {has: o} = Yu(r)
      , a = i ? sp : t ? cp : rn;
    if (o.call(r, e))
        return a(n.get(e));
    if (o.call(r, s))
        return a(n.get(s));
    n !== r && n.get(e)
}
function Pl(n, e=!1) {
    const t = this.__v_raw
      , i = rt(t)
      , r = rt(n);
    return e || (Mr(n, r) && ln(i, "has", n),
    ln(i, "has", r)),
    n === r ? t.has(n) : t.has(n) || t.has(r)
}
function Il(n, e=!1) {
    return n = n.__v_raw,
    !e && ln(rt(n), "iterate", os),
    Reflect.get(n, "size", n)
}
function Dm(n, e=!1) {
    !e && !Wn(n) && !ms(n) && (n = rt(n));
    const t = rt(this);
    return Yu(t).has.call(t, n) || (t.add(n),
    ki(t, "add", n, n)),
    this
}
function Nm(n, e, t=!1) {
    !t && !Wn(e) && !ms(e) && (e = rt(e));
    const i = rt(this)
      , {has: r, get: s} = Yu(i);
    let o = r.call(i, n);
    o || (n = rt(n),
    o = r.call(i, n));
    const a = s.call(i, n);
    return i.set(n, e),
    o ? Mr(e, a) && ki(i, "set", n, e) : ki(i, "add", n, e),
    this
}
function Um(n) {
    const e = rt(this)
      , {has: t, get: i} = Yu(e);
    let r = t.call(e, n);
    r || (n = rt(n),
    r = t.call(e, n)),
    i && i.call(e, n);
    const s = e.delete(n);
    return r && ki(e, "delete", n, void 0),
    s
}
function Om() {
    const n = rt(this)
      , e = n.size !== 0
      , t = n.clear();
    return e && ki(n, "clear", void 0, void 0),
    t
}
function Ll(n, e) {
    return function(i, r) {
        const s = this
          , o = s.__v_raw
          , a = rt(o)
          , l = e ? sp : n ? cp : rn;
        return !n && ln(a, "iterate", os),
        o.forEach( (c, u) => i.call(r, l(c), l(u), s))
    }
}
function Dl(n, e, t) {
    return function(...i) {
        const r = this.__v_raw
          , s = rt(r)
          , o = lo(s)
          , a = n === "entries" || n === Symbol.iterator && o
          , l = n === "keys" && o
          , c = r[n](...i)
          , u = t ? sp : e ? cp : rn;
        return !e && ln(s, "iterate", l ? cd : os),
        {
            next() {
                const {value: h, done: f} = c.next();
                return f ? {
                    value: h,
                    done: f
                } : {
                    value: a ? [u(h[0]), u(h[1])] : u(h),
                    done: f
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}
function tr(n) {
    return function(...e) {
        return n === "delete" ? !1 : n === "clear" ? void 0 : this
    }
}
function yS() {
    const n = {
        get(s) {
            return Rl(this, s)
        },
        get size() {
            return Il(this)
        },
        has: Pl,
        add: Dm,
        set: Nm,
        delete: Um,
        clear: Om,
        forEach: Ll(!1, !1)
    }
      , e = {
        get(s) {
            return Rl(this, s, !1, !0)
        },
        get size() {
            return Il(this)
        },
        has: Pl,
        add(s) {
            return Dm.call(this, s, !0)
        },
        set(s, o) {
            return Nm.call(this, s, o, !0)
        },
        delete: Um,
        clear: Om,
        forEach: Ll(!1, !0)
    }
      , t = {
        get(s) {
            return Rl(this, s, !0)
        },
        get size() {
            return Il(this, !0)
        },
        has(s) {
            return Pl.call(this, s, !0)
        },
        add: tr("add"),
        set: tr("set"),
        delete: tr("delete"),
        clear: tr("clear"),
        forEach: Ll(!0, !1)
    }
      , i = {
        get(s) {
            return Rl(this, s, !0, !0)
        },
        get size() {
            return Il(this, !0)
        },
        has(s) {
            return Pl.call(this, s, !0)
        },
        add: tr("add"),
        set: tr("set"),
        delete: tr("delete"),
        clear: tr("clear"),
        forEach: Ll(!0, !0)
    };
    return ["keys", "values", "entries", Symbol.iterator].forEach(s => {
        n[s] = Dl(s, !1, !1),
        t[s] = Dl(s, !0, !1),
        e[s] = Dl(s, !1, !0),
        i[s] = Dl(s, !0, !0)
    }
    ),
    [n, t, e, i]
}
const [xS,bS,MS,SS] = yS();
function op(n, e) {
    const t = e ? n ? SS : MS : n ? bS : xS;
    return (i, r, s) => r === "__v_isReactive" ? !n : r === "__v_isReadonly" ? n : r === "__v_raw" ? i : Reflect.get(ht(t, r) && r in i ? t : i, r, s)
}
const wS = {
    get: op(!1, !1)
}
  , ES = {
    get: op(!1, !0)
}
  , AS = {
    get: op(!0, !1)
};
const N0 = new WeakMap
  , U0 = new WeakMap
  , O0 = new WeakMap
  , TS = new WeakMap;
function CS(n) {
    switch (n) {
    case "Object":
    case "Array":
        return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
        return 2;
    default:
        return 0
    }
}
function RS(n) {
    return n.__v_skip || !Object.isExtensible(n) ? 0 : CS($M(n))
}
function hl(n) {
    return ms(n) ? n : ap(n, !1, gS, wS, N0)
}
function F0(n) {
    return ap(n, !1, _S, ES, U0)
}
function yo(n) {
    return ap(n, !0, vS, AS, O0)
}
function ap(n, e, t, i, r) {
    if (!mt(n) || n.__v_raw && !(e && n.__v_isReactive))
        return n;
    const s = r.get(n);
    if (s)
        return s;
    const o = RS(n);
    if (o === 0)
        return n;
    const a = new Proxy(n,o === 2 ? i : t);
    return r.set(n, a),
    a
}
function uo(n) {
    return ms(n) ? uo(n.__v_raw) : !!(n && n.__v_isReactive)
}
function ms(n) {
    return !!(n && n.__v_isReadonly)
}
function Wn(n) {
    return !!(n && n.__v_isShallow)
}
function lp(n) {
    return n ? !!n.__v_raw : !1
}
function rt(n) {
    const e = n && n.__v_raw;
    return e ? rt(e) : n
}
function B0(n) {
    return !ht(n, "__v_skip") && Object.isExtensible(n) && m0(n, "__v_skip", !0),
    n
}
const rn = n => mt(n) ? hl(n) : n
  , cp = n => mt(n) ? yo(n) : n;
function Ft(n) {
    return n ? n.__v_isRef === !0 : !1
}
function Qe(n) {
    return z0(n, !1)
}
function gi(n) {
    return z0(n, !0)
}
function z0(n, e) {
    return Ft(n) ? n : new PS(n,e)
}
class PS {
    constructor(e, t) {
        this.dep = new qu,
        this.__v_isRef = !0,
        this.__v_isShallow = !1,
        this._rawValue = t ? e : rt(e),
        this._value = t ? e : rn(e),
        this.__v_isShallow = t
    }
    get value() {
        return this.dep.track(),
        this._value
    }
    set value(e) {
        const t = this._rawValue
          , i = this.__v_isShallow || Wn(e) || ms(e);
        e = i ? e : rt(e),
        Mr(e, t) && (this._rawValue = e,
        this._value = i ? e : rn(e),
        this.dep.trigger())
    }
}
function Pn(n) {
    return Ft(n) ? n.value : n
}
const IS = {
    get: (n, e, t) => e === "__v_raw" ? n : Pn(Reflect.get(n, e, t)),
    set: (n, e, t, i) => {
        const r = n[e];
        return Ft(r) && !Ft(t) ? (r.value = t,
        !0) : Reflect.set(n, e, t, i)
    }
};
function k0(n) {
    return uo(n) ? n : new Proxy(n,IS)
}
class LS {
    constructor(e) {
        this.__v_isRef = !0,
        this._value = void 0;
        const t = this.dep = new qu
          , {get: i, set: r} = e(t.track.bind(t), t.trigger.bind(t));
        this._get = i,
        this._set = r
    }
    get value() {
        return this._value = this._get()
    }
    set value(e) {
        this._set(e)
    }
}
function DS(n) {
    return new LS(n)
}
function NS(n) {
    const e = Oe(n) ? new Array(n.length) : {};
    for (const t in n)
        e[t] = V0(n, t);
    return e
}
class US {
    constructor(e, t, i) {
        this._object = e,
        this._key = t,
        this._defaultValue = i,
        this.__v_isRef = !0,
        this._value = void 0
    }
    get value() {
        const e = this._object[this._key];
        return this._value = e === void 0 ? this._defaultValue : e
    }
    set value(e) {
        this._object[this._key] = e
    }
    get dep() {
        return uS(rt(this._object), this._key)
    }
}
class OS {
    constructor(e) {
        this._getter = e,
        this.__v_isRef = !0,
        this.__v_isReadonly = !0,
        this._value = void 0
    }
    get value() {
        return this._value = this._getter()
    }
}
function tF(n, e, t) {
    return Ft(n) ? n : qe(n) ? new OS(n) : mt(n) && arguments.length > 1 ? V0(n, e, t) : Qe(n)
}
function V0(n, e, t) {
    const i = n[e];
    return Ft(i) ? i : new US(n,e,t)
}
class FS {
    constructor(e, t, i) {
        this.fn = e,
        this.setter = t,
        this._value = void 0,
        this.dep = new qu(this),
        this.__v_isRef = !0,
        this.deps = void 0,
        this.depsTail = void 0,
        this.flags = 16,
        this.globalVersion = Ra - 1,
        this.effect = this,
        this.__v_isReadonly = !t,
        this.isSSR = i
    }
    notify() {
        if (this.flags |= 16,
        !(this.flags & 8) && gt !== this)
            return E0(this),
            !0
    }
    get value() {
        const e = this.dep.track();
        return C0(this),
        e && (e.version = this.dep.version),
        this._value
    }
    set value(e) {
        this.setter && this.setter(e)
    }
}
function BS(n, e, t=!1) {
    let i, r;
    return qe(n) ? i = n : (i = n.get,
    r = n.set),
    new FS(i,r,t)
}
const Nl = {}
  , jc = new WeakMap;
let jr;
function zS(n, e=!1, t=jr) {
    if (t) {
        let i = jc.get(t);
        i || jc.set(t, i = []),
        i.push(n)
    }
}
function kS(n, e, t=yt) {
    const {immediate: i, deep: r, once: s, scheduler: o, augmentJob: a, call: l} = t
      , c = x => r ? x : Wn(x) || r === !1 || r === 0 ? Oi(x, 1) : Oi(x);
    let u, h, f, d, p = !1, v = !1;
    if (Ft(n) ? (h = () => n.value,
    p = Wn(n)) : uo(n) ? (h = () => c(n),
    p = !0) : Oe(n) ? (v = !0,
    p = n.some(x => uo(x) || Wn(x)),
    h = () => n.map(x => {
        if (Ft(x))
            return x.value;
        if (uo(x))
            return c(x);
        if (qe(x))
            return l ? l(x, 2) : x()
    }
    )) : qe(n) ? e ? h = l ? () => l(n, 2) : n : h = () => {
        if (f) {
            Cr();
            try {
                f()
            } finally {
                Rr()
            }
        }
        const x = jr;
        jr = u;
        try {
            return l ? l(n, 3, [d]) : n(d)
        } finally {
            jr = x
        }
    }
    : h = ei,
    e && r) {
        const x = h
          , C = r === !0 ? 1 / 0 : r;
        h = () => Oi(x(), C)
    }
    const g = M0()
      , m = () => {
        u.stop(),
        g && ep(g.effects, u)
    }
    ;
    if (s && e) {
        const x = e;
        e = (...C) => {
            x(...C),
            m()
        }
    }
    let y = v ? new Array(n.length).fill(Nl) : Nl;
    const _ = x => {
        if (!(!(u.flags & 1) || !u.dirty && !x))
            if (e) {
                const C = u.run();
                if (r || p || (v ? C.some( (w, E) => Mr(w, y[E])) : Mr(C, y))) {
                    f && f();
                    const w = jr;
                    jr = u;
                    try {
                        const E = [C, y === Nl ? void 0 : v && y[0] === Nl ? [] : y, d];
                        l ? l(e, 3, E) : e(...E),
                        y = C
                    } finally {
                        jr = w
                    }
                }
            } else
                u.run()
    }
    ;
    return a && a(_),
    u = new S0(h),
    u.scheduler = o ? () => o(_, !1) : _,
    d = x => zS(x, !1, u),
    f = u.onStop = () => {
        const x = jc.get(u);
        if (x) {
            if (l)
                l(x, 4);
            else
                for (const C of x)
                    C();
            jc.delete(u)
        }
    }
    ,
    e ? i ? _(!0) : y = u.run() : o ? o(_.bind(null, !0), !0) : u.run(),
    m.pause = u.pause.bind(u),
    m.resume = u.resume.bind(u),
    m.stop = m,
    m
}
function Oi(n, e=1 / 0, t) {
    if (e <= 0 || !mt(n) || n.__v_skip || (t = t || new Set,
    t.has(n)))
        return n;
    if (t.add(n),
    e--,
    Ft(n))
        Oi(n.value, e, t);
    else if (Oe(n))
        for (let i = 0; i < n.length; i++)
            Oi(n[i], e, t);
    else if (ku(n) || lo(n))
        n.forEach(i => {
            Oi(i, e, t)
        }
        );
    else if (p0(n)) {
        for (const i in n)
            Oi(n[i], e, t);
        for (const i of Object.getOwnPropertySymbols(n))
            Object.prototype.propertyIsEnumerable.call(n, i) && Oi(n[i], e, t)
    }
    return n
}
/**
* @vue/runtime-core v3.5.8
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function fl(n, e, t, i) {
    try {
        return i ? n(...i) : n()
    } catch (r) {
        ju(r, e, t)
    }
}
function ri(n, e, t, i) {
    if (qe(n)) {
        const r = fl(n, e, t, i);
        return r && f0(r) && r.catch(s => {
            ju(s, e, t)
        }
        ),
        r
    }
    if (Oe(n)) {
        const r = [];
        for (let s = 0; s < n.length; s++)
            r.push(ri(n[s], e, t, i));
        return r
    }
}
function ju(n, e, t, i=!0) {
    const r = e ? e.vnode : null
      , {errorHandler: s, throwUnhandledErrorInProduction: o} = e && e.appContext.config || yt;
    if (e) {
        let a = e.parent;
        const l = e.proxy
          , c = `https://vuejs.org/error-reference/#runtime-${t}`;
        for (; a; ) {
            const u = a.ec;
            if (u) {
                for (let h = 0; h < u.length; h++)
                    if (u[h](n, l, c) === !1)
                        return
            }
            a = a.parent
        }
        if (s) {
            Cr(),
            fl(s, null, 10, [n, l, c]),
            Rr();
            return
        }
    }
    VS(n, t, r, i, o)
}
function VS(n, e, t, i=!0, r=!1) {
    if (r)
        throw n;
    console.error(n)
}
let La = !1
  , ud = !1;
const pn = [];
let hi = 0;
const ho = [];
let dr = null
  , Ks = 0;
const H0 = Promise.resolve();
let up = null;
function as(n) {
    const e = up || H0;
    return n ? e.then(this ? n.bind(this) : n) : e
}
function HS(n) {
    let e = La ? hi + 1 : 0
      , t = pn.length;
    for (; e < t; ) {
        const i = e + t >>> 1
          , r = pn[i]
          , s = Da(r);
        s < n || s === n && r.flags & 2 ? e = i + 1 : t = i
    }
    return e
}
function hp(n) {
    if (!(n.flags & 1)) {
        const e = Da(n)
          , t = pn[pn.length - 1];
        !t || !(n.flags & 2) && e >= Da(t) ? pn.push(n) : pn.splice(HS(e), 0, n),
        n.flags |= 1,
        G0()
    }
}
function G0() {
    !La && !ud && (ud = !0,
    up = H0.then(X0))
}
function GS(n) {
    Oe(n) ? ho.push(...n) : dr && n.id === -1 ? dr.splice(Ks + 1, 0, n) : n.flags & 1 || (ho.push(n),
    n.flags |= 1),
    G0()
}
function Fm(n, e, t=La ? hi + 1 : 0) {
    for (; t < pn.length; t++) {
        const i = pn[t];
        if (i && i.flags & 2) {
            if (n && i.id !== n.uid)
                continue;
            pn.splice(t, 1),
            t--,
            i.flags & 4 && (i.flags &= -2),
            i(),
            i.flags & 4 || (i.flags &= -2)
        }
    }
}
function W0(n) {
    if (ho.length) {
        const e = [...new Set(ho)].sort( (t, i) => Da(t) - Da(i));
        if (ho.length = 0,
        dr) {
            dr.push(...e);
            return
        }
        for (dr = e,
        Ks = 0; Ks < dr.length; Ks++) {
            const t = dr[Ks];
            t.flags & 4 && (t.flags &= -2),
            t.flags & 8 || t(),
            t.flags &= -2
        }
        dr = null,
        Ks = 0
    }
}
const Da = n => n.id == null ? n.flags & 2 ? -1 : 1 / 0 : n.id;
function X0(n) {
    ud = !1,
    La = !0;
    try {
        for (hi = 0; hi < pn.length; hi++) {
            const e = pn[hi];
            e && !(e.flags & 8) && (e.flags & 4 && (e.flags &= -2),
            fl(e, e.i, e.i ? 15 : 14),
            e.flags & 4 || (e.flags &= -2))
        }
    } finally {
        for (; hi < pn.length; hi++) {
            const e = pn[hi];
            e && (e.flags &= -2)
        }
        hi = 0,
        pn.length = 0,
        W0(),
        La = !1,
        up = null,
        (pn.length || ho.length) && X0()
    }
}
let jt = null
  , q0 = null;
function Kc(n) {
    const e = jt;
    return jt = n,
    q0 = n && n.type.__scopeId || null,
    e
}
function hd(n, e=jt, t) {
    if (!e || n._n)
        return n;
    const i = (...r) => {
        i._d && Ym(-1);
        const s = Kc(e);
        let o;
        try {
            o = n(...r)
        } finally {
            Kc(s),
            i._d && Ym(1)
        }
        return o
    }
    ;
    return i._n = !0,
    i._c = !0,
    i._d = !0,
    i
}
function nF(n, e) {
    if (jt === null)
        return n;
    const t = nh(jt)
      , i = n.dirs || (n.dirs = []);
    for (let r = 0; r < e.length; r++) {
        let[s,o,a,l=yt] = e[r];
        s && (qe(s) && (s = {
            mounted: s,
            updated: s
        }),
        s.deep && Oi(o),
        i.push({
            dir: s,
            instance: t,
            value: o,
            oldValue: void 0,
            arg: a,
            modifiers: l
        }))
    }
    return n
}
function Nr(n, e, t, i) {
    const r = n.dirs
      , s = e && e.dirs;
    for (let o = 0; o < r.length; o++) {
        const a = r[o];
        s && (a.oldValue = s[o].value);
        let l = a.dir[i];
        l && (Cr(),
        ri(l, t, 8, [n.el, a, n, e]),
        Rr())
    }
}
const $0 = Symbol("_vte")
  , Y0 = n => n.__isTeleport
  , ha = n => n && (n.disabled || n.disabled === "")
  , WS = n => n && (n.defer || n.defer === "")
  , Bm = n => typeof SVGElement < "u" && n instanceof SVGElement
  , zm = n => typeof MathMLElement == "function" && n instanceof MathMLElement
  , fd = (n, e) => {
    const t = n && n.to;
    return wt(t) ? e ? e(t) : null : t
}
  , XS = {
    name: "Teleport",
    __isTeleport: !0,
    process(n, e, t, i, r, s, o, a, l, c) {
        const {mc: u, pc: h, pbc: f, o: {insert: d, querySelector: p, createText: v, createComment: g}} = c
          , m = ha(e.props);
        let {shapeFlag: y, children: _, dynamicChildren: x} = e;
        if (n == null) {
            const C = e.el = v("")
              , w = e.anchor = v("");
            d(C, t, i),
            d(w, t, i);
            const E = (S, b) => {
                y & 16 && (r && r.isCE && (r.ce._teleportTarget = S),
                u(_, S, b, r, s, o, a, l))
            }
              , L = () => {
                const S = e.target = fd(e.props, p)
                  , b = j0(S, e, v, d);
                S && (o !== "svg" && Bm(S) ? o = "svg" : o !== "mathml" && zm(S) && (o = "mathml"),
                m || (E(S, b),
                Bc(e)))
            }
            ;
            m && (E(t, w),
            Bc(e)),
            WS(e.props) ? Yt(L, s) : L()
        } else {
            e.el = n.el,
            e.targetStart = n.targetStart;
            const C = e.anchor = n.anchor
              , w = e.target = n.target
              , E = e.targetAnchor = n.targetAnchor
              , L = ha(n.props)
              , S = L ? t : w
              , b = L ? C : E;
            if (o === "svg" || Bm(w) ? o = "svg" : (o === "mathml" || zm(w)) && (o = "mathml"),
            x ? (f(n.dynamicChildren, x, S, r, s, o, a),
            vp(n, e, !0)) : l || h(n, e, S, b, r, s, o, a, !1),
            m)
                L ? e.props && n.props && e.props.to !== n.props.to && (e.props.to = n.props.to) : Ul(e, t, C, c, 1);
            else if ((e.props && e.props.to) !== (n.props && n.props.to)) {
                const D = e.target = fd(e.props, p);
                D && Ul(e, D, null, c, 0)
            } else
                L && Ul(e, w, E, c, 1);
            Bc(e)
        }
    },
    remove(n, e, t, {um: i, o: {remove: r}}, s) {
        const {shapeFlag: o, children: a, anchor: l, targetStart: c, targetAnchor: u, target: h, props: f} = n;
        if (h && (r(c),
        r(u)),
        s && r(l),
        o & 16) {
            const d = s || !ha(f);
            for (let p = 0; p < a.length; p++) {
                const v = a[p];
                i(v, e, t, d, !!v.dynamicChildren)
            }
        }
    },
    move: Ul,
    hydrate: qS
};
function Ul(n, e, t, {o: {insert: i}, m: r}, s=2) {
    s === 0 && i(n.targetAnchor, e, t);
    const {el: o, anchor: a, shapeFlag: l, children: c, props: u} = n
      , h = s === 2;
    if (h && i(o, e, t),
    (!h || ha(u)) && l & 16)
        for (let f = 0; f < c.length; f++)
            r(c[f], e, t, 2);
    h && i(a, e, t)
}
function qS(n, e, t, i, r, s, {o: {nextSibling: o, parentNode: a, querySelector: l, insert: c, createText: u}}, h) {
    const f = e.target = fd(e.props, l);
    if (f) {
        const d = f._lpa || f.firstChild;
        if (e.shapeFlag & 16)
            if (ha(e.props))
                e.anchor = h(o(n), e, a(n), t, i, r, s),
                e.targetStart = d,
                e.targetAnchor = d && o(d);
            else {
                e.anchor = o(n);
                let p = d;
                for (; p; ) {
                    if (p && p.nodeType === 8) {
                        if (p.data === "teleport start anchor")
                            e.targetStart = p;
                        else if (p.data === "teleport anchor") {
                            e.targetAnchor = p,
                            f._lpa = e.targetAnchor && o(e.targetAnchor);
                            break
                        }
                    }
                    p = o(p)
                }
                e.targetAnchor || j0(f, e, u, c),
                h(d && o(d), e, f, t, i, r, s)
            }
        Bc(e)
    }
    return e.anchor && o(e.anchor)
}
const iF = XS;
function Bc(n) {
    const e = n.ctx;
    if (e && e.ut) {
        let t = n.targetStart;
        for (; t && t !== n.targetAnchor; )
            t.nodeType === 1 && t.setAttribute("data-v-owner", e.uid),
            t = t.nextSibling;
        e.ut()
    }
}
function j0(n, e, t, i) {
    const r = e.targetStart = t("")
      , s = e.targetAnchor = t("");
    return r[$0] = s,
    n && (i(r, n),
    i(s, n)),
    s
}
const pr = Symbol("_leaveCb")
  , Ol = Symbol("_enterCb");
function K0() {
    const n = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return Ms( () => {
        n.isMounted = !0
    }
    ),
    pp( () => {
        n.isUnmounting = !0
    }
    ),
    n
}
const Fn = [Function, Array]
  , Z0 = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Fn,
    onEnter: Fn,
    onAfterEnter: Fn,
    onEnterCancelled: Fn,
    onBeforeLeave: Fn,
    onLeave: Fn,
    onAfterLeave: Fn,
    onLeaveCancelled: Fn,
    onBeforeAppear: Fn,
    onAppear: Fn,
    onAfterAppear: Fn,
    onAppearCancelled: Fn
}
  , J0 = n => {
    const e = n.subTree;
    return e.component ? J0(e.component) : e
}
  , $S = {
    name: "BaseTransition",
    props: Z0,
    setup(n, {slots: e}) {
        const t = wr()
          , i = K0();
        return () => {
            const r = e.default && fp(e.default(), !0);
            if (!r || !r.length)
                return;
            const s = Q0(r)
              , o = rt(n)
              , {mode: a} = o;
            if (i.isLeaving)
                return nf(s);
            const l = km(s);
            if (!l)
                return nf(s);
            let c = Na(l, o, i, t, f => c = f);
            l.type !== sn && Sr(l, c);
            const u = t.subTree
              , h = u && km(u);
            if (h && h.type !== sn && !_r(l, h) && J0(t).type !== sn) {
                const f = Na(h, o, i, t);
                if (Sr(h, f),
                a === "out-in" && l.type !== sn)
                    return i.isLeaving = !0,
                    f.afterLeave = () => {
                        i.isLeaving = !1,
                        t.job.flags & 8 || t.update(),
                        delete f.afterLeave
                    }
                    ,
                    nf(s);
                a === "in-out" && l.type !== sn && (f.delayLeave = (d, p, v) => {
                    const g = ey(i, h);
                    g[String(h.key)] = h,
                    d[pr] = () => {
                        p(),
                        d[pr] = void 0,
                        delete c.delayedLeave
                    }
                    ,
                    c.delayedLeave = v
                }
                )
            }
            return s
        }
    }
};
function Q0(n) {
    let e = n[0];
    if (n.length > 1) {
        for (const t of n)
            if (t.type !== sn) {
                e = t;
                break
            }
    }
    return e
}
const YS = $S;
function ey(n, e) {
    const {leavingVNodes: t} = n;
    let i = t.get(e.type);
    return i || (i = Object.create(null),
    t.set(e.type, i)),
    i
}
function Na(n, e, t, i, r) {
    const {appear: s, mode: o, persisted: a=!1, onBeforeEnter: l, onEnter: c, onAfterEnter: u, onEnterCancelled: h, onBeforeLeave: f, onLeave: d, onAfterLeave: p, onLeaveCancelled: v, onBeforeAppear: g, onAppear: m, onAfterAppear: y, onAppearCancelled: _} = e
      , x = String(n.key)
      , C = ey(t, n)
      , w = (S, b) => {
        S && ri(S, i, 9, b)
    }
      , E = (S, b) => {
        const D = b[1];
        w(S, b),
        Oe(S) ? S.every(F => F.length <= 1) && D() : S.length <= 1 && D()
    }
      , L = {
        mode: o,
        persisted: a,
        beforeEnter(S) {
            let b = l;
            if (!t.isMounted)
                if (s)
                    b = g || l;
                else
                    return;
            S[pr] && S[pr](!0);
            const D = C[x];
            D && _r(n, D) && D.el[pr] && D.el[pr](),
            w(b, [S])
        },
        enter(S) {
            let b = c
              , D = u
              , F = h;
            if (!t.isMounted)
                if (s)
                    b = m || c,
                    D = y || u,
                    F = _ || h;
                else
                    return;
            let z = !1;
            const $ = S[Ol] = ne => {
                z || (z = !0,
                ne ? w(F, [S]) : w(D, [S]),
                L.delayedLeave && L.delayedLeave(),
                S[Ol] = void 0)
            }
            ;
            b ? E(b, [S, $]) : $()
        },
        leave(S, b) {
            const D = String(n.key);
            if (S[Ol] && S[Ol](!0),
            t.isUnmounting)
                return b();
            w(f, [S]);
            let F = !1;
            const z = S[pr] = $ => {
                F || (F = !0,
                b(),
                $ ? w(v, [S]) : w(p, [S]),
                S[pr] = void 0,
                C[D] === n && delete C[D])
            }
            ;
            C[D] = n,
            d ? E(d, [S, z]) : z()
        },
        clone(S) {
            const b = Na(S, e, t, i, r);
            return r && r(b),
            b
        }
    };
    return L
}
function nf(n) {
    if (Ku(n))
        return n = Gi(n),
        n.children = null,
        n
}
function km(n) {
    if (!Ku(n))
        return Y0(n.type) && n.children ? Q0(n.children) : n;
    const {shapeFlag: e, children: t} = n;
    if (t) {
        if (e & 16)
            return t[0];
        if (e & 32 && qe(t.default))
            return t.default()
    }
}
function Sr(n, e) {
    n.shapeFlag & 6 && n.component ? (n.transition = e,
    Sr(n.component.subTree, e)) : n.shapeFlag & 128 ? (n.ssContent.transition = e.clone(n.ssContent),
    n.ssFallback.transition = e.clone(n.ssFallback)) : n.transition = e
}
function fp(n, e=!1, t) {
    let i = []
      , r = 0;
    for (let s = 0; s < n.length; s++) {
        let o = n[s];
        const a = t == null ? o.key : String(t) + String(o.key != null ? o.key : s);
        o.type === mn ? (o.patchFlag & 128 && r++,
        i = i.concat(fp(o.children, e, a))) : (e || o.type !== sn) && i.push(a != null ? Gi(o, {
            key: a
        }) : o)
    }
    if (r > 1)
        for (let s = 0; s < i.length; s++)
            i[s].patchFlag = -2;
    return i
}
/*! #__NO_SIDE_EFFECTS__ */
function Ua(n, e) {
    return qe(n) ? Wt({
        name: n.name
    }, e, {
        setup: n
    }) : n
}
function ty(n) {
    n.ids = [n.ids[0] + n.ids[2]++ + "-", 0, 0]
}
function dd(n, e, t, i, r=!1) {
    if (Oe(n)) {
        n.forEach( (p, v) => dd(p, e && (Oe(e) ? e[v] : e), t, i, r));
        return
    }
    if (ls(i) && !r)
        return;
    const s = i.shapeFlag & 4 ? nh(i.component) : i.el
      , o = r ? null : s
      , {i: a, r: l} = n
      , c = e && e.r
      , u = a.refs === yt ? a.refs = {} : a.refs
      , h = a.setupState
      , f = rt(h)
      , d = h === yt ? () => !1 : p => ht(f, p);
    if (c != null && c !== l && (wt(c) ? (u[c] = null,
    d(c) && (h[c] = null)) : Ft(c) && (c.value = null)),
    qe(l))
        fl(l, a, 12, [o, u]);
    else {
        const p = wt(l)
          , v = Ft(l);
        if (p || v) {
            const g = () => {
                if (n.f) {
                    const m = p ? d(l) ? h[l] : u[l] : l.value;
                    r ? Oe(m) && ep(m, s) : Oe(m) ? m.includes(s) || m.push(s) : p ? (u[l] = [s],
                    d(l) && (h[l] = u[l])) : (l.value = [s],
                    n.k && (u[n.k] = l.value))
                } else
                    p ? (u[l] = o,
                    d(l) && (h[l] = o)) : v && (l.value = o,
                    n.k && (u[n.k] = o))
            }
            ;
            o ? (g.id = -1,
            Yt(g, t)) : g()
        }
    }
}
const ls = n => !!n.type.__asyncLoader
  , Ku = n => n.type.__isKeepAlive
  , jS = {
    name: "KeepAlive",
    __isKeepAlive: !0,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(n, {slots: e}) {
        const t = wr()
          , i = t.ctx;
        if (!i.renderer)
            return () => {
                const y = e.default && e.default();
                return y && y.length === 1 ? y[0] : y
            }
            ;
        const r = new Map
          , s = new Set;
        let o = null;
        const a = t.suspense
          , {renderer: {p: l, m: c, um: u, o: {createElement: h}}} = i
          , f = h("div");
        i.activate = (y, _, x, C, w) => {
            const E = y.component;
            c(y, _, x, 0, a),
            l(E.vnode, y, _, x, E, a, C, y.slotScopeIds, w),
            Yt( () => {
                E.isDeactivated = !1,
                E.a && co(E.a);
                const L = y.props && y.props.onVnodeMounted;
                L && kn(L, E.parent, y)
            }
            , a)
        }
        ,
        i.deactivate = y => {
            const _ = y.component;
            Jc(_.m),
            Jc(_.a),
            c(y, f, null, 1, a),
            Yt( () => {
                _.da && co(_.da);
                const x = y.props && y.props.onVnodeUnmounted;
                x && kn(x, _.parent, y),
                _.isDeactivated = !0
            }
            , a)
        }
        ;
        function d(y) {
            rf(y),
            u(y, t, a, !0)
        }
        function p(y) {
            r.forEach( (_, x) => {
                const C = yd(_.type);
                C && !y(C) && v(x)
            }
            )
        }
        function v(y) {
            const _ = r.get(y);
            _ && (!o || !_r(_, o)) ? d(_) : o && rf(o),
            r.delete(y),
            s.delete(y)
        }
        Bt( () => [n.include, n.exclude], ([y,_]) => {
            y && p(x => ra(y, x)),
            _ && p(x => !ra(_, x))
        }
        , {
            flush: "post",
            deep: !0
        });
        let g = null;
        const m = () => {
            g != null && (Qc(t.subTree.type) ? Yt( () => {
                r.set(g, Fl(t.subTree))
            }
            , t.subTree.suspense) : r.set(g, Fl(t.subTree)))
        }
        ;
        return Ms(m),
        dp(m),
        pp( () => {
            r.forEach(y => {
                const {subTree: _, suspense: x} = t
                  , C = Fl(_);
                if (y.type === C.type && y.key === C.key) {
                    rf(C);
                    const w = C.component.da;
                    w && Yt(w, x);
                    return
                }
                d(y)
            }
            )
        }
        ),
        () => {
            if (g = null,
            !e.default)
                return o = null;
            const y = e.default()
              , _ = y[0];
            if (y.length > 1)
                return o = null,
                y;
            if (!Fa(_) || !(_.shapeFlag & 4) && !(_.shapeFlag & 128))
                return o = null,
                _;
            let x = Fl(_);
            if (x.type === sn)
                return o = null,
                x;
            const C = x.type
              , w = yd(ls(x) ? x.type.__asyncResolved || {} : C)
              , {include: E, exclude: L, max: S} = n;
            if (E && (!w || !ra(E, w)) || L && w && ra(L, w))
                return x.shapeFlag &= -257,
                o = x,
                _;
            const b = x.key == null ? C : x.key
              , D = r.get(b);
            return x.el && (x = Gi(x),
            _.shapeFlag & 128 && (_.ssContent = x)),
            g = b,
            D ? (x.el = D.el,
            x.component = D.component,
            x.transition && Sr(x, x.transition),
            x.shapeFlag |= 512,
            s.delete(b),
            s.add(b)) : (s.add(b),
            S && s.size > parseInt(S, 10) && v(s.values().next().value)),
            x.shapeFlag |= 256,
            o = x,
            Qc(_.type) ? _ : x
        }
    }
}
  , KS = jS;
function ra(n, e) {
    return Oe(n) ? n.some(t => ra(t, e)) : wt(n) ? n.split(",").includes(e) : qM(n) ? (n.lastIndex = 0,
    n.test(e)) : !1
}
function ZS(n, e) {
    ny(n, "a", e)
}
function JS(n, e) {
    ny(n, "da", e)
}
function ny(n, e, t=Qt) {
    const i = n.__wdc || (n.__wdc = () => {
        let r = t;
        for (; r; ) {
            if (r.isDeactivated)
                return;
            r = r.parent
        }
        return n()
    }
    );
    if (Zu(e, i, t),
    t) {
        let r = t.parent;
        for (; r && r.parent; )
            Ku(r.parent.vnode) && QS(i, e, t, r),
            r = r.parent
    }
}
function QS(n, e, t, i) {
    const r = Zu(e, n, i, !0);
    Hi( () => {
        ep(i[e], r)
    }
    , t)
}
function rf(n) {
    n.shapeFlag &= -257,
    n.shapeFlag &= -513
}
function Fl(n) {
    return n.shapeFlag & 128 ? n.ssContent : n
}
function Zu(n, e, t=Qt, i=!1) {
    if (t) {
        const r = t[n] || (t[n] = [])
          , s = e.__weh || (e.__weh = (...o) => {
            Cr();
            const a = dl(t)
              , l = ri(e, t, n, o);
            return a(),
            Rr(),
            l
        }
        );
        return i ? r.unshift(s) : r.push(s),
        s
    }
}
const ji = n => (e, t=Qt) => {
    (!th || n === "sp") && Zu(n, (...i) => e(...i), t)
}
  , ew = ji("bm")
  , Ms = ji("m")
  , tw = ji("bu")
  , dp = ji("u")
  , pp = ji("bum")
  , Hi = ji("um")
  , nw = ji("sp")
  , iw = ji("rtg")
  , rw = ji("rtc");
function sw(n, e=Qt) {
    Zu("ec", n, e)
}
const iy = "components";
function ow(n, e) {
    return sy(iy, n, !0, e) || n
}
const ry = Symbol.for("v-ndc");
function aw(n) {
    return wt(n) ? sy(iy, n, !1) || n : n || ry
}
function sy(n, e, t=!0, i=!1) {
    const r = jt || Qt;
    if (r) {
        const s = r.type;
        {
            const a = yd(s, !1);
            if (a && (a === e || a === ii(e) || a === Hu(ii(e))))
                return s
        }
        const o = Vm(r[n] || s[n], e) || Vm(r.appContext[n], e);
        return !o && i ? s : o
    }
}
function Vm(n, e) {
    return n && (n[e] || n[ii(e)] || n[Hu(ii(e))])
}
function rF(n, e, t, i) {
    let r;
    const s = t
      , o = Oe(n);
    if (o || wt(n)) {
        const a = o && uo(n);
        let l = !1;
        a && (l = !Wn(n),
        n = $u(n)),
        r = new Array(n.length);
        for (let c = 0, u = n.length; c < u; c++)
            r[c] = e(l ? rn(n[c]) : n[c], c, void 0, s)
    } else if (typeof n == "number") {
        r = new Array(n);
        for (let a = 0; a < n; a++)
            r[a] = e(a + 1, a, void 0, s)
    } else if (mt(n))
        if (n[Symbol.iterator])
            r = Array.from(n, (a, l) => e(a, l, void 0, s));
        else {
            const a = Object.keys(n);
            r = new Array(a.length);
            for (let l = 0, c = a.length; l < c; l++) {
                const u = a[l];
                r[l] = e(n[u], u, l, s)
            }
        }
    else
        r = [];
    return r
}
function lw(n, e, t={}, i, r) {
    if (jt.ce || jt.parent && ls(jt.parent) && jt.parent.ce)
        return e !== "default" && (t.name = e),
        br(),
        po(mn, null, [on("slot", t, i && i())], 64);
    let s = n[e];
    s && s._c && (s._d = !1),
    br();
    const o = s && oy(s(t))
      , a = po(mn, {
        key: (t.key || o && o.key || `_${e}`) + (!o && i ? "_fb" : "")
    }, o || (i ? i() : []), o && n._ === 1 ? 64 : -2);
    return a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]),
    s && s._c && (s._d = !0),
    a
}
function oy(n) {
    return n.some(e => Fa(e) ? !(e.type === sn || e.type === mn && !oy(e.children)) : !0) ? n : null
}
const pd = n => n ? Ty(n) ? nh(n) : pd(n.parent) : null
  , fa = Wt(Object.create(null), {
    $: n => n,
    $el: n => n.vnode.el,
    $data: n => n.data,
    $props: n => n.props,
    $attrs: n => n.attrs,
    $slots: n => n.slots,
    $refs: n => n.refs,
    $parent: n => pd(n.parent),
    $root: n => pd(n.root),
    $host: n => n.ce,
    $emit: n => n.emit,
    $options: n => mp(n),
    $forceUpdate: n => n.f || (n.f = () => {
        hp(n.update)
    }
    ),
    $nextTick: n => n.n || (n.n = as.bind(n.proxy)),
    $watch: n => Rw.bind(n)
})
  , sf = (n, e) => n !== yt && !n.__isScriptSetup && ht(n, e)
  , cw = {
    get({_: n}, e) {
        if (e === "__v_skip")
            return !0;
        const {ctx: t, setupState: i, data: r, props: s, accessCache: o, type: a, appContext: l} = n;
        let c;
        if (e[0] !== "$") {
            const d = o[e];
            if (d !== void 0)
                switch (d) {
                case 1:
                    return i[e];
                case 2:
                    return r[e];
                case 4:
                    return t[e];
                case 3:
                    return s[e]
                }
            else {
                if (sf(i, e))
                    return o[e] = 1,
                    i[e];
                if (r !== yt && ht(r, e))
                    return o[e] = 2,
                    r[e];
                if ((c = n.propsOptions[0]) && ht(c, e))
                    return o[e] = 3,
                    s[e];
                if (t !== yt && ht(t, e))
                    return o[e] = 4,
                    t[e];
                md && (o[e] = 0)
            }
        }
        const u = fa[e];
        let h, f;
        if (u)
            return e === "$attrs" && ln(n.attrs, "get", ""),
            u(n);
        if ((h = a.__cssModules) && (h = h[e]))
            return h;
        if (t !== yt && ht(t, e))
            return o[e] = 4,
            t[e];
        if (f = l.config.globalProperties,
        ht(f, e))
            return f[e]
    },
    set({_: n}, e, t) {
        const {data: i, setupState: r, ctx: s} = n;
        return sf(r, e) ? (r[e] = t,
        !0) : i !== yt && ht(i, e) ? (i[e] = t,
        !0) : ht(n.props, e) || e[0] === "$" && e.slice(1)in n ? !1 : (s[e] = t,
        !0)
    },
    has({_: {data: n, setupState: e, accessCache: t, ctx: i, appContext: r, propsOptions: s}}, o) {
        let a;
        return !!t[o] || n !== yt && ht(n, o) || sf(e, o) || (a = s[0]) && ht(a, o) || ht(i, o) || ht(fa, o) || ht(r.config.globalProperties, o)
    },
    defineProperty(n, e, t) {
        return t.get != null ? n._.accessCache[e] = 0 : ht(t, "value") && this.set(n, e, t.value, null),
        Reflect.defineProperty(n, e, t)
    }
};
function uw() {
    return ay().slots
}
function sF() {
    return ay().attrs
}
function ay() {
    const n = wr();
    return n.setupContext || (n.setupContext = Ry(n))
}
function Hm(n) {
    return Oe(n) ? n.reduce( (e, t) => (e[t] = null,
    e), {}) : n
}
let md = !0;
function hw(n) {
    const e = mp(n)
      , t = n.proxy
      , i = n.ctx;
    md = !1,
    e.beforeCreate && Gm(e.beforeCreate, n, "bc");
    const {data: r, computed: s, methods: o, watch: a, provide: l, inject: c, created: u, beforeMount: h, mounted: f, beforeUpdate: d, updated: p, activated: v, deactivated: g, beforeDestroy: m, beforeUnmount: y, destroyed: _, unmounted: x, render: C, renderTracked: w, renderTriggered: E, errorCaptured: L, serverPrefetch: S, expose: b, inheritAttrs: D, components: F, directives: z, filters: $} = e;
    if (c && fw(c, i, null),
    o)
        for (const ie in o) {
            const Z = o[ie];
            qe(Z) && (i[ie] = Z.bind(t))
        }
    if (r) {
        const ie = r.call(t, t);
        mt(ie) && (n.data = hl(ie))
    }
    if (md = !0,
    s)
        for (const ie in s) {
            const Z = s[ie]
              , ve = qe(Z) ? Z.bind(t, t) : qe(Z.get) ? Z.get.bind(t, t) : ei
              , xe = !qe(Z) && qe(Z.set) ? Z.set.bind(t) : ei
              , te = Lt({
                get: ve,
                set: xe
            });
            Object.defineProperty(i, ie, {
                enumerable: !0,
                configurable: !0,
                get: () => te.value,
                set: Se => te.value = Se
            })
        }
    if (a)
        for (const ie in a)
            ly(a[ie], i, t, ie);
    if (l) {
        const ie = qe(l) ? l.call(t) : l;
        Reflect.ownKeys(ie).forEach(Z => {
            cs(Z, ie[Z])
        }
        )
    }
    u && Gm(u, n, "c");
    function W(ie, Z) {
        Oe(Z) ? Z.forEach(ve => ie(ve.bind(t))) : Z && ie(Z.bind(t))
    }
    if (W(ew, h),
    W(Ms, f),
    W(tw, d),
    W(dp, p),
    W(ZS, v),
    W(JS, g),
    W(sw, L),
    W(rw, w),
    W(iw, E),
    W(pp, y),
    W(Hi, x),
    W(nw, S),
    Oe(b))
        if (b.length) {
            const ie = n.exposed || (n.exposed = {});
            b.forEach(Z => {
                Object.defineProperty(ie, Z, {
                    get: () => t[Z],
                    set: ve => t[Z] = ve
                })
            }
            )
        } else
            n.exposed || (n.exposed = {});
    C && n.render === ei && (n.render = C),
    D != null && (n.inheritAttrs = D),
    F && (n.components = F),
    z && (n.directives = z),
    S && ty(n)
}
function fw(n, e, t=ei) {
    Oe(n) && (n = gd(n));
    for (const i in n) {
        const r = n[i];
        let s;
        mt(r) ? "default"in r ? s = ni(r.from || i, r.default, !0) : s = ni(r.from || i) : s = ni(r),
        Ft(s) ? Object.defineProperty(e, i, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: o => s.value = o
        }) : e[i] = s
    }
}
function Gm(n, e, t) {
    ri(Oe(n) ? n.map(i => i.bind(e.proxy)) : n.bind(e.proxy), e, t)
}
function ly(n, e, t, i) {
    let r = i.includes(".") ? by(t, i) : () => t[i];
    if (wt(n)) {
        const s = e[n];
        qe(s) && Bt(r, s)
    } else if (qe(n))
        Bt(r, n.bind(t));
    else if (mt(n))
        if (Oe(n))
            n.forEach(s => ly(s, e, t, i));
        else {
            const s = qe(n.handler) ? n.handler.bind(t) : e[n.handler];
            qe(s) && Bt(r, s, n)
        }
}
function mp(n) {
    const e = n.type
      , {mixins: t, extends: i} = e
      , {mixins: r, optionsCache: s, config: {optionMergeStrategies: o}} = n.appContext
      , a = s.get(e);
    let l;
    return a ? l = a : !r.length && !t && !i ? l = e : (l = {},
    r.length && r.forEach(c => Zc(l, c, o, !0)),
    Zc(l, e, o)),
    mt(e) && s.set(e, l),
    l
}
function Zc(n, e, t, i=!1) {
    const {mixins: r, extends: s} = e;
    s && Zc(n, s, t, !0),
    r && r.forEach(o => Zc(n, o, t, !0));
    for (const o in e)
        if (!(i && o === "expose")) {
            const a = dw[o] || t && t[o];
            n[o] = a ? a(n[o], e[o]) : e[o]
        }
    return n
}
const dw = {
    data: Wm,
    props: Xm,
    emits: Xm,
    methods: sa,
    computed: sa,
    beforeCreate: hn,
    created: hn,
    beforeMount: hn,
    mounted: hn,
    beforeUpdate: hn,
    updated: hn,
    beforeDestroy: hn,
    beforeUnmount: hn,
    destroyed: hn,
    unmounted: hn,
    activated: hn,
    deactivated: hn,
    errorCaptured: hn,
    serverPrefetch: hn,
    components: sa,
    directives: sa,
    watch: mw,
    provide: Wm,
    inject: pw
};
function Wm(n, e) {
    return e ? n ? function() {
        return Wt(qe(n) ? n.call(this, this) : n, qe(e) ? e.call(this, this) : e)
    }
    : e : n
}
function pw(n, e) {
    return sa(gd(n), gd(e))
}
function gd(n) {
    if (Oe(n)) {
        const e = {};
        for (let t = 0; t < n.length; t++)
            e[n[t]] = n[t];
        return e
    }
    return n
}
function hn(n, e) {
    return n ? [...new Set([].concat(n, e))] : e
}
function sa(n, e) {
    return n ? Wt(Object.create(null), n, e) : e
}
function Xm(n, e) {
    return n ? Oe(n) && Oe(e) ? [...new Set([...n, ...e])] : Wt(Object.create(null), Hm(n), Hm(e ?? {})) : e
}
function mw(n, e) {
    if (!n)
        return e;
    if (!e)
        return n;
    const t = Wt(Object.create(null), n);
    for (const i in e)
        t[i] = hn(n[i], e[i]);
    return t
}
function cy() {
    return {
        app: null,
        config: {
            isNativeTag: WM,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let gw = 0;
function vw(n, e) {
    return function(i, r=null) {
        qe(i) || (i = Wt({}, i)),
        r != null && !mt(r) && (r = null);
        const s = cy()
          , o = new WeakSet
          , a = [];
        let l = !1;
        const c = s.app = {
            _uid: gw++,
            _component: i,
            _props: r,
            _container: null,
            _context: s,
            _instance: null,
            version: jw,
            get config() {
                return s.config
            },
            set config(u) {},
            use(u, ...h) {
                return o.has(u) || (u && qe(u.install) ? (o.add(u),
                u.install(c, ...h)) : qe(u) && (o.add(u),
                u(c, ...h))),
                c
            },
            mixin(u) {
                return s.mixins.includes(u) || s.mixins.push(u),
                c
            },
            component(u, h) {
                return h ? (s.components[u] = h,
                c) : s.components[u]
            },
            directive(u, h) {
                return h ? (s.directives[u] = h,
                c) : s.directives[u]
            },
            mount(u, h, f) {
                if (!l) {
                    const d = c._ceVNode || on(i, r);
                    return d.appContext = s,
                    f === !0 ? f = "svg" : f === !1 && (f = void 0),
                    h && e ? e(d, u) : n(d, u, f),
                    l = !0,
                    c._container = u,
                    u.__vue_app__ = c,
                    nh(d.component)
                }
            },
            onUnmount(u) {
                a.push(u)
            },
            unmount() {
                l && (ri(a, c._instance, 16),
                n(null, c._container),
                delete c._container.__vue_app__)
            },
            provide(u, h) {
                return s.provides[u] = h,
                c
            },
            runWithContext(u) {
                const h = fo;
                fo = c;
                try {
                    return u()
                } finally {
                    fo = h
                }
            }
        };
        return c
    }
}
let fo = null;
function cs(n, e) {
    if (Qt) {
        let t = Qt.provides;
        const i = Qt.parent && Qt.parent.provides;
        i === t && (t = Qt.provides = Object.create(i)),
        t[n] = e
    }
}
function ni(n, e, t=!1) {
    const i = Qt || jt;
    if (i || fo) {
        const r = fo ? fo._context.provides : i ? i.parent == null ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : void 0;
        if (r && n in r)
            return r[n];
        if (arguments.length > 1)
            return t && qe(e) ? e.call(i && i.proxy) : e
    }
}
const uy = {}
  , hy = () => Object.create(uy)
  , fy = n => Object.getPrototypeOf(n) === uy;
function _w(n, e, t, i=!1) {
    const r = {}
      , s = hy();
    n.propsDefaults = Object.create(null),
    dy(n, e, r, s);
    for (const o in n.propsOptions[0])
        o in r || (r[o] = void 0);
    t ? n.props = i ? r : F0(r) : n.type.props ? n.props = r : n.props = s,
    n.attrs = s
}
function yw(n, e, t, i) {
    const {props: r, attrs: s, vnode: {patchFlag: o}} = n
      , a = rt(r)
      , [l] = n.propsOptions;
    let c = !1;
    if ((i || o > 0) && !(o & 16)) {
        if (o & 8) {
            const u = n.vnode.dynamicProps;
            for (let h = 0; h < u.length; h++) {
                let f = u[h];
                if (Qu(n.emitsOptions, f))
                    continue;
                const d = e[f];
                if (l)
                    if (ht(s, f))
                        d !== s[f] && (s[f] = d,
                        c = !0);
                    else {
                        const p = ii(f);
                        r[p] = vd(l, a, p, d, n, !1)
                    }
                else
                    d !== s[f] && (s[f] = d,
                    c = !0)
            }
        }
    } else {
        dy(n, e, r, s) && (c = !0);
        let u;
        for (const h in a)
            (!e || !ht(e, h) && ((u = Tr(h)) === h || !ht(e, u))) && (l ? t && (t[h] !== void 0 || t[u] !== void 0) && (r[h] = vd(l, a, h, void 0, n, !0)) : delete r[h]);
        if (s !== a)
            for (const h in s)
                (!e || !ht(e, h)) && (delete s[h],
                c = !0)
    }
    c && ki(n.attrs, "set", "")
}
function dy(n, e, t, i) {
    const [r,s] = n.propsOptions;
    let o = !1, a;
    if (e)
        for (let l in e) {
            if (ca(l))
                continue;
            const c = e[l];
            let u;
            r && ht(r, u = ii(l)) ? !s || !s.includes(u) ? t[u] = c : (a || (a = {}))[u] = c : Qu(n.emitsOptions, l) || (!(l in i) || c !== i[l]) && (i[l] = c,
            o = !0)
        }
    if (s) {
        const l = rt(t)
          , c = a || yt;
        for (let u = 0; u < s.length; u++) {
            const h = s[u];
            t[h] = vd(r, l, h, c[h], n, !ht(c, h))
        }
    }
    return o
}
function vd(n, e, t, i, r, s) {
    const o = n[t];
    if (o != null) {
        const a = ht(o, "default");
        if (a && i === void 0) {
            const l = o.default;
            if (o.type !== Function && !o.skipFactory && qe(l)) {
                const {propsDefaults: c} = r;
                if (t in c)
                    i = c[t];
                else {
                    const u = dl(r);
                    i = c[t] = l.call(null, e),
                    u()
                }
            } else
                i = l;
            r.ce && r.ce._setProp(t, i)
        }
        o[0] && (s && !a ? i = !1 : o[1] && (i === "" || i === Tr(t)) && (i = !0))
    }
    return i
}
const xw = new WeakMap;
function py(n, e, t=!1) {
    const i = t ? xw : e.propsCache
      , r = i.get(n);
    if (r)
        return r;
    const s = n.props
      , o = {}
      , a = [];
    let l = !1;
    if (!qe(n)) {
        const u = h => {
            l = !0;
            const [f,d] = py(h, e, !0);
            Wt(o, f),
            d && a.push(...d)
        }
        ;
        !t && e.mixins.length && e.mixins.forEach(u),
        n.extends && u(n.extends),
        n.mixins && n.mixins.forEach(u)
    }
    if (!s && !l)
        return mt(n) && i.set(n, ao),
        ao;
    if (Oe(s))
        for (let u = 0; u < s.length; u++) {
            const h = ii(s[u]);
            qm(h) && (o[h] = yt)
        }
    else if (s)
        for (const u in s) {
            const h = ii(u);
            if (qm(h)) {
                const f = s[u]
                  , d = o[h] = Oe(f) || qe(f) ? {
                    type: f
                } : Wt({}, f)
                  , p = d.type;
                let v = !1
                  , g = !0;
                if (Oe(p))
                    for (let m = 0; m < p.length; ++m) {
                        const y = p[m]
                          , _ = qe(y) && y.name;
                        if (_ === "Boolean") {
                            v = !0;
                            break
                        } else
                            _ === "String" && (g = !1)
                    }
                else
                    v = qe(p) && p.name === "Boolean";
                d[0] = v,
                d[1] = g,
                (v || ht(d, "default")) && a.push(h)
            }
        }
    const c = [o, a];
    return mt(n) && i.set(n, c),
    c
}
function qm(n) {
    return n[0] !== "$" && !ca(n)
}
const my = n => n[0] === "_" || n === "$stable"
  , gp = n => Oe(n) ? n.map(di) : [di(n)]
  , bw = (n, e, t) => {
    if (e._n)
        return e;
    const i = hd( (...r) => gp(e(...r)), t);
    return i._c = !1,
    i
}
  , gy = (n, e, t) => {
    const i = n._ctx;
    for (const r in n) {
        if (my(r))
            continue;
        const s = n[r];
        if (qe(s))
            e[r] = bw(r, s, i);
        else if (s != null) {
            const o = gp(s);
            e[r] = () => o
        }
    }
}
  , vy = (n, e) => {
    const t = gp(e);
    n.slots.default = () => t
}
  , _y = (n, e, t) => {
    for (const i in e)
        (t || i !== "_") && (n[i] = e[i])
}
  , Mw = (n, e, t) => {
    const i = n.slots = hy();
    if (n.vnode.shapeFlag & 32) {
        const r = e._;
        r ? (_y(i, e, t),
        t && m0(i, "_", r, !0)) : gy(e, i)
    } else
        e && vy(n, e)
}
  , Sw = (n, e, t) => {
    const {vnode: i, slots: r} = n;
    let s = !0
      , o = yt;
    if (i.shapeFlag & 32) {
        const a = e._;
        a ? t && a === 1 ? s = !1 : _y(r, e, t) : (s = !e.$stable,
        gy(e, r)),
        o = e
    } else
        e && (vy(n, e),
        o = {
            default: 1
        });
    if (s)
        for (const a in r)
            !my(a) && o[a] == null && delete r[a]
}
  , Yt = Ow;
function yy(n) {
    return ww(n)
}
function ww(n, e) {
    const t = g0();
    t.__VUE__ = !0;
    const {insert: i, remove: r, patchProp: s, createElement: o, createText: a, createComment: l, setText: c, setElementText: u, parentNode: h, nextSibling: f, setScopeId: d=ei, insertStaticContent: p} = n
      , v = (A, R, O, B=null, Y=null, X=null, ee=void 0, T=null, M=!!R.dynamicChildren) => {
        if (A === R)
            return;
        A && !_r(A, R) && (B = k(A),
        Se(A, Y, X, !0),
        A = null),
        R.patchFlag === -2 && (M = !1,
        R.dynamicChildren = null);
        const {type: U, ref: K, shapeFlag: H} = R;
        switch (U) {
        case eh:
            g(A, R, O, B);
            break;
        case sn:
            m(A, R, O, B);
            break;
        case lf:
            A == null && y(R, O, B, ee);
            break;
        case mn:
            F(A, R, O, B, Y, X, ee, T, M);
            break;
        default:
            H & 1 ? C(A, R, O, B, Y, X, ee, T, M) : H & 6 ? z(A, R, O, B, Y, X, ee, T, M) : (H & 64 || H & 128) && U.process(A, R, O, B, Y, X, ee, T, M, he)
        }
        K != null && Y && dd(K, A && A.ref, X, R || A, !R)
    }
      , g = (A, R, O, B) => {
        if (A == null)
            i(R.el = a(R.children), O, B);
        else {
            const Y = R.el = A.el;
            R.children !== A.children && c(Y, R.children)
        }
    }
      , m = (A, R, O, B) => {
        A == null ? i(R.el = l(R.children || ""), O, B) : R.el = A.el
    }
      , y = (A, R, O, B) => {
        [A.el,A.anchor] = p(A.children, R, O, B, A.el, A.anchor)
    }
      , _ = ({el: A, anchor: R}, O, B) => {
        let Y;
        for (; A && A !== R; )
            Y = f(A),
            i(A, O, B),
            A = Y;
        i(R, O, B)
    }
      , x = ({el: A, anchor: R}) => {
        let O;
        for (; A && A !== R; )
            O = f(A),
            r(A),
            A = O;
        r(R)
    }
      , C = (A, R, O, B, Y, X, ee, T, M) => {
        R.type === "svg" ? ee = "svg" : R.type === "math" && (ee = "mathml"),
        A == null ? w(R, O, B, Y, X, ee, T, M) : S(A, R, Y, X, ee, T, M)
    }
      , w = (A, R, O, B, Y, X, ee, T) => {
        let M, U;
        const {props: K, shapeFlag: H, transition: j, dirs: de} = A;
        if (M = A.el = o(A.type, X, K && K.is, K),
        H & 8 ? u(M, A.children) : H & 16 && L(A.children, M, null, B, Y, of(A, X), ee, T),
        de && Nr(A, null, B, "created"),
        E(M, A, A.scopeId, ee, B),
        K) {
            for (const me in K)
                me !== "value" && !ca(me) && s(M, me, null, K[me], X, B);
            "value"in K && s(M, "value", null, K.value, X),
            (U = K.onVnodeBeforeMount) && kn(U, B, A)
        }
        de && Nr(A, null, B, "beforeMount");
        const le = Ew(Y, j);
        le && j.beforeEnter(M),
        i(M, R, O),
        ((U = K && K.onVnodeMounted) || le || de) && Yt( () => {
            U && kn(U, B, A),
            le && j.enter(M),
            de && Nr(A, null, B, "mounted")
        }
        , Y)
    }
      , E = (A, R, O, B, Y) => {
        if (O && d(A, O),
        B)
            for (let X = 0; X < B.length; X++)
                d(A, B[X]);
        if (Y) {
            let X = Y.subTree;
            if (R === X || Qc(X.type) && (X.ssContent === R || X.ssFallback === R)) {
                const ee = Y.vnode;
                E(A, ee, ee.scopeId, ee.slotScopeIds, Y.parent)
            }
        }
    }
      , L = (A, R, O, B, Y, X, ee, T, M=0) => {
        for (let U = M; U < A.length; U++) {
            const K = A[U] = T ? mr(A[U]) : di(A[U]);
            v(null, K, R, O, B, Y, X, ee, T)
        }
    }
      , S = (A, R, O, B, Y, X, ee) => {
        const T = R.el = A.el;
        let {patchFlag: M, dynamicChildren: U, dirs: K} = R;
        M |= A.patchFlag & 16;
        const H = A.props || yt
          , j = R.props || yt;
        let de;
        if (O && Ur(O, !1),
        (de = j.onVnodeBeforeUpdate) && kn(de, O, R, A),
        K && Nr(R, A, O, "beforeUpdate"),
        O && Ur(O, !0),
        (H.innerHTML && j.innerHTML == null || H.textContent && j.textContent == null) && u(T, ""),
        U ? b(A.dynamicChildren, U, T, O, B, of(R, Y), X) : ee || Z(A, R, T, null, O, B, of(R, Y), X, !1),
        M > 0) {
            if (M & 16)
                D(T, H, j, O, Y);
            else if (M & 2 && H.class !== j.class && s(T, "class", null, j.class, Y),
            M & 4 && s(T, "style", H.style, j.style, Y),
            M & 8) {
                const le = R.dynamicProps;
                for (let me = 0; me < le.length; me++) {
                    const Ae = le[me]
                      , fe = H[Ae]
                      , ge = j[Ae];
                    (ge !== fe || Ae === "value") && s(T, Ae, fe, ge, Y, O)
                }
            }
            M & 1 && A.children !== R.children && u(T, R.children)
        } else
            !ee && U == null && D(T, H, j, O, Y);
        ((de = j.onVnodeUpdated) || K) && Yt( () => {
            de && kn(de, O, R, A),
            K && Nr(R, A, O, "updated")
        }
        , B)
    }
      , b = (A, R, O, B, Y, X, ee) => {
        for (let T = 0; T < R.length; T++) {
            const M = A[T]
              , U = R[T]
              , K = M.el && (M.type === mn || !_r(M, U) || M.shapeFlag & 70) ? h(M.el) : O;
            v(M, U, K, null, B, Y, X, ee, !0)
        }
    }
      , D = (A, R, O, B, Y) => {
        if (R !== O) {
            if (R !== yt)
                for (const X in R)
                    !ca(X) && !(X in O) && s(A, X, R[X], null, Y, B);
            for (const X in O) {
                if (ca(X))
                    continue;
                const ee = O[X]
                  , T = R[X];
                ee !== T && X !== "value" && s(A, X, T, ee, Y, B)
            }
            "value"in O && s(A, "value", R.value, O.value, Y)
        }
    }
      , F = (A, R, O, B, Y, X, ee, T, M) => {
        const U = R.el = A ? A.el : a("")
          , K = R.anchor = A ? A.anchor : a("");
        let {patchFlag: H, dynamicChildren: j, slotScopeIds: de} = R;
        de && (T = T ? T.concat(de) : de),
        A == null ? (i(U, O, B),
        i(K, O, B),
        L(R.children || [], O, K, Y, X, ee, T, M)) : H > 0 && H & 64 && j && A.dynamicChildren ? (b(A.dynamicChildren, j, O, Y, X, ee, T),
        (R.key != null || Y && R === Y.subTree) && vp(A, R, !0)) : Z(A, R, O, K, Y, X, ee, T, M)
    }
      , z = (A, R, O, B, Y, X, ee, T, M) => {
        R.slotScopeIds = T,
        A == null ? R.shapeFlag & 512 ? Y.ctx.activate(R, O, B, ee, M) : $(R, O, B, Y, X, ee, M) : ne(A, R, M)
    }
      , $ = (A, R, O, B, Y, X, ee) => {
        const T = A.component = Ww(A, B, Y);
        if (Ku(A) && (T.ctx.renderer = he),
        Xw(T, !1, ee),
        T.asyncDep) {
            if (Y && Y.registerDep(T, W, ee),
            !A.el) {
                const M = T.subTree = on(sn);
                m(null, M, R, O)
            }
        } else
            W(T, A, R, O, Y, X, ee)
    }
      , ne = (A, R, O) => {
        const B = R.component = A.component;
        if (Nw(A, R, O))
            if (B.asyncDep && !B.asyncResolved) {
                ie(B, R, O);
                return
            } else
                B.next = R,
                B.update();
        else
            R.el = A.el,
            B.vnode = R
    }
      , W = (A, R, O, B, Y, X, ee) => {
        const T = () => {
            if (A.isMounted) {
                let {next: H, bu: j, u: de, parent: le, vnode: me} = A;
                {
                    const De = xy(A);
                    if (De) {
                        H && (H.el = me.el,
                        ie(A, H, ee)),
                        De.asyncDep.then( () => {
                            A.isUnmounted || T()
                        }
                        );
                        return
                    }
                }
                let Ae = H, fe;
                Ur(A, !1),
                H ? (H.el = me.el,
                ie(A, H, ee)) : H = me,
                j && co(j),
                (fe = H.props && H.props.onVnodeBeforeUpdate) && kn(fe, le, H, me),
                Ur(A, !0);
                const ge = af(A)
                  , He = A.subTree;
                A.subTree = ge,
                v(He, ge, h(He.el), k(He), A, Y, X),
                H.el = ge.el,
                Ae === null && Uw(A, ge.el),
                de && Yt(de, Y),
                (fe = H.props && H.props.onVnodeUpdated) && Yt( () => kn(fe, le, H, me), Y)
            } else {
                let H;
                const {el: j, props: de} = R
                  , {bm: le, m: me, parent: Ae, root: fe, type: ge} = A
                  , He = ls(R);
                if (Ur(A, !1),
                le && co(le),
                !He && (H = de && de.onVnodeBeforeMount) && kn(H, Ae, R),
                Ur(A, !0),
                j && I) {
                    const De = () => {
                        A.subTree = af(A),
                        I(j, A.subTree, A, Y, null)
                    }
                    ;
                    He && ge.__asyncHydrate ? ge.__asyncHydrate(j, A, De) : De()
                } else {
                    fe.ce && fe.ce._injectChildStyle(ge);
                    const De = A.subTree = af(A);
                    v(null, De, O, B, A, Y, X),
                    R.el = De.el
                }
                if (me && Yt(me, Y),
                !He && (H = de && de.onVnodeMounted)) {
                    const De = R;
                    Yt( () => kn(H, Ae, De), Y)
                }
                (R.shapeFlag & 256 || Ae && ls(Ae.vnode) && Ae.vnode.shapeFlag & 256) && A.a && Yt(A.a, Y),
                A.isMounted = !0,
                R = O = B = null
            }
        }
        ;
        A.scope.on();
        const M = A.effect = new S0(T);
        A.scope.off();
        const U = A.update = M.run.bind(M)
          , K = A.job = M.runIfDirty.bind(M);
        K.i = A,
        K.id = A.uid,
        M.scheduler = () => hp(K),
        Ur(A, !0),
        U()
    }
      , ie = (A, R, O) => {
        R.component = A;
        const B = A.vnode.props;
        A.vnode = R,
        A.next = null,
        yw(A, R.props, B, O),
        Sw(A, R.children, O),
        Cr(),
        Fm(A),
        Rr()
    }
      , Z = (A, R, O, B, Y, X, ee, T, M=!1) => {
        const U = A && A.children
          , K = A ? A.shapeFlag : 0
          , H = R.children
          , {patchFlag: j, shapeFlag: de} = R;
        if (j > 0) {
            if (j & 128) {
                xe(U, H, O, B, Y, X, ee, T, M);
                return
            } else if (j & 256) {
                ve(U, H, O, B, Y, X, ee, T, M);
                return
            }
        }
        de & 8 ? (K & 16 && Me(U, Y, X),
        H !== U && u(O, H)) : K & 16 ? de & 16 ? xe(U, H, O, B, Y, X, ee, T, M) : Me(U, Y, X, !0) : (K & 8 && u(O, ""),
        de & 16 && L(H, O, B, Y, X, ee, T, M))
    }
      , ve = (A, R, O, B, Y, X, ee, T, M) => {
        A = A || ao,
        R = R || ao;
        const U = A.length
          , K = R.length
          , H = Math.min(U, K);
        let j;
        for (j = 0; j < H; j++) {
            const de = R[j] = M ? mr(R[j]) : di(R[j]);
            v(A[j], de, O, null, Y, X, ee, T, M)
        }
        U > K ? Me(A, Y, X, !0, !1, H) : L(R, O, B, Y, X, ee, T, M, H)
    }
      , xe = (A, R, O, B, Y, X, ee, T, M) => {
        let U = 0;
        const K = R.length;
        let H = A.length - 1
          , j = K - 1;
        for (; U <= H && U <= j; ) {
            const de = A[U]
              , le = R[U] = M ? mr(R[U]) : di(R[U]);
            if (_r(de, le))
                v(de, le, O, null, Y, X, ee, T, M);
            else
                break;
            U++
        }
        for (; U <= H && U <= j; ) {
            const de = A[H]
              , le = R[j] = M ? mr(R[j]) : di(R[j]);
            if (_r(de, le))
                v(de, le, O, null, Y, X, ee, T, M);
            else
                break;
            H--,
            j--
        }
        if (U > H) {
            if (U <= j) {
                const de = j + 1
                  , le = de < K ? R[de].el : B;
                for (; U <= j; )
                    v(null, R[U] = M ? mr(R[U]) : di(R[U]), O, le, Y, X, ee, T, M),
                    U++
            }
        } else if (U > j)
            for (; U <= H; )
                Se(A[U], Y, X, !0),
                U++;
        else {
            const de = U
              , le = U
              , me = new Map;
            for (U = le; U <= j; U++) {
                const Fe = R[U] = M ? mr(R[U]) : di(R[U]);
                Fe.key != null && me.set(Fe.key, U)
            }
            let Ae, fe = 0;
            const ge = j - le + 1;
            let He = !1
              , De = 0;
            const Te = new Array(ge);
            for (U = 0; U < ge; U++)
                Te[U] = 0;
            for (U = de; U <= H; U++) {
                const Fe = A[U];
                if (fe >= ge) {
                    Se(Fe, Y, X, !0);
                    continue
                }
                let et;
                if (Fe.key != null)
                    et = me.get(Fe.key);
                else
                    for (Ae = le; Ae <= j; Ae++)
                        if (Te[Ae - le] === 0 && _r(Fe, R[Ae])) {
                            et = Ae;
                            break
                        }
                et === void 0 ? Se(Fe, Y, X, !0) : (Te[et - le] = U + 1,
                et >= De ? De = et : He = !0,
                v(Fe, R[et], O, null, Y, X, ee, T, M),
                fe++)
            }
            const Ge = He ? Aw(Te) : ao;
            for (Ae = Ge.length - 1,
            U = ge - 1; U >= 0; U--) {
                const Fe = le + U
                  , et = R[Fe]
                  , V = Fe + 1 < K ? R[Fe + 1].el : B;
                Te[U] === 0 ? v(null, et, O, V, Y, X, ee, T, M) : He && (Ae < 0 || U !== Ge[Ae] ? te(et, O, V, 2) : Ae--)
            }
        }
    }
      , te = (A, R, O, B, Y=null) => {
        const {el: X, type: ee, transition: T, children: M, shapeFlag: U} = A;
        if (U & 6) {
            te(A.component.subTree, R, O, B);
            return
        }
        if (U & 128) {
            A.suspense.move(R, O, B);
            return
        }
        if (U & 64) {
            ee.move(A, R, O, he);
            return
        }
        if (ee === mn) {
            i(X, R, O);
            for (let H = 0; H < M.length; H++)
                te(M[H], R, O, B);
            i(A.anchor, R, O);
            return
        }
        if (ee === lf) {
            _(A, R, O);
            return
        }
        if (B !== 2 && U & 1 && T)
            if (B === 0)
                T.beforeEnter(X),
                i(X, R, O),
                Yt( () => T.enter(X), Y);
            else {
                const {leave: H, delayLeave: j, afterLeave: de} = T
                  , le = () => i(X, R, O)
                  , me = () => {
                    H(X, () => {
                        le(),
                        de && de()
                    }
                    )
                }
                ;
                j ? j(X, le, me) : me()
            }
        else
            i(X, R, O)
    }
      , Se = (A, R, O, B=!1, Y=!1) => {
        const {type: X, props: ee, ref: T, children: M, dynamicChildren: U, shapeFlag: K, patchFlag: H, dirs: j, cacheIndex: de} = A;
        if (H === -2 && (Y = !1),
        T != null && dd(T, null, O, A, !0),
        de != null && (R.renderCache[de] = void 0),
        K & 256) {
            R.ctx.deactivate(A);
            return
        }
        const le = K & 1 && j
          , me = !ls(A);
        let Ae;
        if (me && (Ae = ee && ee.onVnodeBeforeUnmount) && kn(Ae, R, A),
        K & 6)
            pe(A.component, O, B);
        else {
            if (K & 128) {
                A.suspense.unmount(O, B);
                return
            }
            le && Nr(A, null, R, "beforeUnmount"),
            K & 64 ? A.type.remove(A, R, O, he, B) : U && !U.hasOnce && (X !== mn || H > 0 && H & 64) ? Me(U, R, O, !1, !0) : (X === mn && H & 384 || !Y && K & 16) && Me(M, R, O),
            B && ze(A)
        }
        (me && (Ae = ee && ee.onVnodeUnmounted) || le) && Yt( () => {
            Ae && kn(Ae, R, A),
            le && Nr(A, null, R, "unmounted")
        }
        , O)
    }
      , ze = A => {
        const {type: R, el: O, anchor: B, transition: Y} = A;
        if (R === mn) {
            re(O, B);
            return
        }
        if (R === lf) {
            x(A);
            return
        }
        const X = () => {
            r(O),
            Y && !Y.persisted && Y.afterLeave && Y.afterLeave()
        }
        ;
        if (A.shapeFlag & 1 && Y && !Y.persisted) {
            const {leave: ee, delayLeave: T} = Y
              , M = () => ee(O, X);
            T ? T(A.el, X, M) : M()
        } else
            X()
    }
      , re = (A, R) => {
        let O;
        for (; A !== R; )
            O = f(A),
            r(A),
            A = O;
        r(R)
    }
      , pe = (A, R, O) => {
        const {bum: B, scope: Y, job: X, subTree: ee, um: T, m: M, a: U} = A;
        Jc(M),
        Jc(U),
        B && co(B),
        Y.stop(),
        X && (X.flags |= 8,
        Se(ee, A, R, O)),
        T && Yt(T, R),
        Yt( () => {
            A.isUnmounted = !0
        }
        , R),
        R && R.pendingBranch && !R.isUnmounted && A.asyncDep && !A.asyncResolved && A.suspenseId === R.pendingId && (R.deps--,
        R.deps === 0 && R.resolve())
    }
      , Me = (A, R, O, B=!1, Y=!1, X=0) => {
        for (let ee = X; ee < A.length; ee++)
            Se(A[ee], R, O, B, Y)
    }
      , k = A => {
        if (A.shapeFlag & 6)
            return k(A.component.subTree);
        if (A.shapeFlag & 128)
            return A.suspense.next();
        const R = f(A.anchor || A.el)
          , O = R && R[$0];
        return O ? f(O) : R
    }
    ;
    let se = !1;
    const oe = (A, R, O) => {
        A == null ? R._vnode && Se(R._vnode, null, null, !0) : v(R._vnode || null, A, R, null, null, null, O),
        R._vnode = A,
        se || (se = !0,
        Fm(),
        W0(),
        se = !1)
    }
      , he = {
        p: v,
        um: Se,
        m: te,
        r: ze,
        mt: $,
        mc: L,
        pc: Z,
        pbc: b,
        n: k,
        o: n
    };
    let Re, I;
    return {
        render: oe,
        hydrate: Re,
        createApp: vw(oe, Re)
    }
}
function of({type: n, props: e}, t) {
    return t === "svg" && n === "foreignObject" || t === "mathml" && n === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : t
}
function Ur({effect: n, job: e}, t) {
    t ? (n.flags |= 32,
    e.flags |= 4) : (n.flags &= -33,
    e.flags &= -5)
}
function Ew(n, e) {
    return (!n || n && !n.pendingBranch) && e && !e.persisted
}
function vp(n, e, t=!1) {
    const i = n.children
      , r = e.children;
    if (Oe(i) && Oe(r))
        for (let s = 0; s < i.length; s++) {
            const o = i[s];
            let a = r[s];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = r[s] = mr(r[s]),
            a.el = o.el),
            !t && a.patchFlag !== -2 && vp(o, a)),
            a.type === eh && (a.el = o.el)
        }
}
function Aw(n) {
    const e = n.slice()
      , t = [0];
    let i, r, s, o, a;
    const l = n.length;
    for (i = 0; i < l; i++) {
        const c = n[i];
        if (c !== 0) {
            if (r = t[t.length - 1],
            n[r] < c) {
                e[i] = r,
                t.push(i);
                continue
            }
            for (s = 0,
            o = t.length - 1; s < o; )
                a = s + o >> 1,
                n[t[a]] < c ? s = a + 1 : o = a;
            c < n[t[s]] && (s > 0 && (e[i] = t[s - 1]),
            t[s] = i)
        }
    }
    for (s = t.length,
    o = t[s - 1]; s-- > 0; )
        t[s] = o,
        o = e[o];
    return t
}
function xy(n) {
    const e = n.subTree.component;
    if (e)
        return e.asyncDep && !e.asyncResolved ? e : xy(e)
}
function Jc(n) {
    if (n)
        for (let e = 0; e < n.length; e++)
            n[e].flags |= 8
}
const Tw = Symbol.for("v-scx")
  , Cw = () => ni(Tw);
function Ju(n, e) {
    return _p(n, null, e)
}
function Bt(n, e, t) {
    return _p(n, e, t)
}
function _p(n, e, t=yt) {
    const {immediate: i, deep: r, flush: s, once: o} = t
      , a = Wt({}, t);
    let l;
    if (th)
        if (s === "sync") {
            const f = Cw();
            l = f.__watcherHandles || (f.__watcherHandles = [])
        } else if (!e || i)
            a.once = !0;
        else {
            const f = () => {}
            ;
            return f.stop = ei,
            f.resume = ei,
            f.pause = ei,
            f
        }
    const c = Qt;
    a.call = (f, d, p) => ri(f, c, d, p);
    let u = !1;
    s === "post" ? a.scheduler = f => {
        Yt(f, c && c.suspense)
    }
    : s !== "sync" && (u = !0,
    a.scheduler = (f, d) => {
        d ? f() : hp(f)
    }
    ),
    a.augmentJob = f => {
        e && (f.flags |= 4),
        u && (f.flags |= 2,
        c && (f.id = c.uid,
        f.i = c))
    }
    ;
    const h = kS(n, e, a);
    return l && l.push(h),
    h
}
function Rw(n, e, t) {
    const i = this.proxy
      , r = wt(n) ? n.includes(".") ? by(i, n) : () => i[n] : n.bind(i, i);
    let s;
    qe(e) ? s = e : (s = e.handler,
    t = e);
    const o = dl(this)
      , a = _p(r, s.bind(i), t);
    return o(),
    a
}
function by(n, e) {
    const t = e.split(".");
    return () => {
        let i = n;
        for (let r = 0; r < t.length && i; r++)
            i = i[t[r]];
        return i
    }
}
const Pw = (n, e) => e === "modelValue" || e === "model-value" ? n.modelModifiers : n[`${e}Modifiers`] || n[`${ii(e)}Modifiers`] || n[`${Tr(e)}Modifiers`];
function Iw(n, e, ...t) {
    if (n.isUnmounted)
        return;
    const i = n.vnode.props || yt;
    let r = t;
    const s = e.startsWith("update:")
      , o = s && Pw(i, e.slice(7));
    o && (o.trim && (r = t.map(u => wt(u) ? u.trim() : u)),
    o.number && (r = t.map(KM)));
    let a, l = i[a = Zh(e)] || i[a = Zh(ii(e))];
    !l && s && (l = i[a = Zh(Tr(e))]),
    l && ri(l, n, 6, r);
    const c = i[a + "Once"];
    if (c) {
        if (!n.emitted)
            n.emitted = {};
        else if (n.emitted[a])
            return;
        n.emitted[a] = !0,
        ri(c, n, 6, r)
    }
}
function My(n, e, t=!1) {
    const i = e.emitsCache
      , r = i.get(n);
    if (r !== void 0)
        return r;
    const s = n.emits;
    let o = {}
      , a = !1;
    if (!qe(n)) {
        const l = c => {
            const u = My(c, e, !0);
            u && (a = !0,
            Wt(o, u))
        }
        ;
        !t && e.mixins.length && e.mixins.forEach(l),
        n.extends && l(n.extends),
        n.mixins && n.mixins.forEach(l)
    }
    return !s && !a ? (mt(n) && i.set(n, null),
    null) : (Oe(s) ? s.forEach(l => o[l] = null) : Wt(o, s),
    mt(n) && i.set(n, o),
    o)
}
function Qu(n, e) {
    return !n || !zu(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""),
    ht(n, e[0].toLowerCase() + e.slice(1)) || ht(n, Tr(e)) || ht(n, e))
}
function af(n) {
    const {type: e, vnode: t, proxy: i, withProxy: r, propsOptions: [s], slots: o, attrs: a, emit: l, render: c, renderCache: u, props: h, data: f, setupState: d, ctx: p, inheritAttrs: v} = n
      , g = Kc(n);
    let m, y;
    try {
        if (t.shapeFlag & 4) {
            const x = r || i
              , C = x;
            m = di(c.call(C, x, u, h, d, f, p)),
            y = a
        } else {
            const x = e;
            m = di(x.length > 1 ? x(h, {
                attrs: a,
                slots: o,
                emit: l
            }) : x(h, null)),
            y = e.props ? a : Lw(a)
        }
    } catch (x) {
        da.length = 0,
        ju(x, n, 1),
        m = on(sn)
    }
    let _ = m;
    if (y && v !== !1) {
        const x = Object.keys(y)
          , {shapeFlag: C} = _;
        x.length && C & 7 && (s && x.some(Qd) && (y = Dw(y, s)),
        _ = Gi(_, y, !1, !0))
    }
    return t.dirs && (_ = Gi(_, null, !1, !0),
    _.dirs = _.dirs ? _.dirs.concat(t.dirs) : t.dirs),
    t.transition && Sr(_, t.transition),
    m = _,
    Kc(g),
    m
}
const Lw = n => {
    let e;
    for (const t in n)
        (t === "class" || t === "style" || zu(t)) && ((e || (e = {}))[t] = n[t]);
    return e
}
  , Dw = (n, e) => {
    const t = {};
    for (const i in n)
        (!Qd(i) || !(i.slice(9)in e)) && (t[i] = n[i]);
    return t
}
;
function Nw(n, e, t) {
    const {props: i, children: r, component: s} = n
      , {props: o, children: a, patchFlag: l} = e
      , c = s.emitsOptions;
    if (e.dirs || e.transition)
        return !0;
    if (t && l >= 0) {
        if (l & 1024)
            return !0;
        if (l & 16)
            return i ? $m(i, o, c) : !!o;
        if (l & 8) {
            const u = e.dynamicProps;
            for (let h = 0; h < u.length; h++) {
                const f = u[h];
                if (o[f] !== i[f] && !Qu(c, f))
                    return !0
            }
        }
    } else
        return (r || a) && (!a || !a.$stable) ? !0 : i === o ? !1 : i ? o ? $m(i, o, c) : !0 : !!o;
    return !1
}
function $m(n, e, t) {
    const i = Object.keys(e);
    if (i.length !== Object.keys(n).length)
        return !0;
    for (let r = 0; r < i.length; r++) {
        const s = i[r];
        if (e[s] !== n[s] && !Qu(t, s))
            return !0
    }
    return !1
}
function Uw({vnode: n, parent: e}, t) {
    for (; e; ) {
        const i = e.subTree;
        if (i.suspense && i.suspense.activeBranch === n && (i.el = n.el),
        i === n)
            (n = e.vnode).el = t,
            e = e.parent;
        else
            break
    }
}
const Qc = n => n.__isSuspense;
function Ow(n, e) {
    e && e.pendingBranch ? Oe(n) ? e.effects.push(...n) : e.effects.push(n) : GS(n)
}
const mn = Symbol.for("v-fgt")
  , eh = Symbol.for("v-txt")
  , sn = Symbol.for("v-cmt")
  , lf = Symbol.for("v-stc")
  , da = [];
let Ln = null;
function br(n=!1) {
    da.push(Ln = n ? null : [])
}
function Fw() {
    da.pop(),
    Ln = da[da.length - 1] || null
}
let Oa = 1;
function Ym(n) {
    Oa += n,
    n < 0 && Ln && (Ln.hasOnce = !0)
}
function Sy(n) {
    return n.dynamicChildren = Oa > 0 ? Ln || ao : null,
    Fw(),
    Oa > 0 && Ln && Ln.push(n),
    n
}
function wy(n, e, t, i, r, s) {
    return Sy(Ay(n, e, t, i, r, s, !0))
}
function po(n, e, t, i, r) {
    return Sy(on(n, e, t, i, r, !0))
}
function Fa(n) {
    return n ? n.__v_isVNode === !0 : !1
}
function _r(n, e) {
    return n.type === e.type && n.key === e.key
}
const Ey = ({key: n}) => n ?? null
  , zc = ({ref: n, ref_key: e, ref_for: t}) => (typeof n == "number" && (n = "" + n),
n != null ? wt(n) || Ft(n) || qe(n) ? {
    i: jt,
    r: n,
    k: e,
    f: !!t
} : n : null);
function Ay(n, e=null, t=null, i=0, r=null, s=n === mn ? 0 : 1, o=!1, a=!1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: n,
        props: e,
        key: e && Ey(e),
        ref: e && zc(e),
        scopeId: q0,
        slotScopeIds: null,
        children: t,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: i,
        dynamicProps: r,
        dynamicChildren: null,
        appContext: null,
        ctx: jt
    };
    return a ? (yp(l, t),
    s & 128 && n.normalize(l)) : t && (l.shapeFlag |= wt(t) ? 8 : 16),
    Oa > 0 && !o && Ln && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && Ln.push(l),
    l
}
const on = Bw;
function Bw(n, e=null, t=null, i=0, r=null, s=!1) {
    if ((!n || n === ry) && (n = sn),
    Fa(n)) {
        const a = Gi(n, e, !0);
        return t && yp(a, t),
        Oa > 0 && !s && Ln && (a.shapeFlag & 6 ? Ln[Ln.indexOf(n)] = a : Ln.push(a)),
        a.patchFlag = -2,
        a
    }
    if (Yw(n) && (n = n.__vccOpts),
    e) {
        e = zw(e);
        let {class: a, style: l} = e;
        a && !wt(a) && (e.class = Wu(a)),
        mt(l) && (lp(l) && !Oe(l) && (l = Wt({}, l)),
        e.style = Gu(l))
    }
    const o = wt(n) ? 1 : Qc(n) ? 128 : Y0(n) ? 64 : mt(n) ? 4 : qe(n) ? 2 : 0;
    return Ay(n, e, t, i, r, o, s, !0)
}
function zw(n) {
    return n ? lp(n) || fy(n) ? Wt({}, n) : n : null
}
function Gi(n, e, t=!1, i=!1) {
    const {props: r, ref: s, patchFlag: o, children: a, transition: l} = n
      , c = e ? Vw(r || {}, e) : r
      , u = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: n.type,
        props: c,
        key: c && Ey(c),
        ref: e && e.ref ? t && s ? Oe(s) ? s.concat(zc(e)) : [s, zc(e)] : zc(e) : s,
        scopeId: n.scopeId,
        slotScopeIds: n.slotScopeIds,
        children: a,
        target: n.target,
        targetStart: n.targetStart,
        targetAnchor: n.targetAnchor,
        staticCount: n.staticCount,
        shapeFlag: n.shapeFlag,
        patchFlag: e && n.type !== mn ? o === -1 ? 16 : o | 16 : o,
        dynamicProps: n.dynamicProps,
        dynamicChildren: n.dynamicChildren,
        appContext: n.appContext,
        dirs: n.dirs,
        transition: l,
        component: n.component,
        suspense: n.suspense,
        ssContent: n.ssContent && Gi(n.ssContent),
        ssFallback: n.ssFallback && Gi(n.ssFallback),
        el: n.el,
        anchor: n.anchor,
        ctx: n.ctx,
        ce: n.ce
    };
    return l && i && Sr(u, l.clone(u)),
    u
}
function kw(n=" ", e=0) {
    return on(eh, null, n, e)
}
function oF(n="", e=!1) {
    return e ? (br(),
    po(sn, null, n)) : on(sn, null, n)
}
function di(n) {
    return n == null || typeof n == "boolean" ? on(sn) : Oe(n) ? on(mn, null, n.slice()) : typeof n == "object" ? mr(n) : on(eh, null, String(n))
}
function mr(n) {
    return n.el === null && n.patchFlag !== -1 || n.memo ? n : Gi(n)
}
function yp(n, e) {
    let t = 0;
    const {shapeFlag: i} = n;
    if (e == null)
        e = null;
    else if (Oe(e))
        t = 16;
    else if (typeof e == "object")
        if (i & 65) {
            const r = e.default;
            r && (r._c && (r._d = !1),
            yp(n, r()),
            r._c && (r._d = !0));
            return
        } else {
            t = 32;
            const r = e._;
            !r && !fy(e) ? e._ctx = jt : r === 3 && jt && (jt.slots._ === 1 ? e._ = 1 : (e._ = 2,
            n.patchFlag |= 1024))
        }
    else
        qe(e) ? (e = {
            default: e,
            _ctx: jt
        },
        t = 32) : (e = String(e),
        i & 64 ? (t = 16,
        e = [kw(e)]) : t = 8);
    n.children = e,
    n.shapeFlag |= t
}
function Vw(...n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = n[t];
        for (const r in i)
            if (r === "class")
                e.class !== i.class && (e.class = Wu([e.class, i.class]));
            else if (r === "style")
                e.style = Gu([e.style, i.style]);
            else if (zu(r)) {
                const s = e[r]
                  , o = i[r];
                o && s !== o && !(Oe(s) && s.includes(o)) && (e[r] = s ? [].concat(s, o) : o)
            } else
                r !== "" && (e[r] = i[r])
    }
    return e
}
function kn(n, e, t, i=null) {
    ri(n, e, 7, [t, i])
}
const Hw = cy();
let Gw = 0;
function Ww(n, e, t) {
    const i = n.type
      , r = (e ? e.appContext : n.appContext) || Hw
      , s = {
        uid: Gw++,
        vnode: n,
        type: i,
        parent: e,
        appContext: r,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        job: null,
        scope: new b0(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: e ? e.provides : Object.create(r.provides),
        ids: e ? e.ids : ["", 0, 0],
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: py(i, r),
        emitsOptions: My(i, r),
        emit: null,
        emitted: null,
        propsDefaults: yt,
        inheritAttrs: i.inheritAttrs,
        ctx: yt,
        data: yt,
        props: yt,
        attrs: yt,
        slots: yt,
        refs: yt,
        setupState: yt,
        setupContext: null,
        suspense: t,
        suspenseId: t ? t.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return s.ctx = {
        _: s
    },
    s.root = e ? e.root : s,
    s.emit = Iw.bind(null, s),
    n.ce && n.ce(s),
    s
}
let Qt = null;
const wr = () => Qt || jt;
let eu, _d;
{
    const n = g0()
      , e = (t, i) => {
        let r;
        return (r = n[t]) || (r = n[t] = []),
        r.push(i),
        s => {
            r.length > 1 ? r.forEach(o => o(s)) : r[0](s)
        }
    }
    ;
    eu = e("__VUE_INSTANCE_SETTERS__", t => Qt = t),
    _d = e("__VUE_SSR_SETTERS__", t => th = t)
}
const dl = n => {
    const e = Qt;
    return eu(n),
    n.scope.on(),
    () => {
        n.scope.off(),
        eu(e)
    }
}
  , jm = () => {
    Qt && Qt.scope.off(),
    eu(null)
}
;
function Ty(n) {
    return n.vnode.shapeFlag & 4
}
let th = !1;
function Xw(n, e=!1, t=!1) {
    e && _d(e);
    const {props: i, children: r} = n.vnode
      , s = Ty(n);
    _w(n, i, s, e),
    Mw(n, r, t);
    const o = s ? qw(n, e) : void 0;
    return e && _d(!1),
    o
}
function qw(n, e) {
    const t = n.type;
    n.accessCache = Object.create(null),
    n.proxy = new Proxy(n.ctx,cw);
    const {setup: i} = t;
    if (i) {
        const r = n.setupContext = i.length > 1 ? Ry(n) : null
          , s = dl(n);
        Cr();
        const o = fl(i, n, 0, [n.props, r]);
        if (Rr(),
        s(),
        f0(o)) {
            if (ls(n) || ty(n),
            o.then(jm, jm),
            e)
                return o.then(a => {
                    Km(n, a, e)
                }
                ).catch(a => {
                    ju(a, n, 0)
                }
                );
            n.asyncDep = o
        } else
            Km(n, o, e)
    } else
        Cy(n, e)
}
function Km(n, e, t) {
    qe(e) ? n.type.__ssrInlineRender ? n.ssrRender = e : n.render = e : mt(e) && (n.setupState = k0(e)),
    Cy(n, t)
}
let Zm;
function Cy(n, e, t) {
    const i = n.type;
    if (!n.render) {
        if (!e && Zm && !i.render) {
            const r = i.template || mp(n).template;
            if (r) {
                const {isCustomElement: s, compilerOptions: o} = n.appContext.config
                  , {delimiters: a, compilerOptions: l} = i
                  , c = Wt(Wt({
                    isCustomElement: s,
                    delimiters: a
                }, o), l);
                i.render = Zm(r, c)
            }
        }
        n.render = i.render || ei
    }
    {
        const r = dl(n);
        Cr();
        try {
            hw(n)
        } finally {
            Rr(),
            r()
        }
    }
}
const $w = {
    get(n, e) {
        return ln(n, "get", ""),
        n[e]
    }
};
function Ry(n) {
    const e = t => {
        n.exposed = t || {}
    }
    ;
    return {
        attrs: new Proxy(n.attrs,$w),
        slots: n.slots,
        emit: n.emit,
        expose: e
    }
}
function nh(n) {
    return n.exposed ? n.exposeProxy || (n.exposeProxy = new Proxy(k0(B0(n.exposed)),{
        get(e, t) {
            if (t in e)
                return e[t];
            if (t in fa)
                return fa[t](n)
        },
        has(e, t) {
            return t in e || t in fa
        }
    })) : n.proxy
}
function yd(n, e=!0) {
    return qe(n) ? n.displayName || n.name : n.name || e && n.__name
}
function Yw(n) {
    return qe(n) && "__vccOpts"in n
}
const Lt = (n, e) => BS(n, e, th);
function gs(n, e, t) {
    const i = arguments.length;
    return i === 2 ? mt(e) && !Oe(e) ? Fa(e) ? on(n, null, [e]) : on(n, e) : on(n, null, e) : (i > 3 ? t = Array.prototype.slice.call(arguments, 2) : i === 3 && Fa(t) && (t = [t]),
    on(n, e, t))
}
const jw = "3.5.8"
  , aF = ei;
/**
* @vue/runtime-dom v3.5.8
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let xd;
const Jm = typeof window < "u" && window.trustedTypes;
if (Jm)
    try {
        xd = Jm.createPolicy("vue", {
            createHTML: n => n
        })
    } catch {}
const Py = xd ? n => xd.createHTML(n) : n => n
  , Kw = "http://www.w3.org/2000/svg"
  , Zw = "http://www.w3.org/1998/Math/MathML"
  , Ui = typeof document < "u" ? document : null
  , Qm = Ui && Ui.createElement("template")
  , Jw = {
    insert: (n, e, t) => {
        e.insertBefore(n, t || null)
    }
    ,
    remove: n => {
        const e = n.parentNode;
        e && e.removeChild(n)
    }
    ,
    createElement: (n, e, t, i) => {
        const r = e === "svg" ? Ui.createElementNS(Kw, n) : e === "mathml" ? Ui.createElementNS(Zw, n) : t ? Ui.createElement(n, {
            is: t
        }) : Ui.createElement(n);
        return n === "select" && i && i.multiple != null && r.setAttribute("multiple", i.multiple),
        r
    }
    ,
    createText: n => Ui.createTextNode(n),
    createComment: n => Ui.createComment(n),
    setText: (n, e) => {
        n.nodeValue = e
    }
    ,
    setElementText: (n, e) => {
        n.textContent = e
    }
    ,
    parentNode: n => n.parentNode,
    nextSibling: n => n.nextSibling,
    querySelector: n => Ui.querySelector(n),
    setScopeId(n, e) {
        n.setAttribute(e, "")
    },
    insertStaticContent(n, e, t, i, r, s) {
        const o = t ? t.previousSibling : e.lastChild;
        if (r && (r === s || r.nextSibling))
            for (; e.insertBefore(r.cloneNode(!0), t),
            !(r === s || !(r = r.nextSibling)); )
                ;
        else {
            Qm.innerHTML = Py(i === "svg" ? `<svg>${n}</svg>` : i === "mathml" ? `<math>${n}</math>` : n);
            const a = Qm.content;
            if (i === "svg" || i === "mathml") {
                const l = a.firstChild;
                for (; l.firstChild; )
                    a.appendChild(l.firstChild);
                a.removeChild(l)
            }
            e.insertBefore(a, t)
        }
        return [o ? o.nextSibling : e.firstChild, t ? t.previousSibling : e.lastChild]
    }
}
  , nr = "transition"
  , zo = "animation"
  , xo = Symbol("_vtc")
  , Iy = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
}
  , Ly = Wt({}, Z0, Iy)
  , Qw = n => (n.displayName = "Transition",
n.props = Ly,
n)
  , eE = Qw( (n, {slots: e}) => gs(YS, Dy(n), e))
  , Or = (n, e=[]) => {
    Oe(n) ? n.forEach(t => t(...e)) : n && n(...e)
}
  , eg = n => n ? Oe(n) ? n.some(e => e.length > 1) : n.length > 1 : !1;
function Dy(n) {
    const e = {};
    for (const F in n)
        F in Iy || (e[F] = n[F]);
    if (n.css === !1)
        return e;
    const {name: t="v", type: i, duration: r, enterFromClass: s=`${t}-enter-from`, enterActiveClass: o=`${t}-enter-active`, enterToClass: a=`${t}-enter-to`, appearFromClass: l=s, appearActiveClass: c=o, appearToClass: u=a, leaveFromClass: h=`${t}-leave-from`, leaveActiveClass: f=`${t}-leave-active`, leaveToClass: d=`${t}-leave-to`} = n
      , p = tE(r)
      , v = p && p[0]
      , g = p && p[1]
      , {onBeforeEnter: m, onEnter: y, onEnterCancelled: _, onLeave: x, onLeaveCancelled: C, onBeforeAppear: w=m, onAppear: E=y, onAppearCancelled: L=_} = e
      , S = (F, z, $) => {
        fr(F, z ? u : a),
        fr(F, z ? c : o),
        $ && $()
    }
      , b = (F, z) => {
        F._isLeaving = !1,
        fr(F, h),
        fr(F, d),
        fr(F, f),
        z && z()
    }
      , D = F => (z, $) => {
        const ne = F ? E : y
          , W = () => S(z, F, $);
        Or(ne, [z, W]),
        tg( () => {
            fr(z, F ? l : s),
            Ni(z, F ? u : a),
            eg(ne) || ng(z, i, v, W)
        }
        )
    }
    ;
    return Wt(e, {
        onBeforeEnter(F) {
            Or(m, [F]),
            Ni(F, s),
            Ni(F, o)
        },
        onBeforeAppear(F) {
            Or(w, [F]),
            Ni(F, l),
            Ni(F, c)
        },
        onEnter: D(!1),
        onAppear: D(!0),
        onLeave(F, z) {
            F._isLeaving = !0;
            const $ = () => b(F, z);
            Ni(F, h),
            Ni(F, f),
            Uy(),
            tg( () => {
                F._isLeaving && (fr(F, h),
                Ni(F, d),
                eg(x) || ng(F, i, g, $))
            }
            ),
            Or(x, [F, $])
        },
        onEnterCancelled(F) {
            S(F, !1),
            Or(_, [F])
        },
        onAppearCancelled(F) {
            S(F, !0),
            Or(L, [F])
        },
        onLeaveCancelled(F) {
            b(F),
            Or(C, [F])
        }
    })
}
function tE(n) {
    if (n == null)
        return null;
    if (mt(n))
        return [cf(n.enter), cf(n.leave)];
    {
        const e = cf(n);
        return [e, e]
    }
}
function cf(n) {
    return ZM(n)
}
function Ni(n, e) {
    e.split(/\s+/).forEach(t => t && n.classList.add(t)),
    (n[xo] || (n[xo] = new Set)).add(e)
}
function fr(n, e) {
    e.split(/\s+/).forEach(i => i && n.classList.remove(i));
    const t = n[xo];
    t && (t.delete(e),
    t.size || (n[xo] = void 0))
}
function tg(n) {
    requestAnimationFrame( () => {
        requestAnimationFrame(n)
    }
    )
}
let nE = 0;
function ng(n, e, t, i) {
    const r = n._endId = ++nE
      , s = () => {
        r === n._endId && i()
    }
    ;
    if (t != null)
        return setTimeout(s, t);
    const {type: o, timeout: a, propCount: l} = Ny(n, e);
    if (!o)
        return i();
    const c = o + "end";
    let u = 0;
    const h = () => {
        n.removeEventListener(c, f),
        s()
    }
      , f = d => {
        d.target === n && ++u >= l && h()
    }
    ;
    setTimeout( () => {
        u < l && h()
    }
    , a + 1),
    n.addEventListener(c, f)
}
function Ny(n, e) {
    const t = window.getComputedStyle(n)
      , i = p => (t[p] || "").split(", ")
      , r = i(`${nr}Delay`)
      , s = i(`${nr}Duration`)
      , o = ig(r, s)
      , a = i(`${zo}Delay`)
      , l = i(`${zo}Duration`)
      , c = ig(a, l);
    let u = null
      , h = 0
      , f = 0;
    e === nr ? o > 0 && (u = nr,
    h = o,
    f = s.length) : e === zo ? c > 0 && (u = zo,
    h = c,
    f = l.length) : (h = Math.max(o, c),
    u = h > 0 ? o > c ? nr : zo : null,
    f = u ? u === nr ? s.length : l.length : 0);
    const d = u === nr && /\b(transform|all)(,|$)/.test(i(`${nr}Property`).toString());
    return {
        type: u,
        timeout: h,
        propCount: f,
        hasTransform: d
    }
}
function ig(n, e) {
    for (; n.length < e.length; )
        n = n.concat(n);
    return Math.max(...e.map( (t, i) => rg(t) + rg(n[i])))
}
function rg(n) {
    return n === "auto" ? 0 : Number(n.slice(0, -1).replace(",", ".")) * 1e3
}
function Uy() {
    return document.body.offsetHeight
}
function iE(n, e, t) {
    const i = n[xo];
    i && (e = (e ? [e, ...i] : [...i]).join(" ")),
    e == null ? n.removeAttribute("class") : t ? n.setAttribute("class", e) : n.className = e
}
const tu = Symbol("_vod")
  , Oy = Symbol("_vsh")
  , lF = {
    beforeMount(n, {value: e}, {transition: t}) {
        n[tu] = n.style.display === "none" ? "" : n.style.display,
        t && e ? t.beforeEnter(n) : ko(n, e)
    },
    mounted(n, {value: e}, {transition: t}) {
        t && e && t.enter(n)
    },
    updated(n, {value: e, oldValue: t}, {transition: i}) {
        !e != !t && (i ? e ? (i.beforeEnter(n),
        ko(n, !0),
        i.enter(n)) : i.leave(n, () => {
            ko(n, !1)
        }
        ) : ko(n, e))
    },
    beforeUnmount(n, {value: e}) {
        ko(n, e)
    }
};
function ko(n, e) {
    n.style.display = e ? n[tu] : "none",
    n[Oy] = !e
}
const rE = Symbol("")
  , sE = /(^|;)\s*display\s*:/;
function oE(n, e, t) {
    const i = n.style
      , r = wt(t);
    let s = !1;
    if (t && !r) {
        if (e)
            if (wt(e))
                for (const o of e.split(";")) {
                    const a = o.slice(0, o.indexOf(":")).trim();
                    t[a] == null && kc(i, a, "")
                }
            else
                for (const o in e)
                    t[o] == null && kc(i, o, "");
        for (const o in t)
            o === "display" && (s = !0),
            kc(i, o, t[o])
    } else if (r) {
        if (e !== t) {
            const o = i[rE];
            o && (t += ";" + o),
            i.cssText = t,
            s = sE.test(t)
        }
    } else
        e && n.removeAttribute("style");
    tu in n && (n[tu] = s ? i.display : "",
    n[Oy] && (i.display = "none"))
}
const sg = /\s*!important$/;
function kc(n, e, t) {
    if (Oe(t))
        t.forEach(i => kc(n, e, i));
    else if (t == null && (t = ""),
    e.startsWith("--"))
        n.setProperty(e, t);
    else {
        const i = aE(n, e);
        sg.test(t) ? n.setProperty(Tr(i), t.replace(sg, ""), "important") : n[i] = t
    }
}
const og = ["Webkit", "Moz", "ms"]
  , uf = {};
function aE(n, e) {
    const t = uf[e];
    if (t)
        return t;
    let i = ii(e);
    if (i !== "filter" && i in n)
        return uf[e] = i;
    i = Hu(i);
    for (let r = 0; r < og.length; r++) {
        const s = og[r] + i;
        if (s in n)
            return uf[e] = s
    }
    return e
}
const ag = "http://www.w3.org/1999/xlink";
function lg(n, e, t, i, r, s=iS(e)) {
    i && e.startsWith("xlink:") ? t == null ? n.removeAttributeNS(ag, e.slice(6, e.length)) : n.setAttributeNS(ag, e, t) : t == null || s && !v0(t) ? n.removeAttribute(e) : n.setAttribute(e, s ? "" : xi(t) ? String(t) : t)
}
function lE(n, e, t, i) {
    if (e === "innerHTML" || e === "textContent") {
        t != null && (n[e] = e === "innerHTML" ? Py(t) : t);
        return
    }
    const r = n.tagName;
    if (e === "value" && r !== "PROGRESS" && !r.includes("-")) {
        const o = r === "OPTION" ? n.getAttribute("value") || "" : n.value
          , a = t == null ? n.type === "checkbox" ? "on" : "" : String(t);
        (o !== a || !("_value"in n)) && (n.value = a),
        t == null && n.removeAttribute(e),
        n._value = t;
        return
    }
    let s = !1;
    if (t === "" || t == null) {
        const o = typeof n[e];
        o === "boolean" ? t = v0(t) : t == null && o === "string" ? (t = "",
        s = !0) : o === "number" && (t = 0,
        s = !0)
    }
    try {
        n[e] = t
    } catch {}
    s && n.removeAttribute(e)
}
function Fy(n, e, t, i) {
    n.addEventListener(e, t, i)
}
function cE(n, e, t, i) {
    n.removeEventListener(e, t, i)
}
const cg = Symbol("_vei");
function uE(n, e, t, i, r=null) {
    const s = n[cg] || (n[cg] = {})
      , o = s[e];
    if (i && o)
        o.value = i;
    else {
        const [a,l] = hE(e);
        if (i) {
            const c = s[e] = pE(i, r);
            Fy(n, a, c, l)
        } else
            o && (cE(n, a, o, l),
            s[e] = void 0)
    }
}
const ug = /(?:Once|Passive|Capture)$/;
function hE(n) {
    let e;
    if (ug.test(n)) {
        e = {};
        let i;
        for (; i = n.match(ug); )
            n = n.slice(0, n.length - i[0].length),
            e[i[0].toLowerCase()] = !0
    }
    return [n[2] === ":" ? n.slice(3) : Tr(n.slice(2)), e]
}
let hf = 0;
const fE = Promise.resolve()
  , dE = () => hf || (fE.then( () => hf = 0),
hf = Date.now());
function pE(n, e) {
    const t = i => {
        if (!i._vts)
            i._vts = Date.now();
        else if (i._vts <= t.attached)
            return;
        ri(mE(i, t.value), e, 5, [i])
    }
    ;
    return t.value = n,
    t.attached = dE(),
    t
}
function mE(n, e) {
    if (Oe(e)) {
        const t = n.stopImmediatePropagation;
        return n.stopImmediatePropagation = () => {
            t.call(n),
            n._stopped = !0
        }
        ,
        e.map(i => r => !r._stopped && i && i(r))
    } else
        return e
}
const hg = n => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && n.charCodeAt(2) > 96 && n.charCodeAt(2) < 123
  , gE = (n, e, t, i, r, s) => {
    const o = r === "svg";
    e === "class" ? iE(n, i, o) : e === "style" ? oE(n, t, i) : zu(e) ? Qd(e) || uE(n, e, t, i, s) : (e[0] === "." ? (e = e.slice(1),
    !0) : e[0] === "^" ? (e = e.slice(1),
    !1) : vE(n, e, i, o)) ? (lE(n, e, i),
    !n.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && lg(n, e, i, o, s, e !== "value")) : (e === "true-value" ? n._trueValue = i : e === "false-value" && (n._falseValue = i),
    lg(n, e, i, o))
}
;
function vE(n, e, t, i) {
    if (i)
        return !!(e === "innerHTML" || e === "textContent" || e in n && hg(e) && qe(t));
    if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && n.tagName === "INPUT" || e === "type" && n.tagName === "TEXTAREA")
        return !1;
    if (e === "width" || e === "height") {
        const r = n.tagName;
        if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE")
            return !1
    }
    return hg(e) && wt(t) ? !1 : !!(e in n || n._isVueCE && (/[A-Z]/.test(e) || !wt(t)))
}
const By = new WeakMap
  , zy = new WeakMap
  , nu = Symbol("_moveCb")
  , fg = Symbol("_enterCb")
  , _E = n => (delete n.props.mode,
n)
  , yE = _E({
    name: "TransitionGroup",
    props: Wt({}, Ly, {
        tag: String,
        moveClass: String
    }),
    setup(n, {slots: e}) {
        const t = wr()
          , i = K0();
        let r, s;
        return dp( () => {
            if (!r.length)
                return;
            const o = n.moveClass || `${n.name || "v"}-move`;
            if (!SE(r[0].el, t.vnode.el, o))
                return;
            r.forEach(xE),
            r.forEach(bE);
            const a = r.filter(ME);
            Uy(),
            a.forEach(l => {
                const c = l.el
                  , u = c.style;
                Ni(c, o),
                u.transform = u.webkitTransform = u.transitionDuration = "";
                const h = c[nu] = f => {
                    f && f.target !== c || (!f || /transform$/.test(f.propertyName)) && (c.removeEventListener("transitionend", h),
                    c[nu] = null,
                    fr(c, o))
                }
                ;
                c.addEventListener("transitionend", h)
            }
            )
        }
        ),
        () => {
            const o = rt(n)
              , a = Dy(o);
            let l = o.tag || mn;
            if (r = [],
            s)
                for (let c = 0; c < s.length; c++) {
                    const u = s[c];
                    u.el && u.el instanceof Element && (r.push(u),
                    Sr(u, Na(u, a, i, t)),
                    By.set(u, u.el.getBoundingClientRect()))
                }
            s = e.default ? fp(e.default()) : [];
            for (let c = 0; c < s.length; c++) {
                const u = s[c];
                u.key != null && Sr(u, Na(u, a, i, t))
            }
            return on(l, null, s)
        }
    }
})
  , cF = yE;
function xE(n) {
    const e = n.el;
    e[nu] && e[nu](),
    e[fg] && e[fg]()
}
function bE(n) {
    zy.set(n, n.el.getBoundingClientRect())
}
function ME(n) {
    const e = By.get(n)
      , t = zy.get(n)
      , i = e.left - t.left
      , r = e.top - t.top;
    if (i || r) {
        const s = n.el.style;
        return s.transform = s.webkitTransform = `translate(${i}px,${r}px)`,
        s.transitionDuration = "0s",
        n
    }
}
function SE(n, e, t) {
    const i = n.cloneNode()
      , r = n[xo];
    r && r.forEach(a => {
        a.split(/\s+/).forEach(l => l && i.classList.remove(l))
    }
    ),
    t.split(/\s+/).forEach(a => a && i.classList.add(a)),
    i.style.display = "none";
    const s = e.nodeType === 1 ? e : e.parentNode;
    s.appendChild(i);
    const {hasTransform: o} = Ny(i);
    return s.removeChild(i),
    o
}
const dg = n => {
    const e = n.props["onUpdate:modelValue"] || !1;
    return Oe(e) ? t => co(e, t) : e
}
  , ff = Symbol("_assign")
  , uF = {
    deep: !0,
    created(n, e, t) {
        n[ff] = dg(t),
        Fy(n, "change", () => {
            const i = n._modelValue
              , r = wE(n)
              , s = n.checked
              , o = n[ff];
            if (Oe(i)) {
                const a = _0(i, r)
                  , l = a !== -1;
                if (s && !l)
                    o(i.concat(r));
                else if (!s && l) {
                    const c = [...i];
                    c.splice(a, 1),
                    o(c)
                }
            } else if (ku(i)) {
                const a = new Set(i);
                s ? a.add(r) : a.delete(r),
                o(a)
            } else
                o(ky(n, s))
        }
        )
    },
    mounted: pg,
    beforeUpdate(n, e, t) {
        n[ff] = dg(t),
        pg(n, e, t)
    }
};
function pg(n, {value: e, oldValue: t}, i) {
    n._modelValue = e;
    let r;
    Oe(e) ? r = _0(e, i.props.value) > -1 : ku(e) ? r = e.has(i.props.value) : r = Xu(e, ky(n, !0)),
    n.checked !== r && (n.checked = r)
}
function wE(n) {
    return "_value"in n ? n._value : n.value
}
function ky(n, e) {
    const t = e ? "_trueValue" : "_falseValue";
    return t in n ? n[t] : e
}
const EE = ["ctrl", "shift", "alt", "meta"]
  , AE = {
    stop: n => n.stopPropagation(),
    prevent: n => n.preventDefault(),
    self: n => n.target !== n.currentTarget,
    ctrl: n => !n.ctrlKey,
    shift: n => !n.shiftKey,
    alt: n => !n.altKey,
    meta: n => !n.metaKey,
    left: n => "button"in n && n.button !== 0,
    middle: n => "button"in n && n.button !== 1,
    right: n => "button"in n && n.button !== 2,
    exact: (n, e) => EE.some(t => n[`${t}Key`] && !e.includes(t))
}
  , hF = (n, e) => {
    const t = n._withMods || (n._withMods = {})
      , i = e.join(".");
    return t[i] || (t[i] = (r, ...s) => {
        for (let o = 0; o < e.length; o++) {
            const a = AE[e[o]];
            if (a && a(r, e))
                return
        }
        return n(r, ...s)
    }
    )
}
  , TE = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
}
  , fF = (n, e) => {
    const t = n._withKeys || (n._withKeys = {})
      , i = e.join(".");
    return t[i] || (t[i] = r => {
        if (!("key"in r))
            return;
        const s = Tr(r.key);
        if (e.some(o => o === s || TE[o] === s))
            return n(r)
    }
    )
}
  , CE = Wt({
    patchProp: gE
}, Jw);
let mg;
function Vy() {
    return mg || (mg = yy(CE))
}
const gg = (...n) => {
    Vy().render(...n)
}
  , RE = (...n) => {
    const e = Vy().createApp(...n)
      , {mount: t} = e;
    return e.mount = i => {
        const r = IE(i);
        if (!r)
            return;
        const s = e._component;
        !qe(s) && !s.render && !s.template && (s.template = r.innerHTML),
        r.nodeType === 1 && (r.textContent = "");
        const o = t(r, !1, PE(r));
        return r instanceof Element && (r.removeAttribute("v-cloak"),
        r.setAttribute("data-v-app", "")),
        o
    }
    ,
    e
}
;
function PE(n) {
    if (n instanceof SVGElement)
        return "svg";
    if (typeof MathMLElement == "function" && n instanceof MathMLElement)
        return "mathml"
}
function IE(n) {
    return wt(n) ? document.querySelector(n) : n
}
var LE = !1;
/*!
 * pinia v2.2.2
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */
const DE = Symbol();
var vg;
(function(n) {
    n.direct = "direct",
    n.patchObject = "patch object",
    n.patchFunction = "patch function"
}
)(vg || (vg = {}));
function NE() {
    const n = oS(!0)
      , e = n.run( () => Qe({}));
    let t = []
      , i = [];
    const r = B0({
        install(s) {
            r._a = s,
            s.provide(DE, r),
            s.config.globalProperties.$pinia = r,
            i.forEach(o => t.push(o)),
            i = []
        },
        use(s) {
            return !this._a && !LE ? i.push(s) : t.push(s),
            this
        },
        _p: t,
        _a: null,
        _e: n,
        _s: new Map,
        state: e
    });
    return r
}
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const pl = "168"
  , UE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , OE = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , Hy = 0
  , bd = 1
  , Gy = 2
  , FE = 3
  , BE = 0
  , xp = 1
  , bp = 2
  , fi = 3
  , Wi = 0
  , _n = 1
  , Zn = 2
  , Vi = 0
  , us = 1
  , Md = 2
  , Sd = 3
  , wd = 4
  , Wy = 5
  , yr = 100
  , Xy = 101
  , qy = 102
  , $y = 103
  , Yy = 104
  , jy = 200
  , Ky = 201
  , Zy = 202
  , Jy = 203
  , iu = 204
  , ru = 205
  , Qy = 206
  , ex = 207
  , tx = 208
  , nx = 209
  , ix = 210
  , rx = 211
  , sx = 212
  , ox = 213
  , ax = 214
  , lx = 0
  , cx = 1
  , ux = 2
  , Ba = 3
  , hx = 4
  , fx = 5
  , dx = 6
  , px = 7
  , ml = 0
  , mx = 1
  , gx = 2
  , vi = 0
  , vx = 1
  , _x = 2
  , yx = 3
  , ih = 4
  , xx = 5
  , bx = 6
  , Mx = 7
  , Ed = "attached"
  , Sx = "detached"
  , rh = 300
  , Xi = 301
  , Er = 302
  , za = 303
  , ka = 304
  , Lo = 306
  , Va = 1e3
  , Gn = 1001
  , Ha = 1002
  , Kt = 1003
  , Mp = 1004
  , zE = 1004
  , Qs = 1005
  , kE = 1005
  , Gt = 1006
  , pa = 1007
  , VE = 1007
  , pi = 1008
  , HE = 1008
  , bi = 1009
  , Sp = 1010
  , wp = 1011
  , bo = 1012
  , sh = 1013
  , qi = 1014
  , Mn = 1015
  , Do = 1016
  , oh = 1017
  , ah = 1018
  , vs = 1020
  , Ep = 35902
  , Ap = 1021
  , Tp = 1022
  , vn = 1023
  , Cp = 1024
  , Rp = 1025
  , hs = 1026
  , _s = 1027
  , lh = 1028
  , gl = 1029
  , Pp = 1030
  , ch = 1031
  , GE = 1032
  , uh = 1033
  , ma = 33776
  , ga = 33777
  , va = 33778
  , _a = 33779
  , su = 35840
  , ou = 35841
  , au = 35842
  , lu = 35843
  , cu = 36196
  , uu = 37492
  , hu = 37496
  , fu = 37808
  , du = 37809
  , pu = 37810
  , mu = 37811
  , gu = 37812
  , vu = 37813
  , _u = 37814
  , yu = 37815
  , xu = 37816
  , bu = 37817
  , Mu = 37818
  , Su = 37819
  , wu = 37820
  , Eu = 37821
  , ya = 36492
  , Au = 36494
  , Tu = 36495
  , Ip = 36283
  , Cu = 36284
  , Ru = 36285
  , Pu = 36286
  , wx = 2200
  , Ex = 2201
  , Ax = 2202
  , Ga = 2300
  , Iu = 2301
  , Vc = 2302
  , ns = 2400
  , is = 2401
  , Wa = 2402
  , hh = 2500
  , Lp = 2501
  , WE = 0
  , XE = 1
  , qE = 2
  , Tx = 3200
  , Cx = 3201
  , $E = 3202
  , YE = 3203
  , Pr = 0
  , Rx = 1
  , Fi = ""
  , Rn = "srgb"
  , Ki = "srgb-linear"
  , fh = "display-p3"
  , vl = "display-p3-linear"
  , Xa = "linear"
  , xt = "srgb"
  , qa = "rec709"
  , $a = "p3"
  , jE = 0
  , Kr = 7680
  , KE = 7681
  , ZE = 7682
  , JE = 7683
  , QE = 34055
  , eA = 34056
  , tA = 5386
  , nA = 512
  , iA = 513
  , rA = 514
  , sA = 515
  , oA = 516
  , aA = 517
  , lA = 518
  , Ad = 519
  , Px = 512
  , Ix = 513
  , Lx = 514
  , Dp = 515
  , Dx = 516
  , Nx = 517
  , Ux = 518
  , Ox = 519
  , Ya = 35044
  , cA = 35048
  , uA = 35040
  , hA = 35045
  , fA = 35049
  , dA = 35041
  , pA = 35046
  , mA = 35050
  , gA = 35042
  , vA = "100"
  , Td = "300 es"
  , mi = 2e3
  , ja = 2001;
class Si {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []),
        i[e].indexOf(t) === -1 && i[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const i = this._listeners;
        return i[e] !== void 0 && i[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const r = this._listeners[e];
        if (r !== void 0) {
            const s = r.indexOf(t);
            s !== -1 && r.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[e.type];
        if (i !== void 0) {
            e.target = this;
            const r = i.slice(0);
            for (let s = 0, o = r.length; s < o; s++)
                r[s].call(this, e);
            e.target = null
        }
    }
}
const en = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let _g = 1234567;
const fs = Math.PI / 180
  , Mo = 180 / Math.PI;
function Nn() {
    const n = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , i = Math.random() * 4294967295 | 0;
    return (en[n & 255] + en[n >> 8 & 255] + en[n >> 16 & 255] + en[n >> 24 & 255] + "-" + en[e & 255] + en[e >> 8 & 255] + "-" + en[e >> 16 & 15 | 64] + en[e >> 24 & 255] + "-" + en[t & 63 | 128] + en[t >> 8 & 255] + "-" + en[t >> 16 & 255] + en[t >> 24 & 255] + en[i & 255] + en[i >> 8 & 255] + en[i >> 16 & 255] + en[i >> 24 & 255]).toLowerCase()
}
function It(n, e, t) {
    return Math.max(e, Math.min(t, n))
}
function Np(n, e) {
    return (n % e + e) % e
}
function _A(n, e, t, i, r) {
    return i + (n - e) * (r - i) / (t - e)
}
function yA(n, e, t) {
    return n !== e ? (t - n) / (e - n) : 0
}
function xa(n, e, t) {
    return (1 - t) * n + t * e
}
function xA(n, e, t, i) {
    return xa(n, e, 1 - Math.exp(-t * i))
}
function bA(n, e=1) {
    return e - Math.abs(Np(n, e * 2) - e)
}
function MA(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * (3 - 2 * n))
}
function SA(n, e, t) {
    return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e),
    n * n * n * (n * (n * 6 - 15) + 10))
}
function wA(n, e) {
    return n + Math.floor(Math.random() * (e - n + 1))
}
function EA(n, e) {
    return n + Math.random() * (e - n)
}
function AA(n) {
    return n * (.5 - Math.random())
}
function TA(n) {
    n !== void 0 && (_g = n);
    let e = _g += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function CA(n) {
    return n * fs
}
function RA(n) {
    return n * Mo
}
function PA(n) {
    return (n & n - 1) === 0 && n !== 0
}
function IA(n) {
    return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}
function LA(n) {
    return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}
function DA(n, e, t, i, r) {
    const s = Math.cos
      , o = Math.sin
      , a = s(t / 2)
      , l = o(t / 2)
      , c = s((e + i) / 2)
      , u = o((e + i) / 2)
      , h = s((e - i) / 2)
      , f = o((e - i) / 2)
      , d = s((i - e) / 2)
      , p = o((i - e) / 2);
    switch (r) {
    case "XYX":
        n.set(a * u, l * h, l * f, a * c);
        break;
    case "YZY":
        n.set(l * f, a * u, l * h, a * c);
        break;
    case "ZXZ":
        n.set(l * h, l * f, a * u, a * c);
        break;
    case "XZX":
        n.set(a * u, l * p, l * d, a * c);
        break;
    case "YXY":
        n.set(l * d, a * u, l * p, a * c);
        break;
    case "ZYZ":
        n.set(l * p, l * d, a * u, a * c);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
    }
}
function gn(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return n / 4294967295;
    case Uint16Array:
        return n / 65535;
    case Uint8Array:
        return n / 255;
    case Int32Array:
        return Math.max(n / 2147483647, -1);
    case Int16Array:
        return Math.max(n / 32767, -1);
    case Int8Array:
        return Math.max(n / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function je(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return Math.round(n * 4294967295);
    case Uint16Array:
        return Math.round(n * 65535);
    case Uint8Array:
        return Math.round(n * 255);
    case Int32Array:
        return Math.round(n * 2147483647);
    case Int16Array:
        return Math.round(n * 32767);
    case Int8Array:
        return Math.round(n * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
const Up = {
    DEG2RAD: fs,
    RAD2DEG: Mo,
    generateUUID: Nn,
    clamp: It,
    euclideanModulo: Np,
    mapLinear: _A,
    inverseLerp: yA,
    lerp: xa,
    damp: xA,
    pingpong: bA,
    smoothstep: MA,
    smootherstep: SA,
    randInt: wA,
    randFloat: EA,
    randFloatSpread: AA,
    seededRandom: TA,
    degToRad: CA,
    radToDeg: RA,
    isPowerOfTwo: PA,
    ceilPowerOfTwo: IA,
    floorPowerOfTwo: LA,
    setQuaternionFromProperEuler: DA,
    normalize: je,
    denormalize: gn
};
class ae {
    constructor(e=0, t=0) {
        ae.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = e.elements;
        return this.x = r[0] * t + r[3] * i + r[6],
        this.y = r[1] * t + r[4] * i + r[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(It(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y;
        return t * t + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = this.x - e.x
          , o = this.y - e.y;
        return this.x = s * i - o * r + e.x,
        this.y = s * r + o * i + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class Ye {
    constructor(e, t, i, r, s, o, a, l, c) {
        Ye.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, i, r, s, o, a, l, c)
    }
    set(e, t, i, r, s, o, a, l, c) {
        const u = this.elements;
        return u[0] = e,
        u[1] = r,
        u[2] = a,
        u[3] = t,
        u[4] = s,
        u[5] = l,
        u[6] = i,
        u[7] = o,
        u[8] = c,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        i.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , a = i[3]
          , l = i[6]
          , c = i[1]
          , u = i[4]
          , h = i[7]
          , f = i[2]
          , d = i[5]
          , p = i[8]
          , v = r[0]
          , g = r[3]
          , m = r[6]
          , y = r[1]
          , _ = r[4]
          , x = r[7]
          , C = r[2]
          , w = r[5]
          , E = r[8];
        return s[0] = o * v + a * y + l * C,
        s[3] = o * g + a * _ + l * w,
        s[6] = o * m + a * x + l * E,
        s[1] = c * v + u * y + h * C,
        s[4] = c * g + u * _ + h * w,
        s[7] = c * m + u * x + h * E,
        s[2] = f * v + d * y + p * C,
        s[5] = f * g + d * _ + p * w,
        s[8] = f * m + d * x + p * E,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8];
        return t * o * u - t * a * c - i * s * u + i * a * l + r * s * c - r * o * l
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8]
          , h = u * o - a * c
          , f = a * l - u * s
          , d = c * s - o * l
          , p = t * h + i * f + r * d;
        if (p === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const v = 1 / p;
        return e[0] = h * v,
        e[1] = (r * c - u * i) * v,
        e[2] = (a * i - r * o) * v,
        e[3] = f * v,
        e[4] = (u * t - r * l) * v,
        e[5] = (r * s - a * t) * v,
        e[6] = d * v,
        e[7] = (i * l - c * t) * v,
        e[8] = (o * t - i * s) * v,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, i, r, s, o, a) {
        const l = Math.cos(s)
          , c = Math.sin(s);
        return this.set(i * l, i * c, -i * (l * o + c * a) + o + e, -r * c, r * l, -r * (-c * o + l * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(df.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(df.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(df.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 9; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 9; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const df = new Ye;
function Fx(n) {
    for (let e = n.length - 1; e >= 0; --e)
        if (n[e] >= 65535)
            return !0;
    return !1
}
const NA = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};
function eo(n, e) {
    return new NA[n](e)
}
function Ka(n) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}
function Bx() {
    const n = Ka("canvas");
    return n.style.display = "block",
    n
}
const yg = {};
function mo(n) {
    n in yg || (yg[n] = !0,
    console.warn(n))
}
function UA(n, e, t) {
    return new Promise(function(i, r) {
        function s() {
            switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
            case n.WAIT_FAILED:
                r();
                break;
            case n.TIMEOUT_EXPIRED:
                setTimeout(s, t);
                break;
            default:
                i()
            }
        }
        setTimeout(s, t)
    }
    )
}
const xg = new Ye().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
  , bg = new Ye().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
  , Vo = {
    [Ki]: {
        transfer: Xa,
        primaries: qa,
        luminanceCoefficients: [.2126, .7152, .0722],
        toReference: n => n,
        fromReference: n => n
    },
    [Rn]: {
        transfer: xt,
        primaries: qa,
        luminanceCoefficients: [.2126, .7152, .0722],
        toReference: n => n.convertSRGBToLinear(),
        fromReference: n => n.convertLinearToSRGB()
    },
    [vl]: {
        transfer: Xa,
        primaries: $a,
        luminanceCoefficients: [.2289, .6917, .0793],
        toReference: n => n.applyMatrix3(bg),
        fromReference: n => n.applyMatrix3(xg)
    },
    [fh]: {
        transfer: xt,
        primaries: $a,
        luminanceCoefficients: [.2289, .6917, .0793],
        toReference: n => n.convertSRGBToLinear().applyMatrix3(bg),
        fromReference: n => n.applyMatrix3(xg).convertLinearToSRGB()
    }
}
  , OA = new Set([Ki, vl])
  , st = {
    enabled: !0,
    _workingColorSpace: Ki,
    get workingColorSpace() {
        return this._workingColorSpace
    },
    set workingColorSpace(n) {
        if (!OA.has(n))
            throw new Error(`Unsupported working color space, "${n}".`);
        this._workingColorSpace = n
    },
    convert: function(n, e, t) {
        if (this.enabled === !1 || e === t || !e || !t)
            return n;
        const i = Vo[e].toReference
          , r = Vo[t].fromReference;
        return r(i(n))
    },
    fromWorkingColorSpace: function(n, e) {
        return this.convert(n, this._workingColorSpace, e)
    },
    toWorkingColorSpace: function(n, e) {
        return this.convert(n, e, this._workingColorSpace)
    },
    getPrimaries: function(n) {
        return Vo[n].primaries
    },
    getTransfer: function(n) {
        return n === Fi ? Xa : Vo[n].transfer
    },
    getLuminanceCoefficients: function(n, e=this._workingColorSpace) {
        return n.fromArray(Vo[e].luminanceCoefficients)
    }
};
function go(n) {
    return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}
function pf(n) {
    return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
let Cs;
class zx {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            Cs === void 0 && (Cs = Ka("canvas")),
            Cs.width = e.width,
            Cs.height = e.height;
            const i = Cs.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height),
            t = Cs
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = Ka("canvas");
            t.width = e.width,
            t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const r = i.getImageData(0, 0, e.width, e.height)
              , s = r.data;
            for (let o = 0; o < s.length; o++)
                s[o] = go(s[o] / 255) * 255;
            return i.putImageData(r, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(go(t[i] / 255) * 255) : t[i] = go(t[i]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let FA = 0;
class rs {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: FA++
        }),
        this.uuid = Nn(),
        this.data = e,
        this.dataReady = !0,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const i = {
            uuid: this.uuid,
            url: ""
        }
          , r = this.data;
        if (r !== null) {
            let s;
            if (Array.isArray(r)) {
                s = [];
                for (let o = 0, a = r.length; o < a; o++)
                    r[o].isDataTexture ? s.push(mf(r[o].image)) : s.push(mf(r[o]))
            } else
                s = mf(r);
            i.url = s
        }
        return t || (e.images[this.uuid] = i),
        i
    }
}
function mf(n) {
    return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? zx.getDataURL(n) : n.data ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let BA = 0;
class Dt extends Si {
    constructor(e=Dt.DEFAULT_IMAGE, t=Dt.DEFAULT_MAPPING, i=Gn, r=Gn, s=Gt, o=pi, a=vn, l=bi, c=Dt.DEFAULT_ANISOTROPY, u=Fi) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: BA++
        }),
        this.uuid = Nn(),
        this.name = "",
        this.source = new rs(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = i,
        this.wrapT = r,
        this.magFilter = s,
        this.minFilter = o,
        this.anisotropy = c,
        this.format = a,
        this.internalFormat = null,
        this.type = l,
        this.offset = new ae(0,0),
        this.repeat = new ae(1,1),
        this.center = new ae(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new Ye,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.colorSpace = u,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.pmremVersion = 0
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const i = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        t || (e.textures[this.uuid] = i),
        i
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== rh)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case Va:
                e.x = e.x - Math.floor(e.x);
                break;
            case Gn:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case Ha:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case Va:
                e.y = e.y - Math.floor(e.y);
                break;
            case Gn:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case Ha:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(e) {
        e === !0 && this.pmremVersion++
    }
}
Dt.DEFAULT_IMAGE = null;
Dt.DEFAULT_MAPPING = rh;
Dt.DEFAULT_ANISOTROPY = 1;
class ft {
    constructor(e=0, t=0, i=0, r=1) {
        ft.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = i,
        this.w = r
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, i, r) {
        return this.x = e,
        this.y = t,
        this.z = i,
        this.w = r,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s,
        this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s,
        this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s,
        this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, i, r, s;
        const l = e.elements
          , c = l[0]
          , u = l[4]
          , h = l[8]
          , f = l[1]
          , d = l[5]
          , p = l[9]
          , v = l[2]
          , g = l[6]
          , m = l[10];
        if (Math.abs(u - f) < .01 && Math.abs(h - v) < .01 && Math.abs(p - g) < .01) {
            if (Math.abs(u + f) < .1 && Math.abs(h + v) < .1 && Math.abs(p + g) < .1 && Math.abs(c + d + m - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const _ = (c + 1) / 2
              , x = (d + 1) / 2
              , C = (m + 1) / 2
              , w = (u + f) / 4
              , E = (h + v) / 4
              , L = (p + g) / 4;
            return _ > x && _ > C ? _ < .01 ? (i = 0,
            r = .707106781,
            s = .707106781) : (i = Math.sqrt(_),
            r = w / i,
            s = E / i) : x > C ? x < .01 ? (i = .707106781,
            r = 0,
            s = .707106781) : (r = Math.sqrt(x),
            i = w / r,
            s = L / r) : C < .01 ? (i = .707106781,
            r = .707106781,
            s = 0) : (s = Math.sqrt(C),
            i = E / s,
            r = L / s),
            this.set(i, r, s, t),
            this
        }
        let y = Math.sqrt((g - p) * (g - p) + (h - v) * (h - v) + (f - u) * (f - u));
        return Math.abs(y) < .001 && (y = 1),
        this.x = (g - p) / y,
        this.y = (h - v) / y,
        this.z = (f - u) / y,
        this.w = Math.acos((c + d + m - 1) / 2),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this.w = t[15],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this.w = e.w + (t.w - e.w) * i,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class kx extends Si {
    constructor(e=1, t=1, i={}) {
        super(),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new ft(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new ft(0,0,e,t);
        const r = {
            width: e,
            height: t,
            depth: 1
        };
        i = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: Gt,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1
        }, i);
        const s = new Dt(r,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace);
        s.flipY = !1,
        s.generateMipmaps = i.generateMipmaps,
        s.internalFormat = i.internalFormat,
        this.textures = [];
        const o = i.count;
        for (let a = 0; a < o; a++)
            this.textures[a] = s.clone(),
            this.textures[a].isRenderTargetTexture = !0;
        this.depthBuffer = i.depthBuffer,
        this.stencilBuffer = i.stencilBuffer,
        this.resolveDepthBuffer = i.resolveDepthBuffer,
        this.resolveStencilBuffer = i.resolveStencilBuffer,
        this.depthTexture = i.depthTexture,
        this.samples = i.samples
    }
    get texture() {
        return this.textures[0]
    }
    set texture(e) {
        this.textures[0] = e
    }
    setSize(e, t, i=1) {
        if (this.width !== e || this.height !== t || this.depth !== i) {
            this.width = e,
            this.height = t,
            this.depth = i;
            for (let r = 0, s = this.textures.length; r < s; r++)
                this.textures[r].image.width = e,
                this.textures[r].image.height = t,
                this.textures[r].image.depth = i;
            this.dispose()
        }
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.textures.length = 0;
        for (let i = 0, r = e.textures.length; i < r; i++)
            this.textures[i] = e.textures[i].clone(),
            this.textures[i].isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new rs(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        this.resolveDepthBuffer = e.resolveDepthBuffer,
        this.resolveStencilBuffer = e.resolveStencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class si extends kx {
    constructor(e=1, t=1, i={}) {
        super(e, t, i),
        this.isWebGLRenderTarget = !0
    }
}
class dh extends Dt {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = Kt,
        this.minFilter = Kt,
        this.wrapR = Gn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class zA extends si {
    constructor(e=1, t=1, i=1, r={}) {
        super(e, t, r),
        this.isWebGLArrayRenderTarget = !0,
        this.depth = i,
        this.texture = new dh(null,e,t,i),
        this.texture.isRenderTargetTexture = !0
    }
}
class Op extends Dt {
    constructor(e=null, t=1, i=1, r=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
        },
        this.magFilter = Kt,
        this.minFilter = Kt,
        this.wrapR = Gn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class kA extends si {
    constructor(e=1, t=1, i=1, r={}) {
        super(e, t, r),
        this.isWebGL3DRenderTarget = !0,
        this.depth = i,
        this.texture = new Op(null,e,t,i),
        this.texture.isRenderTargetTexture = !0
    }
}
class Sn {
    constructor(e=0, t=0, i=0, r=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._w = r
    }
    static slerpFlat(e, t, i, r, s, o, a) {
        let l = i[r + 0]
          , c = i[r + 1]
          , u = i[r + 2]
          , h = i[r + 3];
        const f = s[o + 0]
          , d = s[o + 1]
          , p = s[o + 2]
          , v = s[o + 3];
        if (a === 0) {
            e[t + 0] = l,
            e[t + 1] = c,
            e[t + 2] = u,
            e[t + 3] = h;
            return
        }
        if (a === 1) {
            e[t + 0] = f,
            e[t + 1] = d,
            e[t + 2] = p,
            e[t + 3] = v;
            return
        }
        if (h !== v || l !== f || c !== d || u !== p) {
            let g = 1 - a;
            const m = l * f + c * d + u * p + h * v
              , y = m >= 0 ? 1 : -1
              , _ = 1 - m * m;
            if (_ > Number.EPSILON) {
                const C = Math.sqrt(_)
                  , w = Math.atan2(C, m * y);
                g = Math.sin(g * w) / C,
                a = Math.sin(a * w) / C
            }
            const x = a * y;
            if (l = l * g + f * x,
            c = c * g + d * x,
            u = u * g + p * x,
            h = h * g + v * x,
            g === 1 - a) {
                const C = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
                l *= C,
                c *= C,
                u *= C,
                h *= C
            }
        }
        e[t] = l,
        e[t + 1] = c,
        e[t + 2] = u,
        e[t + 3] = h
    }
    static multiplyQuaternionsFlat(e, t, i, r, s, o) {
        const a = i[r]
          , l = i[r + 1]
          , c = i[r + 2]
          , u = i[r + 3]
          , h = s[o]
          , f = s[o + 1]
          , d = s[o + 2]
          , p = s[o + 3];
        return e[t] = a * p + u * h + l * d - c * f,
        e[t + 1] = l * p + u * f + c * h - a * d,
        e[t + 2] = c * p + u * d + a * f - l * h,
        e[t + 3] = u * p - a * h - l * f - c * d,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, i, r) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._w = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t=!0) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._order
          , a = Math.cos
          , l = Math.sin
          , c = a(i / 2)
          , u = a(r / 2)
          , h = a(s / 2)
          , f = l(i / 2)
          , d = l(r / 2)
          , p = l(s / 2);
        switch (o) {
        case "XYZ":
            this._x = f * u * h + c * d * p,
            this._y = c * d * h - f * u * p,
            this._z = c * u * p + f * d * h,
            this._w = c * u * h - f * d * p;
            break;
        case "YXZ":
            this._x = f * u * h + c * d * p,
            this._y = c * d * h - f * u * p,
            this._z = c * u * p - f * d * h,
            this._w = c * u * h + f * d * p;
            break;
        case "ZXY":
            this._x = f * u * h - c * d * p,
            this._y = c * d * h + f * u * p,
            this._z = c * u * p + f * d * h,
            this._w = c * u * h - f * d * p;
            break;
        case "ZYX":
            this._x = f * u * h - c * d * p,
            this._y = c * d * h + f * u * p,
            this._z = c * u * p - f * d * h,
            this._w = c * u * h + f * d * p;
            break;
        case "YZX":
            this._x = f * u * h + c * d * p,
            this._y = c * d * h + f * u * p,
            this._z = c * u * p - f * d * h,
            this._w = c * u * h - f * d * p;
            break;
        case "XZY":
            this._x = f * u * h - c * d * p,
            this._y = c * d * h - f * u * p,
            this._z = c * u * p + f * d * h,
            this._w = c * u * h + f * d * p;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t === !0 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const i = t / 2
          , r = Math.sin(i);
        return this._x = e.x * r,
        this._y = e.y * r,
        this._z = e.z * r,
        this._w = Math.cos(i),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , i = t[0]
          , r = t[4]
          , s = t[8]
          , o = t[1]
          , a = t[5]
          , l = t[9]
          , c = t[2]
          , u = t[6]
          , h = t[10]
          , f = i + a + h;
        if (f > 0) {
            const d = .5 / Math.sqrt(f + 1);
            this._w = .25 / d,
            this._x = (u - l) * d,
            this._y = (s - c) * d,
            this._z = (o - r) * d
        } else if (i > a && i > h) {
            const d = 2 * Math.sqrt(1 + i - a - h);
            this._w = (u - l) / d,
            this._x = .25 * d,
            this._y = (r + o) / d,
            this._z = (s + c) / d
        } else if (a > h) {
            const d = 2 * Math.sqrt(1 + a - i - h);
            this._w = (s - c) / d,
            this._x = (r + o) / d,
            this._y = .25 * d,
            this._z = (l + u) / d
        } else {
            const d = 2 * Math.sqrt(1 + h - i - a);
            this._w = (o - r) / d,
            this._x = (s + c) / d,
            this._y = (l + u) / d,
            this._z = .25 * d
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return i < Number.EPSILON ? (i = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = i) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = i)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = i),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(It(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (i === 0)
            return this;
        const r = Math.min(1, t / i);
        return this.slerp(e, r),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const i = e._x
          , r = e._y
          , s = e._z
          , o = e._w
          , a = t._x
          , l = t._y
          , c = t._z
          , u = t._w;
        return this._x = i * u + o * a + r * c - s * l,
        this._y = r * u + o * l + s * a - i * c,
        this._z = s * u + o * c + i * l - r * a,
        this._w = o * u - i * a - r * l - s * c,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const i = this._x
          , r = this._y
          , s = this._z
          , o = this._w;
        let a = o * e._w + i * e._x + r * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = i,
            this._y = r,
            this._z = s,
            this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const d = 1 - t;
            return this._w = d * o + t * this._w,
            this._x = d * i + t * this._x,
            this._y = d * r + t * this._y,
            this._z = d * s + t * this._z,
            this.normalize(),
            this
        }
        const c = Math.sqrt(l)
          , u = Math.atan2(c, a)
          , h = Math.sin((1 - t) * u) / c
          , f = Math.sin(t * u) / c;
        return this._w = o * h + this._w * f,
        this._x = i * h + this._x * f,
        this._y = r * h + this._y * f,
        this._z = s * h + this._z * f,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i)
    }
    random() {
        const e = 2 * Math.PI * Math.random()
          , t = 2 * Math.PI * Math.random()
          , i = Math.random()
          , r = Math.sqrt(1 - i)
          , s = Math.sqrt(i);
        return this.set(r * Math.sin(e), r * Math.cos(e), s * Math.sin(t), s * Math.cos(t))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this._onChangeCallback(),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class N {
    constructor(e=0, t=0, i=0) {
        N.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = i
    }
    set(e, t, i) {
        return i === void 0 && (i = this.z),
        this.x = e,
        this.y = t,
        this.z = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(Mg.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(Mg.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[3] * i + s[6] * r,
        this.y = s[1] * t + s[4] * i + s[7] * r,
        this.z = s[2] * t + s[5] * i + s[8] * r,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements
          , o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
        return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o,
        this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o,
        this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.x
          , o = e.y
          , a = e.z
          , l = e.w
          , c = 2 * (o * r - a * i)
          , u = 2 * (a * t - s * r)
          , h = 2 * (s * i - o * t);
        return this.x = t + l * c + o * h - a * u,
        this.y = i + l * u + a * c - s * h,
        this.z = r + l * h + s * u - o * c,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , i = this.y
          , r = this.z
          , s = e.elements;
        return this.x = s[0] * t + s[4] * i + s[8] * r,
        this.y = s[1] * t + s[5] * i + s[9] * r,
        this.z = s[2] * t + s[6] * i + s[10] * r,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i,
        this.y = e.y + (t.y - e.y) * i,
        this.z = e.z + (t.z - e.z) * i,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = t.x
          , a = t.y
          , l = t.z;
        return this.x = r * l - s * a,
        this.y = s * o - i * l,
        this.z = i * a - r * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i)
    }
    projectOnPlane(e) {
        return gf.copy(this).projectOnVector(e),
        this.sub(gf)
    }
    reflect(e) {
        return this.sub(gf.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(It(i, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , i = this.y - e.y
          , r = this.z - e.z;
        return t * t + i * i + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, i) {
        const r = Math.sin(t) * e;
        return this.x = r * Math.sin(i),
        this.y = Math.cos(t) * e,
        this.z = r * Math.cos(i),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, i) {
        return this.x = e * Math.sin(t),
        this.y = i,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , i = this.setFromMatrixColumn(e, 1).length()
          , r = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = i,
        this.z = r,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2
          , t = Math.random() * 2 - 1
          , i = Math.sqrt(1 - t * t);
        return this.x = i * Math.cos(e),
        this.y = t,
        this.z = i * Math.sin(e),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const gf = new N
  , Mg = new Sn;
class yn {
    constructor(e=new N(1 / 0,1 / 0,1 / 0), t=new N(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t += 3)
            this.expandByPoint(qn.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, i = e.count; t < i; t++)
            this.expandByPoint(qn.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = qn.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const i = e.geometry;
        if (i !== void 0) {
            const s = i.getAttribute("position");
            if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = s.count; o < a; o++)
                    e.isMesh === !0 ? e.getVertexPosition(o, qn) : qn.fromBufferAttribute(s, o),
                    qn.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(qn);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                Bl.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(),
                Bl.copy(i.boundingBox)),
                Bl.applyMatrix4(e.matrixWorld),
                this.union(Bl)
        }
        const r = e.children;
        for (let s = 0, o = r.length; s < o; s++)
            this.expandByObject(r[s], t);
        return this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, qn),
        qn.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, i;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        i = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        i += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        i += e.normal.z * this.min.z),
        t <= -e.constant && i >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(Ho),
        zl.subVectors(this.max, Ho),
        Rs.subVectors(e.a, Ho),
        Ps.subVectors(e.b, Ho),
        Is.subVectors(e.c, Ho),
        ir.subVectors(Ps, Rs),
        rr.subVectors(Is, Ps),
        Fr.subVectors(Rs, Is);
        let t = [0, -ir.z, ir.y, 0, -rr.z, rr.y, 0, -Fr.z, Fr.y, ir.z, 0, -ir.x, rr.z, 0, -rr.x, Fr.z, 0, -Fr.x, -ir.y, ir.x, 0, -rr.y, rr.x, 0, -Fr.y, Fr.x, 0];
        return !vf(t, Rs, Ps, Is, zl) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !vf(t, Rs, Ps, Is, zl)) ? !1 : (kl.crossVectors(ir, rr),
        t = [kl.x, kl.y, kl.z],
        vf(t, Rs, Ps, Is, zl))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, qn).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(qn).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (Ti[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Ti[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Ti[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Ti[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Ti[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Ti[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Ti[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Ti[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Ti),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const Ti = [new N, new N, new N, new N, new N, new N, new N, new N]
  , qn = new N
  , Bl = new yn
  , Rs = new N
  , Ps = new N
  , Is = new N
  , ir = new N
  , rr = new N
  , Fr = new N
  , Ho = new N
  , zl = new N
  , kl = new N
  , Br = new N;
function vf(n, e, t, i, r) {
    for (let s = 0, o = n.length - 3; s <= o; s += 3) {
        Br.fromArray(n, s);
        const a = r.x * Math.abs(Br.x) + r.y * Math.abs(Br.y) + r.z * Math.abs(Br.z)
          , l = e.dot(Br)
          , c = t.dot(Br)
          , u = i.dot(Br);
        if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a)
            return !1
    }
    return !0
}
const VA = new yn
  , Go = new N
  , _f = new N;
class an {
    constructor(e=new N, t=-1) {
        this.isSphere = !0,
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const i = this.center;
        t !== void 0 ? i.copy(t) : VA.setFromPoints(e).getCenter(i);
        let r = 0;
        for (let s = 0, o = e.length; s < o; s++)
            r = Math.max(r, i.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(r),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return t.copy(e),
        i > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        Go.subVectors(e, this.center);
        const t = Go.lengthSq();
        if (t > this.radius * this.radius) {
            const i = Math.sqrt(t)
              , r = (i - this.radius) * .5;
            this.center.addScaledVector(Go, r / i),
            this.radius += r
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (_f.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(Go.copy(e.center).add(_f)),
        this.expandByPoint(Go.copy(e.center).sub(_f))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Ci = new N
  , yf = new N
  , Vl = new N
  , sr = new N
  , xf = new N
  , Hl = new N
  , bf = new N;
class No {
    constructor(e=new N, t=new N(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, Ci)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = Ci.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (Ci.copy(this.origin).addScaledVector(this.direction, t),
        Ci.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, i, r) {
        yf.copy(e).add(t).multiplyScalar(.5),
        Vl.copy(t).sub(e).normalize(),
        sr.copy(this.origin).sub(yf);
        const s = e.distanceTo(t) * .5
          , o = -this.direction.dot(Vl)
          , a = sr.dot(this.direction)
          , l = -sr.dot(Vl)
          , c = sr.lengthSq()
          , u = Math.abs(1 - o * o);
        let h, f, d, p;
        if (u > 0)
            if (h = o * l - a,
            f = o * a - l,
            p = s * u,
            h >= 0)
                if (f >= -p)
                    if (f <= p) {
                        const v = 1 / u;
                        h *= v,
                        f *= v,
                        d = h * (h + o * f + 2 * a) + f * (o * h + f + 2 * l) + c
                    } else
                        f = s,
                        h = Math.max(0, -(o * f + a)),
                        d = -h * h + f * (f + 2 * l) + c;
                else
                    f = -s,
                    h = Math.max(0, -(o * f + a)),
                    d = -h * h + f * (f + 2 * l) + c;
            else
                f <= -p ? (h = Math.max(0, -(-o * s + a)),
                f = h > 0 ? -s : Math.min(Math.max(-s, -l), s),
                d = -h * h + f * (f + 2 * l) + c) : f <= p ? (h = 0,
                f = Math.min(Math.max(-s, -l), s),
                d = f * (f + 2 * l) + c) : (h = Math.max(0, -(o * s + a)),
                f = h > 0 ? s : Math.min(Math.max(-s, -l), s),
                d = -h * h + f * (f + 2 * l) + c);
        else
            f = o > 0 ? -s : s,
            h = Math.max(0, -(o * f + a)),
            d = -h * h + f * (f + 2 * l) + c;
        return i && i.copy(this.origin).addScaledVector(this.direction, h),
        r && r.copy(yf).addScaledVector(Vl, f),
        d
    }
    intersectSphere(e, t) {
        Ci.subVectors(e.center, this.origin);
        const i = Ci.dot(this.direction)
          , r = Ci.dot(Ci) - i * i
          , s = e.radius * e.radius;
        if (r > s)
            return null;
        const o = Math.sqrt(s - r)
          , a = i - o
          , l = i + o;
        return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null
    }
    intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let i, r, s, o, a, l;
        const c = 1 / this.direction.x
          , u = 1 / this.direction.y
          , h = 1 / this.direction.z
          , f = this.origin;
        return c >= 0 ? (i = (e.min.x - f.x) * c,
        r = (e.max.x - f.x) * c) : (i = (e.max.x - f.x) * c,
        r = (e.min.x - f.x) * c),
        u >= 0 ? (s = (e.min.y - f.y) * u,
        o = (e.max.y - f.y) * u) : (s = (e.max.y - f.y) * u,
        o = (e.min.y - f.y) * u),
        i > o || s > r || ((s > i || isNaN(i)) && (i = s),
        (o < r || isNaN(r)) && (r = o),
        h >= 0 ? (a = (e.min.z - f.z) * h,
        l = (e.max.z - f.z) * h) : (a = (e.max.z - f.z) * h,
        l = (e.min.z - f.z) * h),
        i > l || a > r) || ((a > i || i !== i) && (i = a),
        (l < r || r !== r) && (r = l),
        r < 0) ? null : this.at(i >= 0 ? i : r, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, Ci) !== null
    }
    intersectTriangle(e, t, i, r, s) {
        xf.subVectors(t, e),
        Hl.subVectors(i, e),
        bf.crossVectors(xf, Hl);
        let o = this.direction.dot(bf), a;
        if (o > 0) {
            if (r)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        sr.subVectors(this.origin, e);
        const l = a * this.direction.dot(Hl.crossVectors(sr, Hl));
        if (l < 0)
            return null;
        const c = a * this.direction.dot(xf.cross(sr));
        if (c < 0 || l + c > o)
            return null;
        const u = -a * sr.dot(bf);
        return u < 0 ? null : this.at(u / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Be {
    constructor(e, t, i, r, s, o, a, l, c, u, h, f, d, p, v, g) {
        Be.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, i, r, s, o, a, l, c, u, h, f, d, p, v, g)
    }
    set(e, t, i, r, s, o, a, l, c, u, h, f, d, p, v, g) {
        const m = this.elements;
        return m[0] = e,
        m[4] = t,
        m[8] = i,
        m[12] = r,
        m[1] = s,
        m[5] = o,
        m[9] = a,
        m[13] = l,
        m[2] = c,
        m[6] = u,
        m[10] = h,
        m[14] = f,
        m[3] = d,
        m[7] = p,
        m[11] = v,
        m[15] = g,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new Be().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , i = e.elements;
        return t[0] = i[0],
        t[1] = i[1],
        t[2] = i[2],
        t[3] = i[3],
        t[4] = i[4],
        t[5] = i[5],
        t[6] = i[6],
        t[7] = i[7],
        t[8] = i[8],
        t[9] = i[9],
        t[10] = i[10],
        t[11] = i[11],
        t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        t[15] = i[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , i = e.elements;
        return t[12] = i[12],
        t[13] = i[13],
        t[14] = i[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, i) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        i.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , i = e.elements
          , r = 1 / Ls.setFromMatrixColumn(e, 0).length()
          , s = 1 / Ls.setFromMatrixColumn(e, 1).length()
          , o = 1 / Ls.setFromMatrixColumn(e, 2).length();
        return t[0] = i[0] * r,
        t[1] = i[1] * r,
        t[2] = i[2] * r,
        t[3] = 0,
        t[4] = i[4] * s,
        t[5] = i[5] * s,
        t[6] = i[6] * s,
        t[7] = 0,
        t[8] = i[8] * o,
        t[9] = i[9] * o,
        t[10] = i[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z
          , o = Math.cos(i)
          , a = Math.sin(i)
          , l = Math.cos(r)
          , c = Math.sin(r)
          , u = Math.cos(s)
          , h = Math.sin(s);
        if (e.order === "XYZ") {
            const f = o * u
              , d = o * h
              , p = a * u
              , v = a * h;
            t[0] = l * u,
            t[4] = -l * h,
            t[8] = c,
            t[1] = d + p * c,
            t[5] = f - v * c,
            t[9] = -a * l,
            t[2] = v - f * c,
            t[6] = p + d * c,
            t[10] = o * l
        } else if (e.order === "YXZ") {
            const f = l * u
              , d = l * h
              , p = c * u
              , v = c * h;
            t[0] = f + v * a,
            t[4] = p * a - d,
            t[8] = o * c,
            t[1] = o * h,
            t[5] = o * u,
            t[9] = -a,
            t[2] = d * a - p,
            t[6] = v + f * a,
            t[10] = o * l
        } else if (e.order === "ZXY") {
            const f = l * u
              , d = l * h
              , p = c * u
              , v = c * h;
            t[0] = f - v * a,
            t[4] = -o * h,
            t[8] = p + d * a,
            t[1] = d + p * a,
            t[5] = o * u,
            t[9] = v - f * a,
            t[2] = -o * c,
            t[6] = a,
            t[10] = o * l
        } else if (e.order === "ZYX") {
            const f = o * u
              , d = o * h
              , p = a * u
              , v = a * h;
            t[0] = l * u,
            t[4] = p * c - d,
            t[8] = f * c + v,
            t[1] = l * h,
            t[5] = v * c + f,
            t[9] = d * c - p,
            t[2] = -c,
            t[6] = a * l,
            t[10] = o * l
        } else if (e.order === "YZX") {
            const f = o * l
              , d = o * c
              , p = a * l
              , v = a * c;
            t[0] = l * u,
            t[4] = v - f * h,
            t[8] = p * h + d,
            t[1] = h,
            t[5] = o * u,
            t[9] = -a * u,
            t[2] = -c * u,
            t[6] = d * h + p,
            t[10] = f - v * h
        } else if (e.order === "XZY") {
            const f = o * l
              , d = o * c
              , p = a * l
              , v = a * c;
            t[0] = l * u,
            t[4] = -h,
            t[8] = c * u,
            t[1] = f * h + v,
            t[5] = o * u,
            t[9] = d * h - p,
            t[2] = p * h - d,
            t[6] = a * u,
            t[10] = v * h + f
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(HA, e, GA)
    }
    lookAt(e, t, i) {
        const r = this.elements;
        return Tn.subVectors(e, t),
        Tn.lengthSq() === 0 && (Tn.z = 1),
        Tn.normalize(),
        or.crossVectors(i, Tn),
        or.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Tn.x += 1e-4 : Tn.z += 1e-4,
        Tn.normalize(),
        or.crossVectors(i, Tn)),
        or.normalize(),
        Gl.crossVectors(Tn, or),
        r[0] = or.x,
        r[4] = Gl.x,
        r[8] = Tn.x,
        r[1] = or.y,
        r[5] = Gl.y,
        r[9] = Tn.y,
        r[2] = or.z,
        r[6] = Gl.z,
        r[10] = Tn.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const i = e.elements
          , r = t.elements
          , s = this.elements
          , o = i[0]
          , a = i[4]
          , l = i[8]
          , c = i[12]
          , u = i[1]
          , h = i[5]
          , f = i[9]
          , d = i[13]
          , p = i[2]
          , v = i[6]
          , g = i[10]
          , m = i[14]
          , y = i[3]
          , _ = i[7]
          , x = i[11]
          , C = i[15]
          , w = r[0]
          , E = r[4]
          , L = r[8]
          , S = r[12]
          , b = r[1]
          , D = r[5]
          , F = r[9]
          , z = r[13]
          , $ = r[2]
          , ne = r[6]
          , W = r[10]
          , ie = r[14]
          , Z = r[3]
          , ve = r[7]
          , xe = r[11]
          , te = r[15];
        return s[0] = o * w + a * b + l * $ + c * Z,
        s[4] = o * E + a * D + l * ne + c * ve,
        s[8] = o * L + a * F + l * W + c * xe,
        s[12] = o * S + a * z + l * ie + c * te,
        s[1] = u * w + h * b + f * $ + d * Z,
        s[5] = u * E + h * D + f * ne + d * ve,
        s[9] = u * L + h * F + f * W + d * xe,
        s[13] = u * S + h * z + f * ie + d * te,
        s[2] = p * w + v * b + g * $ + m * Z,
        s[6] = p * E + v * D + g * ne + m * ve,
        s[10] = p * L + v * F + g * W + m * xe,
        s[14] = p * S + v * z + g * ie + m * te,
        s[3] = y * w + _ * b + x * $ + C * Z,
        s[7] = y * E + _ * D + x * ne + C * ve,
        s[11] = y * L + _ * F + x * W + C * xe,
        s[15] = y * S + _ * z + x * ie + C * te,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , i = e[4]
          , r = e[8]
          , s = e[12]
          , o = e[1]
          , a = e[5]
          , l = e[9]
          , c = e[13]
          , u = e[2]
          , h = e[6]
          , f = e[10]
          , d = e[14]
          , p = e[3]
          , v = e[7]
          , g = e[11]
          , m = e[15];
        return p * (+s * l * h - r * c * h - s * a * f + i * c * f + r * a * d - i * l * d) + v * (+t * l * d - t * c * f + s * o * f - r * o * d + r * c * u - s * l * u) + g * (+t * c * h - t * a * d - s * o * h + i * o * d + s * a * u - i * c * u) + m * (-r * a * u - t * l * h + t * a * f + r * o * h - i * o * f + i * l * u)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, i) {
        const r = this.elements;
        return e.isVector3 ? (r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z) : (r[12] = e,
        r[13] = t,
        r[14] = i),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , i = e[1]
          , r = e[2]
          , s = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , u = e[8]
          , h = e[9]
          , f = e[10]
          , d = e[11]
          , p = e[12]
          , v = e[13]
          , g = e[14]
          , m = e[15]
          , y = h * g * c - v * f * c + v * l * d - a * g * d - h * l * m + a * f * m
          , _ = p * f * c - u * g * c - p * l * d + o * g * d + u * l * m - o * f * m
          , x = u * v * c - p * h * c + p * a * d - o * v * d - u * a * m + o * h * m
          , C = p * h * l - u * v * l - p * a * f + o * v * f + u * a * g - o * h * g
          , w = t * y + i * _ + r * x + s * C;
        if (w === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const E = 1 / w;
        return e[0] = y * E,
        e[1] = (v * f * s - h * g * s - v * r * d + i * g * d + h * r * m - i * f * m) * E,
        e[2] = (a * g * s - v * l * s + v * r * c - i * g * c - a * r * m + i * l * m) * E,
        e[3] = (h * l * s - a * f * s - h * r * c + i * f * c + a * r * d - i * l * d) * E,
        e[4] = _ * E,
        e[5] = (u * g * s - p * f * s + p * r * d - t * g * d - u * r * m + t * f * m) * E,
        e[6] = (p * l * s - o * g * s - p * r * c + t * g * c + o * r * m - t * l * m) * E,
        e[7] = (o * f * s - u * l * s + u * r * c - t * f * c - o * r * d + t * l * d) * E,
        e[8] = x * E,
        e[9] = (p * h * s - u * v * s - p * i * d + t * v * d + u * i * m - t * h * m) * E,
        e[10] = (o * v * s - p * a * s + p * i * c - t * v * c - o * i * m + t * a * m) * E,
        e[11] = (u * a * s - o * h * s - u * i * c + t * h * c + o * i * d - t * a * d) * E,
        e[12] = C * E,
        e[13] = (u * v * r - p * h * r + p * i * f - t * v * f - u * i * g + t * h * g) * E,
        e[14] = (p * a * r - o * v * r - p * i * l + t * v * l + o * i * g - t * a * g) * E,
        e[15] = (o * h * r - u * a * r + u * i * l - t * h * l - o * i * f + t * a * f) * E,
        this
    }
    scale(e) {
        const t = this.elements
          , i = e.x
          , r = e.y
          , s = e.z;
        return t[0] *= i,
        t[4] *= r,
        t[8] *= s,
        t[1] *= i,
        t[5] *= r,
        t[9] *= s,
        t[2] *= i,
        t[6] *= r,
        t[10] *= s,
        t[3] *= i,
        t[7] *= r,
        t[11] *= s,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, r))
    }
    makeTranslation(e, t, i) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const i = Math.cos(t)
          , r = Math.sin(t)
          , s = 1 - i
          , o = e.x
          , a = e.y
          , l = e.z
          , c = s * o
          , u = s * a;
        return this.set(c * o + i, c * a - r * l, c * l + r * a, 0, c * a + r * l, u * a + i, u * l - r * o, 0, c * l - r * a, u * l + r * o, s * l * l + i, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, i, r, s, o) {
        return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, i) {
        const r = this.elements
          , s = t._x
          , o = t._y
          , a = t._z
          , l = t._w
          , c = s + s
          , u = o + o
          , h = a + a
          , f = s * c
          , d = s * u
          , p = s * h
          , v = o * u
          , g = o * h
          , m = a * h
          , y = l * c
          , _ = l * u
          , x = l * h
          , C = i.x
          , w = i.y
          , E = i.z;
        return r[0] = (1 - (v + m)) * C,
        r[1] = (d + x) * C,
        r[2] = (p - _) * C,
        r[3] = 0,
        r[4] = (d - x) * w,
        r[5] = (1 - (f + m)) * w,
        r[6] = (g + y) * w,
        r[7] = 0,
        r[8] = (p + _) * E,
        r[9] = (g - y) * E,
        r[10] = (1 - (f + v)) * E,
        r[11] = 0,
        r[12] = e.x,
        r[13] = e.y,
        r[14] = e.z,
        r[15] = 1,
        this
    }
    decompose(e, t, i) {
        const r = this.elements;
        let s = Ls.set(r[0], r[1], r[2]).length();
        const o = Ls.set(r[4], r[5], r[6]).length()
          , a = Ls.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (s = -s),
        e.x = r[12],
        e.y = r[13],
        e.z = r[14],
        $n.copy(this);
        const c = 1 / s
          , u = 1 / o
          , h = 1 / a;
        return $n.elements[0] *= c,
        $n.elements[1] *= c,
        $n.elements[2] *= c,
        $n.elements[4] *= u,
        $n.elements[5] *= u,
        $n.elements[6] *= u,
        $n.elements[8] *= h,
        $n.elements[9] *= h,
        $n.elements[10] *= h,
        t.setFromRotationMatrix($n),
        i.x = s,
        i.y = o,
        i.z = a,
        this
    }
    makePerspective(e, t, i, r, s, o, a=mi) {
        const l = this.elements
          , c = 2 * s / (t - e)
          , u = 2 * s / (i - r)
          , h = (t + e) / (t - e)
          , f = (i + r) / (i - r);
        let d, p;
        if (a === mi)
            d = -(o + s) / (o - s),
            p = -2 * o * s / (o - s);
        else if (a === ja)
            d = -o / (o - s),
            p = -o * s / (o - s);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return l[0] = c,
        l[4] = 0,
        l[8] = h,
        l[12] = 0,
        l[1] = 0,
        l[5] = u,
        l[9] = f,
        l[13] = 0,
        l[2] = 0,
        l[6] = 0,
        l[10] = d,
        l[14] = p,
        l[3] = 0,
        l[7] = 0,
        l[11] = -1,
        l[15] = 0,
        this
    }
    makeOrthographic(e, t, i, r, s, o, a=mi) {
        const l = this.elements
          , c = 1 / (t - e)
          , u = 1 / (i - r)
          , h = 1 / (o - s)
          , f = (t + e) * c
          , d = (i + r) * u;
        let p, v;
        if (a === mi)
            p = (o + s) * h,
            v = -2 * h;
        else if (a === ja)
            p = s * h,
            v = -1 * h;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return l[0] = 2 * c,
        l[4] = 0,
        l[8] = 0,
        l[12] = -f,
        l[1] = 0,
        l[5] = 2 * u,
        l[9] = 0,
        l[13] = -d,
        l[2] = 0,
        l[6] = 0,
        l[10] = v,
        l[14] = -p,
        l[3] = 0,
        l[7] = 0,
        l[11] = 0,
        l[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , i = e.elements;
        for (let r = 0; r < 16; r++)
            if (t[r] !== i[r])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 16; i++)
            this.elements[i] = e[i + t];
        return this
    }
    toArray(e=[], t=0) {
        const i = this.elements;
        return e[t] = i[0],
        e[t + 1] = i[1],
        e[t + 2] = i[2],
        e[t + 3] = i[3],
        e[t + 4] = i[4],
        e[t + 5] = i[5],
        e[t + 6] = i[6],
        e[t + 7] = i[7],
        e[t + 8] = i[8],
        e[t + 9] = i[9],
        e[t + 10] = i[10],
        e[t + 11] = i[11],
        e[t + 12] = i[12],
        e[t + 13] = i[13],
        e[t + 14] = i[14],
        e[t + 15] = i[15],
        e
    }
}
const Ls = new N
  , $n = new Be
  , HA = new N(0,0,0)
  , GA = new N(1,1,1)
  , or = new N
  , Gl = new N
  , Tn = new N
  , Sg = new Be
  , wg = new Sn;
class Un {
    constructor(e=0, t=0, i=0, r=Un.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = i,
        this._order = r
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, i, r=this._order) {
        return this._x = e,
        this._y = t,
        this._z = i,
        this._order = r,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, i=!0) {
        const r = e.elements
          , s = r[0]
          , o = r[4]
          , a = r[8]
          , l = r[1]
          , c = r[5]
          , u = r[9]
          , h = r[2]
          , f = r[6]
          , d = r[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(It(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, d),
            this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(f, c),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-It(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, d),
            this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, s),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(It(f, -1, 1)),
            Math.abs(f) < .9999999 ? (this._y = Math.atan2(-h, d),
            this._z = Math.atan2(-o, c)) : (this._y = 0,
            this._z = Math.atan2(l, s));
            break;
        case "ZYX":
            this._y = Math.asin(-It(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._x = Math.atan2(f, d),
            this._z = Math.atan2(l, s)) : (this._x = 0,
            this._z = Math.atan2(-o, c));
            break;
        case "YZX":
            this._z = Math.asin(It(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c),
            this._y = Math.atan2(-h, s)) : (this._x = 0,
            this._y = Math.atan2(a, d));
            break;
        case "XZY":
            this._z = Math.asin(-It(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(f, c),
            this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-u, d),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        i === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, i) {
        return Sg.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(Sg, t, i)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return wg.setFromEuler(this),
        this.setFromQuaternion(wg, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
Un.DEFAULT_ORDER = "XYZ";
class ph {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let WA = 0;
const Eg = new N
  , Ds = new Sn
  , Ri = new Be
  , Wl = new N
  , Wo = new N
  , XA = new N
  , qA = new Sn
  , Ag = new N(1,0,0)
  , Tg = new N(0,1,0)
  , Cg = new N(0,0,1)
  , Rg = {
    type: "added"
}
  , $A = {
    type: "removed"
}
  , Ns = {
    type: "childadded",
    child: null
}
  , Mf = {
    type: "childremoved",
    child: null
};
class tt extends Si {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: WA++
        }),
        this.uuid = Nn(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = tt.DEFAULT_UP.clone();
        const e = new N
          , t = new Un
          , i = new Sn
          , r = new N(1,1,1);
        function s() {
            i.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(i, void 0, !1)
        }
        t._onChange(s),
        i._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new Be
            },
            normalMatrix: {
                value: new Ye
            }
        }),
        this.matrix = new Be,
        this.matrixWorld = new Be,
        this.matrixAutoUpdate = tt.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = tt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new ph,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return Ds.setFromAxisAngle(e, t),
        this.quaternion.multiply(Ds),
        this
    }
    rotateOnWorldAxis(e, t) {
        return Ds.setFromAxisAngle(e, t),
        this.quaternion.premultiply(Ds),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(Ag, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(Tg, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(Cg, e)
    }
    translateOnAxis(e, t) {
        return Eg.copy(e).applyQuaternion(this.quaternion),
        this.position.add(Eg.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(Ag, e)
    }
    translateY(e) {
        return this.translateOnAxis(Tg, e)
    }
    translateZ(e) {
        return this.translateOnAxis(Cg, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(Ri.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, i) {
        e.isVector3 ? Wl.copy(e) : Wl.set(e, t, i);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1),
        Wo.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? Ri.lookAt(Wo, Wl, this.up) : Ri.lookAt(Wl, Wo, this.up),
        this.quaternion.setFromRotationMatrix(Ri),
        r && (Ri.extractRotation(r.matrixWorld),
        Ds.setFromRotationMatrix(Ri),
        this.quaternion.premultiply(Ds.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(Rg),
        Ns.child = e,
        this.dispatchEvent(Ns),
        Ns.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++)
                this.remove(arguments[i]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent($A),
        Mf.child = e,
        this.dispatchEvent(Mf),
        Mf.child = null),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        Ri.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        Ri.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(Ri),
        e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.updateWorldMatrix(!1, !0),
        e.dispatchEvent(Rg),
        Ns.child = e,
        this.dispatchEvent(Ns),
        Ns.child = null,
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let i = 0, r = this.children.length; i < r; i++) {
            const o = this.children[i].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t, i=[]) {
        this[e] === t && i.push(this);
        const r = this.children;
        for (let s = 0, o = r.length; s < o; s++)
            r[s].getObjectsByProperty(e, t, i);
        return i
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Wo, e, XA),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Wo, qA, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let i = 0, r = t.length; i < r; i++)
            t[i].updateMatrixWorld(e)
    }
    updateWorldMatrix(e, t) {
        const i = this.parent;
        if (e === !0 && i !== null && i.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        t === !0) {
            const r = this.children;
            for (let s = 0, o = r.length; s < o; s++)
                r[s].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , i = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        i.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const r = {};
        r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.castShadow === !0 && (r.castShadow = !0),
        this.receiveShadow === !0 && (r.receiveShadow = !0),
        this.visible === !1 && (r.visible = !1),
        this.frustumCulled === !1 && (r.frustumCulled = !1),
        this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        r.layers = this.layers.mask,
        r.matrix = this.matrix.toArray(),
        r.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
        this.isInstancedMesh && (r.type = "InstancedMesh",
        r.count = this.count,
        r.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (r.type = "BatchedMesh",
        r.perObjectFrustumCulled = this.perObjectFrustumCulled,
        r.sortObjects = this.sortObjects,
        r.drawRanges = this._drawRanges,
        r.reservedRanges = this._reservedRanges,
        r.visibility = this._visibility,
        r.active = this._active,
        r.bounds = this._bounds.map(a => ({
            boxInitialized: a.boxInitialized,
            boxMin: a.box.min.toArray(),
            boxMax: a.box.max.toArray(),
            sphereInitialized: a.sphereInitialized,
            sphereRadius: a.sphere.radius,
            sphereCenter: a.sphere.center.toArray()
        })),
        r.maxInstanceCount = this._maxInstanceCount,
        r.maxVertexCount = this._maxVertexCount,
        r.maxIndexCount = this._maxIndexCount,
        r.geometryInitialized = this._geometryInitialized,
        r.geometryCount = this._geometryCount,
        r.matricesTexture = this._matricesTexture.toJSON(e),
        this._colorsTexture !== null && (r.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null && (r.boundingSphere = {
            center: r.boundingSphere.center.toArray(),
            radius: r.boundingSphere.radius
        }),
        this.boundingBox !== null && (r.boundingBox = {
            min: r.boundingBox.min.toArray(),
            max: r.boundingBox.max.toArray()
        }));
        function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)),
            l.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, u = l.length; c < u; c++) {
                        const h = l[c];
                        s(e.shapes, h)
                    }
                else
                    s(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
        r.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (s(e.skeletons, this.skeleton),
        r.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++)
                    a.push(s(e.materials, this.material[l]));
                r.material = a
            } else
                r.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            r.children = [];
            for (let a = 0; a < this.children.length; a++)
                r.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            r.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                r.animations.push(s(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , l = o(e.materials)
              , c = o(e.textures)
              , u = o(e.images)
              , h = o(e.shapes)
              , f = o(e.skeletons)
              , d = o(e.animations)
              , p = o(e.nodes);
            a.length > 0 && (i.geometries = a),
            l.length > 0 && (i.materials = l),
            c.length > 0 && (i.textures = c),
            u.length > 0 && (i.images = u),
            h.length > 0 && (i.shapes = h),
            f.length > 0 && (i.skeletons = f),
            d.length > 0 && (i.animations = d),
            p.length > 0 && (i.nodes = p)
        }
        return i.object = r,
        i;
        function o(a) {
            const l = [];
            for (const c in a) {
                const u = a[c];
                delete u.metadata,
                l.push(u)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let i = 0; i < e.children.length; i++) {
                const r = e.children[i];
                this.add(r.clone())
            }
        return this
    }
}
tt.DEFAULT_UP = new N(0,1,0);
tt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
tt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Yn = new N
  , Pi = new N
  , Sf = new N
  , Ii = new N
  , Us = new N
  , Os = new N
  , Pg = new N
  , wf = new N
  , Ef = new N
  , Af = new N;
class In {
    constructor(e=new N, t=new N, i=new N) {
        this.a = e,
        this.b = t,
        this.c = i
    }
    static getNormal(e, t, i, r) {
        r.subVectors(i, t),
        Yn.subVectors(e, t),
        r.cross(Yn);
        const s = r.lengthSq();
        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
    }
    static getBarycoord(e, t, i, r, s) {
        Yn.subVectors(r, t),
        Pi.subVectors(i, t),
        Sf.subVectors(e, t);
        const o = Yn.dot(Yn)
          , a = Yn.dot(Pi)
          , l = Yn.dot(Sf)
          , c = Pi.dot(Pi)
          , u = Pi.dot(Sf)
          , h = o * c - a * a;
        if (h === 0)
            return s.set(0, 0, 0),
            null;
        const f = 1 / h
          , d = (c * l - a * u) * f
          , p = (o * u - a * l) * f;
        return s.set(1 - d - p, p, d)
    }
    static containsPoint(e, t, i, r) {
        return this.getBarycoord(e, t, i, r, Ii) === null ? !1 : Ii.x >= 0 && Ii.y >= 0 && Ii.x + Ii.y <= 1
    }
    static getInterpolation(e, t, i, r, s, o, a, l) {
        return this.getBarycoord(e, t, i, r, Ii) === null ? (l.x = 0,
        l.y = 0,
        "z"in l && (l.z = 0),
        "w"in l && (l.w = 0),
        null) : (l.setScalar(0),
        l.addScaledVector(s, Ii.x),
        l.addScaledVector(o, Ii.y),
        l.addScaledVector(a, Ii.z),
        l)
    }
    static isFrontFacing(e, t, i, r) {
        return Yn.subVectors(i, t),
        Pi.subVectors(e, t),
        Yn.cross(Pi).dot(r) < 0
    }
    set(e, t, i) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(i),
        this
    }
    setFromPointsAndIndices(e, t, i, r) {
        return this.a.copy(e[t]),
        this.b.copy(e[i]),
        this.c.copy(e[r]),
        this
    }
    setFromAttributeAndIndices(e, t, i, r) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, i),
        this.c.fromBufferAttribute(e, r),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return Yn.subVectors(this.c, this.b),
        Pi.subVectors(this.a, this.b),
        Yn.cross(Pi).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return In.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return In.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getInterpolation(e, t, i, r, s) {
        return In.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    }
    containsPoint(e) {
        return In.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return In.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const i = this.a
          , r = this.b
          , s = this.c;
        let o, a;
        Us.subVectors(r, i),
        Os.subVectors(s, i),
        wf.subVectors(e, i);
        const l = Us.dot(wf)
          , c = Os.dot(wf);
        if (l <= 0 && c <= 0)
            return t.copy(i);
        Ef.subVectors(e, r);
        const u = Us.dot(Ef)
          , h = Os.dot(Ef);
        if (u >= 0 && h <= u)
            return t.copy(r);
        const f = l * h - u * c;
        if (f <= 0 && l >= 0 && u <= 0)
            return o = l / (l - u),
            t.copy(i).addScaledVector(Us, o);
        Af.subVectors(e, s);
        const d = Us.dot(Af)
          , p = Os.dot(Af);
        if (p >= 0 && d <= p)
            return t.copy(s);
        const v = d * c - l * p;
        if (v <= 0 && c >= 0 && p <= 0)
            return a = c / (c - p),
            t.copy(i).addScaledVector(Os, a);
        const g = u * p - d * h;
        if (g <= 0 && h - u >= 0 && d - p >= 0)
            return Pg.subVectors(s, r),
            a = (h - u) / (h - u + (d - p)),
            t.copy(r).addScaledVector(Pg, a);
        const m = 1 / (g + v + f);
        return o = v * m,
        a = f * m,
        t.copy(i).addScaledVector(Us, o).addScaledVector(Os, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const Vx = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , ar = {
    h: 0,
    s: 0,
    l: 0
}
  , Xl = {
    h: 0,
    s: 0,
    l: 0
};
function Tf(n, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}
class Ee {
    constructor(e, t, i) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, t, i)
    }
    set(e, t, i) {
        if (t === void 0 && i === void 0) {
            const r = e;
            r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r)
        } else
            this.setRGB(e, t, i);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=Rn) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        st.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, i, r=st.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = i,
        st.toWorkingColorSpace(this, r),
        this
    }
    setHSL(e, t, i, r=st.workingColorSpace) {
        if (e = Np(e, 1),
        t = It(t, 0, 1),
        i = It(i, 0, 1),
        t === 0)
            this.r = this.g = this.b = i;
        else {
            const s = i <= .5 ? i * (1 + t) : i + t - i * t
              , o = 2 * i - s;
            this.r = Tf(o, s, e + 1 / 3),
            this.g = Tf(o, s, e),
            this.b = Tf(o, s, e - 1 / 3)
        }
        return st.toWorkingColorSpace(this, r),
        this
    }
    setStyle(e, t=Rn) {
        function i(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let r;
        if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = r[1]
              , a = r[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return i(s[4]),
                    this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = r[1]
              , o = s.length;
            if (o === 3)
                return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
            if (o === 6)
                return this.setHex(parseInt(s, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=Rn) {
        const i = Vx[e.toLowerCase()];
        return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = go(e.r),
        this.g = go(e.g),
        this.b = go(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = pf(e.r),
        this.g = pf(e.g),
        this.b = pf(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=Rn) {
        return st.fromWorkingColorSpace(tn.copy(this), e),
        Math.round(It(tn.r * 255, 0, 255)) * 65536 + Math.round(It(tn.g * 255, 0, 255)) * 256 + Math.round(It(tn.b * 255, 0, 255))
    }
    getHexString(e=Rn) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=st.workingColorSpace) {
        st.fromWorkingColorSpace(tn.copy(this), t);
        const i = tn.r
          , r = tn.g
          , s = tn.b
          , o = Math.max(i, r, s)
          , a = Math.min(i, r, s);
        let l, c;
        const u = (a + o) / 2;
        if (a === o)
            l = 0,
            c = 0;
        else {
            const h = o - a;
            switch (c = u <= .5 ? h / (o + a) : h / (2 - o - a),
            o) {
            case i:
                l = (r - s) / h + (r < s ? 6 : 0);
                break;
            case r:
                l = (s - i) / h + 2;
                break;
            case s:
                l = (i - r) / h + 4;
                break
            }
            l /= 6
        }
        return e.h = l,
        e.s = c,
        e.l = u,
        e
    }
    getRGB(e, t=st.workingColorSpace) {
        return st.fromWorkingColorSpace(tn.copy(this), t),
        e.r = tn.r,
        e.g = tn.g,
        e.b = tn.b,
        e
    }
    getStyle(e=Rn) {
        st.fromWorkingColorSpace(tn.copy(this), e);
        const t = tn.r
          , i = tn.g
          , r = tn.b;
        return e !== Rn ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`
    }
    offsetHSL(e, t, i) {
        return this.getHSL(ar),
        this.setHSL(ar.h + e, ar.s + t, ar.l + i)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, i) {
        return this.r = e.r + (t.r - e.r) * i,
        this.g = e.g + (t.g - e.g) * i,
        this.b = e.b + (t.b - e.b) * i,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(ar),
        e.getHSL(Xl);
        const i = xa(ar.h, Xl.h, t)
          , r = xa(ar.s, Xl.s, t)
          , s = xa(ar.l, Xl.l, t);
        return this.setHSL(i, r, s),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , i = this.g
          , r = this.b
          , s = e.elements;
        return this.r = s[0] * t + s[3] * i + s[6] * r,
        this.g = s[1] * t + s[4] * i + s[7] * r,
        this.b = s[2] * t + s[5] * i + s[8] * r,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const tn = new Ee;
Ee.NAMES = Vx;
let YA = 0;
class cn extends Si {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: YA++
        }),
        this.uuid = Nn(),
        this.name = "",
        this.type = "Material",
        this.blending = us,
        this.side = Wi,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = iu,
        this.blendDst = ru,
        this.blendEquation = yr,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new Ee(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = Ba,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = Ad,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = Kr,
        this.stencilZFail = Kr,
        this.stencilZPass = Kr,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const i = e[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const r = this[t];
                if (r === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const i = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        this.roughness !== void 0 && (i.roughness = this.roughness),
        this.metalness !== void 0 && (i.metalness = this.metalness),
        this.sheen !== void 0 && (i.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (i.shininess = this.shininess),
        this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.dispersion !== void 0 && (i.dispersion = this.dispersion),
        this.iridescence !== void 0 && (i.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid,
        i.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid,
        i.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid,
        i.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid,
        i.normalMapType = this.normalMapType,
        i.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid,
        i.displacementScale = this.displacementScale,
        i.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (i.combine = this.combine)),
        this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()),
        this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (i.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (i.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (i.size = this.size),
        this.shadowSide !== null && (i.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation),
        this.blending !== us && (i.blending = this.blending),
        this.side !== Wi && (i.side = this.side),
        this.vertexColors === !0 && (i.vertexColors = !0),
        this.opacity < 1 && (i.opacity = this.opacity),
        this.transparent === !0 && (i.transparent = !0),
        this.blendSrc !== iu && (i.blendSrc = this.blendSrc),
        this.blendDst !== ru && (i.blendDst = this.blendDst),
        this.blendEquation !== yr && (i.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
        this.depthFunc !== Ba && (i.depthFunc = this.depthFunc),
        this.depthTest === !1 && (i.depthTest = this.depthTest),
        this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== Ad && (i.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== Kr && (i.stencilFail = this.stencilFail),
        this.stencilZFail !== Kr && (i.stencilZFail = this.stencilZFail),
        this.stencilZPass !== Kr && (i.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation),
        this.polygonOffset === !0 && (i.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth),
        this.dashSize !== void 0 && (i.dashSize = this.dashSize),
        this.gapSize !== void 0 && (i.gapSize = this.gapSize),
        this.scale !== void 0 && (i.scale = this.scale),
        this.dithering === !0 && (i.dithering = !0),
        this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (i.alphaHash = !0),
        this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (i.forceSinglePass = !0),
        this.wireframe === !0 && (i.wireframe = !0),
        this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (i.flatShading = !0),
        this.visible === !1 && (i.visible = !1),
        this.toneMapped === !1 && (i.toneMapped = !1),
        this.fog === !1 && (i.fog = !1),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData);
        function r(s) {
            const o = [];
            for (const a in s) {
                const l = s[a];
                delete l.metadata,
                o.push(l)
            }
            return o
        }
        if (t) {
            const s = r(e.textures)
              , o = r(e.images);
            s.length > 0 && (i.textures = s),
            o.length > 0 && (i.images = o)
        }
        return i
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let i = null;
        if (t !== null) {
            const r = t.length;
            i = new Array(r);
            for (let s = 0; s !== r; ++s)
                i[s] = t[s].clone()
        }
        return this.clippingPlanes = i,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    onBuild() {
        console.warn("Material: onBuild() has been removed.")
    }
}
class Zi extends cn {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new Ee(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Un,
        this.combine = ml,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const Bi = jA();
function jA() {
    const n = new ArrayBuffer(4)
      , e = new Float32Array(n)
      , t = new Uint32Array(n)
      , i = new Uint32Array(512)
      , r = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const c = l - 127;
        c < -27 ? (i[l] = 0,
        i[l | 256] = 32768,
        r[l] = 24,
        r[l | 256] = 24) : c < -14 ? (i[l] = 1024 >> -c - 14,
        i[l | 256] = 1024 >> -c - 14 | 32768,
        r[l] = -c - 1,
        r[l | 256] = -c - 1) : c <= 15 ? (i[l] = c + 15 << 10,
        i[l | 256] = c + 15 << 10 | 32768,
        r[l] = 13,
        r[l | 256] = 13) : c < 128 ? (i[l] = 31744,
        i[l | 256] = 64512,
        r[l] = 24,
        r[l | 256] = 24) : (i[l] = 31744,
        i[l | 256] = 64512,
        r[l] = 13,
        r[l | 256] = 13)
    }
    const s = new Uint32Array(2048)
      , o = new Uint32Array(64)
      , a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let c = l << 13
          , u = 0;
        for (; !(c & 8388608); )
            c <<= 1,
            u -= 8388608;
        c &= -8388609,
        u += 947912704,
        s[l] = c | u
    }
    for (let l = 1024; l < 2048; ++l)
        s[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l)
        o[l] = l << 23;
    o[31] = 1199570944,
    o[32] = 2147483648;
    for (let l = 33; l < 63; ++l)
        o[l] = 2147483648 + (l - 32 << 23);
    o[63] = 3347054592;
    for (let l = 1; l < 64; ++l)
        l !== 32 && (a[l] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: i,
        shiftTable: r,
        mantissaTable: s,
        exponentTable: o,
        offsetTable: a
    }
}
function bn(n) {
    Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    n = It(n, -65504, 65504),
    Bi.floatView[0] = n;
    const e = Bi.uint32View[0]
      , t = e >> 23 & 511;
    return Bi.baseTable[t] + ((e & 8388607) >> Bi.shiftTable[t])
}
function oa(n) {
    const e = n >> 10;
    return Bi.uint32View[0] = Bi.mantissaTable[Bi.offsetTable[e] + (n & 1023)] + Bi.exponentTable[e],
    Bi.floatView[0]
}
const KA = {
    toHalfFloat: bn,
    fromHalfFloat: oa
}
  , Vt = new N
  , ql = new ae;
class pt {
    constructor(e, t, i=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = i,
        this.usage = Ya,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.gpuType = Mn,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return mo("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, t, i) {
        e *= this.itemSize,
        i *= t.itemSize;
        for (let r = 0, s = this.itemSize; r < s; r++)
            this.array[e + r] = t.array[i + r];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, i = this.count; t < i; t++)
                ql.fromBufferAttribute(this, t),
                ql.applyMatrix3(e),
                this.setXY(t, ql.x, ql.y);
        else if (this.itemSize === 3)
            for (let t = 0, i = this.count; t < i; t++)
                Vt.fromBufferAttribute(this, t),
                Vt.applyMatrix3(e),
                this.setXYZ(t, Vt.x, Vt.y, Vt.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Vt.fromBufferAttribute(this, t),
            Vt.applyMatrix4(e),
            this.setXYZ(t, Vt.x, Vt.y, Vt.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Vt.fromBufferAttribute(this, t),
            Vt.applyNormalMatrix(e),
            this.setXYZ(t, Vt.x, Vt.y, Vt.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            Vt.fromBufferAttribute(this, t),
            Vt.transformDirection(e),
            this.setXYZ(t, Vt.x, Vt.y, Vt.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getComponent(e, t) {
        let i = this.array[e * this.itemSize + t];
        return this.normalized && (i = gn(i, this.array)),
        i
    }
    setComponent(e, t, i) {
        return this.normalized && (i = je(i, this.array)),
        this.array[e * this.itemSize + t] = i,
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = gn(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = je(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = gn(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = je(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = gn(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = je(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = gn(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = je(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, i) {
        return e *= this.itemSize,
        this.normalized && (t = je(t, this.array),
        i = je(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, r) {
        return e *= this.itemSize,
        this.normalized && (t = je(t, this.array),
        i = je(i, this.array),
        r = je(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this
    }
    setXYZW(e, t, i, r, s) {
        return e *= this.itemSize,
        this.normalized && (t = je(t, this.array),
        i = je(i, this.array),
        r = je(r, this.array),
        s = je(s, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = i,
        this.array[e + 2] = r,
        this.array[e + 3] = s,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== Ya && (e.usage = this.usage),
        e
    }
}
class ZA extends pt {
    constructor(e, t, i) {
        super(new Int8Array(e), t, i)
    }
}
class JA extends pt {
    constructor(e, t, i) {
        super(new Uint8Array(e), t, i)
    }
}
class QA extends pt {
    constructor(e, t, i) {
        super(new Uint8ClampedArray(e), t, i)
    }
}
class eT extends pt {
    constructor(e, t, i) {
        super(new Int16Array(e), t, i)
    }
}
class Fp extends pt {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i)
    }
}
class tT extends pt {
    constructor(e, t, i) {
        super(new Int32Array(e), t, i)
    }
}
class Bp extends pt {
    constructor(e, t, i) {
        super(new Uint32Array(e), t, i)
    }
}
class nT extends pt {
    constructor(e, t, i) {
        super(new Uint16Array(e), t, i),
        this.isFloat16BufferAttribute = !0
    }
    getX(e) {
        let t = oa(this.array[e * this.itemSize]);
        return this.normalized && (t = gn(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = je(t, this.array)),
        this.array[e * this.itemSize] = bn(t),
        this
    }
    getY(e) {
        let t = oa(this.array[e * this.itemSize + 1]);
        return this.normalized && (t = gn(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = je(t, this.array)),
        this.array[e * this.itemSize + 1] = bn(t),
        this
    }
    getZ(e) {
        let t = oa(this.array[e * this.itemSize + 2]);
        return this.normalized && (t = gn(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = je(t, this.array)),
        this.array[e * this.itemSize + 2] = bn(t),
        this
    }
    getW(e) {
        let t = oa(this.array[e * this.itemSize + 3]);
        return this.normalized && (t = gn(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = je(t, this.array)),
        this.array[e * this.itemSize + 3] = bn(t),
        this
    }
    setXY(e, t, i) {
        return e *= this.itemSize,
        this.normalized && (t = je(t, this.array),
        i = je(i, this.array)),
        this.array[e + 0] = bn(t),
        this.array[e + 1] = bn(i),
        this
    }
    setXYZ(e, t, i, r) {
        return e *= this.itemSize,
        this.normalized && (t = je(t, this.array),
        i = je(i, this.array),
        r = je(r, this.array)),
        this.array[e + 0] = bn(t),
        this.array[e + 1] = bn(i),
        this.array[e + 2] = bn(r),
        this
    }
    setXYZW(e, t, i, r, s) {
        return e *= this.itemSize,
        this.normalized && (t = je(t, this.array),
        i = je(i, this.array),
        r = je(r, this.array),
        s = je(s, this.array)),
        this.array[e + 0] = bn(t),
        this.array[e + 1] = bn(i),
        this.array[e + 2] = bn(r),
        this.array[e + 3] = bn(s),
        this
    }
}
class Le extends pt {
    constructor(e, t, i) {
        super(new Float32Array(e), t, i)
    }
}
let iT = 0;
const Bn = new Be
  , Cf = new tt
  , Fs = new N
  , Cn = new yn
  , Xo = new yn
  , $t = new N;
class Ze extends Si {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: iT++
        }),
        this.uuid = Nn(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (Fx(e) ? Bp : Fp)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, i=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: i
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const i = this.attributes.normal;
        if (i !== void 0) {
            const s = new Ye().getNormalMatrix(e);
            i.applyNormalMatrix(s),
            i.needsUpdate = !0
        }
        const r = this.attributes.tangent;
        return r !== void 0 && (r.transformDirection(e),
        r.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return Bn.makeRotationFromQuaternion(e),
        this.applyMatrix4(Bn),
        this
    }
    rotateX(e) {
        return Bn.makeRotationX(e),
        this.applyMatrix4(Bn),
        this
    }
    rotateY(e) {
        return Bn.makeRotationY(e),
        this.applyMatrix4(Bn),
        this
    }
    rotateZ(e) {
        return Bn.makeRotationZ(e),
        this.applyMatrix4(Bn),
        this
    }
    translate(e, t, i) {
        return Bn.makeTranslation(e, t, i),
        this.applyMatrix4(Bn),
        this
    }
    scale(e, t, i) {
        return Bn.makeScale(e, t, i),
        this.applyMatrix4(Bn),
        this
    }
    lookAt(e) {
        return Cf.lookAt(e),
        Cf.updateMatrix(),
        this.applyMatrix4(Cf.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(Fs).negate(),
        this.translate(Fs.x, Fs.y, Fs.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let i = 0, r = e.length; i < r; i++) {
            const s = e[i];
            t.push(s.x, s.y, s.z || 0)
        }
        return this.setAttribute("position", new Le(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new yn);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
            this.boundingBox.set(new N(-1 / 0,-1 / 0,-1 / 0), new N(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let i = 0, r = t.length; i < r; i++) {
                    const s = t[i];
                    Cn.setFromBufferAttribute(s),
                    this.morphTargetsRelative ? ($t.addVectors(this.boundingBox.min, Cn.min),
                    this.boundingBox.expandByPoint($t),
                    $t.addVectors(this.boundingBox.max, Cn.max),
                    this.boundingBox.expandByPoint($t)) : (this.boundingBox.expandByPoint(Cn.min),
                    this.boundingBox.expandByPoint(Cn.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new an);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
            this.boundingSphere.set(new N, 1 / 0);
            return
        }
        if (e) {
            const i = this.boundingSphere.center;
            if (Cn.setFromBufferAttribute(e),
            t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    Xo.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? ($t.addVectors(Cn.min, Xo.min),
                    Cn.expandByPoint($t),
                    $t.addVectors(Cn.max, Xo.max),
                    Cn.expandByPoint($t)) : (Cn.expandByPoint(Xo.min),
                    Cn.expandByPoint(Xo.max))
                }
            Cn.getCenter(i);
            let r = 0;
            for (let s = 0, o = e.count; s < o; s++)
                $t.fromBufferAttribute(e, s),
                r = Math.max(r, i.distanceToSquared($t));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s]
                      , l = this.morphTargetsRelative;
                    for (let c = 0, u = a.count; c < u; c++)
                        $t.fromBufferAttribute(a, c),
                        l && (Fs.fromBufferAttribute(e, c),
                        $t.add(Fs)),
                        r = Math.max(r, i.distanceToSquared($t))
                }
            this.boundingSphere.radius = Math.sqrt(r),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const i = t.position
          , r = t.normal
          , s = t.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new pt(new Float32Array(4 * i.count),4));
        const o = this.getAttribute("tangent")
          , a = []
          , l = [];
        for (let L = 0; L < i.count; L++)
            a[L] = new N,
            l[L] = new N;
        const c = new N
          , u = new N
          , h = new N
          , f = new ae
          , d = new ae
          , p = new ae
          , v = new N
          , g = new N;
        function m(L, S, b) {
            c.fromBufferAttribute(i, L),
            u.fromBufferAttribute(i, S),
            h.fromBufferAttribute(i, b),
            f.fromBufferAttribute(s, L),
            d.fromBufferAttribute(s, S),
            p.fromBufferAttribute(s, b),
            u.sub(c),
            h.sub(c),
            d.sub(f),
            p.sub(f);
            const D = 1 / (d.x * p.y - p.x * d.y);
            isFinite(D) && (v.copy(u).multiplyScalar(p.y).addScaledVector(h, -d.y).multiplyScalar(D),
            g.copy(h).multiplyScalar(d.x).addScaledVector(u, -p.x).multiplyScalar(D),
            a[L].add(v),
            a[S].add(v),
            a[b].add(v),
            l[L].add(g),
            l[S].add(g),
            l[b].add(g))
        }
        let y = this.groups;
        y.length === 0 && (y = [{
            start: 0,
            count: e.count
        }]);
        for (let L = 0, S = y.length; L < S; ++L) {
            const b = y[L]
              , D = b.start
              , F = b.count;
            for (let z = D, $ = D + F; z < $; z += 3)
                m(e.getX(z + 0), e.getX(z + 1), e.getX(z + 2))
        }
        const _ = new N
          , x = new N
          , C = new N
          , w = new N;
        function E(L) {
            C.fromBufferAttribute(r, L),
            w.copy(C);
            const S = a[L];
            _.copy(S),
            _.sub(C.multiplyScalar(C.dot(S))).normalize(),
            x.crossVectors(w, S);
            const D = x.dot(l[L]) < 0 ? -1 : 1;
            o.setXYZW(L, _.x, _.y, _.z, D)
        }
        for (let L = 0, S = y.length; L < S; ++L) {
            const b = y[L]
              , D = b.start
              , F = b.count;
            for (let z = D, $ = D + F; z < $; z += 3)
                E(e.getX(z + 0)),
                E(e.getX(z + 1)),
                E(e.getX(z + 2))
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0)
                i = new pt(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", i);
            else
                for (let f = 0, d = i.count; f < d; f++)
                    i.setXYZ(f, 0, 0, 0);
            const r = new N
              , s = new N
              , o = new N
              , a = new N
              , l = new N
              , c = new N
              , u = new N
              , h = new N;
            if (e)
                for (let f = 0, d = e.count; f < d; f += 3) {
                    const p = e.getX(f + 0)
                      , v = e.getX(f + 1)
                      , g = e.getX(f + 2);
                    r.fromBufferAttribute(t, p),
                    s.fromBufferAttribute(t, v),
                    o.fromBufferAttribute(t, g),
                    u.subVectors(o, s),
                    h.subVectors(r, s),
                    u.cross(h),
                    a.fromBufferAttribute(i, p),
                    l.fromBufferAttribute(i, v),
                    c.fromBufferAttribute(i, g),
                    a.add(u),
                    l.add(u),
                    c.add(u),
                    i.setXYZ(p, a.x, a.y, a.z),
                    i.setXYZ(v, l.x, l.y, l.z),
                    i.setXYZ(g, c.x, c.y, c.z)
                }
            else
                for (let f = 0, d = t.count; f < d; f += 3)
                    r.fromBufferAttribute(t, f + 0),
                    s.fromBufferAttribute(t, f + 1),
                    o.fromBufferAttribute(t, f + 2),
                    u.subVectors(o, s),
                    h.subVectors(r, s),
                    u.cross(h),
                    i.setXYZ(f + 0, u.x, u.y, u.z),
                    i.setXYZ(f + 1, u.x, u.y, u.z),
                    i.setXYZ(f + 2, u.x, u.y, u.z);
            this.normalizeNormals(),
            i.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++)
            $t.fromBufferAttribute(e, t),
            $t.normalize(),
            e.setXYZ(t, $t.x, $t.y, $t.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const c = a.array
              , u = a.itemSize
              , h = a.normalized
              , f = new c.constructor(l.length * u);
            let d = 0
              , p = 0;
            for (let v = 0, g = l.length; v < g; v++) {
                a.isInterleavedBufferAttribute ? d = l[v] * a.data.stride + a.offset : d = l[v] * u;
                for (let m = 0; m < u; m++)
                    f[p++] = c[d++]
            }
            return new pt(f,u,h)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new Ze
          , i = this.index.array
          , r = this.attributes;
        for (const a in r) {
            const l = r[a]
              , c = e(l, i);
            t.setAttribute(a, c)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const l = []
              , c = s[a];
            for (let u = 0, h = c.length; u < h; u++) {
                const f = c[u]
                  , d = e(f, i);
                l.push(d)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l)
                l[c] !== void 0 && (e[c] = l[c]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const i = this.attributes;
        for (const l in i) {
            const c = i[l];
            e.data.attributes[l] = c.toJSON(e.data)
        }
        const r = {};
        let s = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l]
              , u = [];
            for (let h = 0, f = c.length; h < f; h++) {
                const d = c[h];
                u.push(d.toJSON(e.data))
            }
            u.length > 0 && (r[l] = u,
            s = !0)
        }
        s && (e.data.morphAttributes = r,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone(t));
        const r = e.attributes;
        for (const c in r) {
            const u = r[c];
            this.setAttribute(c, u.clone(t))
        }
        const s = e.morphAttributes;
        for (const c in s) {
            const u = []
              , h = s[c];
            for (let f = 0, d = h.length; f < d; f++)
                u.push(h[f].clone(t));
            this.morphAttributes[c] = u
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let c = 0, u = o.length; c < u; c++) {
            const h = o[c];
            this.addGroup(h.start, h.count, h.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const Ig = new Be
  , zr = new No
  , $l = new an
  , Lg = new N
  , Bs = new N
  , zs = new N
  , ks = new N
  , Rf = new N
  , Yl = new N
  , jl = new ae
  , Kl = new ae
  , Zl = new ae
  , Dg = new N
  , Ng = new N
  , Ug = new N
  , Jl = new N
  , Ql = new N;
class Ot extends tt {
    constructor(e=new Ze, t=new Zi) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const i = this.geometry
          , r = i.attributes.position
          , s = i.morphAttributes.position
          , o = i.morphTargetsRelative;
        t.fromBufferAttribute(r, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            Yl.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
                const u = a[l]
                  , h = s[l];
                u !== 0 && (Rf.fromBufferAttribute(h, e),
                o ? Yl.addScaledVector(Rf, u) : Yl.addScaledVector(Rf.sub(t), u))
            }
            t.add(Yl)
        }
        return t
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.material
          , s = this.matrixWorld;
        r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(),
        $l.copy(i.boundingSphere),
        $l.applyMatrix4(s),
        zr.copy(e.ray).recast(e.near),
        !($l.containsPoint(zr.origin) === !1 && (zr.intersectSphere($l, Lg) === null || zr.origin.distanceToSquared(Lg) > (e.far - e.near) ** 2)) && (Ig.copy(s).invert(),
        zr.copy(e.ray).applyMatrix4(Ig),
        !(i.boundingBox !== null && zr.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, zr)))
    }
    _computeIntersections(e, t, i) {
        let r;
        const s = this.geometry
          , o = this.material
          , a = s.index
          , l = s.attributes.position
          , c = s.attributes.uv
          , u = s.attributes.uv1
          , h = s.attributes.normal
          , f = s.groups
          , d = s.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let p = 0, v = f.length; p < v; p++) {
                    const g = f[p]
                      , m = o[g.materialIndex]
                      , y = Math.max(g.start, d.start)
                      , _ = Math.min(a.count, Math.min(g.start + g.count, d.start + d.count));
                    for (let x = y, C = _; x < C; x += 3) {
                        const w = a.getX(x)
                          , E = a.getX(x + 1)
                          , L = a.getX(x + 2);
                        r = ec(this, m, e, i, c, u, h, w, E, L),
                        r && (r.faceIndex = Math.floor(x / 3),
                        r.face.materialIndex = g.materialIndex,
                        t.push(r))
                    }
                }
            else {
                const p = Math.max(0, d.start)
                  , v = Math.min(a.count, d.start + d.count);
                for (let g = p, m = v; g < m; g += 3) {
                    const y = a.getX(g)
                      , _ = a.getX(g + 1)
                      , x = a.getX(g + 2);
                    r = ec(this, o, e, i, c, u, h, y, _, x),
                    r && (r.faceIndex = Math.floor(g / 3),
                    t.push(r))
                }
            }
        else if (l !== void 0)
            if (Array.isArray(o))
                for (let p = 0, v = f.length; p < v; p++) {
                    const g = f[p]
                      , m = o[g.materialIndex]
                      , y = Math.max(g.start, d.start)
                      , _ = Math.min(l.count, Math.min(g.start + g.count, d.start + d.count));
                    for (let x = y, C = _; x < C; x += 3) {
                        const w = x
                          , E = x + 1
                          , L = x + 2;
                        r = ec(this, m, e, i, c, u, h, w, E, L),
                        r && (r.faceIndex = Math.floor(x / 3),
                        r.face.materialIndex = g.materialIndex,
                        t.push(r))
                    }
                }
            else {
                const p = Math.max(0, d.start)
                  , v = Math.min(l.count, d.start + d.count);
                for (let g = p, m = v; g < m; g += 3) {
                    const y = g
                      , _ = g + 1
                      , x = g + 2;
                    r = ec(this, o, e, i, c, u, h, y, _, x),
                    r && (r.faceIndex = Math.floor(g / 3),
                    t.push(r))
                }
            }
    }
}
function rT(n, e, t, i, r, s, o, a) {
    let l;
    if (e.side === _n ? l = i.intersectTriangle(o, s, r, !0, a) : l = i.intersectTriangle(r, s, o, e.side === Wi, a),
    l === null)
        return null;
    Ql.copy(a),
    Ql.applyMatrix4(n.matrixWorld);
    const c = t.ray.origin.distanceTo(Ql);
    return c < t.near || c > t.far ? null : {
        distance: c,
        point: Ql.clone(),
        object: n
    }
}
function ec(n, e, t, i, r, s, o, a, l, c) {
    n.getVertexPosition(a, Bs),
    n.getVertexPosition(l, zs),
    n.getVertexPosition(c, ks);
    const u = rT(n, e, t, i, Bs, zs, ks, Jl);
    if (u) {
        r && (jl.fromBufferAttribute(r, a),
        Kl.fromBufferAttribute(r, l),
        Zl.fromBufferAttribute(r, c),
        u.uv = In.getInterpolation(Jl, Bs, zs, ks, jl, Kl, Zl, new ae)),
        s && (jl.fromBufferAttribute(s, a),
        Kl.fromBufferAttribute(s, l),
        Zl.fromBufferAttribute(s, c),
        u.uv1 = In.getInterpolation(Jl, Bs, zs, ks, jl, Kl, Zl, new ae)),
        o && (Dg.fromBufferAttribute(o, a),
        Ng.fromBufferAttribute(o, l),
        Ug.fromBufferAttribute(o, c),
        u.normal = In.getInterpolation(Jl, Bs, zs, ks, Dg, Ng, Ug, new N),
        u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
        const h = {
            a,
            b: l,
            c,
            normal: new N,
            materialIndex: 0
        };
        In.getNormal(Bs, zs, ks, h.normal),
        u.face = h
    }
    return u
}
class Ss extends Ze {
    constructor(e=1, t=1, i=1, r=1, s=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: r,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        r = Math.floor(r),
        s = Math.floor(s),
        o = Math.floor(o);
        const l = []
          , c = []
          , u = []
          , h = [];
        let f = 0
          , d = 0;
        p("z", "y", "x", -1, -1, i, t, e, o, s, 0),
        p("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
        p("x", "z", "y", 1, 1, e, i, t, r, o, 2),
        p("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
        p("x", "y", "z", 1, -1, e, t, i, r, s, 4),
        p("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
        this.setIndex(l),
        this.setAttribute("position", new Le(c,3)),
        this.setAttribute("normal", new Le(u,3)),
        this.setAttribute("uv", new Le(h,2));
        function p(v, g, m, y, _, x, C, w, E, L, S) {
            const b = x / E
              , D = C / L
              , F = x / 2
              , z = C / 2
              , $ = w / 2
              , ne = E + 1
              , W = L + 1;
            let ie = 0
              , Z = 0;
            const ve = new N;
            for (let xe = 0; xe < W; xe++) {
                const te = xe * D - z;
                for (let Se = 0; Se < ne; Se++) {
                    const ze = Se * b - F;
                    ve[v] = ze * y,
                    ve[g] = te * _,
                    ve[m] = $,
                    c.push(ve.x, ve.y, ve.z),
                    ve[v] = 0,
                    ve[g] = 0,
                    ve[m] = w > 0 ? 1 : -1,
                    u.push(ve.x, ve.y, ve.z),
                    h.push(Se / E),
                    h.push(1 - xe / L),
                    ie += 1
                }
            }
            for (let xe = 0; xe < L; xe++)
                for (let te = 0; te < E; te++) {
                    const Se = f + te + ne * xe
                      , ze = f + te + ne * (xe + 1)
                      , re = f + (te + 1) + ne * (xe + 1)
                      , pe = f + (te + 1) + ne * xe;
                    l.push(Se, ze, pe),
                    l.push(ze, re, pe),
                    Z += 6
                }
            a.addGroup(d, Z, S),
            d += Z,
            f += ie
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Ss(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function So(n) {
    const e = {};
    for (const t in n) {
        e[t] = {};
        for (const i in n[t]) {
            const r = n[t][i];
            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[t][i] = null) : e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r
        }
    }
    return e
}
function fn(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const i = So(n[t]);
        for (const r in i)
            e[r] = i[r]
    }
    return e
}
function sT(n) {
    const e = [];
    for (let t = 0; t < n.length; t++)
        e.push(n[t].clone());
    return e
}
function Hx(n) {
    const e = n.getRenderTarget();
    return e === null ? n.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : st.workingColorSpace
}
const Gx = {
    clone: So,
    merge: fn
};
var oT = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , aT = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class oi extends cn {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = oT,
        this.fragmentShader = aT,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = So(e.uniforms),
        this.uniformsGroups = sT(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const r in this.uniforms) {
            const o = this.uniforms[r].value;
            o && o.isTexture ? t.uniforms[r] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[r] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[r] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[r] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[r] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[r] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[r] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[r] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const i = {};
        for (const r in this.extensions)
            this.extensions[r] === !0 && (i[r] = !0);
        return Object.keys(i).length > 0 && (t.extensions = i),
        t
    }
}
class _l extends tt {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new Be,
        this.projectionMatrix = new Be,
        this.projectionMatrixInverse = new Be,
        this.coordinateSystem = mi
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const lr = new N
  , Og = new ae
  , Fg = new ae;
class Ht extends _l {
    constructor(e=50, t=1, i=.1, r=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = i,
        this.far = r,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = Mo * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(fs * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Mo * 2 * Math.atan(Math.tan(fs * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, t, i) {
        lr.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
        t.set(lr.x, lr.y).multiplyScalar(-e / lr.z),
        lr.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
        i.set(lr.x, lr.y).multiplyScalar(-e / lr.z)
    }
    getViewSize(e, t) {
        return this.getViewBounds(e, Og, Fg),
        t.subVectors(Fg, Og)
    }
    setViewOffset(e, t, i, r, s, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(fs * .5 * this.fov) / this.zoom
          , i = 2 * t
          , r = this.aspect * i
          , s = -.5 * r;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth
              , c = o.fullHeight;
            s += o.offsetX * r / l,
            t -= o.offsetY * i / c,
            r *= o.width / l,
            i *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const Vs = -90
  , Hs = 1;
class Wx extends tt {
    constructor(e, t, i) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = i,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const r = new Ht(Vs,Hs,e,t);
        r.layers = this.layers,
        this.add(r);
        const s = new Ht(Vs,Hs,e,t);
        s.layers = this.layers,
        this.add(s);
        const o = new Ht(Vs,Hs,e,t);
        o.layers = this.layers,
        this.add(o);
        const a = new Ht(Vs,Hs,e,t);
        a.layers = this.layers,
        this.add(a);
        const l = new Ht(Vs,Hs,e,t);
        l.layers = this.layers,
        this.add(l);
        const c = new Ht(Vs,Hs,e,t);
        c.layers = this.layers,
        this.add(c)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , t = this.children.concat()
          , [i,r,s,o,a,l] = t;
        for (const c of t)
            this.remove(c);
        if (e === mi)
            i.up.set(0, 1, 0),
            i.lookAt(1, 0, 0),
            r.up.set(0, 1, 0),
            r.lookAt(-1, 0, 0),
            s.up.set(0, 0, -1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, -1, 0),
            a.up.set(0, 1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, 1, 0),
            l.lookAt(0, 0, -1);
        else if (e === ja)
            i.up.set(0, -1, 0),
            i.lookAt(-1, 0, 0),
            r.up.set(0, -1, 0),
            r.lookAt(1, 0, 0),
            s.up.set(0, 0, 1),
            s.lookAt(0, 1, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, -1, 0),
            a.up.set(0, -1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, -1, 0),
            l.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const c of t)
            this.add(c),
            c.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: i, activeMipmapLevel: r} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [s,o,a,l,c,u] = this.children
          , h = e.getRenderTarget()
          , f = e.getActiveCubeFace()
          , d = e.getActiveMipmapLevel()
          , p = e.xr.enabled;
        e.xr.enabled = !1;
        const v = i.texture.generateMipmaps;
        i.texture.generateMipmaps = !1,
        e.setRenderTarget(i, 0, r),
        e.render(t, s),
        e.setRenderTarget(i, 1, r),
        e.render(t, o),
        e.setRenderTarget(i, 2, r),
        e.render(t, a),
        e.setRenderTarget(i, 3, r),
        e.render(t, l),
        e.setRenderTarget(i, 4, r),
        e.render(t, c),
        i.texture.generateMipmaps = v,
        e.setRenderTarget(i, 5, r),
        e.render(t, u),
        e.setRenderTarget(h, f, d),
        e.xr.enabled = p,
        i.texture.needsPMREMUpdate = !0
    }
}
class yl extends Dt {
    constructor(e, t, i, r, s, o, a, l, c, u) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : Xi,
        super(e, t, i, r, s, o, a, l, c, u),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class Xx extends si {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const i = {
            width: e,
            height: e,
            depth: 1
        }
          , r = [i, i, i, i, i, i];
        this.texture = new yl(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Gt
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const i = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , r = new Ss(5,5,5)
          , s = new oi({
            name: "CubemapFromEquirect",
            uniforms: So(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: _n,
            blending: Vi
        });
        s.uniforms.tEquirect.value = t;
        const o = new Ot(r,s)
          , a = t.minFilter;
        return t.minFilter === pi && (t.minFilter = Gt),
        new Wx(1,10,this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t, i, r) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, i, r);
        e.setRenderTarget(s)
    }
}
const Pf = new N
  , lT = new N
  , cT = new Ye;
class gr {
    constructor(e=new N(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, i, r) {
        return this.normal.set(e, t, i),
        this.constant = r,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, i) {
        const r = Pf.subVectors(i, t).cross(lT.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const i = e.delta(Pf)
          , r = this.normal.dot(i);
        if (r === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / r;
        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , i = this.distanceToPoint(e.end);
        return t < 0 && i > 0 || i < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const i = t || cT.getNormalMatrix(e)
          , r = this.coplanarPoint(Pf).applyMatrix4(e)
          , s = this.normal.applyMatrix3(i).normalize();
        return this.constant = -r.dot(s),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const kr = new an
  , tc = new N;
class xl {
    constructor(e=new gr, t=new gr, i=new gr, r=new gr, s=new gr, o=new gr) {
        this.planes = [e, t, i, r, s, o]
    }
    set(e, t, i, r, s, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(i),
        a[3].copy(r),
        a[4].copy(s),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            t[i].copy(e.planes[i]);
        return this
    }
    setFromProjectionMatrix(e, t=mi) {
        const i = this.planes
          , r = e.elements
          , s = r[0]
          , o = r[1]
          , a = r[2]
          , l = r[3]
          , c = r[4]
          , u = r[5]
          , h = r[6]
          , f = r[7]
          , d = r[8]
          , p = r[9]
          , v = r[10]
          , g = r[11]
          , m = r[12]
          , y = r[13]
          , _ = r[14]
          , x = r[15];
        if (i[0].setComponents(l - s, f - c, g - d, x - m).normalize(),
        i[1].setComponents(l + s, f + c, g + d, x + m).normalize(),
        i[2].setComponents(l + o, f + u, g + p, x + y).normalize(),
        i[3].setComponents(l - o, f - u, g - p, x - y).normalize(),
        i[4].setComponents(l - a, f - h, g - v, x - _).normalize(),
        t === mi)
            i[5].setComponents(l + a, f + h, g + v, x + _).normalize();
        else if (t === ja)
            i[5].setComponents(a, h, v, _).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            kr.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            kr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(kr)
    }
    intersectsSprite(e) {
        return kr.center.set(0, 0, 0),
        kr.radius = .7071067811865476,
        kr.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(kr)
    }
    intersectsSphere(e) {
        const t = this.planes
          , i = e.center
          , r = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(i) < r)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
            const r = t[i];
            if (tc.x = r.normal.x > 0 ? e.max.x : e.min.x,
            tc.y = r.normal.y > 0 ? e.max.y : e.min.y,
            tc.z = r.normal.z > 0 ? e.max.z : e.min.z,
            r.distanceToPoint(tc) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++)
            if (t[i].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function qx() {
    let n = null
      , e = !1
      , t = null
      , i = null;
    function r(s, o) {
        t(s, o),
        i = n.requestAnimationFrame(r)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (i = n.requestAnimationFrame(r),
            e = !0)
        },
        stop: function() {
            n.cancelAnimationFrame(i),
            e = !1
        },
        setAnimationLoop: function(s) {
            t = s
        },
        setContext: function(s) {
            n = s
        }
    }
}
function uT(n) {
    const e = new WeakMap;
    function t(a, l) {
        const c = a.array
          , u = a.usage
          , h = c.byteLength
          , f = n.createBuffer();
        n.bindBuffer(l, f),
        n.bufferData(l, c, u),
        a.onUploadCallback();
        let d;
        if (c instanceof Float32Array)
            d = n.FLOAT;
        else if (c instanceof Uint16Array)
            a.isFloat16BufferAttribute ? d = n.HALF_FLOAT : d = n.UNSIGNED_SHORT;
        else if (c instanceof Int16Array)
            d = n.SHORT;
        else if (c instanceof Uint32Array)
            d = n.UNSIGNED_INT;
        else if (c instanceof Int32Array)
            d = n.INT;
        else if (c instanceof Int8Array)
            d = n.BYTE;
        else if (c instanceof Uint8Array)
            d = n.UNSIGNED_BYTE;
        else if (c instanceof Uint8ClampedArray)
            d = n.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
        return {
            buffer: f,
            type: d,
            bytesPerElement: c.BYTES_PER_ELEMENT,
            version: a.version,
            size: h
        }
    }
    function i(a, l, c) {
        const u = l.array
          , h = l._updateRange
          , f = l.updateRanges;
        if (n.bindBuffer(c, a),
        h.count === -1 && f.length === 0 && n.bufferSubData(c, 0, u),
        f.length !== 0) {
            for (let d = 0, p = f.length; d < p; d++) {
                const v = f[d];
                n.bufferSubData(c, v.start * u.BYTES_PER_ELEMENT, u, v.start, v.count)
            }
            l.clearUpdateRanges()
        }
        h.count !== -1 && (n.bufferSubData(c, h.offset * u.BYTES_PER_ELEMENT, u, h.offset, h.count),
        h.count = -1),
        l.onUploadCallback()
    }
    function r(a) {
        return a.isInterleavedBufferAttribute && (a = a.data),
        e.get(a)
    }
    function s(a) {
        a.isInterleavedBufferAttribute && (a = a.data);
        const l = e.get(a);
        l && (n.deleteBuffer(l.buffer),
        e.delete(a))
    }
    function o(a, l) {
        if (a.isInterleavedBufferAttribute && (a = a.data),
        a.isGLBufferAttribute) {
            const u = e.get(a);
            (!u || u.version < a.version) && e.set(a, {
                buffer: a.buffer,
                type: a.type,
                bytesPerElement: a.elementSize,
                version: a.version
            });
            return
        }
        const c = e.get(a);
        if (c === void 0)
            e.set(a, t(a, l));
        else if (c.version < a.version) {
            if (c.size !== a.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            i(c.buffer, a, l),
            c.version = a.version
        }
    }
    return {
        get: r,
        remove: s,
        update: o
    }
}
class Uo extends Ze {
    constructor(e=1, t=1, i=1, r=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: r
        };
        const s = e / 2
          , o = t / 2
          , a = Math.floor(i)
          , l = Math.floor(r)
          , c = a + 1
          , u = l + 1
          , h = e / a
          , f = t / l
          , d = []
          , p = []
          , v = []
          , g = [];
        for (let m = 0; m < u; m++) {
            const y = m * f - o;
            for (let _ = 0; _ < c; _++) {
                const x = _ * h - s;
                p.push(x, -y, 0),
                v.push(0, 0, 1),
                g.push(_ / a),
                g.push(1 - m / l)
            }
        }
        for (let m = 0; m < l; m++)
            for (let y = 0; y < a; y++) {
                const _ = y + c * m
                  , x = y + c * (m + 1)
                  , C = y + 1 + c * (m + 1)
                  , w = y + 1 + c * m;
                d.push(_, x, w),
                d.push(x, C, w)
            }
        this.setIndex(d),
        this.setAttribute("position", new Le(p,3)),
        this.setAttribute("normal", new Le(v,3)),
        this.setAttribute("uv", new Le(g,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Uo(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var hT = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`
  , fT = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`
  , dT = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , pT = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , mT = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`
  , gT = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , vT = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , _T = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , yT = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`
  , xT = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`
  , bT = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`
  , MT = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , ST = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , wT = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , ET = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , AT = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`
  , TT = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , CT = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , RT = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , PT = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , IT = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , LT = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`
  , DT = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`
  , NT = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , UT = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , OT = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , FT = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , BT = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , zT = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , kT = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , VT = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , HT = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , GT = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , WT = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , XT = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , qT = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , $T = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , YT = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , jT = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , KT = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , ZT = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , JT = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , QT = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , e1 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , t1 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , n1 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , i1 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
  , r1 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , s1 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , o1 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , a1 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , l1 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`
  , c1 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , u1 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , h1 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , f1 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`
  , d1 = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , p1 = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , m1 = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , g1 = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`
  , v1 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , _1 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , y1 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , x1 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , b1 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , M1 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , S1 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`
  , w1 = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , E1 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , A1 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`
  , T1 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , C1 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`
  , R1 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , P1 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , I1 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , L1 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , D1 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , N1 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`
  , U1 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , O1 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , F1 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , B1 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , z1 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , k1 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , V1 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , H1 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , G1 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , W1 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , X1 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , q1 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`
  , $1 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , Y1 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , j1 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , K1 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , Z1 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , J1 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , Q1 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , eC = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , tC = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , nC = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , iC = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , rC = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`
  , sC = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`
  , oC = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , aC = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , lC = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , cC = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const uC = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , hC = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , fC = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , dC = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , pC = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , mC = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , gC = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , vC = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`
  , _C = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , yC = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , xC = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , bC = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , MC = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , SC = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , wC = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , EC = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , AC = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , TC = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , CC = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , RC = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , PC = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , IC = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , LC = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , DC = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , NC = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , UC = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , OC = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , FC = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , BC = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , zC = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , kC = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , VC = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , HC = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , GC = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , Ke = {
    alphahash_fragment: hT,
    alphahash_pars_fragment: fT,
    alphamap_fragment: dT,
    alphamap_pars_fragment: pT,
    alphatest_fragment: mT,
    alphatest_pars_fragment: gT,
    aomap_fragment: vT,
    aomap_pars_fragment: _T,
    batching_pars_vertex: yT,
    batching_vertex: xT,
    begin_vertex: bT,
    beginnormal_vertex: MT,
    bsdfs: ST,
    iridescence_fragment: wT,
    bumpmap_pars_fragment: ET,
    clipping_planes_fragment: AT,
    clipping_planes_pars_fragment: TT,
    clipping_planes_pars_vertex: CT,
    clipping_planes_vertex: RT,
    color_fragment: PT,
    color_pars_fragment: IT,
    color_pars_vertex: LT,
    color_vertex: DT,
    common: NT,
    cube_uv_reflection_fragment: UT,
    defaultnormal_vertex: OT,
    displacementmap_pars_vertex: FT,
    displacementmap_vertex: BT,
    emissivemap_fragment: zT,
    emissivemap_pars_fragment: kT,
    colorspace_fragment: VT,
    colorspace_pars_fragment: HT,
    envmap_fragment: GT,
    envmap_common_pars_fragment: WT,
    envmap_pars_fragment: XT,
    envmap_pars_vertex: qT,
    envmap_physical_pars_fragment: i1,
    envmap_vertex: $T,
    fog_vertex: YT,
    fog_pars_vertex: jT,
    fog_fragment: KT,
    fog_pars_fragment: ZT,
    gradientmap_pars_fragment: JT,
    lightmap_pars_fragment: QT,
    lights_lambert_fragment: e1,
    lights_lambert_pars_fragment: t1,
    lights_pars_begin: n1,
    lights_toon_fragment: r1,
    lights_toon_pars_fragment: s1,
    lights_phong_fragment: o1,
    lights_phong_pars_fragment: a1,
    lights_physical_fragment: l1,
    lights_physical_pars_fragment: c1,
    lights_fragment_begin: u1,
    lights_fragment_maps: h1,
    lights_fragment_end: f1,
    logdepthbuf_fragment: d1,
    logdepthbuf_pars_fragment: p1,
    logdepthbuf_pars_vertex: m1,
    logdepthbuf_vertex: g1,
    map_fragment: v1,
    map_pars_fragment: _1,
    map_particle_fragment: y1,
    map_particle_pars_fragment: x1,
    metalnessmap_fragment: b1,
    metalnessmap_pars_fragment: M1,
    morphinstance_vertex: S1,
    morphcolor_vertex: w1,
    morphnormal_vertex: E1,
    morphtarget_pars_vertex: A1,
    morphtarget_vertex: T1,
    normal_fragment_begin: C1,
    normal_fragment_maps: R1,
    normal_pars_fragment: P1,
    normal_pars_vertex: I1,
    normal_vertex: L1,
    normalmap_pars_fragment: D1,
    clearcoat_normal_fragment_begin: N1,
    clearcoat_normal_fragment_maps: U1,
    clearcoat_pars_fragment: O1,
    iridescence_pars_fragment: F1,
    opaque_fragment: B1,
    packing: z1,
    premultiplied_alpha_fragment: k1,
    project_vertex: V1,
    dithering_fragment: H1,
    dithering_pars_fragment: G1,
    roughnessmap_fragment: W1,
    roughnessmap_pars_fragment: X1,
    shadowmap_pars_fragment: q1,
    shadowmap_pars_vertex: $1,
    shadowmap_vertex: Y1,
    shadowmask_pars_fragment: j1,
    skinbase_vertex: K1,
    skinning_pars_vertex: Z1,
    skinning_vertex: J1,
    skinnormal_vertex: Q1,
    specularmap_fragment: eC,
    specularmap_pars_fragment: tC,
    tonemapping_fragment: nC,
    tonemapping_pars_fragment: iC,
    transmission_fragment: rC,
    transmission_pars_fragment: sC,
    uv_pars_fragment: oC,
    uv_pars_vertex: aC,
    uv_vertex: lC,
    worldpos_vertex: cC,
    background_vert: uC,
    background_frag: hC,
    backgroundCube_vert: fC,
    backgroundCube_frag: dC,
    cube_vert: pC,
    cube_frag: mC,
    depth_vert: gC,
    depth_frag: vC,
    distanceRGBA_vert: _C,
    distanceRGBA_frag: yC,
    equirect_vert: xC,
    equirect_frag: bC,
    linedashed_vert: MC,
    linedashed_frag: SC,
    meshbasic_vert: wC,
    meshbasic_frag: EC,
    meshlambert_vert: AC,
    meshlambert_frag: TC,
    meshmatcap_vert: CC,
    meshmatcap_frag: RC,
    meshnormal_vert: PC,
    meshnormal_frag: IC,
    meshphong_vert: LC,
    meshphong_frag: DC,
    meshphysical_vert: NC,
    meshphysical_frag: UC,
    meshtoon_vert: OC,
    meshtoon_frag: FC,
    points_vert: BC,
    points_frag: zC,
    shadow_vert: kC,
    shadow_frag: VC,
    sprite_vert: HC,
    sprite_frag: GC
}
  , we = {
    common: {
        diffuse: {
            value: new Ee(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new Ye
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new Ye
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new Ye
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        envMapRotation: {
            value: new Ye
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new Ye
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new Ye
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new Ye
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new Ye
        },
        normalScale: {
            value: new ae(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new Ye
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new Ye
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new Ye
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new Ye
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new Ee(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new Ee(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new Ye
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Ye
        }
    },
    sprite: {
        diffuse: {
            value: new Ee(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new ae(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new Ye
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new Ye
        },
        alphaTest: {
            value: 0
        }
    }
}
  , Kn = {
    basic: {
        uniforms: fn([we.common, we.specularmap, we.envmap, we.aomap, we.lightmap, we.fog]),
        vertexShader: Ke.meshbasic_vert,
        fragmentShader: Ke.meshbasic_frag
    },
    lambert: {
        uniforms: fn([we.common, we.specularmap, we.envmap, we.aomap, we.lightmap, we.emissivemap, we.bumpmap, we.normalmap, we.displacementmap, we.fog, we.lights, {
            emissive: {
                value: new Ee(0)
            }
        }]),
        vertexShader: Ke.meshlambert_vert,
        fragmentShader: Ke.meshlambert_frag
    },
    phong: {
        uniforms: fn([we.common, we.specularmap, we.envmap, we.aomap, we.lightmap, we.emissivemap, we.bumpmap, we.normalmap, we.displacementmap, we.fog, we.lights, {
            emissive: {
                value: new Ee(0)
            },
            specular: {
                value: new Ee(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: Ke.meshphong_vert,
        fragmentShader: Ke.meshphong_frag
    },
    standard: {
        uniforms: fn([we.common, we.envmap, we.aomap, we.lightmap, we.emissivemap, we.bumpmap, we.normalmap, we.displacementmap, we.roughnessmap, we.metalnessmap, we.fog, we.lights, {
            emissive: {
                value: new Ee(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: Ke.meshphysical_vert,
        fragmentShader: Ke.meshphysical_frag
    },
    toon: {
        uniforms: fn([we.common, we.aomap, we.lightmap, we.emissivemap, we.bumpmap, we.normalmap, we.displacementmap, we.gradientmap, we.fog, we.lights, {
            emissive: {
                value: new Ee(0)
            }
        }]),
        vertexShader: Ke.meshtoon_vert,
        fragmentShader: Ke.meshtoon_frag
    },
    matcap: {
        uniforms: fn([we.common, we.bumpmap, we.normalmap, we.displacementmap, we.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: Ke.meshmatcap_vert,
        fragmentShader: Ke.meshmatcap_frag
    },
    points: {
        uniforms: fn([we.points, we.fog]),
        vertexShader: Ke.points_vert,
        fragmentShader: Ke.points_frag
    },
    dashed: {
        uniforms: fn([we.common, we.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: Ke.linedashed_vert,
        fragmentShader: Ke.linedashed_frag
    },
    depth: {
        uniforms: fn([we.common, we.displacementmap]),
        vertexShader: Ke.depth_vert,
        fragmentShader: Ke.depth_frag
    },
    normal: {
        uniforms: fn([we.common, we.bumpmap, we.normalmap, we.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Ke.meshnormal_vert,
        fragmentShader: Ke.meshnormal_frag
    },
    sprite: {
        uniforms: fn([we.sprite, we.fog]),
        vertexShader: Ke.sprite_vert,
        fragmentShader: Ke.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Ye
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: Ke.background_vert,
        fragmentShader: Ke.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            },
            backgroundRotation: {
                value: new Ye
            }
        },
        vertexShader: Ke.backgroundCube_vert,
        fragmentShader: Ke.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: Ke.cube_vert,
        fragmentShader: Ke.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: Ke.equirect_vert,
        fragmentShader: Ke.equirect_frag
    },
    distanceRGBA: {
        uniforms: fn([we.common, we.displacementmap, {
            referencePosition: {
                value: new N
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: Ke.distanceRGBA_vert,
        fragmentShader: Ke.distanceRGBA_frag
    },
    shadow: {
        uniforms: fn([we.lights, we.fog, {
            color: {
                value: new Ee(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Ke.shadow_vert,
        fragmentShader: Ke.shadow_frag
    }
};
Kn.physical = {
    uniforms: fn([Kn.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new Ye
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new Ye
        },
        clearcoatNormalScale: {
            value: new ae(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new Ye
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new Ye
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new Ye
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new Ee(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new Ye
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new Ye
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new Ye
        },
        transmissionSamplerSize: {
            value: new ae
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new Ye
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new Ee(0)
        },
        specularColor: {
            value: new Ee(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new Ye
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new Ye
        },
        anisotropyVector: {
            value: new ae
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new Ye
        }
    }]),
    vertexShader: Ke.meshphysical_vert,
    fragmentShader: Ke.meshphysical_frag
};
const nc = {
    r: 0,
    b: 0,
    g: 0
}
  , Vr = new Un
  , WC = new Be;
function XC(n, e, t, i, r, s, o) {
    const a = new Ee(0);
    let l = s === !0 ? 0 : 1, c, u, h = null, f = 0, d = null;
    function p(y) {
        let _ = y.isScene === !0 ? y.background : null;
        return _ && _.isTexture && (_ = (y.backgroundBlurriness > 0 ? t : e).get(_)),
        _
    }
    function v(y) {
        let _ = !1;
        const x = p(y);
        x === null ? m(a, l) : x && x.isColor && (m(x, 1),
        _ = !0);
        const C = n.xr.getEnvironmentBlendMode();
        C === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : C === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o),
        (n.autoClear || _) && (i.buffers.depth.setTest(!0),
        i.buffers.depth.setMask(!0),
        i.buffers.color.setMask(!0),
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil))
    }
    function g(y, _) {
        const x = p(_);
        x && (x.isCubeTexture || x.mapping === Lo) ? (u === void 0 && (u = new Ot(new Ss(1,1,1),new oi({
            name: "BackgroundCubeMaterial",
            uniforms: So(Kn.backgroundCube.uniforms),
            vertexShader: Kn.backgroundCube.vertexShader,
            fragmentShader: Kn.backgroundCube.fragmentShader,
            side: _n,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        u.geometry.deleteAttribute("normal"),
        u.geometry.deleteAttribute("uv"),
        u.onBeforeRender = function(C, w, E) {
            this.matrixWorld.copyPosition(E.matrixWorld)
        }
        ,
        Object.defineProperty(u.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        r.update(u)),
        Vr.copy(_.backgroundRotation),
        Vr.x *= -1,
        Vr.y *= -1,
        Vr.z *= -1,
        x.isCubeTexture && x.isRenderTargetTexture === !1 && (Vr.y *= -1,
        Vr.z *= -1),
        u.material.uniforms.envMap.value = x,
        u.material.uniforms.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1,
        u.material.uniforms.backgroundBlurriness.value = _.backgroundBlurriness,
        u.material.uniforms.backgroundIntensity.value = _.backgroundIntensity,
        u.material.uniforms.backgroundRotation.value.setFromMatrix4(WC.makeRotationFromEuler(Vr)),
        u.material.toneMapped = st.getTransfer(x.colorSpace) !== xt,
        (h !== x || f !== x.version || d !== n.toneMapping) && (u.material.needsUpdate = !0,
        h = x,
        f = x.version,
        d = n.toneMapping),
        u.layers.enableAll(),
        y.unshift(u, u.geometry, u.material, 0, 0, null)) : x && x.isTexture && (c === void 0 && (c = new Ot(new Uo(2,2),new oi({
            name: "BackgroundMaterial",
            uniforms: So(Kn.background.uniforms),
            vertexShader: Kn.background.vertexShader,
            fragmentShader: Kn.background.fragmentShader,
            side: Wi,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        c.geometry.deleteAttribute("normal"),
        Object.defineProperty(c.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        r.update(c)),
        c.material.uniforms.t2D.value = x,
        c.material.uniforms.backgroundIntensity.value = _.backgroundIntensity,
        c.material.toneMapped = st.getTransfer(x.colorSpace) !== xt,
        x.matrixAutoUpdate === !0 && x.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(x.matrix),
        (h !== x || f !== x.version || d !== n.toneMapping) && (c.material.needsUpdate = !0,
        h = x,
        f = x.version,
        d = n.toneMapping),
        c.layers.enableAll(),
        y.unshift(c, c.geometry, c.material, 0, 0, null))
    }
    function m(y, _) {
        y.getRGB(nc, Hx(n)),
        i.buffers.color.setClear(nc.r, nc.g, nc.b, _, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(y, _=1) {
            a.set(y),
            l = _,
            m(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(y) {
            l = y,
            m(a, l)
        },
        render: v,
        addToRenderList: g
    }
}
function qC(n, e) {
    const t = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , i = {}
      , r = f(null);
    let s = r
      , o = !1;
    function a(b, D, F, z, $) {
        let ne = !1;
        const W = h(z, F, D);
        s !== W && (s = W,
        c(s.object)),
        ne = d(b, z, F, $),
        ne && p(b, z, F, $),
        $ !== null && e.update($, n.ELEMENT_ARRAY_BUFFER),
        (ne || o) && (o = !1,
        x(b, D, F, z),
        $ !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get($).buffer))
    }
    function l() {
        return n.createVertexArray()
    }
    function c(b) {
        return n.bindVertexArray(b)
    }
    function u(b) {
        return n.deleteVertexArray(b)
    }
    function h(b, D, F) {
        const z = F.wireframe === !0;
        let $ = i[b.id];
        $ === void 0 && ($ = {},
        i[b.id] = $);
        let ne = $[D.id];
        ne === void 0 && (ne = {},
        $[D.id] = ne);
        let W = ne[z];
        return W === void 0 && (W = f(l()),
        ne[z] = W),
        W
    }
    function f(b) {
        const D = []
          , F = []
          , z = [];
        for (let $ = 0; $ < t; $++)
            D[$] = 0,
            F[$] = 0,
            z[$] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: D,
            enabledAttributes: F,
            attributeDivisors: z,
            object: b,
            attributes: {},
            index: null
        }
    }
    function d(b, D, F, z) {
        const $ = s.attributes
          , ne = D.attributes;
        let W = 0;
        const ie = F.getAttributes();
        for (const Z in ie)
            if (ie[Z].location >= 0) {
                const xe = $[Z];
                let te = ne[Z];
                if (te === void 0 && (Z === "instanceMatrix" && b.instanceMatrix && (te = b.instanceMatrix),
                Z === "instanceColor" && b.instanceColor && (te = b.instanceColor)),
                xe === void 0 || xe.attribute !== te || te && xe.data !== te.data)
                    return !0;
                W++
            }
        return s.attributesNum !== W || s.index !== z
    }
    function p(b, D, F, z) {
        const $ = {}
          , ne = D.attributes;
        let W = 0;
        const ie = F.getAttributes();
        for (const Z in ie)
            if (ie[Z].location >= 0) {
                let xe = ne[Z];
                xe === void 0 && (Z === "instanceMatrix" && b.instanceMatrix && (xe = b.instanceMatrix),
                Z === "instanceColor" && b.instanceColor && (xe = b.instanceColor));
                const te = {};
                te.attribute = xe,
                xe && xe.data && (te.data = xe.data),
                $[Z] = te,
                W++
            }
        s.attributes = $,
        s.attributesNum = W,
        s.index = z
    }
    function v() {
        const b = s.newAttributes;
        for (let D = 0, F = b.length; D < F; D++)
            b[D] = 0
    }
    function g(b) {
        m(b, 0)
    }
    function m(b, D) {
        const F = s.newAttributes
          , z = s.enabledAttributes
          , $ = s.attributeDivisors;
        F[b] = 1,
        z[b] === 0 && (n.enableVertexAttribArray(b),
        z[b] = 1),
        $[b] !== D && (n.vertexAttribDivisor(b, D),
        $[b] = D)
    }
    function y() {
        const b = s.newAttributes
          , D = s.enabledAttributes;
        for (let F = 0, z = D.length; F < z; F++)
            D[F] !== b[F] && (n.disableVertexAttribArray(F),
            D[F] = 0)
    }
    function _(b, D, F, z, $, ne, W) {
        W === !0 ? n.vertexAttribIPointer(b, D, F, $, ne) : n.vertexAttribPointer(b, D, F, z, $, ne)
    }
    function x(b, D, F, z) {
        v();
        const $ = z.attributes
          , ne = F.getAttributes()
          , W = D.defaultAttributeValues;
        for (const ie in ne) {
            const Z = ne[ie];
            if (Z.location >= 0) {
                let ve = $[ie];
                if (ve === void 0 && (ie === "instanceMatrix" && b.instanceMatrix && (ve = b.instanceMatrix),
                ie === "instanceColor" && b.instanceColor && (ve = b.instanceColor)),
                ve !== void 0) {
                    const xe = ve.normalized
                      , te = ve.itemSize
                      , Se = e.get(ve);
                    if (Se === void 0)
                        continue;
                    const ze = Se.buffer
                      , re = Se.type
                      , pe = Se.bytesPerElement
                      , Me = re === n.INT || re === n.UNSIGNED_INT || ve.gpuType === sh;
                    if (ve.isInterleavedBufferAttribute) {
                        const k = ve.data
                          , se = k.stride
                          , oe = ve.offset;
                        if (k.isInstancedInterleavedBuffer) {
                            for (let he = 0; he < Z.locationSize; he++)
                                m(Z.location + he, k.meshPerAttribute);
                            b.isInstancedMesh !== !0 && z._maxInstanceCount === void 0 && (z._maxInstanceCount = k.meshPerAttribute * k.count)
                        } else
                            for (let he = 0; he < Z.locationSize; he++)
                                g(Z.location + he);
                        n.bindBuffer(n.ARRAY_BUFFER, ze);
                        for (let he = 0; he < Z.locationSize; he++)
                            _(Z.location + he, te / Z.locationSize, re, xe, se * pe, (oe + te / Z.locationSize * he) * pe, Me)
                    } else {
                        if (ve.isInstancedBufferAttribute) {
                            for (let k = 0; k < Z.locationSize; k++)
                                m(Z.location + k, ve.meshPerAttribute);
                            b.isInstancedMesh !== !0 && z._maxInstanceCount === void 0 && (z._maxInstanceCount = ve.meshPerAttribute * ve.count)
                        } else
                            for (let k = 0; k < Z.locationSize; k++)
                                g(Z.location + k);
                        n.bindBuffer(n.ARRAY_BUFFER, ze);
                        for (let k = 0; k < Z.locationSize; k++)
                            _(Z.location + k, te / Z.locationSize, re, xe, te * pe, te / Z.locationSize * k * pe, Me)
                    }
                } else if (W !== void 0) {
                    const xe = W[ie];
                    if (xe !== void 0)
                        switch (xe.length) {
                        case 2:
                            n.vertexAttrib2fv(Z.location, xe);
                            break;
                        case 3:
                            n.vertexAttrib3fv(Z.location, xe);
                            break;
                        case 4:
                            n.vertexAttrib4fv(Z.location, xe);
                            break;
                        default:
                            n.vertexAttrib1fv(Z.location, xe)
                        }
                }
            }
        }
        y()
    }
    function C() {
        L();
        for (const b in i) {
            const D = i[b];
            for (const F in D) {
                const z = D[F];
                for (const $ in z)
                    u(z[$].object),
                    delete z[$];
                delete D[F]
            }
            delete i[b]
        }
    }
    function w(b) {
        if (i[b.id] === void 0)
            return;
        const D = i[b.id];
        for (const F in D) {
            const z = D[F];
            for (const $ in z)
                u(z[$].object),
                delete z[$];
            delete D[F]
        }
        delete i[b.id]
    }
    function E(b) {
        for (const D in i) {
            const F = i[D];
            if (F[b.id] === void 0)
                continue;
            const z = F[b.id];
            for (const $ in z)
                u(z[$].object),
                delete z[$];
            delete F[b.id]
        }
    }
    function L() {
        S(),
        o = !0,
        s !== r && (s = r,
        c(s.object))
    }
    function S() {
        r.geometry = null,
        r.program = null,
        r.wireframe = !1
    }
    return {
        setup: a,
        reset: L,
        resetDefaultState: S,
        dispose: C,
        releaseStatesOfGeometry: w,
        releaseStatesOfProgram: E,
        initAttributes: v,
        enableAttribute: g,
        disableUnusedAttributes: y
    }
}
function $C(n, e, t) {
    let i;
    function r(c) {
        i = c
    }
    function s(c, u) {
        n.drawArrays(i, c, u),
        t.update(u, i, 1)
    }
    function o(c, u, h) {
        h !== 0 && (n.drawArraysInstanced(i, c, u, h),
        t.update(u, i, h))
    }
    function a(c, u, h) {
        if (h === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, c, 0, u, 0, h);
        let d = 0;
        for (let p = 0; p < h; p++)
            d += u[p];
        t.update(d, i, 1)
    }
    function l(c, u, h, f) {
        if (h === 0)
            return;
        const d = e.get("WEBGL_multi_draw");
        if (d === null)
            for (let p = 0; p < c.length; p++)
                o(c[p], u[p], f[p]);
        else {
            d.multiDrawArraysInstancedWEBGL(i, c, 0, u, 0, f, 0, h);
            let p = 0;
            for (let v = 0; v < h; v++)
                p += u[v];
            for (let v = 0; v < f.length; v++)
                t.update(p, i, f[v])
        }
    }
    this.setMode = r,
    this.render = s,
    this.renderInstances = o,
    this.renderMultiDraw = a,
    this.renderMultiDrawInstances = l
}
function YC(n, e, t, i) {
    let r;
    function s() {
        if (r !== void 0)
            return r;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const w = e.get("EXT_texture_filter_anisotropic");
            r = n.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            r = 0;
        return r
    }
    function o(w) {
        return !(w !== vn && i.convert(w) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT))
    }
    function a(w) {
        const E = w === Do && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
        return !(w !== bi && i.convert(w) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) && w !== Mn && !E)
    }
    function l(w) {
        if (w === "highp") {
            if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0)
                return "highp";
            w = "mediump"
        }
        return w === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let c = t.precision !== void 0 ? t.precision : "highp";
    const u = l(c);
    u !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", u, "instead."),
    c = u);
    const h = t.logarithmicDepthBuffer === !0
      , f = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)
      , d = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , p = n.getParameter(n.MAX_TEXTURE_SIZE)
      , v = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)
      , g = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , m = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)
      , y = n.getParameter(n.MAX_VARYING_VECTORS)
      , _ = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)
      , x = d > 0
      , C = n.getParameter(n.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: s,
        getMaxPrecision: l,
        textureFormatReadable: o,
        textureTypeReadable: a,
        precision: c,
        logarithmicDepthBuffer: h,
        maxTextures: f,
        maxVertexTextures: d,
        maxTextureSize: p,
        maxCubemapSize: v,
        maxAttributes: g,
        maxVertexUniforms: m,
        maxVaryings: y,
        maxFragmentUniforms: _,
        vertexTextures: x,
        maxSamples: C
    }
}
function jC(n) {
    const e = this;
    let t = null
      , i = 0
      , r = !1
      , s = !1;
    const o = new gr
      , a = new Ye
      , l = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(h, f) {
        const d = h.length !== 0 || f || i !== 0 || r;
        return r = f,
        i = h.length,
        d
    }
    ,
    this.beginShadows = function() {
        s = !0,
        u(null)
    }
    ,
    this.endShadows = function() {
        s = !1
    }
    ,
    this.setGlobalState = function(h, f) {
        t = u(h, f, 0)
    }
    ,
    this.setState = function(h, f, d) {
        const p = h.clippingPlanes
          , v = h.clipIntersection
          , g = h.clipShadows
          , m = n.get(h);
        if (!r || p === null || p.length === 0 || s && !g)
            s ? u(null) : c();
        else {
            const y = s ? 0 : i
              , _ = y * 4;
            let x = m.clippingState || null;
            l.value = x,
            x = u(p, f, _, d);
            for (let C = 0; C !== _; ++C)
                x[C] = t[C];
            m.clippingState = x,
            this.numIntersection = v ? this.numPlanes : 0,
            this.numPlanes += y
        }
    }
    ;
    function c() {
        l.value !== t && (l.value = t,
        l.needsUpdate = i > 0),
        e.numPlanes = i,
        e.numIntersection = 0
    }
    function u(h, f, d, p) {
        const v = h !== null ? h.length : 0;
        let g = null;
        if (v !== 0) {
            if (g = l.value,
            p !== !0 || g === null) {
                const m = d + v * 4
                  , y = f.matrixWorldInverse;
                a.getNormalMatrix(y),
                (g === null || g.length < m) && (g = new Float32Array(m));
                for (let _ = 0, x = d; _ !== v; ++_,
                x += 4)
                    o.copy(h[_]).applyMatrix4(y, a),
                    o.normal.toArray(g, x),
                    g[x + 3] = o.constant
            }
            l.value = g,
            l.needsUpdate = !0
        }
        return e.numPlanes = v,
        e.numIntersection = 0,
        g
    }
}
function KC(n) {
    let e = new WeakMap;
    function t(o, a) {
        return a === za ? o.mapping = Xi : a === ka && (o.mapping = Er),
        o
    }
    function i(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === za || a === ka)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return t(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const c = new Xx(l.height);
                        return c.fromEquirectangularTexture(n, o),
                        e.set(o, c),
                        o.addEventListener("dispose", r),
                        t(c.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function r(o) {
        const a = o.target;
        a.removeEventListener("dispose", r);
        const l = e.get(a);
        l !== void 0 && (e.delete(a),
        l.dispose())
    }
    function s() {
        e = new WeakMap
    }
    return {
        get: i,
        dispose: s
    }
}
class mh extends _l {
    constructor(e=-1, t=1, i=1, r=-1, s=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = i,
        this.bottom = r,
        this.near = s,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, i, r, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = i,
        this.view.offsetY = r,
        this.view.width = s,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , i = (this.right + this.left) / 2
          , r = (this.top + this.bottom) / 2;
        let s = i - e
          , o = i + e
          , a = r + t
          , l = r - t;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom
              , u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += c * this.view.offsetX,
            o = s + c * this.view.width,
            a -= u * this.view.offsetY,
            l = a - u * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const to = 4
  , Bg = [.125, .215, .35, .446, .526, .582]
  , Qr = 20
  , If = new mh
  , zg = new Ee;
let Lf = null
  , Df = 0
  , Nf = 0
  , Uf = !1;
const Zr = (1 + Math.sqrt(5)) / 2
  , Gs = 1 / Zr
  , kg = [new N(-Zr,Gs,0), new N(Zr,Gs,0), new N(-Gs,0,Zr), new N(Gs,0,Zr), new N(0,Zr,-Gs), new N(0,Zr,Gs), new N(-1,1,-1), new N(1,1,-1), new N(-1,1,1), new N(1,1,1)];
class Cd {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, i=.1, r=100) {
        Lf = this._renderer.getRenderTarget(),
        Df = this._renderer.getActiveCubeFace(),
        Nf = this._renderer.getActiveMipmapLevel(),
        Uf = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1,
        this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0,
        this._sceneToCubeUV(e, i, r, s),
        t > 0 && this._blur(s, 0, 0, t),
        this._applyPMREM(s),
        this._cleanup(s),
        s
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = Gg(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = Hg(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(Lf, Df, Nf),
        this._renderer.xr.enabled = Uf,
        e.scissorTest = !1,
        ic(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === Xi || e.mapping === Er ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        Lf = this._renderer.getRenderTarget(),
        Df = this._renderer.getActiveCubeFace(),
        Nf = this._renderer.getActiveMipmapLevel(),
        Uf = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1;
        const i = t || this._allocateTargets();
        return this._textureToCubeUV(e, i),
        this._applyPMREM(i),
        this._cleanup(i),
        i
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , i = {
            magFilter: Gt,
            minFilter: Gt,
            generateMipmaps: !1,
            type: Do,
            format: vn,
            colorSpace: Ki,
            depthBuffer: !1
        }
          , r = Vg(e, t, i);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = Vg(e, t, i);
            const {_lodMax: s} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = ZC(s)),
            this._blurMaterial = JC(s, e, t)
        }
        return r
    }
    _compileMaterial(e) {
        const t = new Ot(this._lodPlanes[0],e);
        this._renderer.compile(t, If)
    }
    _sceneToCubeUV(e, t, i, r) {
        const a = new Ht(90,1,t,i)
          , l = [1, -1, 1, 1, 1, 1]
          , c = [1, 1, 1, -1, -1, -1]
          , u = this._renderer
          , h = u.autoClear
          , f = u.toneMapping;
        u.getClearColor(zg),
        u.toneMapping = vi,
        u.autoClear = !1;
        const d = new Zi({
            name: "PMREM.Background",
            side: _n,
            depthWrite: !1,
            depthTest: !1
        })
          , p = new Ot(new Ss,d);
        let v = !1;
        const g = e.background;
        g ? g.isColor && (d.color.copy(g),
        e.background = null,
        v = !0) : (d.color.copy(zg),
        v = !0);
        for (let m = 0; m < 6; m++) {
            const y = m % 3;
            y === 0 ? (a.up.set(0, l[m], 0),
            a.lookAt(c[m], 0, 0)) : y === 1 ? (a.up.set(0, 0, l[m]),
            a.lookAt(0, c[m], 0)) : (a.up.set(0, l[m], 0),
            a.lookAt(0, 0, c[m]));
            const _ = this._cubeSize;
            ic(r, y * _, m > 2 ? _ : 0, _, _),
            u.setRenderTarget(r),
            v && u.render(p, a),
            u.render(e, a)
        }
        p.geometry.dispose(),
        p.material.dispose(),
        u.toneMapping = f,
        u.autoClear = h,
        e.background = g
    }
    _textureToCubeUV(e, t) {
        const i = this._renderer
          , r = e.mapping === Xi || e.mapping === Er;
        r ? (this._cubemapMaterial === null && (this._cubemapMaterial = Gg()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Hg());
        const s = r ? this._cubemapMaterial : this._equirectMaterial
          , o = new Ot(this._lodPlanes[0],s)
          , a = s.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        ic(t, 0, 0, 3 * l, 2 * l),
        i.setRenderTarget(t),
        i.render(o, If)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , i = t.autoClear;
        t.autoClear = !1;
        const r = this._lodPlanes.length;
        for (let s = 1; s < r; s++) {
            const o = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1])
              , a = kg[(r - s - 1) % kg.length];
            this._blur(e, s - 1, s, o, a)
        }
        t.autoClear = i
    }
    _blur(e, t, i, r, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, i, r, "latitudinal", s),
        this._halfBlur(o, e, i, i, r, "longitudinal", s)
    }
    _halfBlur(e, t, i, r, s, o, a) {
        const l = this._renderer
          , c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const u = 3
          , h = new Ot(this._lodPlanes[r],c)
          , f = c.uniforms
          , d = this._sizeLods[i] - 1
          , p = isFinite(s) ? Math.PI / (2 * d) : 2 * Math.PI / (2 * Qr - 1)
          , v = s / p
          , g = isFinite(s) ? 1 + Math.floor(u * v) : Qr;
        g > Qr && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${Qr}`);
        const m = [];
        let y = 0;
        for (let E = 0; E < Qr; ++E) {
            const L = E / v
              , S = Math.exp(-L * L / 2);
            m.push(S),
            E === 0 ? y += S : E < g && (y += 2 * S)
        }
        for (let E = 0; E < m.length; E++)
            m[E] = m[E] / y;
        f.envMap.value = e.texture,
        f.samples.value = g,
        f.weights.value = m,
        f.latitudinal.value = o === "latitudinal",
        a && (f.poleAxis.value = a);
        const {_lodMax: _} = this;
        f.dTheta.value = p,
        f.mipInt.value = _ - i;
        const x = this._sizeLods[r]
          , C = 3 * x * (r > _ - to ? r - _ + to : 0)
          , w = 4 * (this._cubeSize - x);
        ic(t, C, w, 3 * x, 2 * x),
        l.setRenderTarget(t),
        l.render(h, If)
    }
}
function ZC(n) {
    const e = []
      , t = []
      , i = [];
    let r = n;
    const s = n - to + 1 + Bg.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, r);
        t.push(a);
        let l = 1 / a;
        o > n - to ? l = Bg[o - n + to - 1] : o === 0 && (l = 0),
        i.push(l);
        const c = 1 / (a - 2)
          , u = -c
          , h = 1 + c
          , f = [u, u, h, u, h, h, u, u, h, h, u, h]
          , d = 6
          , p = 6
          , v = 3
          , g = 2
          , m = 1
          , y = new Float32Array(v * p * d)
          , _ = new Float32Array(g * p * d)
          , x = new Float32Array(m * p * d);
        for (let w = 0; w < d; w++) {
            const E = w % 3 * 2 / 3 - 1
              , L = w > 2 ? 0 : -1
              , S = [E, L, 0, E + 2 / 3, L, 0, E + 2 / 3, L + 1, 0, E, L, 0, E + 2 / 3, L + 1, 0, E, L + 1, 0];
            y.set(S, v * p * w),
            _.set(f, g * p * w);
            const b = [w, w, w, w, w, w];
            x.set(b, m * p * w)
        }
        const C = new Ze;
        C.setAttribute("position", new pt(y,v)),
        C.setAttribute("uv", new pt(_,g)),
        C.setAttribute("faceIndex", new pt(x,m)),
        e.push(C),
        r > to && r--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: i
    }
}
function Vg(n, e, t) {
    const i = new si(n,e,t);
    return i.texture.mapping = Lo,
    i.texture.name = "PMREM.cubeUv",
    i.scissorTest = !0,
    i
}
function ic(n, e, t, i, r) {
    n.viewport.set(e, t, i, r),
    n.scissor.set(e, t, i, r)
}
function JC(n, e, t) {
    const i = new Float32Array(Qr)
      , r = new N(0,1,0);
    return new oi({
        name: "SphericalGaussianBlur",
        defines: {
            n: Qr,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: i
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: r
            }
        },
        vertexShader: zp(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Vi,
        depthTest: !1,
        depthWrite: !1
    })
}
function Hg() {
    return new oi({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: zp(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: Vi,
        depthTest: !1,
        depthWrite: !1
    })
}
function Gg() {
    return new oi({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: zp(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: Vi,
        depthTest: !1,
        depthWrite: !1
    })
}
function zp() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function QC(n) {
    let e = new WeakMap
      , t = null;
    function i(a) {
        if (a && a.isTexture) {
            const l = a.mapping
              , c = l === za || l === ka
              , u = l === Xi || l === Er;
            if (c || u) {
                let h = e.get(a);
                const f = h !== void 0 ? h.texture.pmremVersion : 0;
                if (a.isRenderTargetTexture && a.pmremVersion !== f)
                    return t === null && (t = new Cd(n)),
                    h = c ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h),
                    h.texture.pmremVersion = a.pmremVersion,
                    e.set(a, h),
                    h.texture;
                if (h !== void 0)
                    return h.texture;
                {
                    const d = a.image;
                    return c && d && d.height > 0 || u && d && r(d) ? (t === null && (t = new Cd(n)),
                    h = c ? t.fromEquirectangular(a) : t.fromCubemap(a),
                    h.texture.pmremVersion = a.pmremVersion,
                    e.set(a, h),
                    a.addEventListener("dispose", s),
                    h.texture) : null
                }
            }
        }
        return a
    }
    function r(a) {
        let l = 0;
        const c = 6;
        for (let u = 0; u < c; u++)
            a[u] !== void 0 && l++;
        return l === c
    }
    function s(a) {
        const l = a.target;
        l.removeEventListener("dispose", s);
        const c = e.get(l);
        c !== void 0 && (e.delete(l),
        c.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: i,
        dispose: o
    }
}
function eR(n) {
    const e = {};
    function t(i) {
        if (e[i] !== void 0)
            return e[i];
        let r;
        switch (i) {
        case "WEBGL_depth_texture":
            r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            r = n.getExtension(i)
        }
        return e[i] = r,
        r
    }
    return {
        has: function(i) {
            return t(i) !== null
        },
        init: function() {
            t("EXT_color_buffer_float"),
            t("WEBGL_clip_cull_distance"),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture"),
            t("WEBGL_render_shared_exponent")
        },
        get: function(i) {
            const r = t(i);
            return r === null && mo("THREE.WebGLRenderer: " + i + " extension not supported."),
            r
        }
    }
}
function tR(n, e, t, i) {
    const r = {}
      , s = new WeakMap;
    function o(h) {
        const f = h.target;
        f.index !== null && e.remove(f.index);
        for (const p in f.attributes)
            e.remove(f.attributes[p]);
        for (const p in f.morphAttributes) {
            const v = f.morphAttributes[p];
            for (let g = 0, m = v.length; g < m; g++)
                e.remove(v[g])
        }
        f.removeEventListener("dispose", o),
        delete r[f.id];
        const d = s.get(f);
        d && (e.remove(d),
        s.delete(f)),
        i.releaseStatesOfGeometry(f),
        f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount,
        t.memory.geometries--
    }
    function a(h, f) {
        return r[f.id] === !0 || (f.addEventListener("dispose", o),
        r[f.id] = !0,
        t.memory.geometries++),
        f
    }
    function l(h) {
        const f = h.attributes;
        for (const p in f)
            e.update(f[p], n.ARRAY_BUFFER);
        const d = h.morphAttributes;
        for (const p in d) {
            const v = d[p];
            for (let g = 0, m = v.length; g < m; g++)
                e.update(v[g], n.ARRAY_BUFFER)
        }
    }
    function c(h) {
        const f = []
          , d = h.index
          , p = h.attributes.position;
        let v = 0;
        if (d !== null) {
            const y = d.array;
            v = d.version;
            for (let _ = 0, x = y.length; _ < x; _ += 3) {
                const C = y[_ + 0]
                  , w = y[_ + 1]
                  , E = y[_ + 2];
                f.push(C, w, w, E, E, C)
            }
        } else if (p !== void 0) {
            const y = p.array;
            v = p.version;
            for (let _ = 0, x = y.length / 3 - 1; _ < x; _ += 3) {
                const C = _ + 0
                  , w = _ + 1
                  , E = _ + 2;
                f.push(C, w, w, E, E, C)
            }
        } else
            return;
        const g = new (Fx(f) ? Bp : Fp)(f,1);
        g.version = v;
        const m = s.get(h);
        m && e.remove(m),
        s.set(h, g)
    }
    function u(h) {
        const f = s.get(h);
        if (f) {
            const d = h.index;
            d !== null && f.version < d.version && c(h)
        } else
            c(h);
        return s.get(h)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: u
    }
}
function nR(n, e, t) {
    let i;
    function r(f) {
        i = f
    }
    let s, o;
    function a(f) {
        s = f.type,
        o = f.bytesPerElement
    }
    function l(f, d) {
        n.drawElements(i, d, s, f * o),
        t.update(d, i, 1)
    }
    function c(f, d, p) {
        p !== 0 && (n.drawElementsInstanced(i, d, s, f * o, p),
        t.update(d, i, p))
    }
    function u(f, d, p) {
        if (p === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, d, 0, s, f, 0, p);
        let g = 0;
        for (let m = 0; m < p; m++)
            g += d[m];
        t.update(g, i, 1)
    }
    function h(f, d, p, v) {
        if (p === 0)
            return;
        const g = e.get("WEBGL_multi_draw");
        if (g === null)
            for (let m = 0; m < f.length; m++)
                c(f[m] / o, d[m], v[m]);
        else {
            g.multiDrawElementsInstancedWEBGL(i, d, 0, s, f, 0, v, 0, p);
            let m = 0;
            for (let y = 0; y < p; y++)
                m += d[y];
            for (let y = 0; y < v.length; y++)
                t.update(m, i, v[y])
        }
    }
    this.setMode = r,
    this.setIndex = a,
    this.render = l,
    this.renderInstances = c,
    this.renderMultiDraw = u,
    this.renderMultiDrawInstances = h
}
function iR(n) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function i(s, o, a) {
        switch (t.calls++,
        o) {
        case n.TRIANGLES:
            t.triangles += a * (s / 3);
            break;
        case n.LINES:
            t.lines += a * (s / 2);
            break;
        case n.LINE_STRIP:
            t.lines += a * (s - 1);
            break;
        case n.LINE_LOOP:
            t.lines += a * s;
            break;
        case n.POINTS:
            t.points += a * s;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function r() {
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: r,
        update: i
    }
}
function rR(n, e, t) {
    const i = new WeakMap
      , r = new ft;
    function s(o, a, l) {
        const c = o.morphTargetInfluences
          , u = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color
          , h = u !== void 0 ? u.length : 0;
        let f = i.get(a);
        if (f === void 0 || f.count !== h) {
            let S = function() {
                E.dispose(),
                i.delete(a),
                a.removeEventListener("dispose", S)
            };
            f !== void 0 && f.texture.dispose();
            const d = a.morphAttributes.position !== void 0
              , p = a.morphAttributes.normal !== void 0
              , v = a.morphAttributes.color !== void 0
              , g = a.morphAttributes.position || []
              , m = a.morphAttributes.normal || []
              , y = a.morphAttributes.color || [];
            let _ = 0;
            d === !0 && (_ = 1),
            p === !0 && (_ = 2),
            v === !0 && (_ = 3);
            let x = a.attributes.position.count * _
              , C = 1;
            x > e.maxTextureSize && (C = Math.ceil(x / e.maxTextureSize),
            x = e.maxTextureSize);
            const w = new Float32Array(x * C * 4 * h)
              , E = new dh(w,x,C,h);
            E.type = Mn,
            E.needsUpdate = !0;
            const L = _ * 4;
            for (let b = 0; b < h; b++) {
                const D = g[b]
                  , F = m[b]
                  , z = y[b]
                  , $ = x * C * 4 * b;
                for (let ne = 0; ne < D.count; ne++) {
                    const W = ne * L;
                    d === !0 && (r.fromBufferAttribute(D, ne),
                    w[$ + W + 0] = r.x,
                    w[$ + W + 1] = r.y,
                    w[$ + W + 2] = r.z,
                    w[$ + W + 3] = 0),
                    p === !0 && (r.fromBufferAttribute(F, ne),
                    w[$ + W + 4] = r.x,
                    w[$ + W + 5] = r.y,
                    w[$ + W + 6] = r.z,
                    w[$ + W + 7] = 0),
                    v === !0 && (r.fromBufferAttribute(z, ne),
                    w[$ + W + 8] = r.x,
                    w[$ + W + 9] = r.y,
                    w[$ + W + 10] = r.z,
                    w[$ + W + 11] = z.itemSize === 4 ? r.w : 1)
                }
            }
            f = {
                count: h,
                texture: E,
                size: new ae(x,C)
            },
            i.set(a, f),
            a.addEventListener("dispose", S)
        }
        if (o.isInstancedMesh === !0 && o.morphTexture !== null)
            l.getUniforms().setValue(n, "morphTexture", o.morphTexture, t);
        else {
            let d = 0;
            for (let v = 0; v < c.length; v++)
                d += c[v];
            const p = a.morphTargetsRelative ? 1 : 1 - d;
            l.getUniforms().setValue(n, "morphTargetBaseInfluence", p),
            l.getUniforms().setValue(n, "morphTargetInfluences", c)
        }
        l.getUniforms().setValue(n, "morphTargetsTexture", f.texture, t),
        l.getUniforms().setValue(n, "morphTargetsTextureSize", f.size)
    }
    return {
        update: s
    }
}
function sR(n, e, t, i) {
    let r = new WeakMap;
    function s(l) {
        const c = i.render.frame
          , u = l.geometry
          , h = e.get(l, u);
        if (r.get(h) !== c && (e.update(h),
        r.set(h, c)),
        l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a),
        r.get(l) !== c && (t.update(l.instanceMatrix, n.ARRAY_BUFFER),
        l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER),
        r.set(l, c))),
        l.isSkinnedMesh) {
            const f = l.skeleton;
            r.get(f) !== c && (f.update(),
            r.set(f, c))
        }
        return h
    }
    function o() {
        r = new WeakMap
    }
    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a),
        t.remove(c.instanceMatrix),
        c.instanceColor !== null && t.remove(c.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
class kp extends Dt {
    constructor(e, t, i, r, s, o, a, l, c, u=hs) {
        if (u !== hs && u !== _s)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        i === void 0 && u === hs && (i = qi),
        i === void 0 && u === _s && (i = vs),
        super(null, r, s, o, a, l, u, i, c),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = a !== void 0 ? a : Kt,
        this.minFilter = l !== void 0 ? l : Kt,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
        t
    }
}
const $x = new Dt
  , Wg = new kp(1,1)
  , Yx = new dh
  , jx = new Op
  , Kx = new yl
  , Xg = []
  , qg = []
  , $g = new Float32Array(16)
  , Yg = new Float32Array(9)
  , jg = new Float32Array(4);
function Oo(n, e, t) {
    const i = n[0];
    if (i <= 0 || i > 0)
        return n;
    const r = e * t;
    let s = Xg[r];
    if (s === void 0 && (s = new Float32Array(r),
    Xg[r] = s),
    e !== 0) {
        i.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += t,
            n[o].toArray(s, a)
    }
    return s
}
function Xt(n, e) {
    if (n.length !== e.length)
        return !1;
    for (let t = 0, i = n.length; t < i; t++)
        if (n[t] !== e[t])
            return !1;
    return !0
}
function qt(n, e) {
    for (let t = 0, i = e.length; t < i; t++)
        n[t] = e[t]
}
function gh(n, e) {
    let t = qg[e];
    t === void 0 && (t = new Int32Array(e),
    qg[e] = t);
    for (let i = 0; i !== e; ++i)
        t[i] = n.allocateTextureUnit();
    return t
}
function oR(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e),
    t[0] = e)
}
function aR(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Xt(t, e))
            return;
        n.uniform2fv(this.addr, e),
        qt(t, e)
    }
}
function lR(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (Xt(t, e))
            return;
        n.uniform3fv(this.addr, e),
        qt(t, e)
    }
}
function cR(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Xt(t, e))
            return;
        n.uniform4fv(this.addr, e),
        qt(t, e)
    }
}
function uR(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Xt(t, e))
            return;
        n.uniformMatrix2fv(this.addr, !1, e),
        qt(t, e)
    } else {
        if (Xt(t, i))
            return;
        jg.set(i),
        n.uniformMatrix2fv(this.addr, !1, jg),
        qt(t, i)
    }
}
function hR(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Xt(t, e))
            return;
        n.uniformMatrix3fv(this.addr, !1, e),
        qt(t, e)
    } else {
        if (Xt(t, i))
            return;
        Yg.set(i),
        n.uniformMatrix3fv(this.addr, !1, Yg),
        qt(t, i)
    }
}
function fR(n, e) {
    const t = this.cache
      , i = e.elements;
    if (i === void 0) {
        if (Xt(t, e))
            return;
        n.uniformMatrix4fv(this.addr, !1, e),
        qt(t, e)
    } else {
        if (Xt(t, i))
            return;
        $g.set(i),
        n.uniformMatrix4fv(this.addr, !1, $g),
        qt(t, i)
    }
}
function dR(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e),
    t[0] = e)
}
function pR(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Xt(t, e))
            return;
        n.uniform2iv(this.addr, e),
        qt(t, e)
    }
}
function mR(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Xt(t, e))
            return;
        n.uniform3iv(this.addr, e),
        qt(t, e)
    }
}
function gR(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Xt(t, e))
            return;
        n.uniform4iv(this.addr, e),
        qt(t, e)
    }
}
function vR(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e),
    t[0] = e)
}
function _R(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Xt(t, e))
            return;
        n.uniform2uiv(this.addr, e),
        qt(t, e)
    }
}
function yR(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Xt(t, e))
            return;
        n.uniform3uiv(this.addr, e),
        qt(t, e)
    }
}
function xR(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Xt(t, e))
            return;
        n.uniform4uiv(this.addr, e),
        qt(t, e)
    }
}
function bR(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r);
    let s;
    this.type === n.SAMPLER_2D_SHADOW ? (Wg.compareFunction = Dp,
    s = Wg) : s = $x,
    t.setTexture2D(e || s, r)
}
function MR(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture3D(e || jx, r)
}
function SR(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTextureCube(e || Kx, r)
}
function wR(n, e, t) {
    const i = this.cache
      , r = t.allocateTextureUnit();
    i[0] !== r && (n.uniform1i(this.addr, r),
    i[0] = r),
    t.setTexture2DArray(e || Yx, r)
}
function ER(n) {
    switch (n) {
    case 5126:
        return oR;
    case 35664:
        return aR;
    case 35665:
        return lR;
    case 35666:
        return cR;
    case 35674:
        return uR;
    case 35675:
        return hR;
    case 35676:
        return fR;
    case 5124:
    case 35670:
        return dR;
    case 35667:
    case 35671:
        return pR;
    case 35668:
    case 35672:
        return mR;
    case 35669:
    case 35673:
        return gR;
    case 5125:
        return vR;
    case 36294:
        return _R;
    case 36295:
        return yR;
    case 36296:
        return xR;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return bR;
    case 35679:
    case 36299:
    case 36307:
        return MR;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return SR;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return wR
    }
}
function AR(n, e) {
    n.uniform1fv(this.addr, e)
}
function TR(n, e) {
    const t = Oo(e, this.size, 2);
    n.uniform2fv(this.addr, t)
}
function CR(n, e) {
    const t = Oo(e, this.size, 3);
    n.uniform3fv(this.addr, t)
}
function RR(n, e) {
    const t = Oo(e, this.size, 4);
    n.uniform4fv(this.addr, t)
}
function PR(n, e) {
    const t = Oo(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t)
}
function IR(n, e) {
    const t = Oo(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t)
}
function LR(n, e) {
    const t = Oo(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t)
}
function DR(n, e) {
    n.uniform1iv(this.addr, e)
}
function NR(n, e) {
    n.uniform2iv(this.addr, e)
}
function UR(n, e) {
    n.uniform3iv(this.addr, e)
}
function OR(n, e) {
    n.uniform4iv(this.addr, e)
}
function FR(n, e) {
    n.uniform1uiv(this.addr, e)
}
function BR(n, e) {
    n.uniform2uiv(this.addr, e)
}
function zR(n, e) {
    n.uniform3uiv(this.addr, e)
}
function kR(n, e) {
    n.uniform4uiv(this.addr, e)
}
function VR(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = gh(t, r);
    Xt(i, s) || (n.uniform1iv(this.addr, s),
    qt(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2D(e[o] || $x, s[o])
}
function HR(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = gh(t, r);
    Xt(i, s) || (n.uniform1iv(this.addr, s),
    qt(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture3D(e[o] || jx, s[o])
}
function GR(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = gh(t, r);
    Xt(i, s) || (n.uniform1iv(this.addr, s),
    qt(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTextureCube(e[o] || Kx, s[o])
}
function WR(n, e, t) {
    const i = this.cache
      , r = e.length
      , s = gh(t, r);
    Xt(i, s) || (n.uniform1iv(this.addr, s),
    qt(i, s));
    for (let o = 0; o !== r; ++o)
        t.setTexture2DArray(e[o] || Yx, s[o])
}
function XR(n) {
    switch (n) {
    case 5126:
        return AR;
    case 35664:
        return TR;
    case 35665:
        return CR;
    case 35666:
        return RR;
    case 35674:
        return PR;
    case 35675:
        return IR;
    case 35676:
        return LR;
    case 5124:
    case 35670:
        return DR;
    case 35667:
    case 35671:
        return NR;
    case 35668:
    case 35672:
        return UR;
    case 35669:
    case 35673:
        return OR;
    case 5125:
        return FR;
    case 36294:
        return BR;
    case 36295:
        return zR;
    case 36296:
        return kR;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return VR;
    case 35679:
    case 36299:
    case 36307:
        return HR;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return GR;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return WR
    }
}
class qR {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.type = t.type,
        this.setValue = ER(t.type)
    }
}
class $R {
    constructor(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.type = t.type,
        this.size = t.size,
        this.setValue = XR(t.type)
    }
}
class YR {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, i) {
        const r = this.seq;
        for (let s = 0, o = r.length; s !== o; ++s) {
            const a = r[s];
            a.setValue(e, t[a.id], i)
        }
    }
}
const Of = /(\w+)(\])?(\[|\.)?/g;
function Kg(n, e) {
    n.seq.push(e),
    n.map[e.id] = e
}
function jR(n, e, t) {
    const i = n.name
      , r = i.length;
    for (Of.lastIndex = 0; ; ) {
        const s = Of.exec(i)
          , o = Of.lastIndex;
        let a = s[1];
        const l = s[2] === "]"
          , c = s[3];
        if (l && (a = a | 0),
        c === void 0 || c === "[" && o + 2 === r) {
            Kg(t, c === void 0 ? new qR(a,n,e) : new $R(a,n,e));
            break
        } else {
            let h = t.map[a];
            h === void 0 && (h = new YR(a),
            Kg(t, h)),
            t = h
        }
    }
}
class Hc {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let r = 0; r < i; ++r) {
            const s = e.getActiveUniform(t, r)
              , o = e.getUniformLocation(t, s.name);
            jR(s, o, this)
        }
    }
    setValue(e, t, i, r) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, i, r)
    }
    setOptional(e, t, i) {
        const r = t[i];
        r !== void 0 && this.setValue(e, i, r)
    }
    static upload(e, t, i, r) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s]
              , l = i[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, r)
        }
    }
    static seqWithValue(e, t) {
        const i = [];
        for (let r = 0, s = e.length; r !== s; ++r) {
            const o = e[r];
            o.id in t && i.push(o)
        }
        return i
    }
}
function Zg(n, e, t) {
    const i = n.createShader(e);
    return n.shaderSource(i, t),
    n.compileShader(i),
    i
}
const KR = 37297;
let ZR = 0;
function JR(n, e) {
    const t = n.split(`
`)
      , i = []
      , r = Math.max(e - 6, 0)
      , s = Math.min(e + 6, t.length);
    for (let o = r; o < s; o++) {
        const a = o + 1;
        i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
    }
    return i.join(`
`)
}
function QR(n) {
    const e = st.getPrimaries(st.workingColorSpace)
      , t = st.getPrimaries(n);
    let i;
    switch (e === t ? i = "" : e === $a && t === qa ? i = "LinearDisplayP3ToLinearSRGB" : e === qa && t === $a && (i = "LinearSRGBToLinearDisplayP3"),
    n) {
    case Ki:
    case vl:
        return [i, "LinearTransferOETF"];
    case Rn:
    case fh:
        return [i, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        [i, "LinearTransferOETF"]
    }
}
function Jg(n, e, t) {
    const i = n.getShaderParameter(e, n.COMPILE_STATUS)
      , r = n.getShaderInfoLog(e).trim();
    if (i && r === "")
        return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + `

` + r + `

` + JR(n.getShaderSource(e), o)
    } else
        return r
}
function eP(n, e) {
    const t = QR(e);
    return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`
}
function tP(n, e) {
    let t;
    switch (e) {
    case vx:
        t = "Linear";
        break;
    case _x:
        t = "Reinhard";
        break;
    case yx:
        t = "Cineon";
        break;
    case ih:
        t = "ACESFilmic";
        break;
    case bx:
        t = "AgX";
        break;
    case Mx:
        t = "Neutral";
        break;
    case xx:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
const rc = new N;
function nP() {
    st.getLuminanceCoefficients(rc);
    const n = rc.x.toFixed(4)
      , e = rc.y.toFixed(4)
      , t = rc.z.toFixed(4);
    return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`, "	return dot( weights, rgb );", "}"].join(`
`)
}
function iP(n) {
    return [n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(aa).join(`
`)
}
function rP(n) {
    const e = [];
    for (const t in n) {
        const i = n[t];
        i !== !1 && e.push("#define " + t + " " + i)
    }
    return e.join(`
`)
}
function sP(n, e) {
    const t = {}
      , i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
    for (let r = 0; r < i; r++) {
        const s = n.getActiveAttrib(e, r)
          , o = s.name;
        let a = 1;
        s.type === n.FLOAT_MAT2 && (a = 2),
        s.type === n.FLOAT_MAT3 && (a = 3),
        s.type === n.FLOAT_MAT4 && (a = 4),
        t[o] = {
            type: s.type,
            location: n.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}
function aa(n) {
    return n !== ""
}
function Qg(n, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function ev(n, e) {
    return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const oP = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Rd(n) {
    return n.replace(oP, lP)
}
const aP = new Map;
function lP(n, e) {
    let t = Ke[e];
    if (t === void 0) {
        const i = aP.get(e);
        if (i !== void 0)
            t = Ke[i],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return Rd(t)
}
const cP = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function tv(n) {
    return n.replace(cP, uP)
}
function uP(n, e, t, i) {
    let r = "";
    for (let s = parseInt(e); s < parseInt(t); s++)
        r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return r
}
function nv(n) {
    let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
    return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function hP(n) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return n.shadowMapType === xp ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === bp ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === fi && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function fP(n) {
    let e = "ENVMAP_TYPE_CUBE";
    if (n.envMap)
        switch (n.envMapMode) {
        case Xi:
        case Er:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case Lo:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function dP(n) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (n.envMap)
        switch (n.envMapMode) {
        case Er:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function pP(n) {
    let e = "ENVMAP_BLENDING_NONE";
    if (n.envMap)
        switch (n.combine) {
        case ml:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case mx:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case gx:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function mP(n) {
    const e = n.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , i = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: i,
        maxMip: t
    }
}
function gP(n, e, t, i) {
    const r = n.getContext()
      , s = t.defines;
    let o = t.vertexShader
      , a = t.fragmentShader;
    const l = hP(t)
      , c = fP(t)
      , u = dP(t)
      , h = pP(t)
      , f = mP(t)
      , d = iP(t)
      , p = rP(s)
      , v = r.createProgram();
    let g, m, y = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (g = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, p].filter(aa).join(`
`),
    g.length > 0 && (g += `
`),
    m = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, p].filter(aa).join(`
`),
    m.length > 0 && (m += `
`)) : (g = [nv(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, p, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(aa).join(`
`),
    m = [nv(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, p, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + h : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== vi ? "#define TONE_MAPPING" : "", t.toneMapping !== vi ? Ke.tonemapping_pars_fragment : "", t.toneMapping !== vi ? tP("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Ke.colorspace_pars_fragment, eP("linearToOutputTexel", t.outputColorSpace), nP(), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(aa).join(`
`)),
    o = Rd(o),
    o = Qg(o, t),
    o = ev(o, t),
    a = Rd(a),
    a = Qg(a, t),
    a = ev(a, t),
    o = tv(o),
    a = tv(a),
    t.isRawShaderMaterial !== !0 && (y = `#version 300 es
`,
    g = [d, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + g,
    m = ["#define varying in", t.glslVersion === Td ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === Td ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + m);
    const _ = y + g + o
      , x = y + m + a
      , C = Zg(r, r.VERTEX_SHADER, _)
      , w = Zg(r, r.FRAGMENT_SHADER, x);
    r.attachShader(v, C),
    r.attachShader(v, w),
    t.index0AttributeName !== void 0 ? r.bindAttribLocation(v, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(v, 0, "position"),
    r.linkProgram(v);
    function E(D) {
        if (n.debug.checkShaderErrors) {
            const F = r.getProgramInfoLog(v).trim()
              , z = r.getShaderInfoLog(C).trim()
              , $ = r.getShaderInfoLog(w).trim();
            let ne = !0
              , W = !0;
            if (r.getProgramParameter(v, r.LINK_STATUS) === !1)
                if (ne = !1,
                typeof n.debug.onShaderError == "function")
                    n.debug.onShaderError(r, v, C, w);
                else {
                    const ie = Jg(r, C, "vertex")
                      , Z = Jg(r, w, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(v, r.VALIDATE_STATUS) + `

Material Name: ` + D.name + `
Material Type: ` + D.type + `

Program Info Log: ` + F + `
` + ie + `
` + Z)
                }
            else
                F !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", F) : (z === "" || $ === "") && (W = !1);
            W && (D.diagnostics = {
                runnable: ne,
                programLog: F,
                vertexShader: {
                    log: z,
                    prefix: g
                },
                fragmentShader: {
                    log: $,
                    prefix: m
                }
            })
        }
        r.deleteShader(C),
        r.deleteShader(w),
        L = new Hc(r,v),
        S = sP(r, v)
    }
    let L;
    this.getUniforms = function() {
        return L === void 0 && E(this),
        L
    }
    ;
    let S;
    this.getAttributes = function() {
        return S === void 0 && E(this),
        S
    }
    ;
    let b = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return b === !1 && (b = r.getProgramParameter(v, KR)),
        b
    }
    ,
    this.destroy = function() {
        i.releaseStatesOfProgram(this),
        r.deleteProgram(v),
        this.program = void 0
    }
    ,
    this.type = t.shaderType,
    this.name = t.shaderName,
    this.id = ZR++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = v,
    this.vertexShader = C,
    this.fragmentShader = w,
    this
}
let vP = 0;
class _P {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , i = e.fragmentShader
          , r = this._getShaderStage(t)
          , s = this._getShaderStage(i)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(r) === !1 && (o.add(r),
        r.usedTimes++),
        o.has(s) === !1 && (o.add(s),
        s.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const i of t)
            i.usedTimes--,
            i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let i = t.get(e);
        return i === void 0 && (i = new Set,
        t.set(e, i)),
        i
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let i = t.get(e);
        return i === void 0 && (i = new yP(e),
        t.set(e, i)),
        i
    }
}
class yP {
    constructor(e) {
        this.id = vP++,
        this.code = e,
        this.usedTimes = 0
    }
}
function xP(n, e, t, i, r, s, o) {
    const a = new ph
      , l = new _P
      , c = new Set
      , u = []
      , h = r.logarithmicDepthBuffer
      , f = r.vertexTextures;
    let d = r.precision;
    const p = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function v(S) {
        return c.add(S),
        S === 0 ? "uv" : `uv${S}`
    }
    function g(S, b, D, F, z) {
        const $ = F.fog
          , ne = z.geometry
          , W = S.isMeshStandardMaterial ? F.environment : null
          , ie = (S.isMeshStandardMaterial ? t : e).get(S.envMap || W)
          , Z = ie && ie.mapping === Lo ? ie.image.height : null
          , ve = p[S.type];
        S.precision !== null && (d = r.getMaxPrecision(S.precision),
        d !== S.precision && console.warn("THREE.WebGLProgram.getParameters:", S.precision, "not supported, using", d, "instead."));
        const xe = ne.morphAttributes.position || ne.morphAttributes.normal || ne.morphAttributes.color
          , te = xe !== void 0 ? xe.length : 0;
        let Se = 0;
        ne.morphAttributes.position !== void 0 && (Se = 1),
        ne.morphAttributes.normal !== void 0 && (Se = 2),
        ne.morphAttributes.color !== void 0 && (Se = 3);
        let ze, re, pe, Me;
        if (ve) {
            const at = Kn[ve];
            ze = at.vertexShader,
            re = at.fragmentShader
        } else
            ze = S.vertexShader,
            re = S.fragmentShader,
            l.update(S),
            pe = l.getVertexShaderID(S),
            Me = l.getFragmentShaderID(S);
        const k = n.getRenderTarget()
          , se = z.isInstancedMesh === !0
          , oe = z.isBatchedMesh === !0
          , he = !!S.map
          , Re = !!S.matcap
          , I = !!ie
          , A = !!S.aoMap
          , R = !!S.lightMap
          , O = !!S.bumpMap
          , B = !!S.normalMap
          , Y = !!S.displacementMap
          , X = !!S.emissiveMap
          , ee = !!S.metalnessMap
          , T = !!S.roughnessMap
          , M = S.anisotropy > 0
          , U = S.clearcoat > 0
          , K = S.dispersion > 0
          , H = S.iridescence > 0
          , j = S.sheen > 0
          , de = S.transmission > 0
          , le = M && !!S.anisotropyMap
          , me = U && !!S.clearcoatMap
          , Ae = U && !!S.clearcoatNormalMap
          , fe = U && !!S.clearcoatRoughnessMap
          , ge = H && !!S.iridescenceMap
          , He = H && !!S.iridescenceThicknessMap
          , De = j && !!S.sheenColorMap
          , Te = j && !!S.sheenRoughnessMap
          , Ge = !!S.specularMap
          , Fe = !!S.specularColorMap
          , et = !!S.specularIntensityMap
          , V = de && !!S.transmissionMap
          , _e = de && !!S.thicknessMap
          , ce = !!S.gradientMap
          , ue = !!S.alphaMap
          , be = S.alphaTest > 0
          , ke = !!S.alphaHash
          , nt = !!S.extensions;
        let zt = vi;
        S.toneMapped && (k === null || k.isXRRenderTarget === !0) && (zt = n.toneMapping);
        const Zt = {
            shaderID: ve,
            shaderType: S.type,
            shaderName: S.name,
            vertexShader: ze,
            fragmentShader: re,
            defines: S.defines,
            customVertexShaderID: pe,
            customFragmentShaderID: Me,
            isRawShaderMaterial: S.isRawShaderMaterial === !0,
            glslVersion: S.glslVersion,
            precision: d,
            batching: oe,
            batchingColor: oe && z._colorsTexture !== null,
            instancing: se,
            instancingColor: se && z.instanceColor !== null,
            instancingMorph: se && z.morphTexture !== null,
            supportsVertexTextures: f,
            outputColorSpace: k === null ? n.outputColorSpace : k.isXRRenderTarget === !0 ? k.texture.colorSpace : Ki,
            alphaToCoverage: !!S.alphaToCoverage,
            map: he,
            matcap: Re,
            envMap: I,
            envMapMode: I && ie.mapping,
            envMapCubeUVHeight: Z,
            aoMap: A,
            lightMap: R,
            bumpMap: O,
            normalMap: B,
            displacementMap: f && Y,
            emissiveMap: X,
            normalMapObjectSpace: B && S.normalMapType === Rx,
            normalMapTangentSpace: B && S.normalMapType === Pr,
            metalnessMap: ee,
            roughnessMap: T,
            anisotropy: M,
            anisotropyMap: le,
            clearcoat: U,
            clearcoatMap: me,
            clearcoatNormalMap: Ae,
            clearcoatRoughnessMap: fe,
            dispersion: K,
            iridescence: H,
            iridescenceMap: ge,
            iridescenceThicknessMap: He,
            sheen: j,
            sheenColorMap: De,
            sheenRoughnessMap: Te,
            specularMap: Ge,
            specularColorMap: Fe,
            specularIntensityMap: et,
            transmission: de,
            transmissionMap: V,
            thicknessMap: _e,
            gradientMap: ce,
            opaque: S.transparent === !1 && S.blending === us && S.alphaToCoverage === !1,
            alphaMap: ue,
            alphaTest: be,
            alphaHash: ke,
            combine: S.combine,
            mapUv: he && v(S.map.channel),
            aoMapUv: A && v(S.aoMap.channel),
            lightMapUv: R && v(S.lightMap.channel),
            bumpMapUv: O && v(S.bumpMap.channel),
            normalMapUv: B && v(S.normalMap.channel),
            displacementMapUv: Y && v(S.displacementMap.channel),
            emissiveMapUv: X && v(S.emissiveMap.channel),
            metalnessMapUv: ee && v(S.metalnessMap.channel),
            roughnessMapUv: T && v(S.roughnessMap.channel),
            anisotropyMapUv: le && v(S.anisotropyMap.channel),
            clearcoatMapUv: me && v(S.clearcoatMap.channel),
            clearcoatNormalMapUv: Ae && v(S.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: fe && v(S.clearcoatRoughnessMap.channel),
            iridescenceMapUv: ge && v(S.iridescenceMap.channel),
            iridescenceThicknessMapUv: He && v(S.iridescenceThicknessMap.channel),
            sheenColorMapUv: De && v(S.sheenColorMap.channel),
            sheenRoughnessMapUv: Te && v(S.sheenRoughnessMap.channel),
            specularMapUv: Ge && v(S.specularMap.channel),
            specularColorMapUv: Fe && v(S.specularColorMap.channel),
            specularIntensityMapUv: et && v(S.specularIntensityMap.channel),
            transmissionMapUv: V && v(S.transmissionMap.channel),
            thicknessMapUv: _e && v(S.thicknessMap.channel),
            alphaMapUv: ue && v(S.alphaMap.channel),
            vertexTangents: !!ne.attributes.tangent && (B || M),
            vertexColors: S.vertexColors,
            vertexAlphas: S.vertexColors === !0 && !!ne.attributes.color && ne.attributes.color.itemSize === 4,
            pointsUvs: z.isPoints === !0 && !!ne.attributes.uv && (he || ue),
            fog: !!$,
            useFog: S.fog === !0,
            fogExp2: !!$ && $.isFogExp2,
            flatShading: S.flatShading === !0,
            sizeAttenuation: S.sizeAttenuation === !0,
            logarithmicDepthBuffer: h,
            skinning: z.isSkinnedMesh === !0,
            morphTargets: ne.morphAttributes.position !== void 0,
            morphNormals: ne.morphAttributes.normal !== void 0,
            morphColors: ne.morphAttributes.color !== void 0,
            morphTargetsCount: te,
            morphTextureStride: Se,
            numDirLights: b.directional.length,
            numPointLights: b.point.length,
            numSpotLights: b.spot.length,
            numSpotLightMaps: b.spotLightMap.length,
            numRectAreaLights: b.rectArea.length,
            numHemiLights: b.hemi.length,
            numDirLightShadows: b.directionalShadowMap.length,
            numPointLightShadows: b.pointShadowMap.length,
            numSpotLightShadows: b.spotShadowMap.length,
            numSpotLightShadowsWithMaps: b.numSpotLightShadowsWithMaps,
            numLightProbes: b.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: S.dithering,
            shadowMapEnabled: n.shadowMap.enabled && D.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: zt,
            decodeVideoTexture: he && S.map.isVideoTexture === !0 && st.getTransfer(S.map.colorSpace) === xt,
            premultipliedAlpha: S.premultipliedAlpha,
            doubleSided: S.side === Zn,
            flipSided: S.side === _n,
            useDepthPacking: S.depthPacking >= 0,
            depthPacking: S.depthPacking || 0,
            index0AttributeName: S.index0AttributeName,
            extensionClipCullDistance: nt && S.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (nt && S.extensions.multiDraw === !0 || oe) && i.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: S.customProgramCacheKey()
        };
        return Zt.vertexUv1s = c.has(1),
        Zt.vertexUv2s = c.has(2),
        Zt.vertexUv3s = c.has(3),
        c.clear(),
        Zt
    }
    function m(S) {
        const b = [];
        if (S.shaderID ? b.push(S.shaderID) : (b.push(S.customVertexShaderID),
        b.push(S.customFragmentShaderID)),
        S.defines !== void 0)
            for (const D in S.defines)
                b.push(D),
                b.push(S.defines[D]);
        return S.isRawShaderMaterial === !1 && (y(b, S),
        _(b, S),
        b.push(n.outputColorSpace)),
        b.push(S.customProgramCacheKey),
        b.join()
    }
    function y(S, b) {
        S.push(b.precision),
        S.push(b.outputColorSpace),
        S.push(b.envMapMode),
        S.push(b.envMapCubeUVHeight),
        S.push(b.mapUv),
        S.push(b.alphaMapUv),
        S.push(b.lightMapUv),
        S.push(b.aoMapUv),
        S.push(b.bumpMapUv),
        S.push(b.normalMapUv),
        S.push(b.displacementMapUv),
        S.push(b.emissiveMapUv),
        S.push(b.metalnessMapUv),
        S.push(b.roughnessMapUv),
        S.push(b.anisotropyMapUv),
        S.push(b.clearcoatMapUv),
        S.push(b.clearcoatNormalMapUv),
        S.push(b.clearcoatRoughnessMapUv),
        S.push(b.iridescenceMapUv),
        S.push(b.iridescenceThicknessMapUv),
        S.push(b.sheenColorMapUv),
        S.push(b.sheenRoughnessMapUv),
        S.push(b.specularMapUv),
        S.push(b.specularColorMapUv),
        S.push(b.specularIntensityMapUv),
        S.push(b.transmissionMapUv),
        S.push(b.thicknessMapUv),
        S.push(b.combine),
        S.push(b.fogExp2),
        S.push(b.sizeAttenuation),
        S.push(b.morphTargetsCount),
        S.push(b.morphAttributeCount),
        S.push(b.numDirLights),
        S.push(b.numPointLights),
        S.push(b.numSpotLights),
        S.push(b.numSpotLightMaps),
        S.push(b.numHemiLights),
        S.push(b.numRectAreaLights),
        S.push(b.numDirLightShadows),
        S.push(b.numPointLightShadows),
        S.push(b.numSpotLightShadows),
        S.push(b.numSpotLightShadowsWithMaps),
        S.push(b.numLightProbes),
        S.push(b.shadowMapType),
        S.push(b.toneMapping),
        S.push(b.numClippingPlanes),
        S.push(b.numClipIntersection),
        S.push(b.depthPacking)
    }
    function _(S, b) {
        a.disableAll(),
        b.supportsVertexTextures && a.enable(0),
        b.instancing && a.enable(1),
        b.instancingColor && a.enable(2),
        b.instancingMorph && a.enable(3),
        b.matcap && a.enable(4),
        b.envMap && a.enable(5),
        b.normalMapObjectSpace && a.enable(6),
        b.normalMapTangentSpace && a.enable(7),
        b.clearcoat && a.enable(8),
        b.iridescence && a.enable(9),
        b.alphaTest && a.enable(10),
        b.vertexColors && a.enable(11),
        b.vertexAlphas && a.enable(12),
        b.vertexUv1s && a.enable(13),
        b.vertexUv2s && a.enable(14),
        b.vertexUv3s && a.enable(15),
        b.vertexTangents && a.enable(16),
        b.anisotropy && a.enable(17),
        b.alphaHash && a.enable(18),
        b.batching && a.enable(19),
        b.dispersion && a.enable(20),
        b.batchingColor && a.enable(21),
        S.push(a.mask),
        a.disableAll(),
        b.fog && a.enable(0),
        b.useFog && a.enable(1),
        b.flatShading && a.enable(2),
        b.logarithmicDepthBuffer && a.enable(3),
        b.skinning && a.enable(4),
        b.morphTargets && a.enable(5),
        b.morphNormals && a.enable(6),
        b.morphColors && a.enable(7),
        b.premultipliedAlpha && a.enable(8),
        b.shadowMapEnabled && a.enable(9),
        b.doubleSided && a.enable(10),
        b.flipSided && a.enable(11),
        b.useDepthPacking && a.enable(12),
        b.dithering && a.enable(13),
        b.transmission && a.enable(14),
        b.sheen && a.enable(15),
        b.opaque && a.enable(16),
        b.pointsUvs && a.enable(17),
        b.decodeVideoTexture && a.enable(18),
        b.alphaToCoverage && a.enable(19),
        S.push(a.mask)
    }
    function x(S) {
        const b = p[S.type];
        let D;
        if (b) {
            const F = Kn[b];
            D = Gx.clone(F.uniforms)
        } else
            D = S.uniforms;
        return D
    }
    function C(S, b) {
        let D;
        for (let F = 0, z = u.length; F < z; F++) {
            const $ = u[F];
            if ($.cacheKey === b) {
                D = $,
                ++D.usedTimes;
                break
            }
        }
        return D === void 0 && (D = new gP(n,b,S,s),
        u.push(D)),
        D
    }
    function w(S) {
        if (--S.usedTimes === 0) {
            const b = u.indexOf(S);
            u[b] = u[u.length - 1],
            u.pop(),
            S.destroy()
        }
    }
    function E(S) {
        l.remove(S)
    }
    function L() {
        l.dispose()
    }
    return {
        getParameters: g,
        getProgramCacheKey: m,
        getUniforms: x,
        acquireProgram: C,
        releaseProgram: w,
        releaseShaderCache: E,
        programs: u,
        dispose: L
    }
}
function bP() {
    let n = new WeakMap;
    function e(o) {
        return n.has(o)
    }
    function t(o) {
        let a = n.get(o);
        return a === void 0 && (a = {},
        n.set(o, a)),
        a
    }
    function i(o) {
        n.delete(o)
    }
    function r(o, a, l) {
        n.get(o)[a] = l
    }
    function s() {
        n = new WeakMap
    }
    return {
        has: e,
        get: t,
        remove: i,
        update: r,
        dispose: s
    }
}
function MP(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}
function iv(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}
function rv() {
    const n = [];
    let e = 0;
    const t = []
      , i = []
      , r = [];
    function s() {
        e = 0,
        t.length = 0,
        i.length = 0,
        r.length = 0
    }
    function o(h, f, d, p, v, g) {
        let m = n[e];
        return m === void 0 ? (m = {
            id: h.id,
            object: h,
            geometry: f,
            material: d,
            groupOrder: p,
            renderOrder: h.renderOrder,
            z: v,
            group: g
        },
        n[e] = m) : (m.id = h.id,
        m.object = h,
        m.geometry = f,
        m.material = d,
        m.groupOrder = p,
        m.renderOrder = h.renderOrder,
        m.z = v,
        m.group = g),
        e++,
        m
    }
    function a(h, f, d, p, v, g) {
        const m = o(h, f, d, p, v, g);
        d.transmission > 0 ? i.push(m) : d.transparent === !0 ? r.push(m) : t.push(m)
    }
    function l(h, f, d, p, v, g) {
        const m = o(h, f, d, p, v, g);
        d.transmission > 0 ? i.unshift(m) : d.transparent === !0 ? r.unshift(m) : t.unshift(m)
    }
    function c(h, f) {
        t.length > 1 && t.sort(h || MP),
        i.length > 1 && i.sort(f || iv),
        r.length > 1 && r.sort(f || iv)
    }
    function u() {
        for (let h = e, f = n.length; h < f; h++) {
            const d = n[h];
            if (d.id === null)
                break;
            d.id = null,
            d.object = null,
            d.geometry = null,
            d.material = null,
            d.group = null
        }
    }
    return {
        opaque: t,
        transmissive: i,
        transparent: r,
        init: s,
        push: a,
        unshift: l,
        finish: u,
        sort: c
    }
}
function SP() {
    let n = new WeakMap;
    function e(i, r) {
        const s = n.get(i);
        let o;
        return s === void 0 ? (o = new rv,
        n.set(i, [o])) : r >= s.length ? (o = new rv,
        s.push(o)) : o = s[r],
        o
    }
    function t() {
        n = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function wP() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new N,
                    color: new Ee
                };
                break;
            case "SpotLight":
                t = {
                    position: new N,
                    direction: new N,
                    color: new Ee,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new N,
                    color: new Ee,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new N,
                    skyColor: new Ee,
                    groundColor: new Ee
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new Ee,
                    position: new N,
                    halfWidth: new N,
                    halfHeight: new N
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
function EP() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new ae
                };
                break;
            case "SpotLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new ae
                };
                break;
            case "PointLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new ae,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
let AP = 0;
function TP(n, e) {
    return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}
function CP(n) {
    const e = new wP
      , t = EP()
      , i = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let c = 0; c < 9; c++)
        i.probe.push(new N);
    const r = new N
      , s = new Be
      , o = new Be;
    function a(c) {
        let u = 0
          , h = 0
          , f = 0;
        for (let S = 0; S < 9; S++)
            i.probe[S].set(0, 0, 0);
        let d = 0
          , p = 0
          , v = 0
          , g = 0
          , m = 0
          , y = 0
          , _ = 0
          , x = 0
          , C = 0
          , w = 0
          , E = 0;
        c.sort(TP);
        for (let S = 0, b = c.length; S < b; S++) {
            const D = c[S]
              , F = D.color
              , z = D.intensity
              , $ = D.distance
              , ne = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
            if (D.isAmbientLight)
                u += F.r * z,
                h += F.g * z,
                f += F.b * z;
            else if (D.isLightProbe) {
                for (let W = 0; W < 9; W++)
                    i.probe[W].addScaledVector(D.sh.coefficients[W], z);
                E++
            } else if (D.isDirectionalLight) {
                const W = e.get(D);
                if (W.color.copy(D.color).multiplyScalar(D.intensity),
                D.castShadow) {
                    const ie = D.shadow
                      , Z = t.get(D);
                    Z.shadowIntensity = ie.intensity,
                    Z.shadowBias = ie.bias,
                    Z.shadowNormalBias = ie.normalBias,
                    Z.shadowRadius = ie.radius,
                    Z.shadowMapSize = ie.mapSize,
                    i.directionalShadow[d] = Z,
                    i.directionalShadowMap[d] = ne,
                    i.directionalShadowMatrix[d] = D.shadow.matrix,
                    y++
                }
                i.directional[d] = W,
                d++
            } else if (D.isSpotLight) {
                const W = e.get(D);
                W.position.setFromMatrixPosition(D.matrixWorld),
                W.color.copy(F).multiplyScalar(z),
                W.distance = $,
                W.coneCos = Math.cos(D.angle),
                W.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)),
                W.decay = D.decay,
                i.spot[v] = W;
                const ie = D.shadow;
                if (D.map && (i.spotLightMap[C] = D.map,
                C++,
                ie.updateMatrices(D),
                D.castShadow && w++),
                i.spotLightMatrix[v] = ie.matrix,
                D.castShadow) {
                    const Z = t.get(D);
                    Z.shadowIntensity = ie.intensity,
                    Z.shadowBias = ie.bias,
                    Z.shadowNormalBias = ie.normalBias,
                    Z.shadowRadius = ie.radius,
                    Z.shadowMapSize = ie.mapSize,
                    i.spotShadow[v] = Z,
                    i.spotShadowMap[v] = ne,
                    x++
                }
                v++
            } else if (D.isRectAreaLight) {
                const W = e.get(D);
                W.color.copy(F).multiplyScalar(z),
                W.halfWidth.set(D.width * .5, 0, 0),
                W.halfHeight.set(0, D.height * .5, 0),
                i.rectArea[g] = W,
                g++
            } else if (D.isPointLight) {
                const W = e.get(D);
                if (W.color.copy(D.color).multiplyScalar(D.intensity),
                W.distance = D.distance,
                W.decay = D.decay,
                D.castShadow) {
                    const ie = D.shadow
                      , Z = t.get(D);
                    Z.shadowIntensity = ie.intensity,
                    Z.shadowBias = ie.bias,
                    Z.shadowNormalBias = ie.normalBias,
                    Z.shadowRadius = ie.radius,
                    Z.shadowMapSize = ie.mapSize,
                    Z.shadowCameraNear = ie.camera.near,
                    Z.shadowCameraFar = ie.camera.far,
                    i.pointShadow[p] = Z,
                    i.pointShadowMap[p] = ne,
                    i.pointShadowMatrix[p] = D.shadow.matrix,
                    _++
                }
                i.point[p] = W,
                p++
            } else if (D.isHemisphereLight) {
                const W = e.get(D);
                W.skyColor.copy(D.color).multiplyScalar(z),
                W.groundColor.copy(D.groundColor).multiplyScalar(z),
                i.hemi[m] = W,
                m++
            }
        }
        g > 0 && (n.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = we.LTC_FLOAT_1,
        i.rectAreaLTC2 = we.LTC_FLOAT_2) : (i.rectAreaLTC1 = we.LTC_HALF_1,
        i.rectAreaLTC2 = we.LTC_HALF_2)),
        i.ambient[0] = u,
        i.ambient[1] = h,
        i.ambient[2] = f;
        const L = i.hash;
        (L.directionalLength !== d || L.pointLength !== p || L.spotLength !== v || L.rectAreaLength !== g || L.hemiLength !== m || L.numDirectionalShadows !== y || L.numPointShadows !== _ || L.numSpotShadows !== x || L.numSpotMaps !== C || L.numLightProbes !== E) && (i.directional.length = d,
        i.spot.length = v,
        i.rectArea.length = g,
        i.point.length = p,
        i.hemi.length = m,
        i.directionalShadow.length = y,
        i.directionalShadowMap.length = y,
        i.pointShadow.length = _,
        i.pointShadowMap.length = _,
        i.spotShadow.length = x,
        i.spotShadowMap.length = x,
        i.directionalShadowMatrix.length = y,
        i.pointShadowMatrix.length = _,
        i.spotLightMatrix.length = x + C - w,
        i.spotLightMap.length = C,
        i.numSpotLightShadowsWithMaps = w,
        i.numLightProbes = E,
        L.directionalLength = d,
        L.pointLength = p,
        L.spotLength = v,
        L.rectAreaLength = g,
        L.hemiLength = m,
        L.numDirectionalShadows = y,
        L.numPointShadows = _,
        L.numSpotShadows = x,
        L.numSpotMaps = C,
        L.numLightProbes = E,
        i.version = AP++)
    }
    function l(c, u) {
        let h = 0
          , f = 0
          , d = 0
          , p = 0
          , v = 0;
        const g = u.matrixWorldInverse;
        for (let m = 0, y = c.length; m < y; m++) {
            const _ = c[m];
            if (_.isDirectionalLight) {
                const x = i.directional[h];
                x.direction.setFromMatrixPosition(_.matrixWorld),
                r.setFromMatrixPosition(_.target.matrixWorld),
                x.direction.sub(r),
                x.direction.transformDirection(g),
                h++
            } else if (_.isSpotLight) {
                const x = i.spot[d];
                x.position.setFromMatrixPosition(_.matrixWorld),
                x.position.applyMatrix4(g),
                x.direction.setFromMatrixPosition(_.matrixWorld),
                r.setFromMatrixPosition(_.target.matrixWorld),
                x.direction.sub(r),
                x.direction.transformDirection(g),
                d++
            } else if (_.isRectAreaLight) {
                const x = i.rectArea[p];
                x.position.setFromMatrixPosition(_.matrixWorld),
                x.position.applyMatrix4(g),
                o.identity(),
                s.copy(_.matrixWorld),
                s.premultiply(g),
                o.extractRotation(s),
                x.halfWidth.set(_.width * .5, 0, 0),
                x.halfHeight.set(0, _.height * .5, 0),
                x.halfWidth.applyMatrix4(o),
                x.halfHeight.applyMatrix4(o),
                p++
            } else if (_.isPointLight) {
                const x = i.point[f];
                x.position.setFromMatrixPosition(_.matrixWorld),
                x.position.applyMatrix4(g),
                f++
            } else if (_.isHemisphereLight) {
                const x = i.hemi[v];
                x.direction.setFromMatrixPosition(_.matrixWorld),
                x.direction.transformDirection(g),
                v++
            }
        }
    }
    return {
        setup: a,
        setupView: l,
        state: i
    }
}
function sv(n) {
    const e = new CP(n)
      , t = []
      , i = [];
    function r(u) {
        c.camera = u,
        t.length = 0,
        i.length = 0
    }
    function s(u) {
        t.push(u)
    }
    function o(u) {
        i.push(u)
    }
    function a() {
        e.setup(t)
    }
    function l(u) {
        e.setupView(t, u)
    }
    const c = {
        lightsArray: t,
        shadowsArray: i,
        camera: null,
        lights: e,
        transmissionRenderTarget: {}
    };
    return {
        init: r,
        state: c,
        setupLights: a,
        setupLightsView: l,
        pushLight: s,
        pushShadow: o
    }
}
function RP(n) {
    let e = new WeakMap;
    function t(r, s=0) {
        const o = e.get(r);
        let a;
        return o === void 0 ? (a = new sv(n),
        e.set(r, [a])) : s >= o.length ? (a = new sv(n),
        o.push(a)) : a = o[s],
        a
    }
    function i() {
        e = new WeakMap
    }
    return {
        get: t,
        dispose: i
    }
}
class Vp extends cn {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = Tx,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class Hp extends cn {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const PP = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , IP = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function LP(n, e, t) {
    let i = new xl;
    const r = new ae
      , s = new ae
      , o = new ft
      , a = new Vp({
        depthPacking: Cx
    })
      , l = new Hp
      , c = {}
      , u = t.maxTextureSize
      , h = {
        [Wi]: _n,
        [_n]: Wi,
        [Zn]: Zn
    }
      , f = new oi({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new ae
            },
            radius: {
                value: 4
            }
        },
        vertexShader: PP,
        fragmentShader: IP
    })
      , d = f.clone();
    d.defines.HORIZONTAL_PASS = 1;
    const p = new Ze;
    p.setAttribute("position", new pt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const v = new Ot(p,f)
      , g = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = xp;
    let m = this.type;
    this.render = function(w, E, L) {
        if (g.enabled === !1 || g.autoUpdate === !1 && g.needsUpdate === !1 || w.length === 0)
            return;
        const S = n.getRenderTarget()
          , b = n.getActiveCubeFace()
          , D = n.getActiveMipmapLevel()
          , F = n.state;
        F.setBlending(Vi),
        F.buffers.color.setClear(1, 1, 1, 1),
        F.buffers.depth.setTest(!0),
        F.setScissorTest(!1);
        const z = m !== fi && this.type === fi
          , $ = m === fi && this.type !== fi;
        for (let ne = 0, W = w.length; ne < W; ne++) {
            const ie = w[ne]
              , Z = ie.shadow;
            if (Z === void 0) {
                console.warn("THREE.WebGLShadowMap:", ie, "has no shadow.");
                continue
            }
            if (Z.autoUpdate === !1 && Z.needsUpdate === !1)
                continue;
            r.copy(Z.mapSize);
            const ve = Z.getFrameExtents();
            if (r.multiply(ve),
            s.copy(Z.mapSize),
            (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / ve.x),
            r.x = s.x * ve.x,
            Z.mapSize.x = s.x),
            r.y > u && (s.y = Math.floor(u / ve.y),
            r.y = s.y * ve.y,
            Z.mapSize.y = s.y)),
            Z.map === null || z === !0 || $ === !0) {
                const te = this.type !== fi ? {
                    minFilter: Kt,
                    magFilter: Kt
                } : {};
                Z.map !== null && Z.map.dispose(),
                Z.map = new si(r.x,r.y,te),
                Z.map.texture.name = ie.name + ".shadowMap",
                Z.camera.updateProjectionMatrix()
            }
            n.setRenderTarget(Z.map),
            n.clear();
            const xe = Z.getViewportCount();
            for (let te = 0; te < xe; te++) {
                const Se = Z.getViewport(te);
                o.set(s.x * Se.x, s.y * Se.y, s.x * Se.z, s.y * Se.w),
                F.viewport(o),
                Z.updateMatrices(ie, te),
                i = Z.getFrustum(),
                x(E, L, Z.camera, ie, this.type)
            }
            Z.isPointLightShadow !== !0 && this.type === fi && y(Z, L),
            Z.needsUpdate = !1
        }
        m = this.type,
        g.needsUpdate = !1,
        n.setRenderTarget(S, b, D)
    }
    ;
    function y(w, E) {
        const L = e.update(v);
        f.defines.VSM_SAMPLES !== w.blurSamples && (f.defines.VSM_SAMPLES = w.blurSamples,
        d.defines.VSM_SAMPLES = w.blurSamples,
        f.needsUpdate = !0,
        d.needsUpdate = !0),
        w.mapPass === null && (w.mapPass = new si(r.x,r.y)),
        f.uniforms.shadow_pass.value = w.map.texture,
        f.uniforms.resolution.value = w.mapSize,
        f.uniforms.radius.value = w.radius,
        n.setRenderTarget(w.mapPass),
        n.clear(),
        n.renderBufferDirect(E, null, L, f, v, null),
        d.uniforms.shadow_pass.value = w.mapPass.texture,
        d.uniforms.resolution.value = w.mapSize,
        d.uniforms.radius.value = w.radius,
        n.setRenderTarget(w.map),
        n.clear(),
        n.renderBufferDirect(E, null, L, d, v, null)
    }
    function _(w, E, L, S) {
        let b = null;
        const D = L.isPointLight === !0 ? w.customDistanceMaterial : w.customDepthMaterial;
        if (D !== void 0)
            b = D;
        else if (b = L.isPointLight === !0 ? l : a,
        n.localClippingEnabled && E.clipShadows === !0 && Array.isArray(E.clippingPlanes) && E.clippingPlanes.length !== 0 || E.displacementMap && E.displacementScale !== 0 || E.alphaMap && E.alphaTest > 0 || E.map && E.alphaTest > 0) {
            const F = b.uuid
              , z = E.uuid;
            let $ = c[F];
            $ === void 0 && ($ = {},
            c[F] = $);
            let ne = $[z];
            ne === void 0 && (ne = b.clone(),
            $[z] = ne,
            E.addEventListener("dispose", C)),
            b = ne
        }
        if (b.visible = E.visible,
        b.wireframe = E.wireframe,
        S === fi ? b.side = E.shadowSide !== null ? E.shadowSide : E.side : b.side = E.shadowSide !== null ? E.shadowSide : h[E.side],
        b.alphaMap = E.alphaMap,
        b.alphaTest = E.alphaTest,
        b.map = E.map,
        b.clipShadows = E.clipShadows,
        b.clippingPlanes = E.clippingPlanes,
        b.clipIntersection = E.clipIntersection,
        b.displacementMap = E.displacementMap,
        b.displacementScale = E.displacementScale,
        b.displacementBias = E.displacementBias,
        b.wireframeLinewidth = E.wireframeLinewidth,
        b.linewidth = E.linewidth,
        L.isPointLight === !0 && b.isMeshDistanceMaterial === !0) {
            const F = n.properties.get(b);
            F.light = L
        }
        return b
    }
    function x(w, E, L, S, b) {
        if (w.visible === !1)
            return;
        if (w.layers.test(E.layers) && (w.isMesh || w.isLine || w.isPoints) && (w.castShadow || w.receiveShadow && b === fi) && (!w.frustumCulled || i.intersectsObject(w))) {
            w.modelViewMatrix.multiplyMatrices(L.matrixWorldInverse, w.matrixWorld);
            const z = e.update(w)
              , $ = w.material;
            if (Array.isArray($)) {
                const ne = z.groups;
                for (let W = 0, ie = ne.length; W < ie; W++) {
                    const Z = ne[W]
                      , ve = $[Z.materialIndex];
                    if (ve && ve.visible) {
                        const xe = _(w, ve, S, b);
                        w.onBeforeShadow(n, w, E, L, z, xe, Z),
                        n.renderBufferDirect(L, null, z, xe, w, Z),
                        w.onAfterShadow(n, w, E, L, z, xe, Z)
                    }
                }
            } else if ($.visible) {
                const ne = _(w, $, S, b);
                w.onBeforeShadow(n, w, E, L, z, ne, null),
                n.renderBufferDirect(L, null, z, ne, w, null),
                w.onAfterShadow(n, w, E, L, z, ne, null)
            }
        }
        const F = w.children;
        for (let z = 0, $ = F.length; z < $; z++)
            x(F[z], E, L, S, b)
    }
    function C(w) {
        w.target.removeEventListener("dispose", C);
        for (const L in c) {
            const S = c[L]
              , b = w.target.uuid;
            b in S && (S[b].dispose(),
            delete S[b])
        }
    }
}
function DP(n) {
    function e() {
        let V = !1;
        const _e = new ft;
        let ce = null;
        const ue = new ft(0,0,0,0);
        return {
            setMask: function(be) {
                ce !== be && !V && (n.colorMask(be, be, be, be),
                ce = be)
            },
            setLocked: function(be) {
                V = be
            },
            setClear: function(be, ke, nt, zt, Zt) {
                Zt === !0 && (be *= zt,
                ke *= zt,
                nt *= zt),
                _e.set(be, ke, nt, zt),
                ue.equals(_e) === !1 && (n.clearColor(be, ke, nt, zt),
                ue.copy(_e))
            },
            reset: function() {
                V = !1,
                ce = null,
                ue.set(-1, 0, 0, 0)
            }
        }
    }
    function t() {
        let V = !1
          , _e = null
          , ce = null
          , ue = null;
        return {
            setTest: function(be) {
                be ? Me(n.DEPTH_TEST) : k(n.DEPTH_TEST)
            },
            setMask: function(be) {
                _e !== be && !V && (n.depthMask(be),
                _e = be)
            },
            setFunc: function(be) {
                if (ce !== be) {
                    switch (be) {
                    case lx:
                        n.depthFunc(n.NEVER);
                        break;
                    case cx:
                        n.depthFunc(n.ALWAYS);
                        break;
                    case ux:
                        n.depthFunc(n.LESS);
                        break;
                    case Ba:
                        n.depthFunc(n.LEQUAL);
                        break;
                    case hx:
                        n.depthFunc(n.EQUAL);
                        break;
                    case fx:
                        n.depthFunc(n.GEQUAL);
                        break;
                    case dx:
                        n.depthFunc(n.GREATER);
                        break;
                    case px:
                        n.depthFunc(n.NOTEQUAL);
                        break;
                    default:
                        n.depthFunc(n.LEQUAL)
                    }
                    ce = be
                }
            },
            setLocked: function(be) {
                V = be
            },
            setClear: function(be) {
                ue !== be && (n.clearDepth(be),
                ue = be)
            },
            reset: function() {
                V = !1,
                _e = null,
                ce = null,
                ue = null
            }
        }
    }
    function i() {
        let V = !1
          , _e = null
          , ce = null
          , ue = null
          , be = null
          , ke = null
          , nt = null
          , zt = null
          , Zt = null;
        return {
            setTest: function(at) {
                V || (at ? Me(n.STENCIL_TEST) : k(n.STENCIL_TEST))
            },
            setMask: function(at) {
                _e !== at && !V && (n.stencilMask(at),
                _e = at)
            },
            setFunc: function(at, Ei, ui) {
                (ce !== at || ue !== Ei || be !== ui) && (n.stencilFunc(at, Ei, ui),
                ce = at,
                ue = Ei,
                be = ui)
            },
            setOp: function(at, Ei, ui) {
                (ke !== at || nt !== Ei || zt !== ui) && (n.stencilOp(at, Ei, ui),
                ke = at,
                nt = Ei,
                zt = ui)
            },
            setLocked: function(at) {
                V = at
            },
            setClear: function(at) {
                Zt !== at && (n.clearStencil(at),
                Zt = at)
            },
            reset: function() {
                V = !1,
                _e = null,
                ce = null,
                ue = null,
                be = null,
                ke = null,
                nt = null,
                zt = null,
                Zt = null
            }
        }
    }
    const r = new e
      , s = new t
      , o = new i
      , a = new WeakMap
      , l = new WeakMap;
    let c = {}
      , u = {}
      , h = new WeakMap
      , f = []
      , d = null
      , p = !1
      , v = null
      , g = null
      , m = null
      , y = null
      , _ = null
      , x = null
      , C = null
      , w = new Ee(0,0,0)
      , E = 0
      , L = !1
      , S = null
      , b = null
      , D = null
      , F = null
      , z = null;
    const $ = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let ne = !1
      , W = 0;
    const ie = n.getParameter(n.VERSION);
    ie.indexOf("WebGL") !== -1 ? (W = parseFloat(/^WebGL (\d)/.exec(ie)[1]),
    ne = W >= 1) : ie.indexOf("OpenGL ES") !== -1 && (W = parseFloat(/^OpenGL ES (\d)/.exec(ie)[1]),
    ne = W >= 2);
    let Z = null
      , ve = {};
    const xe = n.getParameter(n.SCISSOR_BOX)
      , te = n.getParameter(n.VIEWPORT)
      , Se = new ft().fromArray(xe)
      , ze = new ft().fromArray(te);
    function re(V, _e, ce, ue) {
        const be = new Uint8Array(4)
          , ke = n.createTexture();
        n.bindTexture(V, ke),
        n.texParameteri(V, n.TEXTURE_MIN_FILTER, n.NEAREST),
        n.texParameteri(V, n.TEXTURE_MAG_FILTER, n.NEAREST);
        for (let nt = 0; nt < ce; nt++)
            V === n.TEXTURE_3D || V === n.TEXTURE_2D_ARRAY ? n.texImage3D(_e, 0, n.RGBA, 1, 1, ue, 0, n.RGBA, n.UNSIGNED_BYTE, be) : n.texImage2D(_e + nt, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, be);
        return ke
    }
    const pe = {};
    pe[n.TEXTURE_2D] = re(n.TEXTURE_2D, n.TEXTURE_2D, 1),
    pe[n.TEXTURE_CUBE_MAP] = re(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    pe[n.TEXTURE_2D_ARRAY] = re(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1),
    pe[n.TEXTURE_3D] = re(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1),
    r.setClear(0, 0, 0, 1),
    s.setClear(1),
    o.setClear(0),
    Me(n.DEPTH_TEST),
    s.setFunc(Ba),
    O(!1),
    B(bd),
    Me(n.CULL_FACE),
    A(Vi);
    function Me(V) {
        c[V] !== !0 && (n.enable(V),
        c[V] = !0)
    }
    function k(V) {
        c[V] !== !1 && (n.disable(V),
        c[V] = !1)
    }
    function se(V, _e) {
        return u[V] !== _e ? (n.bindFramebuffer(V, _e),
        u[V] = _e,
        V === n.DRAW_FRAMEBUFFER && (u[n.FRAMEBUFFER] = _e),
        V === n.FRAMEBUFFER && (u[n.DRAW_FRAMEBUFFER] = _e),
        !0) : !1
    }
    function oe(V, _e) {
        let ce = f
          , ue = !1;
        if (V) {
            ce = h.get(_e),
            ce === void 0 && (ce = [],
            h.set(_e, ce));
            const be = V.textures;
            if (ce.length !== be.length || ce[0] !== n.COLOR_ATTACHMENT0) {
                for (let ke = 0, nt = be.length; ke < nt; ke++)
                    ce[ke] = n.COLOR_ATTACHMENT0 + ke;
                ce.length = be.length,
                ue = !0
            }
        } else
            ce[0] !== n.BACK && (ce[0] = n.BACK,
            ue = !0);
        ue && n.drawBuffers(ce)
    }
    function he(V) {
        return d !== V ? (n.useProgram(V),
        d = V,
        !0) : !1
    }
    const Re = {
        [yr]: n.FUNC_ADD,
        [Xy]: n.FUNC_SUBTRACT,
        [qy]: n.FUNC_REVERSE_SUBTRACT
    };
    Re[$y] = n.MIN,
    Re[Yy] = n.MAX;
    const I = {
        [jy]: n.ZERO,
        [Ky]: n.ONE,
        [Zy]: n.SRC_COLOR,
        [iu]: n.SRC_ALPHA,
        [ix]: n.SRC_ALPHA_SATURATE,
        [tx]: n.DST_COLOR,
        [Qy]: n.DST_ALPHA,
        [Jy]: n.ONE_MINUS_SRC_COLOR,
        [ru]: n.ONE_MINUS_SRC_ALPHA,
        [nx]: n.ONE_MINUS_DST_COLOR,
        [ex]: n.ONE_MINUS_DST_ALPHA,
        [rx]: n.CONSTANT_COLOR,
        [sx]: n.ONE_MINUS_CONSTANT_COLOR,
        [ox]: n.CONSTANT_ALPHA,
        [ax]: n.ONE_MINUS_CONSTANT_ALPHA
    };
    function A(V, _e, ce, ue, be, ke, nt, zt, Zt, at) {
        if (V === Vi) {
            p === !0 && (k(n.BLEND),
            p = !1);
            return
        }
        if (p === !1 && (Me(n.BLEND),
        p = !0),
        V !== Wy) {
            if (V !== v || at !== L) {
                if ((g !== yr || _ !== yr) && (n.blendEquation(n.FUNC_ADD),
                g = yr,
                _ = yr),
                at)
                    switch (V) {
                    case us:
                        n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Md:
                        n.blendFunc(n.ONE, n.ONE);
                        break;
                    case Sd:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case wd:
                        n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", V);
                        break
                    }
                else
                    switch (V) {
                    case us:
                        n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Md:
                        n.blendFunc(n.SRC_ALPHA, n.ONE);
                        break;
                    case Sd:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case wd:
                        n.blendFunc(n.ZERO, n.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", V);
                        break
                    }
                m = null,
                y = null,
                x = null,
                C = null,
                w.set(0, 0, 0),
                E = 0,
                v = V,
                L = at
            }
            return
        }
        be = be || _e,
        ke = ke || ce,
        nt = nt || ue,
        (_e !== g || be !== _) && (n.blendEquationSeparate(Re[_e], Re[be]),
        g = _e,
        _ = be),
        (ce !== m || ue !== y || ke !== x || nt !== C) && (n.blendFuncSeparate(I[ce], I[ue], I[ke], I[nt]),
        m = ce,
        y = ue,
        x = ke,
        C = nt),
        (zt.equals(w) === !1 || Zt !== E) && (n.blendColor(zt.r, zt.g, zt.b, Zt),
        w.copy(zt),
        E = Zt),
        v = V,
        L = !1
    }
    function R(V, _e) {
        V.side === Zn ? k(n.CULL_FACE) : Me(n.CULL_FACE);
        let ce = V.side === _n;
        _e && (ce = !ce),
        O(ce),
        V.blending === us && V.transparent === !1 ? A(Vi) : A(V.blending, V.blendEquation, V.blendSrc, V.blendDst, V.blendEquationAlpha, V.blendSrcAlpha, V.blendDstAlpha, V.blendColor, V.blendAlpha, V.premultipliedAlpha),
        s.setFunc(V.depthFunc),
        s.setTest(V.depthTest),
        s.setMask(V.depthWrite),
        r.setMask(V.colorWrite);
        const ue = V.stencilWrite;
        o.setTest(ue),
        ue && (o.setMask(V.stencilWriteMask),
        o.setFunc(V.stencilFunc, V.stencilRef, V.stencilFuncMask),
        o.setOp(V.stencilFail, V.stencilZFail, V.stencilZPass)),
        X(V.polygonOffset, V.polygonOffsetFactor, V.polygonOffsetUnits),
        V.alphaToCoverage === !0 ? Me(n.SAMPLE_ALPHA_TO_COVERAGE) : k(n.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function O(V) {
        S !== V && (V ? n.frontFace(n.CW) : n.frontFace(n.CCW),
        S = V)
    }
    function B(V) {
        V !== Hy ? (Me(n.CULL_FACE),
        V !== b && (V === bd ? n.cullFace(n.BACK) : V === Gy ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : k(n.CULL_FACE),
        b = V
    }
    function Y(V) {
        V !== D && (ne && n.lineWidth(V),
        D = V)
    }
    function X(V, _e, ce) {
        V ? (Me(n.POLYGON_OFFSET_FILL),
        (F !== _e || z !== ce) && (n.polygonOffset(_e, ce),
        F = _e,
        z = ce)) : k(n.POLYGON_OFFSET_FILL)
    }
    function ee(V) {
        V ? Me(n.SCISSOR_TEST) : k(n.SCISSOR_TEST)
    }
    function T(V) {
        V === void 0 && (V = n.TEXTURE0 + $ - 1),
        Z !== V && (n.activeTexture(V),
        Z = V)
    }
    function M(V, _e, ce) {
        ce === void 0 && (Z === null ? ce = n.TEXTURE0 + $ - 1 : ce = Z);
        let ue = ve[ce];
        ue === void 0 && (ue = {
            type: void 0,
            texture: void 0
        },
        ve[ce] = ue),
        (ue.type !== V || ue.texture !== _e) && (Z !== ce && (n.activeTexture(ce),
        Z = ce),
        n.bindTexture(V, _e || pe[V]),
        ue.type = V,
        ue.texture = _e)
    }
    function U() {
        const V = ve[Z];
        V !== void 0 && V.type !== void 0 && (n.bindTexture(V.type, null),
        V.type = void 0,
        V.texture = void 0)
    }
    function K() {
        try {
            n.compressedTexImage2D.apply(n, arguments)
        } catch (V) {
            console.error("THREE.WebGLState:", V)
        }
    }
    function H() {
        try {
            n.compressedTexImage3D.apply(n, arguments)
        } catch (V) {
            console.error("THREE.WebGLState:", V)
        }
    }
    function j() {
        try {
            n.texSubImage2D.apply(n, arguments)
        } catch (V) {
            console.error("THREE.WebGLState:", V)
        }
    }
    function de() {
        try {
            n.texSubImage3D.apply(n, arguments)
        } catch (V) {
            console.error("THREE.WebGLState:", V)
        }
    }
    function le() {
        try {
            n.compressedTexSubImage2D.apply(n, arguments)
        } catch (V) {
            console.error("THREE.WebGLState:", V)
        }
    }
    function me() {
        try {
            n.compressedTexSubImage3D.apply(n, arguments)
        } catch (V) {
            console.error("THREE.WebGLState:", V)
        }
    }
    function Ae() {
        try {
            n.texStorage2D.apply(n, arguments)
        } catch (V) {
            console.error("THREE.WebGLState:", V)
        }
    }
    function fe() {
        try {
            n.texStorage3D.apply(n, arguments)
        } catch (V) {
            console.error("THREE.WebGLState:", V)
        }
    }
    function ge() {
        try {
            n.texImage2D.apply(n, arguments)
        } catch (V) {
            console.error("THREE.WebGLState:", V)
        }
    }
    function He() {
        try {
            n.texImage3D.apply(n, arguments)
        } catch (V) {
            console.error("THREE.WebGLState:", V)
        }
    }
    function De(V) {
        Se.equals(V) === !1 && (n.scissor(V.x, V.y, V.z, V.w),
        Se.copy(V))
    }
    function Te(V) {
        ze.equals(V) === !1 && (n.viewport(V.x, V.y, V.z, V.w),
        ze.copy(V))
    }
    function Ge(V, _e) {
        let ce = l.get(_e);
        ce === void 0 && (ce = new WeakMap,
        l.set(_e, ce));
        let ue = ce.get(V);
        ue === void 0 && (ue = n.getUniformBlockIndex(_e, V.name),
        ce.set(V, ue))
    }
    function Fe(V, _e) {
        const ue = l.get(_e).get(V);
        a.get(_e) !== ue && (n.uniformBlockBinding(_e, ue, V.__bindingPointIndex),
        a.set(_e, ue))
    }
    function et() {
        n.disable(n.BLEND),
        n.disable(n.CULL_FACE),
        n.disable(n.DEPTH_TEST),
        n.disable(n.POLYGON_OFFSET_FILL),
        n.disable(n.SCISSOR_TEST),
        n.disable(n.STENCIL_TEST),
        n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
        n.blendEquation(n.FUNC_ADD),
        n.blendFunc(n.ONE, n.ZERO),
        n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
        n.blendColor(0, 0, 0, 0),
        n.colorMask(!0, !0, !0, !0),
        n.clearColor(0, 0, 0, 0),
        n.depthMask(!0),
        n.depthFunc(n.LESS),
        n.clearDepth(1),
        n.stencilMask(4294967295),
        n.stencilFunc(n.ALWAYS, 0, 4294967295),
        n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
        n.clearStencil(0),
        n.cullFace(n.BACK),
        n.frontFace(n.CCW),
        n.polygonOffset(0, 0),
        n.activeTexture(n.TEXTURE0),
        n.bindFramebuffer(n.FRAMEBUFFER, null),
        n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
        n.useProgram(null),
        n.lineWidth(1),
        n.scissor(0, 0, n.canvas.width, n.canvas.height),
        n.viewport(0, 0, n.canvas.width, n.canvas.height),
        c = {},
        Z = null,
        ve = {},
        u = {},
        h = new WeakMap,
        f = [],
        d = null,
        p = !1,
        v = null,
        g = null,
        m = null,
        y = null,
        _ = null,
        x = null,
        C = null,
        w = new Ee(0,0,0),
        E = 0,
        L = !1,
        S = null,
        b = null,
        D = null,
        F = null,
        z = null,
        Se.set(0, 0, n.canvas.width, n.canvas.height),
        ze.set(0, 0, n.canvas.width, n.canvas.height),
        r.reset(),
        s.reset(),
        o.reset()
    }
    return {
        buffers: {
            color: r,
            depth: s,
            stencil: o
        },
        enable: Me,
        disable: k,
        bindFramebuffer: se,
        drawBuffers: oe,
        useProgram: he,
        setBlending: A,
        setMaterial: R,
        setFlipSided: O,
        setCullFace: B,
        setLineWidth: Y,
        setPolygonOffset: X,
        setScissorTest: ee,
        activeTexture: T,
        bindTexture: M,
        unbindTexture: U,
        compressedTexImage2D: K,
        compressedTexImage3D: H,
        texImage2D: ge,
        texImage3D: He,
        updateUBOMapping: Ge,
        uniformBlockBinding: Fe,
        texStorage2D: Ae,
        texStorage3D: fe,
        texSubImage2D: j,
        texSubImage3D: de,
        compressedTexSubImage2D: le,
        compressedTexSubImage3D: me,
        scissor: De,
        viewport: Te,
        reset: et
    }
}
function NP(n, e) {
    const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
    return t > e ? (n.repeat.x = 1,
    n.repeat.y = t / e,
    n.offset.x = 0,
    n.offset.y = (1 - n.repeat.y) / 2) : (n.repeat.x = e / t,
    n.repeat.y = 1,
    n.offset.x = (1 - n.repeat.x) / 2,
    n.offset.y = 0),
    n
}
function UP(n, e) {
    const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
    return t > e ? (n.repeat.x = e / t,
    n.repeat.y = 1,
    n.offset.x = (1 - n.repeat.x) / 2,
    n.offset.y = 0) : (n.repeat.x = 1,
    n.repeat.y = t / e,
    n.offset.x = 0,
    n.offset.y = (1 - n.repeat.y) / 2),
    n
}
function OP(n) {
    return n.repeat.x = 1,
    n.repeat.y = 1,
    n.offset.x = 0,
    n.offset.y = 0,
    n
}
function Pd(n, e, t, i) {
    const r = FP(i);
    switch (t) {
    case Ap:
        return n * e;
    case Cp:
        return n * e;
    case Rp:
        return n * e * 2;
    case lh:
        return n * e / r.components * r.byteLength;
    case gl:
        return n * e / r.components * r.byteLength;
    case Pp:
        return n * e * 2 / r.components * r.byteLength;
    case ch:
        return n * e * 2 / r.components * r.byteLength;
    case Tp:
        return n * e * 3 / r.components * r.byteLength;
    case vn:
        return n * e * 4 / r.components * r.byteLength;
    case uh:
        return n * e * 4 / r.components * r.byteLength;
    case ma:
    case ga:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case va:
    case _a:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case ou:
    case lu:
        return Math.max(n, 16) * Math.max(e, 8) / 4;
    case su:
    case au:
        return Math.max(n, 8) * Math.max(e, 8) / 2;
    case cu:
    case uu:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case hu:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case fu:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case du:
        return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case pu:
        return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case mu:
        return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case gu:
        return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case vu:
        return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case _u:
        return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case yu:
        return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case xu:
        return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case bu:
        return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Mu:
        return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Su:
        return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case wu:
        return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Eu:
        return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case ya:
    case Au:
    case Tu:
        return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
    case Ip:
    case Cu:
        return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
    case Ru:
    case Pu:
        return Math.ceil(n / 4) * Math.ceil(e / 4) * 16
    }
    throw new Error(`Unable to determine texture byte length for ${t} format.`)
}
function FP(n) {
    switch (n) {
    case bi:
    case Sp:
        return {
            byteLength: 1,
            components: 1
        };
    case bo:
    case wp:
    case Do:
        return {
            byteLength: 2,
            components: 1
        };
    case oh:
    case ah:
        return {
            byteLength: 2,
            components: 4
        };
    case qi:
    case sh:
    case Mn:
        return {
            byteLength: 4,
            components: 1
        };
    case Ep:
        return {
            byteLength: 4,
            components: 3
        }
    }
    throw new Error(`Unknown texture type ${n}.`)
}
const BP = {
    contain: NP,
    cover: UP,
    fill: OP,
    getByteLength: Pd
};
function zP(n, e, t, i, r, s, o) {
    const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , c = new ae
      , u = new WeakMap;
    let h;
    const f = new WeakMap;
    let d = !1;
    try {
        d = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function p(T, M) {
        return d ? new OffscreenCanvas(T,M) : Ka("canvas")
    }
    function v(T, M, U) {
        let K = 1;
        const H = ee(T);
        if ((H.width > U || H.height > U) && (K = U / Math.max(H.width, H.height)),
        K < 1)
            if (typeof HTMLImageElement < "u" && T instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && T instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && T instanceof ImageBitmap || typeof VideoFrame < "u" && T instanceof VideoFrame) {
                const j = Math.floor(K * H.width)
                  , de = Math.floor(K * H.height);
                h === void 0 && (h = p(j, de));
                const le = M ? p(j, de) : h;
                return le.width = j,
                le.height = de,
                le.getContext("2d").drawImage(T, 0, 0, j, de),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + H.width + "x" + H.height + ") to (" + j + "x" + de + ")."),
                le
            } else
                return "data"in T && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + H.width + "x" + H.height + ")."),
                T;
        return T
    }
    function g(T) {
        return T.generateMipmaps && T.minFilter !== Kt && T.minFilter !== Gt
    }
    function m(T) {
        n.generateMipmap(T)
    }
    function y(T, M, U, K, H=!1) {
        if (T !== null) {
            if (n[T] !== void 0)
                return n[T];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + T + "'")
        }
        let j = M;
        if (M === n.RED && (U === n.FLOAT && (j = n.R32F),
        U === n.HALF_FLOAT && (j = n.R16F),
        U === n.UNSIGNED_BYTE && (j = n.R8)),
        M === n.RED_INTEGER && (U === n.UNSIGNED_BYTE && (j = n.R8UI),
        U === n.UNSIGNED_SHORT && (j = n.R16UI),
        U === n.UNSIGNED_INT && (j = n.R32UI),
        U === n.BYTE && (j = n.R8I),
        U === n.SHORT && (j = n.R16I),
        U === n.INT && (j = n.R32I)),
        M === n.RG && (U === n.FLOAT && (j = n.RG32F),
        U === n.HALF_FLOAT && (j = n.RG16F),
        U === n.UNSIGNED_BYTE && (j = n.RG8)),
        M === n.RG_INTEGER && (U === n.UNSIGNED_BYTE && (j = n.RG8UI),
        U === n.UNSIGNED_SHORT && (j = n.RG16UI),
        U === n.UNSIGNED_INT && (j = n.RG32UI),
        U === n.BYTE && (j = n.RG8I),
        U === n.SHORT && (j = n.RG16I),
        U === n.INT && (j = n.RG32I)),
        M === n.RGB && U === n.UNSIGNED_INT_5_9_9_9_REV && (j = n.RGB9_E5),
        M === n.RGBA) {
            const de = H ? Xa : st.getTransfer(K);
            U === n.FLOAT && (j = n.RGBA32F),
            U === n.HALF_FLOAT && (j = n.RGBA16F),
            U === n.UNSIGNED_BYTE && (j = de === xt ? n.SRGB8_ALPHA8 : n.RGBA8),
            U === n.UNSIGNED_SHORT_4_4_4_4 && (j = n.RGBA4),
            U === n.UNSIGNED_SHORT_5_5_5_1 && (j = n.RGB5_A1)
        }
        return (j === n.R16F || j === n.R32F || j === n.RG16F || j === n.RG32F || j === n.RGBA16F || j === n.RGBA32F) && e.get("EXT_color_buffer_float"),
        j
    }
    function _(T, M) {
        let U;
        return T ? M === null || M === qi || M === vs ? U = n.DEPTH24_STENCIL8 : M === Mn ? U = n.DEPTH32F_STENCIL8 : M === bo && (U = n.DEPTH24_STENCIL8,
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : M === null || M === qi || M === vs ? U = n.DEPTH_COMPONENT24 : M === Mn ? U = n.DEPTH_COMPONENT32F : M === bo && (U = n.DEPTH_COMPONENT16),
        U
    }
    function x(T, M) {
        return g(T) === !0 || T.isFramebufferTexture && T.minFilter !== Kt && T.minFilter !== Gt ? Math.log2(Math.max(M.width, M.height)) + 1 : T.mipmaps !== void 0 && T.mipmaps.length > 0 ? T.mipmaps.length : T.isCompressedTexture && Array.isArray(T.image) ? M.mipmaps.length : 1
    }
    function C(T) {
        const M = T.target;
        M.removeEventListener("dispose", C),
        E(M),
        M.isVideoTexture && u.delete(M)
    }
    function w(T) {
        const M = T.target;
        M.removeEventListener("dispose", w),
        S(M)
    }
    function E(T) {
        const M = i.get(T);
        if (M.__webglInit === void 0)
            return;
        const U = T.source
          , K = f.get(U);
        if (K) {
            const H = K[M.__cacheKey];
            H.usedTimes--,
            H.usedTimes === 0 && L(T),
            Object.keys(K).length === 0 && f.delete(U)
        }
        i.remove(T)
    }
    function L(T) {
        const M = i.get(T);
        n.deleteTexture(M.__webglTexture);
        const U = T.source
          , K = f.get(U);
        delete K[M.__cacheKey],
        o.memory.textures--
    }
    function S(T) {
        const M = i.get(T);
        if (T.depthTexture && T.depthTexture.dispose(),
        T.isWebGLCubeRenderTarget)
            for (let K = 0; K < 6; K++) {
                if (Array.isArray(M.__webglFramebuffer[K]))
                    for (let H = 0; H < M.__webglFramebuffer[K].length; H++)
                        n.deleteFramebuffer(M.__webglFramebuffer[K][H]);
                else
                    n.deleteFramebuffer(M.__webglFramebuffer[K]);
                M.__webglDepthbuffer && n.deleteRenderbuffer(M.__webglDepthbuffer[K])
            }
        else {
            if (Array.isArray(M.__webglFramebuffer))
                for (let K = 0; K < M.__webglFramebuffer.length; K++)
                    n.deleteFramebuffer(M.__webglFramebuffer[K]);
            else
                n.deleteFramebuffer(M.__webglFramebuffer);
            if (M.__webglDepthbuffer && n.deleteRenderbuffer(M.__webglDepthbuffer),
            M.__webglMultisampledFramebuffer && n.deleteFramebuffer(M.__webglMultisampledFramebuffer),
            M.__webglColorRenderbuffer)
                for (let K = 0; K < M.__webglColorRenderbuffer.length; K++)
                    M.__webglColorRenderbuffer[K] && n.deleteRenderbuffer(M.__webglColorRenderbuffer[K]);
            M.__webglDepthRenderbuffer && n.deleteRenderbuffer(M.__webglDepthRenderbuffer)
        }
        const U = T.textures;
        for (let K = 0, H = U.length; K < H; K++) {
            const j = i.get(U[K]);
            j.__webglTexture && (n.deleteTexture(j.__webglTexture),
            o.memory.textures--),
            i.remove(U[K])
        }
        i.remove(T)
    }
    let b = 0;
    function D() {
        b = 0
    }
    function F() {
        const T = b;
        return T >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + T + " texture units while this GPU supports only " + r.maxTextures),
        b += 1,
        T
    }
    function z(T) {
        const M = [];
        return M.push(T.wrapS),
        M.push(T.wrapT),
        M.push(T.wrapR || 0),
        M.push(T.magFilter),
        M.push(T.minFilter),
        M.push(T.anisotropy),
        M.push(T.internalFormat),
        M.push(T.format),
        M.push(T.type),
        M.push(T.generateMipmaps),
        M.push(T.premultiplyAlpha),
        M.push(T.flipY),
        M.push(T.unpackAlignment),
        M.push(T.colorSpace),
        M.join()
    }
    function $(T, M) {
        const U = i.get(T);
        if (T.isVideoTexture && Y(T),
        T.isRenderTargetTexture === !1 && T.version > 0 && U.__version !== T.version) {
            const K = T.image;
            if (K === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (K.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                ze(U, T, M);
                return
            }
        }
        t.bindTexture(n.TEXTURE_2D, U.__webglTexture, n.TEXTURE0 + M)
    }
    function ne(T, M) {
        const U = i.get(T);
        if (T.version > 0 && U.__version !== T.version) {
            ze(U, T, M);
            return
        }
        t.bindTexture(n.TEXTURE_2D_ARRAY, U.__webglTexture, n.TEXTURE0 + M)
    }
    function W(T, M) {
        const U = i.get(T);
        if (T.version > 0 && U.__version !== T.version) {
            ze(U, T, M);
            return
        }
        t.bindTexture(n.TEXTURE_3D, U.__webglTexture, n.TEXTURE0 + M)
    }
    function ie(T, M) {
        const U = i.get(T);
        if (T.version > 0 && U.__version !== T.version) {
            re(U, T, M);
            return
        }
        t.bindTexture(n.TEXTURE_CUBE_MAP, U.__webglTexture, n.TEXTURE0 + M)
    }
    const Z = {
        [Va]: n.REPEAT,
        [Gn]: n.CLAMP_TO_EDGE,
        [Ha]: n.MIRRORED_REPEAT
    }
      , ve = {
        [Kt]: n.NEAREST,
        [Mp]: n.NEAREST_MIPMAP_NEAREST,
        [Qs]: n.NEAREST_MIPMAP_LINEAR,
        [Gt]: n.LINEAR,
        [pa]: n.LINEAR_MIPMAP_NEAREST,
        [pi]: n.LINEAR_MIPMAP_LINEAR
    }
      , xe = {
        [Px]: n.NEVER,
        [Ox]: n.ALWAYS,
        [Ix]: n.LESS,
        [Dp]: n.LEQUAL,
        [Lx]: n.EQUAL,
        [Ux]: n.GEQUAL,
        [Dx]: n.GREATER,
        [Nx]: n.NOTEQUAL
    };
    function te(T, M) {
        if (M.type === Mn && e.has("OES_texture_float_linear") === !1 && (M.magFilter === Gt || M.magFilter === pa || M.magFilter === Qs || M.magFilter === pi || M.minFilter === Gt || M.minFilter === pa || M.minFilter === Qs || M.minFilter === pi) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
        n.texParameteri(T, n.TEXTURE_WRAP_S, Z[M.wrapS]),
        n.texParameteri(T, n.TEXTURE_WRAP_T, Z[M.wrapT]),
        (T === n.TEXTURE_3D || T === n.TEXTURE_2D_ARRAY) && n.texParameteri(T, n.TEXTURE_WRAP_R, Z[M.wrapR]),
        n.texParameteri(T, n.TEXTURE_MAG_FILTER, ve[M.magFilter]),
        n.texParameteri(T, n.TEXTURE_MIN_FILTER, ve[M.minFilter]),
        M.compareFunction && (n.texParameteri(T, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(T, n.TEXTURE_COMPARE_FUNC, xe[M.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            if (M.magFilter === Kt || M.minFilter !== Qs && M.minFilter !== pi || M.type === Mn && e.has("OES_texture_float_linear") === !1)
                return;
            if (M.anisotropy > 1 || i.get(M).__currentAnisotropy) {
                const U = e.get("EXT_texture_filter_anisotropic");
                n.texParameterf(T, U.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(M.anisotropy, r.getMaxAnisotropy())),
                i.get(M).__currentAnisotropy = M.anisotropy
            }
        }
    }
    function Se(T, M) {
        let U = !1;
        T.__webglInit === void 0 && (T.__webglInit = !0,
        M.addEventListener("dispose", C));
        const K = M.source;
        let H = f.get(K);
        H === void 0 && (H = {},
        f.set(K, H));
        const j = z(M);
        if (j !== T.__cacheKey) {
            H[j] === void 0 && (H[j] = {
                texture: n.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            U = !0),
            H[j].usedTimes++;
            const de = H[T.__cacheKey];
            de !== void 0 && (H[T.__cacheKey].usedTimes--,
            de.usedTimes === 0 && L(M)),
            T.__cacheKey = j,
            T.__webglTexture = H[j].texture
        }
        return U
    }
    function ze(T, M, U) {
        let K = n.TEXTURE_2D;
        (M.isDataArrayTexture || M.isCompressedArrayTexture) && (K = n.TEXTURE_2D_ARRAY),
        M.isData3DTexture && (K = n.TEXTURE_3D);
        const H = Se(T, M)
          , j = M.source;
        t.bindTexture(K, T.__webglTexture, n.TEXTURE0 + U);
        const de = i.get(j);
        if (j.version !== de.__version || H === !0) {
            t.activeTexture(n.TEXTURE0 + U);
            const le = st.getPrimaries(st.workingColorSpace)
              , me = M.colorSpace === Fi ? null : st.getPrimaries(M.colorSpace)
              , Ae = M.colorSpace === Fi || le === me ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, M.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, M.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ae);
            let fe = v(M.image, !1, r.maxTextureSize);
            fe = X(M, fe);
            const ge = s.convert(M.format, M.colorSpace)
              , He = s.convert(M.type);
            let De = y(M.internalFormat, ge, He, M.colorSpace, M.isVideoTexture);
            te(K, M);
            let Te;
            const Ge = M.mipmaps
              , Fe = M.isVideoTexture !== !0
              , et = de.__version === void 0 || H === !0
              , V = j.dataReady
              , _e = x(M, fe);
            if (M.isDepthTexture)
                De = _(M.format === _s, M.type),
                et && (Fe ? t.texStorage2D(n.TEXTURE_2D, 1, De, fe.width, fe.height) : t.texImage2D(n.TEXTURE_2D, 0, De, fe.width, fe.height, 0, ge, He, null));
            else if (M.isDataTexture)
                if (Ge.length > 0) {
                    Fe && et && t.texStorage2D(n.TEXTURE_2D, _e, De, Ge[0].width, Ge[0].height);
                    for (let ce = 0, ue = Ge.length; ce < ue; ce++)
                        Te = Ge[ce],
                        Fe ? V && t.texSubImage2D(n.TEXTURE_2D, ce, 0, 0, Te.width, Te.height, ge, He, Te.data) : t.texImage2D(n.TEXTURE_2D, ce, De, Te.width, Te.height, 0, ge, He, Te.data);
                    M.generateMipmaps = !1
                } else
                    Fe ? (et && t.texStorage2D(n.TEXTURE_2D, _e, De, fe.width, fe.height),
                    V && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, fe.width, fe.height, ge, He, fe.data)) : t.texImage2D(n.TEXTURE_2D, 0, De, fe.width, fe.height, 0, ge, He, fe.data);
            else if (M.isCompressedTexture)
                if (M.isCompressedArrayTexture) {
                    Fe && et && t.texStorage3D(n.TEXTURE_2D_ARRAY, _e, De, Ge[0].width, Ge[0].height, fe.depth);
                    for (let ce = 0, ue = Ge.length; ce < ue; ce++)
                        if (Te = Ge[ce],
                        M.format !== vn)
                            if (ge !== null)
                                if (Fe) {
                                    if (V)
                                        if (M.layerUpdates.size > 0) {
                                            const be = Pd(Te.width, Te.height, M.format, M.type);
                                            for (const ke of M.layerUpdates) {
                                                const nt = Te.data.subarray(ke * be / Te.data.BYTES_PER_ELEMENT, (ke + 1) * be / Te.data.BYTES_PER_ELEMENT);
                                                t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, ce, 0, 0, ke, Te.width, Te.height, 1, ge, nt, 0, 0)
                                            }
                                            M.clearLayerUpdates()
                                        } else
                                            t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, ce, 0, 0, 0, Te.width, Te.height, fe.depth, ge, Te.data, 0, 0)
                                } else
                                    t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, ce, De, Te.width, Te.height, fe.depth, 0, Te.data, 0, 0);
                            else
                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        else
                            Fe ? V && t.texSubImage3D(n.TEXTURE_2D_ARRAY, ce, 0, 0, 0, Te.width, Te.height, fe.depth, ge, He, Te.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, ce, De, Te.width, Te.height, fe.depth, 0, ge, He, Te.data)
                } else {
                    Fe && et && t.texStorage2D(n.TEXTURE_2D, _e, De, Ge[0].width, Ge[0].height);
                    for (let ce = 0, ue = Ge.length; ce < ue; ce++)
                        Te = Ge[ce],
                        M.format !== vn ? ge !== null ? Fe ? V && t.compressedTexSubImage2D(n.TEXTURE_2D, ce, 0, 0, Te.width, Te.height, ge, Te.data) : t.compressedTexImage2D(n.TEXTURE_2D, ce, De, Te.width, Te.height, 0, Te.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Fe ? V && t.texSubImage2D(n.TEXTURE_2D, ce, 0, 0, Te.width, Te.height, ge, He, Te.data) : t.texImage2D(n.TEXTURE_2D, ce, De, Te.width, Te.height, 0, ge, He, Te.data)
                }
            else if (M.isDataArrayTexture)
                if (Fe) {
                    if (et && t.texStorage3D(n.TEXTURE_2D_ARRAY, _e, De, fe.width, fe.height, fe.depth),
                    V)
                        if (M.layerUpdates.size > 0) {
                            const ce = Pd(fe.width, fe.height, M.format, M.type);
                            for (const ue of M.layerUpdates) {
                                const be = fe.data.subarray(ue * ce / fe.data.BYTES_PER_ELEMENT, (ue + 1) * ce / fe.data.BYTES_PER_ELEMENT);
                                t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, ue, fe.width, fe.height, 1, ge, He, be)
                            }
                            M.clearLayerUpdates()
                        } else
                            t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, fe.width, fe.height, fe.depth, ge, He, fe.data)
                } else
                    t.texImage3D(n.TEXTURE_2D_ARRAY, 0, De, fe.width, fe.height, fe.depth, 0, ge, He, fe.data);
            else if (M.isData3DTexture)
                Fe ? (et && t.texStorage3D(n.TEXTURE_3D, _e, De, fe.width, fe.height, fe.depth),
                V && t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, fe.width, fe.height, fe.depth, ge, He, fe.data)) : t.texImage3D(n.TEXTURE_3D, 0, De, fe.width, fe.height, fe.depth, 0, ge, He, fe.data);
            else if (M.isFramebufferTexture) {
                if (et)
                    if (Fe)
                        t.texStorage2D(n.TEXTURE_2D, _e, De, fe.width, fe.height);
                    else {
                        let ce = fe.width
                          , ue = fe.height;
                        for (let be = 0; be < _e; be++)
                            t.texImage2D(n.TEXTURE_2D, be, De, ce, ue, 0, ge, He, null),
                            ce >>= 1,
                            ue >>= 1
                    }
            } else if (Ge.length > 0) {
                if (Fe && et) {
                    const ce = ee(Ge[0]);
                    t.texStorage2D(n.TEXTURE_2D, _e, De, ce.width, ce.height)
                }
                for (let ce = 0, ue = Ge.length; ce < ue; ce++)
                    Te = Ge[ce],
                    Fe ? V && t.texSubImage2D(n.TEXTURE_2D, ce, 0, 0, ge, He, Te) : t.texImage2D(n.TEXTURE_2D, ce, De, ge, He, Te);
                M.generateMipmaps = !1
            } else if (Fe) {
                if (et) {
                    const ce = ee(fe);
                    t.texStorage2D(n.TEXTURE_2D, _e, De, ce.width, ce.height)
                }
                V && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, ge, He, fe)
            } else
                t.texImage2D(n.TEXTURE_2D, 0, De, ge, He, fe);
            g(M) && m(K),
            de.__version = j.version,
            M.onUpdate && M.onUpdate(M)
        }
        T.__version = M.version
    }
    function re(T, M, U) {
        if (M.image.length !== 6)
            return;
        const K = Se(T, M)
          , H = M.source;
        t.bindTexture(n.TEXTURE_CUBE_MAP, T.__webglTexture, n.TEXTURE0 + U);
        const j = i.get(H);
        if (H.version !== j.__version || K === !0) {
            t.activeTexture(n.TEXTURE0 + U);
            const de = st.getPrimaries(st.workingColorSpace)
              , le = M.colorSpace === Fi ? null : st.getPrimaries(M.colorSpace)
              , me = M.colorSpace === Fi || de === le ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, M.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, M.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, me);
            const Ae = M.isCompressedTexture || M.image[0].isCompressedTexture
              , fe = M.image[0] && M.image[0].isDataTexture
              , ge = [];
            for (let ue = 0; ue < 6; ue++)
                !Ae && !fe ? ge[ue] = v(M.image[ue], !0, r.maxCubemapSize) : ge[ue] = fe ? M.image[ue].image : M.image[ue],
                ge[ue] = X(M, ge[ue]);
            const He = ge[0]
              , De = s.convert(M.format, M.colorSpace)
              , Te = s.convert(M.type)
              , Ge = y(M.internalFormat, De, Te, M.colorSpace)
              , Fe = M.isVideoTexture !== !0
              , et = j.__version === void 0 || K === !0
              , V = H.dataReady;
            let _e = x(M, He);
            te(n.TEXTURE_CUBE_MAP, M);
            let ce;
            if (Ae) {
                Fe && et && t.texStorage2D(n.TEXTURE_CUBE_MAP, _e, Ge, He.width, He.height);
                for (let ue = 0; ue < 6; ue++) {
                    ce = ge[ue].mipmaps;
                    for (let be = 0; be < ce.length; be++) {
                        const ke = ce[be];
                        M.format !== vn ? De !== null ? Fe ? V && t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ue, be, 0, 0, ke.width, ke.height, De, ke.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ue, be, Ge, ke.width, ke.height, 0, ke.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Fe ? V && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ue, be, 0, 0, ke.width, ke.height, De, Te, ke.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ue, be, Ge, ke.width, ke.height, 0, De, Te, ke.data)
                    }
                }
            } else {
                if (ce = M.mipmaps,
                Fe && et) {
                    ce.length > 0 && _e++;
                    const ue = ee(ge[0]);
                    t.texStorage2D(n.TEXTURE_CUBE_MAP, _e, Ge, ue.width, ue.height)
                }
                for (let ue = 0; ue < 6; ue++)
                    if (fe) {
                        Fe ? V && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ue, 0, 0, 0, ge[ue].width, ge[ue].height, De, Te, ge[ue].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ue, 0, Ge, ge[ue].width, ge[ue].height, 0, De, Te, ge[ue].data);
                        for (let be = 0; be < ce.length; be++) {
                            const nt = ce[be].image[ue].image;
                            Fe ? V && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ue, be + 1, 0, 0, nt.width, nt.height, De, Te, nt.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ue, be + 1, Ge, nt.width, nt.height, 0, De, Te, nt.data)
                        }
                    } else {
                        Fe ? V && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ue, 0, 0, 0, De, Te, ge[ue]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ue, 0, Ge, De, Te, ge[ue]);
                        for (let be = 0; be < ce.length; be++) {
                            const ke = ce[be];
                            Fe ? V && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ue, be + 1, 0, 0, De, Te, ke.image[ue]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + ue, be + 1, Ge, De, Te, ke.image[ue])
                        }
                    }
            }
            g(M) && m(n.TEXTURE_CUBE_MAP),
            j.__version = H.version,
            M.onUpdate && M.onUpdate(M)
        }
        T.__version = M.version
    }
    function pe(T, M, U, K, H, j) {
        const de = s.convert(U.format, U.colorSpace)
          , le = s.convert(U.type)
          , me = y(U.internalFormat, de, le, U.colorSpace);
        if (!i.get(M).__hasExternalTextures) {
            const fe = Math.max(1, M.width >> j)
              , ge = Math.max(1, M.height >> j);
            H === n.TEXTURE_3D || H === n.TEXTURE_2D_ARRAY ? t.texImage3D(H, j, me, fe, ge, M.depth, 0, de, le, null) : t.texImage2D(H, j, me, fe, ge, 0, de, le, null)
        }
        t.bindFramebuffer(n.FRAMEBUFFER, T),
        B(M) ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, K, H, i.get(U).__webglTexture, 0, O(M)) : (H === n.TEXTURE_2D || H >= n.TEXTURE_CUBE_MAP_POSITIVE_X && H <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, K, H, i.get(U).__webglTexture, j),
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function Me(T, M, U) {
        if (n.bindRenderbuffer(n.RENDERBUFFER, T),
        M.depthBuffer) {
            const K = M.depthTexture
              , H = K && K.isDepthTexture ? K.type : null
              , j = _(M.stencilBuffer, H)
              , de = M.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
              , le = O(M);
            B(M) ? a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, le, j, M.width, M.height) : U ? n.renderbufferStorageMultisample(n.RENDERBUFFER, le, j, M.width, M.height) : n.renderbufferStorage(n.RENDERBUFFER, j, M.width, M.height),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, de, n.RENDERBUFFER, T)
        } else {
            const K = M.textures;
            for (let H = 0; H < K.length; H++) {
                const j = K[H]
                  , de = s.convert(j.format, j.colorSpace)
                  , le = s.convert(j.type)
                  , me = y(j.internalFormat, de, le, j.colorSpace)
                  , Ae = O(M);
                U && B(M) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, Ae, me, M.width, M.height) : B(M) ? a.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, Ae, me, M.width, M.height) : n.renderbufferStorage(n.RENDERBUFFER, me, M.width, M.height)
            }
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null)
    }
    function k(T, M) {
        if (M && M.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(n.FRAMEBUFFER, T),
        !(M.depthTexture && M.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!i.get(M.depthTexture).__webglTexture || M.depthTexture.image.width !== M.width || M.depthTexture.image.height !== M.height) && (M.depthTexture.image.width = M.width,
        M.depthTexture.image.height = M.height,
        M.depthTexture.needsUpdate = !0),
        $(M.depthTexture, 0);
        const K = i.get(M.depthTexture).__webglTexture
          , H = O(M);
        if (M.depthTexture.format === hs)
            B(M) ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, K, 0, H) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, K, 0);
        else if (M.depthTexture.format === _s)
            B(M) ? a.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, K, 0, H) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, K, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function se(T) {
        const M = i.get(T)
          , U = T.isWebGLCubeRenderTarget === !0;
        if (M.__boundDepthTexture !== T.depthTexture) {
            const K = T.depthTexture;
            if (M.__depthDisposeCallback && M.__depthDisposeCallback(),
            K) {
                const H = () => {
                    delete M.__boundDepthTexture,
                    delete M.__depthDisposeCallback,
                    K.removeEventListener("dispose", H)
                }
                ;
                K.addEventListener("dispose", H),
                M.__depthDisposeCallback = H
            }
            M.__boundDepthTexture = K
        }
        if (T.depthTexture && !M.__autoAllocateDepthBuffer) {
            if (U)
                throw new Error("target.depthTexture not supported in Cube render targets");
            k(M.__webglFramebuffer, T)
        } else if (U) {
            M.__webglDepthbuffer = [];
            for (let K = 0; K < 6; K++)
                if (t.bindFramebuffer(n.FRAMEBUFFER, M.__webglFramebuffer[K]),
                M.__webglDepthbuffer[K] === void 0)
                    M.__webglDepthbuffer[K] = n.createRenderbuffer(),
                    Me(M.__webglDepthbuffer[K], T, !1);
                else {
                    const H = T.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
                      , j = M.__webglDepthbuffer[K];
                    n.bindRenderbuffer(n.RENDERBUFFER, j),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, H, n.RENDERBUFFER, j)
                }
        } else if (t.bindFramebuffer(n.FRAMEBUFFER, M.__webglFramebuffer),
        M.__webglDepthbuffer === void 0)
            M.__webglDepthbuffer = n.createRenderbuffer(),
            Me(M.__webglDepthbuffer, T, !1);
        else {
            const K = T.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
              , H = M.__webglDepthbuffer;
            n.bindRenderbuffer(n.RENDERBUFFER, H),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, K, n.RENDERBUFFER, H)
        }
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function oe(T, M, U) {
        const K = i.get(T);
        M !== void 0 && pe(K.__webglFramebuffer, T, T.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0),
        U !== void 0 && se(T)
    }
    function he(T) {
        const M = T.texture
          , U = i.get(T)
          , K = i.get(M);
        T.addEventListener("dispose", w);
        const H = T.textures
          , j = T.isWebGLCubeRenderTarget === !0
          , de = H.length > 1;
        if (de || (K.__webglTexture === void 0 && (K.__webglTexture = n.createTexture()),
        K.__version = M.version,
        o.memory.textures++),
        j) {
            U.__webglFramebuffer = [];
            for (let le = 0; le < 6; le++)
                if (M.mipmaps && M.mipmaps.length > 0) {
                    U.__webglFramebuffer[le] = [];
                    for (let me = 0; me < M.mipmaps.length; me++)
                        U.__webglFramebuffer[le][me] = n.createFramebuffer()
                } else
                    U.__webglFramebuffer[le] = n.createFramebuffer()
        } else {
            if (M.mipmaps && M.mipmaps.length > 0) {
                U.__webglFramebuffer = [];
                for (let le = 0; le < M.mipmaps.length; le++)
                    U.__webglFramebuffer[le] = n.createFramebuffer()
            } else
                U.__webglFramebuffer = n.createFramebuffer();
            if (de)
                for (let le = 0, me = H.length; le < me; le++) {
                    const Ae = i.get(H[le]);
                    Ae.__webglTexture === void 0 && (Ae.__webglTexture = n.createTexture(),
                    o.memory.textures++)
                }
            if (T.samples > 0 && B(T) === !1) {
                U.__webglMultisampledFramebuffer = n.createFramebuffer(),
                U.__webglColorRenderbuffer = [],
                t.bindFramebuffer(n.FRAMEBUFFER, U.__webglMultisampledFramebuffer);
                for (let le = 0; le < H.length; le++) {
                    const me = H[le];
                    U.__webglColorRenderbuffer[le] = n.createRenderbuffer(),
                    n.bindRenderbuffer(n.RENDERBUFFER, U.__webglColorRenderbuffer[le]);
                    const Ae = s.convert(me.format, me.colorSpace)
                      , fe = s.convert(me.type)
                      , ge = y(me.internalFormat, Ae, fe, me.colorSpace, T.isXRRenderTarget === !0)
                      , He = O(T);
                    n.renderbufferStorageMultisample(n.RENDERBUFFER, He, ge, T.width, T.height),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + le, n.RENDERBUFFER, U.__webglColorRenderbuffer[le])
                }
                n.bindRenderbuffer(n.RENDERBUFFER, null),
                T.depthBuffer && (U.__webglDepthRenderbuffer = n.createRenderbuffer(),
                Me(U.__webglDepthRenderbuffer, T, !0)),
                t.bindFramebuffer(n.FRAMEBUFFER, null)
            }
        }
        if (j) {
            t.bindTexture(n.TEXTURE_CUBE_MAP, K.__webglTexture),
            te(n.TEXTURE_CUBE_MAP, M);
            for (let le = 0; le < 6; le++)
                if (M.mipmaps && M.mipmaps.length > 0)
                    for (let me = 0; me < M.mipmaps.length; me++)
                        pe(U.__webglFramebuffer[le][me], T, M, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + le, me);
                else
                    pe(U.__webglFramebuffer[le], T, M, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + le, 0);
            g(M) && m(n.TEXTURE_CUBE_MAP),
            t.unbindTexture()
        } else if (de) {
            for (let le = 0, me = H.length; le < me; le++) {
                const Ae = H[le]
                  , fe = i.get(Ae);
                t.bindTexture(n.TEXTURE_2D, fe.__webglTexture),
                te(n.TEXTURE_2D, Ae),
                pe(U.__webglFramebuffer, T, Ae, n.COLOR_ATTACHMENT0 + le, n.TEXTURE_2D, 0),
                g(Ae) && m(n.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let le = n.TEXTURE_2D;
            if ((T.isWebGL3DRenderTarget || T.isWebGLArrayRenderTarget) && (le = T.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
            t.bindTexture(le, K.__webglTexture),
            te(le, M),
            M.mipmaps && M.mipmaps.length > 0)
                for (let me = 0; me < M.mipmaps.length; me++)
                    pe(U.__webglFramebuffer[me], T, M, n.COLOR_ATTACHMENT0, le, me);
            else
                pe(U.__webglFramebuffer, T, M, n.COLOR_ATTACHMENT0, le, 0);
            g(M) && m(le),
            t.unbindTexture()
        }
        T.depthBuffer && se(T)
    }
    function Re(T) {
        const M = T.textures;
        for (let U = 0, K = M.length; U < K; U++) {
            const H = M[U];
            if (g(H)) {
                const j = T.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : n.TEXTURE_2D
                  , de = i.get(H).__webglTexture;
                t.bindTexture(j, de),
                m(j),
                t.unbindTexture()
            }
        }
    }
    const I = []
      , A = [];
    function R(T) {
        if (T.samples > 0) {
            if (B(T) === !1) {
                const M = T.textures
                  , U = T.width
                  , K = T.height;
                let H = n.COLOR_BUFFER_BIT;
                const j = T.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
                  , de = i.get(T)
                  , le = M.length > 1;
                if (le)
                    for (let me = 0; me < M.length; me++)
                        t.bindFramebuffer(n.FRAMEBUFFER, de.__webglMultisampledFramebuffer),
                        n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + me, n.RENDERBUFFER, null),
                        t.bindFramebuffer(n.FRAMEBUFFER, de.__webglFramebuffer),
                        n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + me, n.TEXTURE_2D, null, 0);
                t.bindFramebuffer(n.READ_FRAMEBUFFER, de.__webglMultisampledFramebuffer),
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, de.__webglFramebuffer);
                for (let me = 0; me < M.length; me++) {
                    if (T.resolveDepthBuffer && (T.depthBuffer && (H |= n.DEPTH_BUFFER_BIT),
                    T.stencilBuffer && T.resolveStencilBuffer && (H |= n.STENCIL_BUFFER_BIT)),
                    le) {
                        n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, de.__webglColorRenderbuffer[me]);
                        const Ae = i.get(M[me]).__webglTexture;
                        n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, Ae, 0)
                    }
                    n.blitFramebuffer(0, 0, U, K, 0, 0, U, K, H, n.NEAREST),
                    l === !0 && (I.length = 0,
                    A.length = 0,
                    I.push(n.COLOR_ATTACHMENT0 + me),
                    T.depthBuffer && T.resolveDepthBuffer === !1 && (I.push(j),
                    A.push(j),
                    n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, A)),
                    n.invalidateFramebuffer(n.READ_FRAMEBUFFER, I))
                }
                if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
                le)
                    for (let me = 0; me < M.length; me++) {
                        t.bindFramebuffer(n.FRAMEBUFFER, de.__webglMultisampledFramebuffer),
                        n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + me, n.RENDERBUFFER, de.__webglColorRenderbuffer[me]);
                        const Ae = i.get(M[me]).__webglTexture;
                        t.bindFramebuffer(n.FRAMEBUFFER, de.__webglFramebuffer),
                        n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + me, n.TEXTURE_2D, Ae, 0)
                    }
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, de.__webglMultisampledFramebuffer)
            } else if (T.depthBuffer && T.resolveDepthBuffer === !1 && l) {
                const M = T.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT;
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [M])
            }
        }
    }
    function O(T) {
        return Math.min(r.maxSamples, T.samples)
    }
    function B(T) {
        const M = i.get(T);
        return T.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && M.__useRenderToTexture !== !1
    }
    function Y(T) {
        const M = o.render.frame;
        u.get(T) !== M && (u.set(T, M),
        T.update())
    }
    function X(T, M) {
        const U = T.colorSpace
          , K = T.format
          , H = T.type;
        return T.isCompressedTexture === !0 || T.isVideoTexture === !0 || U !== Ki && U !== Fi && (st.getTransfer(U) === xt ? (K !== vn || H !== bi) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", U)),
        M
    }
    function ee(T) {
        return typeof HTMLImageElement < "u" && T instanceof HTMLImageElement ? (c.width = T.naturalWidth || T.width,
        c.height = T.naturalHeight || T.height) : typeof VideoFrame < "u" && T instanceof VideoFrame ? (c.width = T.displayWidth,
        c.height = T.displayHeight) : (c.width = T.width,
        c.height = T.height),
        c
    }
    this.allocateTextureUnit = F,
    this.resetTextureUnits = D,
    this.setTexture2D = $,
    this.setTexture2DArray = ne,
    this.setTexture3D = W,
    this.setTextureCube = ie,
    this.rebindTextures = oe,
    this.setupRenderTarget = he,
    this.updateRenderTargetMipmap = Re,
    this.updateMultisampleRenderTarget = R,
    this.setupDepthRenderbuffer = se,
    this.setupFrameBufferTexture = pe,
    this.useMultisampledRTT = B
}
function Zx(n, e) {
    function t(i, r=Fi) {
        let s;
        const o = st.getTransfer(r);
        if (i === bi)
            return n.UNSIGNED_BYTE;
        if (i === oh)
            return n.UNSIGNED_SHORT_4_4_4_4;
        if (i === ah)
            return n.UNSIGNED_SHORT_5_5_5_1;
        if (i === Ep)
            return n.UNSIGNED_INT_5_9_9_9_REV;
        if (i === Sp)
            return n.BYTE;
        if (i === wp)
            return n.SHORT;
        if (i === bo)
            return n.UNSIGNED_SHORT;
        if (i === sh)
            return n.INT;
        if (i === qi)
            return n.UNSIGNED_INT;
        if (i === Mn)
            return n.FLOAT;
        if (i === Do)
            return n.HALF_FLOAT;
        if (i === Ap)
            return n.ALPHA;
        if (i === Tp)
            return n.RGB;
        if (i === vn)
            return n.RGBA;
        if (i === Cp)
            return n.LUMINANCE;
        if (i === Rp)
            return n.LUMINANCE_ALPHA;
        if (i === hs)
            return n.DEPTH_COMPONENT;
        if (i === _s)
            return n.DEPTH_STENCIL;
        if (i === lh)
            return n.RED;
        if (i === gl)
            return n.RED_INTEGER;
        if (i === Pp)
            return n.RG;
        if (i === ch)
            return n.RG_INTEGER;
        if (i === uh)
            return n.RGBA_INTEGER;
        if (i === ma || i === ga || i === va || i === _a)
            if (o === xt)
                if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                s !== null) {
                    if (i === ma)
                        return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (i === ga)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (i === va)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (i === _a)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (s = e.get("WEBGL_compressed_texture_s3tc"),
            s !== null) {
                if (i === ma)
                    return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (i === ga)
                    return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (i === va)
                    return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (i === _a)
                    return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (i === su || i === ou || i === au || i === lu)
            if (s = e.get("WEBGL_compressed_texture_pvrtc"),
            s !== null) {
                if (i === su)
                    return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (i === ou)
                    return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (i === au)
                    return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (i === lu)
                    return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (i === cu || i === uu || i === hu)
            if (s = e.get("WEBGL_compressed_texture_etc"),
            s !== null) {
                if (i === cu || i === uu)
                    return o === xt ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                if (i === hu)
                    return o === xt ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (i === fu || i === du || i === pu || i === mu || i === gu || i === vu || i === _u || i === yu || i === xu || i === bu || i === Mu || i === Su || i === wu || i === Eu)
            if (s = e.get("WEBGL_compressed_texture_astc"),
            s !== null) {
                if (i === fu)
                    return o === xt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (i === du)
                    return o === xt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (i === pu)
                    return o === xt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (i === mu)
                    return o === xt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (i === gu)
                    return o === xt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (i === vu)
                    return o === xt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (i === _u)
                    return o === xt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (i === yu)
                    return o === xt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (i === xu)
                    return o === xt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (i === bu)
                    return o === xt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (i === Mu)
                    return o === xt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (i === Su)
                    return o === xt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (i === wu)
                    return o === xt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (i === Eu)
                    return o === xt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (i === ya || i === Au || i === Tu)
            if (s = e.get("EXT_texture_compression_bptc"),
            s !== null) {
                if (i === ya)
                    return o === xt ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (i === Au)
                    return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (i === Tu)
                    return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (i === Ip || i === Cu || i === Ru || i === Pu)
            if (s = e.get("EXT_texture_compression_rgtc"),
            s !== null) {
                if (i === ya)
                    return s.COMPRESSED_RED_RGTC1_EXT;
                if (i === Cu)
                    return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (i === Ru)
                    return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (i === Pu)
                    return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return i === vs ? n.UNSIGNED_INT_24_8 : n[i] !== void 0 ? n[i] : null
    }
    return {
        convert: t
    }
}
class Jx extends Ht {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class no extends tt {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const kP = {
    type: "move"
};
class Ff {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new no,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new no,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new N,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new N),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new no,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new N,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new N),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const i of e.hand.values())
                    this._getHandJoint(t, i)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, i) {
        let r = null
          , s = null
          , o = null;
        const a = this._targetRay
          , l = this._grip
          , c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
                o = !0;
                for (const v of e.hand.values()) {
                    const g = t.getJointPose(v, i)
                      , m = this._getHandJoint(c, v);
                    g !== null && (m.matrix.fromArray(g.transform.matrix),
                    m.matrix.decompose(m.position, m.rotation, m.scale),
                    m.matrixWorldNeedsUpdate = !0,
                    m.jointRadius = g.radius),
                    m.visible = g !== null
                }
                const u = c.joints["index-finger-tip"]
                  , h = c.joints["thumb-tip"]
                  , f = u.position.distanceTo(h.position)
                  , d = .02
                  , p = .005;
                c.inputState.pinching && f > d + p ? (c.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !c.inputState.pinching && f <= d - p && (c.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i),
                s !== null && (l.matrix.fromArray(s.transform.matrix),
                l.matrix.decompose(l.position, l.rotation, l.scale),
                l.matrixWorldNeedsUpdate = !0,
                s.linearVelocity ? (l.hasLinearVelocity = !0,
                l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1,
                s.angularVelocity ? (l.hasAngularVelocity = !0,
                l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (r = t.getPose(e.targetRaySpace, i),
            r === null && s !== null && (r = s),
            r !== null && (a.matrix.fromArray(r.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            a.matrixWorldNeedsUpdate = !0,
            r.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1,
            r.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(kP)))
        }
        return a !== null && (a.visible = r !== null),
        l !== null && (l.visible = s !== null),
        c !== null && (c.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const i = new no;
            i.matrixAutoUpdate = !1,
            i.visible = !1,
            e.joints[t.jointName] = i,
            e.add(i)
        }
        return e.joints[t.jointName]
    }
}
const VP = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
  , HP = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class GP {
    constructor() {
        this.texture = null,
        this.mesh = null,
        this.depthNear = 0,
        this.depthFar = 0
    }
    init(e, t, i) {
        if (this.texture === null) {
            const r = new Dt
              , s = e.properties.get(r);
            s.__webglTexture = t.texture,
            (t.depthNear != i.depthNear || t.depthFar != i.depthFar) && (this.depthNear = t.depthNear,
            this.depthFar = t.depthFar),
            this.texture = r
        }
    }
    getMesh(e) {
        if (this.texture !== null && this.mesh === null) {
            const t = e.cameras[0].viewport
              , i = new oi({
                vertexShader: VP,
                fragmentShader: HP,
                uniforms: {
                    depthColor: {
                        value: this.texture
                    },
                    depthWidth: {
                        value: t.z
                    },
                    depthHeight: {
                        value: t.w
                    }
                }
            });
            this.mesh = new Ot(new Uo(20,20),i)
        }
        return this.mesh
    }
    reset() {
        this.texture = null,
        this.mesh = null
    }
    getDepthTexture() {
        return this.texture
    }
}
class WP extends Si {
    constructor(e, t) {
        super();
        const i = this;
        let r = null
          , s = 1
          , o = null
          , a = "local-floor"
          , l = 1
          , c = null
          , u = null
          , h = null
          , f = null
          , d = null
          , p = null;
        const v = new GP
          , g = t.getContextAttributes();
        let m = null
          , y = null;
        const _ = []
          , x = []
          , C = new ae;
        let w = null;
        const E = new Ht;
        E.layers.enable(1),
        E.viewport = new ft;
        const L = new Ht;
        L.layers.enable(2),
        L.viewport = new ft;
        const S = [E, L]
          , b = new Jx;
        b.layers.enable(1),
        b.layers.enable(2);
        let D = null
          , F = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(re) {
            let pe = _[re];
            return pe === void 0 && (pe = new Ff,
            _[re] = pe),
            pe.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(re) {
            let pe = _[re];
            return pe === void 0 && (pe = new Ff,
            _[re] = pe),
            pe.getGripSpace()
        }
        ,
        this.getHand = function(re) {
            let pe = _[re];
            return pe === void 0 && (pe = new Ff,
            _[re] = pe),
            pe.getHandSpace()
        }
        ;
        function z(re) {
            const pe = x.indexOf(re.inputSource);
            if (pe === -1)
                return;
            const Me = _[pe];
            Me !== void 0 && (Me.update(re.inputSource, re.frame, c || o),
            Me.dispatchEvent({
                type: re.type,
                data: re.inputSource
            }))
        }
        function $() {
            r.removeEventListener("select", z),
            r.removeEventListener("selectstart", z),
            r.removeEventListener("selectend", z),
            r.removeEventListener("squeeze", z),
            r.removeEventListener("squeezestart", z),
            r.removeEventListener("squeezeend", z),
            r.removeEventListener("end", $),
            r.removeEventListener("inputsourceschange", ne);
            for (let re = 0; re < _.length; re++) {
                const pe = x[re];
                pe !== null && (x[re] = null,
                _[re].disconnect(pe))
            }
            D = null,
            F = null,
            v.reset(),
            e.setRenderTarget(m),
            d = null,
            f = null,
            h = null,
            r = null,
            y = null,
            ze.stop(),
            i.isPresenting = !1,
            e.setPixelRatio(w),
            e.setSize(C.width, C.height, !1),
            i.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(re) {
            s = re,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(re) {
            a = re,
            i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return c || o
        }
        ,
        this.setReferenceSpace = function(re) {
            c = re
        }
        ,
        this.getBaseLayer = function() {
            return f !== null ? f : d
        }
        ,
        this.getBinding = function() {
            return h
        }
        ,
        this.getFrame = function() {
            return p
        }
        ,
        this.getSession = function() {
            return r
        }
        ,
        this.setSession = async function(re) {
            if (r = re,
            r !== null) {
                if (m = e.getRenderTarget(),
                r.addEventListener("select", z),
                r.addEventListener("selectstart", z),
                r.addEventListener("selectend", z),
                r.addEventListener("squeeze", z),
                r.addEventListener("squeezestart", z),
                r.addEventListener("squeezeend", z),
                r.addEventListener("end", $),
                r.addEventListener("inputsourceschange", ne),
                g.xrCompatible !== !0 && await t.makeXRCompatible(),
                w = e.getPixelRatio(),
                e.getSize(C),
                r.renderState.layers === void 0) {
                    const pe = {
                        antialias: g.antialias,
                        alpha: !0,
                        depth: g.depth,
                        stencil: g.stencil,
                        framebufferScaleFactor: s
                    };
                    d = new XRWebGLLayer(r,t,pe),
                    r.updateRenderState({
                        baseLayer: d
                    }),
                    e.setPixelRatio(1),
                    e.setSize(d.framebufferWidth, d.framebufferHeight, !1),
                    y = new si(d.framebufferWidth,d.framebufferHeight,{
                        format: vn,
                        type: bi,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: g.stencil
                    })
                } else {
                    let pe = null
                      , Me = null
                      , k = null;
                    g.depth && (k = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                    pe = g.stencil ? _s : hs,
                    Me = g.stencil ? vs : qi);
                    const se = {
                        colorFormat: t.RGBA8,
                        depthFormat: k,
                        scaleFactor: s
                    };
                    h = new XRWebGLBinding(r,t),
                    f = h.createProjectionLayer(se),
                    r.updateRenderState({
                        layers: [f]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(f.textureWidth, f.textureHeight, !1),
                    y = new si(f.textureWidth,f.textureHeight,{
                        format: vn,
                        type: bi,
                        depthTexture: new kp(f.textureWidth,f.textureHeight,Me,void 0,void 0,void 0,void 0,void 0,void 0,pe),
                        stencilBuffer: g.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: g.antialias ? 4 : 0,
                        resolveDepthBuffer: f.ignoreDepthValues === !1
                    })
                }
                y.isXRRenderTarget = !0,
                this.setFoveation(l),
                c = null,
                o = await r.requestReferenceSpace(a),
                ze.setContext(r),
                ze.start(),
                i.isPresenting = !0,
                i.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (r !== null)
                return r.environmentBlendMode
        }
        ,
        this.getDepthTexture = function() {
            return v.getDepthTexture()
        }
        ;
        function ne(re) {
            for (let pe = 0; pe < re.removed.length; pe++) {
                const Me = re.removed[pe]
                  , k = x.indexOf(Me);
                k >= 0 && (x[k] = null,
                _[k].disconnect(Me))
            }
            for (let pe = 0; pe < re.added.length; pe++) {
                const Me = re.added[pe];
                let k = x.indexOf(Me);
                if (k === -1) {
                    for (let oe = 0; oe < _.length; oe++)
                        if (oe >= x.length) {
                            x.push(Me),
                            k = oe;
                            break
                        } else if (x[oe] === null) {
                            x[oe] = Me,
                            k = oe;
                            break
                        }
                    if (k === -1)
                        break
                }
                const se = _[k];
                se && se.connect(Me)
            }
        }
        const W = new N
          , ie = new N;
        function Z(re, pe, Me) {
            W.setFromMatrixPosition(pe.matrixWorld),
            ie.setFromMatrixPosition(Me.matrixWorld);
            const k = W.distanceTo(ie)
              , se = pe.projectionMatrix.elements
              , oe = Me.projectionMatrix.elements
              , he = se[14] / (se[10] - 1)
              , Re = se[14] / (se[10] + 1)
              , I = (se[9] + 1) / se[5]
              , A = (se[9] - 1) / se[5]
              , R = (se[8] - 1) / se[0]
              , O = (oe[8] + 1) / oe[0]
              , B = he * R
              , Y = he * O
              , X = k / (-R + O)
              , ee = X * -R;
            if (pe.matrixWorld.decompose(re.position, re.quaternion, re.scale),
            re.translateX(ee),
            re.translateZ(X),
            re.matrixWorld.compose(re.position, re.quaternion, re.scale),
            re.matrixWorldInverse.copy(re.matrixWorld).invert(),
            se[10] === -1)
                re.projectionMatrix.copy(pe.projectionMatrix),
                re.projectionMatrixInverse.copy(pe.projectionMatrixInverse);
            else {
                const T = he + X
                  , M = Re + X
                  , U = B - ee
                  , K = Y + (k - ee)
                  , H = I * Re / M * T
                  , j = A * Re / M * T;
                re.projectionMatrix.makePerspective(U, K, H, j, T, M),
                re.projectionMatrixInverse.copy(re.projectionMatrix).invert()
            }
        }
        function ve(re, pe) {
            pe === null ? re.matrixWorld.copy(re.matrix) : re.matrixWorld.multiplyMatrices(pe.matrixWorld, re.matrix),
            re.matrixWorldInverse.copy(re.matrixWorld).invert()
        }
        this.updateCamera = function(re) {
            if (r === null)
                return;
            let pe = re.near
              , Me = re.far;
            v.texture !== null && (v.depthNear > 0 && (pe = v.depthNear),
            v.depthFar > 0 && (Me = v.depthFar)),
            b.near = L.near = E.near = pe,
            b.far = L.far = E.far = Me,
            (D !== b.near || F !== b.far) && (r.updateRenderState({
                depthNear: b.near,
                depthFar: b.far
            }),
            D = b.near,
            F = b.far);
            const k = re.parent
              , se = b.cameras;
            ve(b, k);
            for (let oe = 0; oe < se.length; oe++)
                ve(se[oe], k);
            se.length === 2 ? Z(b, E, L) : b.projectionMatrix.copy(E.projectionMatrix),
            xe(re, b, k)
        }
        ;
        function xe(re, pe, Me) {
            Me === null ? re.matrix.copy(pe.matrixWorld) : (re.matrix.copy(Me.matrixWorld),
            re.matrix.invert(),
            re.matrix.multiply(pe.matrixWorld)),
            re.matrix.decompose(re.position, re.quaternion, re.scale),
            re.updateMatrixWorld(!0),
            re.projectionMatrix.copy(pe.projectionMatrix),
            re.projectionMatrixInverse.copy(pe.projectionMatrixInverse),
            re.isPerspectiveCamera && (re.fov = Mo * 2 * Math.atan(1 / re.projectionMatrix.elements[5]),
            re.zoom = 1)
        }
        this.getCamera = function() {
            return b
        }
        ,
        this.getFoveation = function() {
            if (!(f === null && d === null))
                return l
        }
        ,
        this.setFoveation = function(re) {
            l = re,
            f !== null && (f.fixedFoveation = re),
            d !== null && d.fixedFoveation !== void 0 && (d.fixedFoveation = re)
        }
        ,
        this.hasDepthSensing = function() {
            return v.texture !== null
        }
        ,
        this.getDepthSensingMesh = function() {
            return v.getMesh(b)
        }
        ;
        let te = null;
        function Se(re, pe) {
            if (u = pe.getViewerPose(c || o),
            p = pe,
            u !== null) {
                const Me = u.views;
                d !== null && (e.setRenderTargetFramebuffer(y, d.framebuffer),
                e.setRenderTarget(y));
                let k = !1;
                Me.length !== b.cameras.length && (b.cameras.length = 0,
                k = !0);
                for (let oe = 0; oe < Me.length; oe++) {
                    const he = Me[oe];
                    let Re = null;
                    if (d !== null)
                        Re = d.getViewport(he);
                    else {
                        const A = h.getViewSubImage(f, he);
                        Re = A.viewport,
                        oe === 0 && (e.setRenderTargetTextures(y, A.colorTexture, f.ignoreDepthValues ? void 0 : A.depthStencilTexture),
                        e.setRenderTarget(y))
                    }
                    let I = S[oe];
                    I === void 0 && (I = new Ht,
                    I.layers.enable(oe),
                    I.viewport = new ft,
                    S[oe] = I),
                    I.matrix.fromArray(he.transform.matrix),
                    I.matrix.decompose(I.position, I.quaternion, I.scale),
                    I.projectionMatrix.fromArray(he.projectionMatrix),
                    I.projectionMatrixInverse.copy(I.projectionMatrix).invert(),
                    I.viewport.set(Re.x, Re.y, Re.width, Re.height),
                    oe === 0 && (b.matrix.copy(I.matrix),
                    b.matrix.decompose(b.position, b.quaternion, b.scale)),
                    k === !0 && b.cameras.push(I)
                }
                const se = r.enabledFeatures;
                if (se && se.includes("depth-sensing")) {
                    const oe = h.getDepthInformation(Me[0]);
                    oe && oe.isValid && oe.texture && v.init(e, oe, r.renderState)
                }
            }
            for (let Me = 0; Me < _.length; Me++) {
                const k = x[Me]
                  , se = _[Me];
                k !== null && se !== void 0 && se.update(k, pe, c || o)
            }
            te && te(re, pe),
            pe.detectedPlanes && i.dispatchEvent({
                type: "planesdetected",
                data: pe
            }),
            p = null
        }
        const ze = new qx;
        ze.setAnimationLoop(Se),
        this.setAnimationLoop = function(re) {
            te = re
        }
        ,
        this.dispose = function() {}
    }
}
const Hr = new Un
  , XP = new Be;
function qP(n, e) {
    function t(g, m) {
        g.matrixAutoUpdate === !0 && g.updateMatrix(),
        m.value.copy(g.matrix)
    }
    function i(g, m) {
        m.color.getRGB(g.fogColor.value, Hx(n)),
        m.isFog ? (g.fogNear.value = m.near,
        g.fogFar.value = m.far) : m.isFogExp2 && (g.fogDensity.value = m.density)
    }
    function r(g, m, y, _, x) {
        m.isMeshBasicMaterial || m.isMeshLambertMaterial ? s(g, m) : m.isMeshToonMaterial ? (s(g, m),
        h(g, m)) : m.isMeshPhongMaterial ? (s(g, m),
        u(g, m)) : m.isMeshStandardMaterial ? (s(g, m),
        f(g, m),
        m.isMeshPhysicalMaterial && d(g, m, x)) : m.isMeshMatcapMaterial ? (s(g, m),
        p(g, m)) : m.isMeshDepthMaterial ? s(g, m) : m.isMeshDistanceMaterial ? (s(g, m),
        v(g, m)) : m.isMeshNormalMaterial ? s(g, m) : m.isLineBasicMaterial ? (o(g, m),
        m.isLineDashedMaterial && a(g, m)) : m.isPointsMaterial ? l(g, m, y, _) : m.isSpriteMaterial ? c(g, m) : m.isShadowMaterial ? (g.color.value.copy(m.color),
        g.opacity.value = m.opacity) : m.isShaderMaterial && (m.uniformsNeedUpdate = !1)
    }
    function s(g, m) {
        g.opacity.value = m.opacity,
        m.color && g.diffuse.value.copy(m.color),
        m.emissive && g.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),
        m.map && (g.map.value = m.map,
        t(m.map, g.mapTransform)),
        m.alphaMap && (g.alphaMap.value = m.alphaMap,
        t(m.alphaMap, g.alphaMapTransform)),
        m.bumpMap && (g.bumpMap.value = m.bumpMap,
        t(m.bumpMap, g.bumpMapTransform),
        g.bumpScale.value = m.bumpScale,
        m.side === _n && (g.bumpScale.value *= -1)),
        m.normalMap && (g.normalMap.value = m.normalMap,
        t(m.normalMap, g.normalMapTransform),
        g.normalScale.value.copy(m.normalScale),
        m.side === _n && g.normalScale.value.negate()),
        m.displacementMap && (g.displacementMap.value = m.displacementMap,
        t(m.displacementMap, g.displacementMapTransform),
        g.displacementScale.value = m.displacementScale,
        g.displacementBias.value = m.displacementBias),
        m.emissiveMap && (g.emissiveMap.value = m.emissiveMap,
        t(m.emissiveMap, g.emissiveMapTransform)),
        m.specularMap && (g.specularMap.value = m.specularMap,
        t(m.specularMap, g.specularMapTransform)),
        m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest);
        const y = e.get(m)
          , _ = y.envMap
          , x = y.envMapRotation;
        _ && (g.envMap.value = _,
        Hr.copy(x),
        Hr.x *= -1,
        Hr.y *= -1,
        Hr.z *= -1,
        _.isCubeTexture && _.isRenderTargetTexture === !1 && (Hr.y *= -1,
        Hr.z *= -1),
        g.envMapRotation.value.setFromMatrix4(XP.makeRotationFromEuler(Hr)),
        g.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1,
        g.reflectivity.value = m.reflectivity,
        g.ior.value = m.ior,
        g.refractionRatio.value = m.refractionRatio),
        m.lightMap && (g.lightMap.value = m.lightMap,
        g.lightMapIntensity.value = m.lightMapIntensity,
        t(m.lightMap, g.lightMapTransform)),
        m.aoMap && (g.aoMap.value = m.aoMap,
        g.aoMapIntensity.value = m.aoMapIntensity,
        t(m.aoMap, g.aoMapTransform))
    }
    function o(g, m) {
        g.diffuse.value.copy(m.color),
        g.opacity.value = m.opacity,
        m.map && (g.map.value = m.map,
        t(m.map, g.mapTransform))
    }
    function a(g, m) {
        g.dashSize.value = m.dashSize,
        g.totalSize.value = m.dashSize + m.gapSize,
        g.scale.value = m.scale
    }
    function l(g, m, y, _) {
        g.diffuse.value.copy(m.color),
        g.opacity.value = m.opacity,
        g.size.value = m.size * y,
        g.scale.value = _ * .5,
        m.map && (g.map.value = m.map,
        t(m.map, g.uvTransform)),
        m.alphaMap && (g.alphaMap.value = m.alphaMap,
        t(m.alphaMap, g.alphaMapTransform)),
        m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest)
    }
    function c(g, m) {
        g.diffuse.value.copy(m.color),
        g.opacity.value = m.opacity,
        g.rotation.value = m.rotation,
        m.map && (g.map.value = m.map,
        t(m.map, g.mapTransform)),
        m.alphaMap && (g.alphaMap.value = m.alphaMap,
        t(m.alphaMap, g.alphaMapTransform)),
        m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest)
    }
    function u(g, m) {
        g.specular.value.copy(m.specular),
        g.shininess.value = Math.max(m.shininess, 1e-4)
    }
    function h(g, m) {
        m.gradientMap && (g.gradientMap.value = m.gradientMap)
    }
    function f(g, m) {
        g.metalness.value = m.metalness,
        m.metalnessMap && (g.metalnessMap.value = m.metalnessMap,
        t(m.metalnessMap, g.metalnessMapTransform)),
        g.roughness.value = m.roughness,
        m.roughnessMap && (g.roughnessMap.value = m.roughnessMap,
        t(m.roughnessMap, g.roughnessMapTransform)),
        m.envMap && (g.envMapIntensity.value = m.envMapIntensity)
    }
    function d(g, m, y) {
        g.ior.value = m.ior,
        m.sheen > 0 && (g.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen),
        g.sheenRoughness.value = m.sheenRoughness,
        m.sheenColorMap && (g.sheenColorMap.value = m.sheenColorMap,
        t(m.sheenColorMap, g.sheenColorMapTransform)),
        m.sheenRoughnessMap && (g.sheenRoughnessMap.value = m.sheenRoughnessMap,
        t(m.sheenRoughnessMap, g.sheenRoughnessMapTransform))),
        m.clearcoat > 0 && (g.clearcoat.value = m.clearcoat,
        g.clearcoatRoughness.value = m.clearcoatRoughness,
        m.clearcoatMap && (g.clearcoatMap.value = m.clearcoatMap,
        t(m.clearcoatMap, g.clearcoatMapTransform)),
        m.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap,
        t(m.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)),
        m.clearcoatNormalMap && (g.clearcoatNormalMap.value = m.clearcoatNormalMap,
        t(m.clearcoatNormalMap, g.clearcoatNormalMapTransform),
        g.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),
        m.side === _n && g.clearcoatNormalScale.value.negate())),
        m.dispersion > 0 && (g.dispersion.value = m.dispersion),
        m.iridescence > 0 && (g.iridescence.value = m.iridescence,
        g.iridescenceIOR.value = m.iridescenceIOR,
        g.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0],
        g.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1],
        m.iridescenceMap && (g.iridescenceMap.value = m.iridescenceMap,
        t(m.iridescenceMap, g.iridescenceMapTransform)),
        m.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = m.iridescenceThicknessMap,
        t(m.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))),
        m.transmission > 0 && (g.transmission.value = m.transmission,
        g.transmissionSamplerMap.value = y.texture,
        g.transmissionSamplerSize.value.set(y.width, y.height),
        m.transmissionMap && (g.transmissionMap.value = m.transmissionMap,
        t(m.transmissionMap, g.transmissionMapTransform)),
        g.thickness.value = m.thickness,
        m.thicknessMap && (g.thicknessMap.value = m.thicknessMap,
        t(m.thicknessMap, g.thicknessMapTransform)),
        g.attenuationDistance.value = m.attenuationDistance,
        g.attenuationColor.value.copy(m.attenuationColor)),
        m.anisotropy > 0 && (g.anisotropyVector.value.set(m.anisotropy * Math.cos(m.anisotropyRotation), m.anisotropy * Math.sin(m.anisotropyRotation)),
        m.anisotropyMap && (g.anisotropyMap.value = m.anisotropyMap,
        t(m.anisotropyMap, g.anisotropyMapTransform))),
        g.specularIntensity.value = m.specularIntensity,
        g.specularColor.value.copy(m.specularColor),
        m.specularColorMap && (g.specularColorMap.value = m.specularColorMap,
        t(m.specularColorMap, g.specularColorMapTransform)),
        m.specularIntensityMap && (g.specularIntensityMap.value = m.specularIntensityMap,
        t(m.specularIntensityMap, g.specularIntensityMapTransform))
    }
    function p(g, m) {
        m.matcap && (g.matcap.value = m.matcap)
    }
    function v(g, m) {
        const y = e.get(m).light;
        g.referencePosition.value.setFromMatrixPosition(y.matrixWorld),
        g.nearDistance.value = y.shadow.camera.near,
        g.farDistance.value = y.shadow.camera.far
    }
    return {
        refreshFogUniforms: i,
        refreshMaterialUniforms: r
    }
}
function $P(n, e, t, i) {
    let r = {}
      , s = {}
      , o = [];
    const a = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
    function l(y, _) {
        const x = _.program;
        i.uniformBlockBinding(y, x)
    }
    function c(y, _) {
        let x = r[y.id];
        x === void 0 && (p(y),
        x = u(y),
        r[y.id] = x,
        y.addEventListener("dispose", g));
        const C = _.program;
        i.updateUBOMapping(y, C);
        const w = e.render.frame;
        s[y.id] !== w && (f(y),
        s[y.id] = w)
    }
    function u(y) {
        const _ = h();
        y.__bindingPointIndex = _;
        const x = n.createBuffer()
          , C = y.__size
          , w = y.usage;
        return n.bindBuffer(n.UNIFORM_BUFFER, x),
        n.bufferData(n.UNIFORM_BUFFER, C, w),
        n.bindBuffer(n.UNIFORM_BUFFER, null),
        n.bindBufferBase(n.UNIFORM_BUFFER, _, x),
        x
    }
    function h() {
        for (let y = 0; y < a; y++)
            if (o.indexOf(y) === -1)
                return o.push(y),
                y;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function f(y) {
        const _ = r[y.id]
          , x = y.uniforms
          , C = y.__cache;
        n.bindBuffer(n.UNIFORM_BUFFER, _);
        for (let w = 0, E = x.length; w < E; w++) {
            const L = Array.isArray(x[w]) ? x[w] : [x[w]];
            for (let S = 0, b = L.length; S < b; S++) {
                const D = L[S];
                if (d(D, w, S, C) === !0) {
                    const F = D.__offset
                      , z = Array.isArray(D.value) ? D.value : [D.value];
                    let $ = 0;
                    for (let ne = 0; ne < z.length; ne++) {
                        const W = z[ne]
                          , ie = v(W);
                        typeof W == "number" || typeof W == "boolean" ? (D.__data[0] = W,
                        n.bufferSubData(n.UNIFORM_BUFFER, F + $, D.__data)) : W.isMatrix3 ? (D.__data[0] = W.elements[0],
                        D.__data[1] = W.elements[1],
                        D.__data[2] = W.elements[2],
                        D.__data[3] = 0,
                        D.__data[4] = W.elements[3],
                        D.__data[5] = W.elements[4],
                        D.__data[6] = W.elements[5],
                        D.__data[7] = 0,
                        D.__data[8] = W.elements[6],
                        D.__data[9] = W.elements[7],
                        D.__data[10] = W.elements[8],
                        D.__data[11] = 0) : (W.toArray(D.__data, $),
                        $ += ie.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    n.bufferSubData(n.UNIFORM_BUFFER, F, D.__data)
                }
            }
        }
        n.bindBuffer(n.UNIFORM_BUFFER, null)
    }
    function d(y, _, x, C) {
        const w = y.value
          , E = _ + "_" + x;
        if (C[E] === void 0)
            return typeof w == "number" || typeof w == "boolean" ? C[E] = w : C[E] = w.clone(),
            !0;
        {
            const L = C[E];
            if (typeof w == "number" || typeof w == "boolean") {
                if (L !== w)
                    return C[E] = w,
                    !0
            } else if (L.equals(w) === !1)
                return L.copy(w),
                !0
        }
        return !1
    }
    function p(y) {
        const _ = y.uniforms;
        let x = 0;
        const C = 16;
        for (let E = 0, L = _.length; E < L; E++) {
            const S = Array.isArray(_[E]) ? _[E] : [_[E]];
            for (let b = 0, D = S.length; b < D; b++) {
                const F = S[b]
                  , z = Array.isArray(F.value) ? F.value : [F.value];
                for (let $ = 0, ne = z.length; $ < ne; $++) {
                    const W = z[$]
                      , ie = v(W)
                      , Z = x % C
                      , ve = Z % ie.boundary
                      , xe = Z + ve;
                    x += ve,
                    xe !== 0 && C - xe < ie.storage && (x += C - xe),
                    F.__data = new Float32Array(ie.storage / Float32Array.BYTES_PER_ELEMENT),
                    F.__offset = x,
                    x += ie.storage
                }
            }
        }
        const w = x % C;
        return w > 0 && (x += C - w),
        y.__size = x,
        y.__cache = {},
        this
    }
    function v(y) {
        const _ = {
            boundary: 0,
            storage: 0
        };
        return typeof y == "number" || typeof y == "boolean" ? (_.boundary = 4,
        _.storage = 4) : y.isVector2 ? (_.boundary = 8,
        _.storage = 8) : y.isVector3 || y.isColor ? (_.boundary = 16,
        _.storage = 12) : y.isVector4 ? (_.boundary = 16,
        _.storage = 16) : y.isMatrix3 ? (_.boundary = 48,
        _.storage = 48) : y.isMatrix4 ? (_.boundary = 64,
        _.storage = 64) : y.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", y),
        _
    }
    function g(y) {
        const _ = y.target;
        _.removeEventListener("dispose", g);
        const x = o.indexOf(_.__bindingPointIndex);
        o.splice(x, 1),
        n.deleteBuffer(r[_.id]),
        delete r[_.id],
        delete s[_.id]
    }
    function m() {
        for (const y in r)
            n.deleteBuffer(r[y]);
        o = [],
        r = {},
        s = {}
    }
    return {
        bind: l,
        update: c,
        dispose: m
    }
}
class Gc {
    constructor(e={}) {
        const {canvas: t=Bx(), context: i=null, depth: r=!0, stencil: s=!1, alpha: o=!1, antialias: a=!1, premultipliedAlpha: l=!0, preserveDrawingBuffer: c=!1, powerPreference: u="default", failIfMajorPerformanceCaveat: h=!1} = e;
        this.isWebGLRenderer = !0;
        let f;
        if (i !== null) {
            if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext)
                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            f = i.getContextAttributes().alpha
        } else
            f = o;
        const d = new Uint32Array(4)
          , p = new Int32Array(4);
        let v = null
          , g = null;
        const m = []
          , y = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this._outputColorSpace = Rn,
        this.toneMapping = vi,
        this.toneMappingExposure = 1;
        const _ = this;
        let x = !1
          , C = 0
          , w = 0
          , E = null
          , L = -1
          , S = null;
        const b = new ft
          , D = new ft;
        let F = null;
        const z = new Ee(0);
        let $ = 0
          , ne = t.width
          , W = t.height
          , ie = 1
          , Z = null
          , ve = null;
        const xe = new ft(0,0,ne,W)
          , te = new ft(0,0,ne,W);
        let Se = !1;
        const ze = new xl;
        let re = !1
          , pe = !1;
        const Me = new Be
          , k = new N
          , se = new ft
          , oe = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        let he = !1;
        function Re() {
            return E === null ? ie : 1
        }
        let I = i;
        function A(P, G) {
            return t.getContext(P, G)
        }
        try {
            const P = {
                alpha: !0,
                depth: r,
                stencil: s,
                antialias: a,
                premultipliedAlpha: l,
                preserveDrawingBuffer: c,
                powerPreference: u,
                failIfMajorPerformanceCaveat: h
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${pl}`),
            t.addEventListener("webglcontextlost", ce, !1),
            t.addEventListener("webglcontextrestored", ue, !1),
            t.addEventListener("webglcontextcreationerror", be, !1),
            I === null) {
                const G = "webgl2";
                if (I = A(G, P),
                I === null)
                    throw A(G) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (P) {
            throw console.error("THREE.WebGLRenderer: " + P.message),
            P
        }
        let R, O, B, Y, X, ee, T, M, U, K, H, j, de, le, me, Ae, fe, ge, He, De, Te, Ge, Fe, et;
        function V() {
            R = new eR(I),
            R.init(),
            Ge = new Zx(I,R),
            O = new YC(I,R,e,Ge),
            B = new DP(I),
            Y = new iR(I),
            X = new bP,
            ee = new zP(I,R,B,X,O,Ge,Y),
            T = new KC(_),
            M = new QC(_),
            U = new uT(I),
            Fe = new qC(I,U),
            K = new tR(I,U,Y,Fe),
            H = new sR(I,K,U,Y),
            He = new rR(I,O,ee),
            Ae = new jC(X),
            j = new xP(_,T,M,R,O,Fe,Ae),
            de = new qP(_,X),
            le = new SP,
            me = new RP(R),
            ge = new XC(_,T,M,B,H,f,l),
            fe = new LP(_,H,O),
            et = new $P(I,Y,O,B),
            De = new $C(I,R,Y),
            Te = new nR(I,R,Y),
            Y.programs = j.programs,
            _.capabilities = O,
            _.extensions = R,
            _.properties = X,
            _.renderLists = le,
            _.shadowMap = fe,
            _.state = B,
            _.info = Y
        }
        V();
        const _e = new WP(_,I);
        this.xr = _e,
        this.getContext = function() {
            return I
        }
        ,
        this.getContextAttributes = function() {
            return I.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const P = R.get("WEBGL_lose_context");
            P && P.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const P = R.get("WEBGL_lose_context");
            P && P.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return ie
        }
        ,
        this.setPixelRatio = function(P) {
            P !== void 0 && (ie = P,
            this.setSize(ne, W, !1))
        }
        ,
        this.getSize = function(P) {
            return P.set(ne, W)
        }
        ,
        this.setSize = function(P, G, J=!0) {
            if (_e.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            ne = P,
            W = G,
            t.width = Math.floor(P * ie),
            t.height = Math.floor(G * ie),
            J === !0 && (t.style.width = P + "px",
            t.style.height = G + "px"),
            this.setViewport(0, 0, P, G)
        }
        ,
        this.getDrawingBufferSize = function(P) {
            return P.set(ne * ie, W * ie).floor()
        }
        ,
        this.setDrawingBufferSize = function(P, G, J) {
            ne = P,
            W = G,
            ie = J,
            t.width = Math.floor(P * J),
            t.height = Math.floor(G * J),
            this.setViewport(0, 0, P, G)
        }
        ,
        this.getCurrentViewport = function(P) {
            return P.copy(b)
        }
        ,
        this.getViewport = function(P) {
            return P.copy(xe)
        }
        ,
        this.setViewport = function(P, G, J, Q) {
            P.isVector4 ? xe.set(P.x, P.y, P.z, P.w) : xe.set(P, G, J, Q),
            B.viewport(b.copy(xe).multiplyScalar(ie).round())
        }
        ,
        this.getScissor = function(P) {
            return P.copy(te)
        }
        ,
        this.setScissor = function(P, G, J, Q) {
            P.isVector4 ? te.set(P.x, P.y, P.z, P.w) : te.set(P, G, J, Q),
            B.scissor(D.copy(te).multiplyScalar(ie).round())
        }
        ,
        this.getScissorTest = function() {
            return Se
        }
        ,
        this.setScissorTest = function(P) {
            B.setScissorTest(Se = P)
        }
        ,
        this.setOpaqueSort = function(P) {
            Z = P
        }
        ,
        this.setTransparentSort = function(P) {
            ve = P
        }
        ,
        this.getClearColor = function(P) {
            return P.copy(ge.getClearColor())
        }
        ,
        this.setClearColor = function() {
            ge.setClearColor.apply(ge, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return ge.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            ge.setClearAlpha.apply(ge, arguments)
        }
        ,
        this.clear = function(P=!0, G=!0, J=!0) {
            let Q = 0;
            if (P) {
                let q = !1;
                if (E !== null) {
                    const ye = E.texture.format;
                    q = ye === uh || ye === ch || ye === gl
                }
                if (q) {
                    const ye = E.texture.type
                      , Ce = ye === bi || ye === qi || ye === bo || ye === vs || ye === oh || ye === ah
                      , Pe = ge.getClearColor()
                      , Ie = ge.getClearAlpha()
                      , Ve = Pe.r
                      , We = Pe.g
                      , Ne = Pe.b;
                    Ce ? (d[0] = Ve,
                    d[1] = We,
                    d[2] = Ne,
                    d[3] = Ie,
                    I.clearBufferuiv(I.COLOR, 0, d)) : (p[0] = Ve,
                    p[1] = We,
                    p[2] = Ne,
                    p[3] = Ie,
                    I.clearBufferiv(I.COLOR, 0, p))
                } else
                    Q |= I.COLOR_BUFFER_BIT
            }
            G && (Q |= I.DEPTH_BUFFER_BIT),
            J && (Q |= I.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            I.clear(Q)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", ce, !1),
            t.removeEventListener("webglcontextrestored", ue, !1),
            t.removeEventListener("webglcontextcreationerror", be, !1),
            le.dispose(),
            me.dispose(),
            X.dispose(),
            T.dispose(),
            M.dispose(),
            H.dispose(),
            Fe.dispose(),
            et.dispose(),
            j.dispose(),
            _e.dispose(),
            _e.removeEventListener("sessionstart", ui),
            _e.removeEventListener("sessionend", Mm),
            Dr.stop()
        }
        ;
        function ce(P) {
            P.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            x = !0
        }
        function ue() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            x = !1;
            const P = Y.autoReset
              , G = fe.enabled
              , J = fe.autoUpdate
              , Q = fe.needsUpdate
              , q = fe.type;
            V(),
            Y.autoReset = P,
            fe.enabled = G,
            fe.autoUpdate = J,
            fe.needsUpdate = Q,
            fe.type = q
        }
        function be(P) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", P.statusMessage)
        }
        function ke(P) {
            const G = P.target;
            G.removeEventListener("dispose", ke),
            nt(G)
        }
        function nt(P) {
            zt(P),
            X.remove(P)
        }
        function zt(P) {
            const G = X.get(P).programs;
            G !== void 0 && (G.forEach(function(J) {
                j.releaseProgram(J)
            }),
            P.isShaderMaterial && j.releaseShaderCache(P))
        }
        this.renderBufferDirect = function(P, G, J, Q, q, ye) {
            G === null && (G = oe);
            const Ce = q.isMesh && q.matrixWorld.determinant() < 0
              , Pe = FM(P, G, J, Q, q);
            B.setMaterial(Q, Ce);
            let Ie = J.index
              , Ve = 1;
            if (Q.wireframe === !0) {
                if (Ie = K.getWireframeAttribute(J),
                Ie === void 0)
                    return;
                Ve = 2
            }
            const We = J.drawRange
              , Ne = J.attributes.position;
            let lt = We.start * Ve
              , Tt = (We.start + We.count) * Ve;
            ye !== null && (lt = Math.max(lt, ye.start * Ve),
            Tt = Math.min(Tt, (ye.start + ye.count) * Ve)),
            Ie !== null ? (lt = Math.max(lt, 0),
            Tt = Math.min(Tt, Ie.count)) : Ne != null && (lt = Math.max(lt, 0),
            Tt = Math.min(Tt, Ne.count));
            const Ct = Tt - lt;
            if (Ct < 0 || Ct === 1 / 0)
                return;
            Fe.setup(q, Q, Pe, J, Ie);
            let En, ct = De;
            if (Ie !== null && (En = U.get(Ie),
            ct = Te,
            ct.setIndex(En)),
            q.isMesh)
                Q.wireframe === !0 ? (B.setLineWidth(Q.wireframeLinewidth * Re()),
                ct.setMode(I.LINES)) : ct.setMode(I.TRIANGLES);
            else if (q.isLine) {
                let Ue = Q.linewidth;
                Ue === void 0 && (Ue = 1),
                B.setLineWidth(Ue * Re()),
                q.isLineSegments ? ct.setMode(I.LINES) : q.isLineLoop ? ct.setMode(I.LINE_LOOP) : ct.setMode(I.LINE_STRIP)
            } else
                q.isPoints ? ct.setMode(I.POINTS) : q.isSprite && ct.setMode(I.TRIANGLES);
            if (q.isBatchedMesh)
                if (q._multiDrawInstances !== null)
                    ct.renderMultiDrawInstances(q._multiDrawStarts, q._multiDrawCounts, q._multiDrawCount, q._multiDrawInstances);
                else if (R.get("WEBGL_multi_draw"))
                    ct.renderMultiDraw(q._multiDrawStarts, q._multiDrawCounts, q._multiDrawCount);
                else {
                    const Ue = q._multiDrawStarts
                      , Jt = q._multiDrawCounts
                      , ut = q._multiDrawCount
                      , Xn = Ie ? U.get(Ie).bytesPerElement : 1
                      , As = X.get(Q).currentProgram.getUniforms();
                    for (let An = 0; An < ut; An++)
                        As.setValue(I, "_gl_DrawID", An),
                        ct.render(Ue[An] / Xn, Jt[An])
                }
            else if (q.isInstancedMesh)
                ct.renderInstances(lt, Ct, q.count);
            else if (J.isInstancedBufferGeometry) {
                const Ue = J._maxInstanceCount !== void 0 ? J._maxInstanceCount : 1 / 0
                  , Jt = Math.min(J.instanceCount, Ue);
                ct.renderInstances(lt, Ct, Jt)
            } else
                ct.render(lt, Ct)
        }
        ;
        function Zt(P, G, J) {
            P.transparent === !0 && P.side === Zn && P.forceSinglePass === !1 ? (P.side = _n,
            P.needsUpdate = !0,
            Cl(P, G, J),
            P.side = Wi,
            P.needsUpdate = !0,
            Cl(P, G, J),
            P.side = Zn) : Cl(P, G, J)
        }
        this.compile = function(P, G, J=null) {
            J === null && (J = P),
            g = me.get(J),
            g.init(G),
            y.push(g),
            J.traverseVisible(function(q) {
                q.isLight && q.layers.test(G.layers) && (g.pushLight(q),
                q.castShadow && g.pushShadow(q))
            }),
            P !== J && P.traverseVisible(function(q) {
                q.isLight && q.layers.test(G.layers) && (g.pushLight(q),
                q.castShadow && g.pushShadow(q))
            }),
            g.setupLights();
            const Q = new Set;
            return P.traverse(function(q) {
                const ye = q.material;
                if (ye)
                    if (Array.isArray(ye))
                        for (let Ce = 0; Ce < ye.length; Ce++) {
                            const Pe = ye[Ce];
                            Zt(Pe, J, q),
                            Q.add(Pe)
                        }
                    else
                        Zt(ye, J, q),
                        Q.add(ye)
            }),
            y.pop(),
            g = null,
            Q
        }
        ,
        this.compileAsync = function(P, G, J=null) {
            const Q = this.compile(P, G, J);
            return new Promise(q => {
                function ye() {
                    if (Q.forEach(function(Ce) {
                        X.get(Ce).currentProgram.isReady() && Q.delete(Ce)
                    }),
                    Q.size === 0) {
                        q(P);
                        return
                    }
                    setTimeout(ye, 10)
                }
                R.get("KHR_parallel_shader_compile") !== null ? ye() : setTimeout(ye, 10)
            }
            )
        }
        ;
        let at = null;
        function Ei(P) {
            at && at(P)
        }
        function ui() {
            Dr.stop()
        }
        function Mm() {
            Dr.start()
        }
        const Dr = new qx;
        Dr.setAnimationLoop(Ei),
        typeof self < "u" && Dr.setContext(self),
        this.setAnimationLoop = function(P) {
            at = P,
            _e.setAnimationLoop(P),
            P === null ? Dr.stop() : Dr.start()
        }
        ,
        _e.addEventListener("sessionstart", ui),
        _e.addEventListener("sessionend", Mm),
        this.render = function(P, G) {
            if (G !== void 0 && G.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (x === !0)
                return;
            if (P.matrixWorldAutoUpdate === !0 && P.updateMatrixWorld(),
            G.parent === null && G.matrixWorldAutoUpdate === !0 && G.updateMatrixWorld(),
            _e.enabled === !0 && _e.isPresenting === !0 && (_e.cameraAutoUpdate === !0 && _e.updateCamera(G),
            G = _e.getCamera()),
            P.isScene === !0 && P.onBeforeRender(_, P, G, E),
            g = me.get(P, y.length),
            g.init(G),
            y.push(g),
            Me.multiplyMatrices(G.projectionMatrix, G.matrixWorldInverse),
            ze.setFromProjectionMatrix(Me),
            pe = this.localClippingEnabled,
            re = Ae.init(this.clippingPlanes, pe),
            v = le.get(P, m.length),
            v.init(),
            m.push(v),
            _e.enabled === !0 && _e.isPresenting === !0) {
                const ye = _.xr.getDepthSensingMesh();
                ye !== null && $h(ye, G, -1 / 0, _.sortObjects)
            }
            $h(P, G, 0, _.sortObjects),
            v.finish(),
            _.sortObjects === !0 && v.sort(Z, ve),
            he = _e.enabled === !1 || _e.isPresenting === !1 || _e.hasDepthSensing() === !1,
            he && ge.addToRenderList(v, P),
            this.info.render.frame++,
            re === !0 && Ae.beginShadows();
            const J = g.state.shadowsArray;
            fe.render(J, P, G),
            re === !0 && Ae.endShadows(),
            this.info.autoReset === !0 && this.info.reset();
            const Q = v.opaque
              , q = v.transmissive;
            if (g.setupLights(),
            G.isArrayCamera) {
                const ye = G.cameras;
                if (q.length > 0)
                    for (let Ce = 0, Pe = ye.length; Ce < Pe; Ce++) {
                        const Ie = ye[Ce];
                        wm(Q, q, P, Ie)
                    }
                he && ge.render(P);
                for (let Ce = 0, Pe = ye.length; Ce < Pe; Ce++) {
                    const Ie = ye[Ce];
                    Sm(v, P, Ie, Ie.viewport)
                }
            } else
                q.length > 0 && wm(Q, q, P, G),
                he && ge.render(P),
                Sm(v, P, G);
            E !== null && (ee.updateMultisampleRenderTarget(E),
            ee.updateRenderTargetMipmap(E)),
            P.isScene === !0 && P.onAfterRender(_, P, G),
            Fe.resetDefaultState(),
            L = -1,
            S = null,
            y.pop(),
            y.length > 0 ? (g = y[y.length - 1],
            re === !0 && Ae.setGlobalState(_.clippingPlanes, g.state.camera)) : g = null,
            m.pop(),
            m.length > 0 ? v = m[m.length - 1] : v = null
        }
        ;
        function $h(P, G, J, Q) {
            if (P.visible === !1)
                return;
            if (P.layers.test(G.layers)) {
                if (P.isGroup)
                    J = P.renderOrder;
                else if (P.isLOD)
                    P.autoUpdate === !0 && P.update(G);
                else if (P.isLight)
                    g.pushLight(P),
                    P.castShadow && g.pushShadow(P);
                else if (P.isSprite) {
                    if (!P.frustumCulled || ze.intersectsSprite(P)) {
                        Q && se.setFromMatrixPosition(P.matrixWorld).applyMatrix4(Me);
                        const Ce = H.update(P)
                          , Pe = P.material;
                        Pe.visible && v.push(P, Ce, Pe, J, se.z, null)
                    }
                } else if ((P.isMesh || P.isLine || P.isPoints) && (!P.frustumCulled || ze.intersectsObject(P))) {
                    const Ce = H.update(P)
                      , Pe = P.material;
                    if (Q && (P.boundingSphere !== void 0 ? (P.boundingSphere === null && P.computeBoundingSphere(),
                    se.copy(P.boundingSphere.center)) : (Ce.boundingSphere === null && Ce.computeBoundingSphere(),
                    se.copy(Ce.boundingSphere.center)),
                    se.applyMatrix4(P.matrixWorld).applyMatrix4(Me)),
                    Array.isArray(Pe)) {
                        const Ie = Ce.groups;
                        for (let Ve = 0, We = Ie.length; Ve < We; Ve++) {
                            const Ne = Ie[Ve]
                              , lt = Pe[Ne.materialIndex];
                            lt && lt.visible && v.push(P, Ce, lt, J, se.z, Ne)
                        }
                    } else
                        Pe.visible && v.push(P, Ce, Pe, J, se.z, null)
                }
            }
            const ye = P.children;
            for (let Ce = 0, Pe = ye.length; Ce < Pe; Ce++)
                $h(ye[Ce], G, J, Q)
        }
        function Sm(P, G, J, Q) {
            const q = P.opaque
              , ye = P.transmissive
              , Ce = P.transparent;
            g.setupLightsView(J),
            re === !0 && Ae.setGlobalState(_.clippingPlanes, J),
            Q && B.viewport(b.copy(Q)),
            q.length > 0 && Tl(q, G, J),
            ye.length > 0 && Tl(ye, G, J),
            Ce.length > 0 && Tl(Ce, G, J),
            B.buffers.depth.setTest(!0),
            B.buffers.depth.setMask(!0),
            B.buffers.color.setMask(!0),
            B.setPolygonOffset(!1)
        }
        function wm(P, G, J, Q) {
            if ((J.isScene === !0 ? J.overrideMaterial : null) !== null)
                return;
            g.state.transmissionRenderTarget[Q.id] === void 0 && (g.state.transmissionRenderTarget[Q.id] = new si(1,1,{
                generateMipmaps: !0,
                type: R.has("EXT_color_buffer_half_float") || R.has("EXT_color_buffer_float") ? Do : bi,
                minFilter: pi,
                samples: 4,
                stencilBuffer: s,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: st.workingColorSpace
            }));
            const ye = g.state.transmissionRenderTarget[Q.id]
              , Ce = Q.viewport || b;
            ye.setSize(Ce.z, Ce.w);
            const Pe = _.getRenderTarget();
            _.setRenderTarget(ye),
            _.getClearColor(z),
            $ = _.getClearAlpha(),
            $ < 1 && _.setClearColor(16777215, .5),
            _.clear(),
            he && ge.render(J);
            const Ie = _.toneMapping;
            _.toneMapping = vi;
            const Ve = Q.viewport;
            if (Q.viewport !== void 0 && (Q.viewport = void 0),
            g.setupLightsView(Q),
            re === !0 && Ae.setGlobalState(_.clippingPlanes, Q),
            Tl(P, J, Q),
            ee.updateMultisampleRenderTarget(ye),
            ee.updateRenderTargetMipmap(ye),
            R.has("WEBGL_multisampled_render_to_texture") === !1) {
                let We = !1;
                for (let Ne = 0, lt = G.length; Ne < lt; Ne++) {
                    const Tt = G[Ne]
                      , Ct = Tt.object
                      , En = Tt.geometry
                      , ct = Tt.material
                      , Ue = Tt.group;
                    if (ct.side === Zn && Ct.layers.test(Q.layers)) {
                        const Jt = ct.side;
                        ct.side = _n,
                        ct.needsUpdate = !0,
                        Em(Ct, J, Q, En, ct, Ue),
                        ct.side = Jt,
                        ct.needsUpdate = !0,
                        We = !0
                    }
                }
                We === !0 && (ee.updateMultisampleRenderTarget(ye),
                ee.updateRenderTargetMipmap(ye))
            }
            _.setRenderTarget(Pe),
            _.setClearColor(z, $),
            Ve !== void 0 && (Q.viewport = Ve),
            _.toneMapping = Ie
        }
        function Tl(P, G, J) {
            const Q = G.isScene === !0 ? G.overrideMaterial : null;
            for (let q = 0, ye = P.length; q < ye; q++) {
                const Ce = P[q]
                  , Pe = Ce.object
                  , Ie = Ce.geometry
                  , Ve = Q === null ? Ce.material : Q
                  , We = Ce.group;
                Pe.layers.test(J.layers) && Em(Pe, G, J, Ie, Ve, We)
            }
        }
        function Em(P, G, J, Q, q, ye) {
            P.onBeforeRender(_, G, J, Q, q, ye),
            P.modelViewMatrix.multiplyMatrices(J.matrixWorldInverse, P.matrixWorld),
            P.normalMatrix.getNormalMatrix(P.modelViewMatrix),
            q.onBeforeRender(_, G, J, Q, P, ye),
            q.transparent === !0 && q.side === Zn && q.forceSinglePass === !1 ? (q.side = _n,
            q.needsUpdate = !0,
            _.renderBufferDirect(J, G, Q, q, P, ye),
            q.side = Wi,
            q.needsUpdate = !0,
            _.renderBufferDirect(J, G, Q, q, P, ye),
            q.side = Zn) : _.renderBufferDirect(J, G, Q, q, P, ye),
            P.onAfterRender(_, G, J, Q, q, ye)
        }
        function Cl(P, G, J) {
            G.isScene !== !0 && (G = oe);
            const Q = X.get(P)
              , q = g.state.lights
              , ye = g.state.shadowsArray
              , Ce = q.state.version
              , Pe = j.getParameters(P, q.state, ye, G, J)
              , Ie = j.getProgramCacheKey(Pe);
            let Ve = Q.programs;
            Q.environment = P.isMeshStandardMaterial ? G.environment : null,
            Q.fog = G.fog,
            Q.envMap = (P.isMeshStandardMaterial ? M : T).get(P.envMap || Q.environment),
            Q.envMapRotation = Q.environment !== null && P.envMap === null ? G.environmentRotation : P.envMapRotation,
            Ve === void 0 && (P.addEventListener("dispose", ke),
            Ve = new Map,
            Q.programs = Ve);
            let We = Ve.get(Ie);
            if (We !== void 0) {
                if (Q.currentProgram === We && Q.lightsStateVersion === Ce)
                    return Tm(P, Pe),
                    We
            } else
                Pe.uniforms = j.getUniforms(P),
                P.onBeforeCompile(Pe, _),
                We = j.acquireProgram(Pe, Ie),
                Ve.set(Ie, We),
                Q.uniforms = Pe.uniforms;
            const Ne = Q.uniforms;
            return (!P.isShaderMaterial && !P.isRawShaderMaterial || P.clipping === !0) && (Ne.clippingPlanes = Ae.uniform),
            Tm(P, Pe),
            Q.needsLights = zM(P),
            Q.lightsStateVersion = Ce,
            Q.needsLights && (Ne.ambientLightColor.value = q.state.ambient,
            Ne.lightProbe.value = q.state.probe,
            Ne.directionalLights.value = q.state.directional,
            Ne.directionalLightShadows.value = q.state.directionalShadow,
            Ne.spotLights.value = q.state.spot,
            Ne.spotLightShadows.value = q.state.spotShadow,
            Ne.rectAreaLights.value = q.state.rectArea,
            Ne.ltc_1.value = q.state.rectAreaLTC1,
            Ne.ltc_2.value = q.state.rectAreaLTC2,
            Ne.pointLights.value = q.state.point,
            Ne.pointLightShadows.value = q.state.pointShadow,
            Ne.hemisphereLights.value = q.state.hemi,
            Ne.directionalShadowMap.value = q.state.directionalShadowMap,
            Ne.directionalShadowMatrix.value = q.state.directionalShadowMatrix,
            Ne.spotShadowMap.value = q.state.spotShadowMap,
            Ne.spotLightMatrix.value = q.state.spotLightMatrix,
            Ne.spotLightMap.value = q.state.spotLightMap,
            Ne.pointShadowMap.value = q.state.pointShadowMap,
            Ne.pointShadowMatrix.value = q.state.pointShadowMatrix),
            Q.currentProgram = We,
            Q.uniformsList = null,
            We
        }
        function Am(P) {
            if (P.uniformsList === null) {
                const G = P.currentProgram.getUniforms();
                P.uniformsList = Hc.seqWithValue(G.seq, P.uniforms)
            }
            return P.uniformsList
        }
        function Tm(P, G) {
            const J = X.get(P);
            J.outputColorSpace = G.outputColorSpace,
            J.batching = G.batching,
            J.batchingColor = G.batchingColor,
            J.instancing = G.instancing,
            J.instancingColor = G.instancingColor,
            J.instancingMorph = G.instancingMorph,
            J.skinning = G.skinning,
            J.morphTargets = G.morphTargets,
            J.morphNormals = G.morphNormals,
            J.morphColors = G.morphColors,
            J.morphTargetsCount = G.morphTargetsCount,
            J.numClippingPlanes = G.numClippingPlanes,
            J.numIntersection = G.numClipIntersection,
            J.vertexAlphas = G.vertexAlphas,
            J.vertexTangents = G.vertexTangents,
            J.toneMapping = G.toneMapping
        }
        function FM(P, G, J, Q, q) {
            G.isScene !== !0 && (G = oe),
            ee.resetTextureUnits();
            const ye = G.fog
              , Ce = Q.isMeshStandardMaterial ? G.environment : null
              , Pe = E === null ? _.outputColorSpace : E.isXRRenderTarget === !0 ? E.texture.colorSpace : Ki
              , Ie = (Q.isMeshStandardMaterial ? M : T).get(Q.envMap || Ce)
              , Ve = Q.vertexColors === !0 && !!J.attributes.color && J.attributes.color.itemSize === 4
              , We = !!J.attributes.tangent && (!!Q.normalMap || Q.anisotropy > 0)
              , Ne = !!J.morphAttributes.position
              , lt = !!J.morphAttributes.normal
              , Tt = !!J.morphAttributes.color;
            let Ct = vi;
            Q.toneMapped && (E === null || E.isXRRenderTarget === !0) && (Ct = _.toneMapping);
            const En = J.morphAttributes.position || J.morphAttributes.normal || J.morphAttributes.color
              , ct = En !== void 0 ? En.length : 0
              , Ue = X.get(Q)
              , Jt = g.state.lights;
            if (re === !0 && (pe === !0 || P !== S)) {
                const On = P === S && Q.id === L;
                Ae.setState(Q, P, On)
            }
            let ut = !1;
            Q.version === Ue.__version ? (Ue.needsLights && Ue.lightsStateVersion !== Jt.state.version || Ue.outputColorSpace !== Pe || q.isBatchedMesh && Ue.batching === !1 || !q.isBatchedMesh && Ue.batching === !0 || q.isBatchedMesh && Ue.batchingColor === !0 && q.colorTexture === null || q.isBatchedMesh && Ue.batchingColor === !1 && q.colorTexture !== null || q.isInstancedMesh && Ue.instancing === !1 || !q.isInstancedMesh && Ue.instancing === !0 || q.isSkinnedMesh && Ue.skinning === !1 || !q.isSkinnedMesh && Ue.skinning === !0 || q.isInstancedMesh && Ue.instancingColor === !0 && q.instanceColor === null || q.isInstancedMesh && Ue.instancingColor === !1 && q.instanceColor !== null || q.isInstancedMesh && Ue.instancingMorph === !0 && q.morphTexture === null || q.isInstancedMesh && Ue.instancingMorph === !1 && q.morphTexture !== null || Ue.envMap !== Ie || Q.fog === !0 && Ue.fog !== ye || Ue.numClippingPlanes !== void 0 && (Ue.numClippingPlanes !== Ae.numPlanes || Ue.numIntersection !== Ae.numIntersection) || Ue.vertexAlphas !== Ve || Ue.vertexTangents !== We || Ue.morphTargets !== Ne || Ue.morphNormals !== lt || Ue.morphColors !== Tt || Ue.toneMapping !== Ct || Ue.morphTargetsCount !== ct) && (ut = !0) : (ut = !0,
            Ue.__version = Q.version);
            let Xn = Ue.currentProgram;
            ut === !0 && (Xn = Cl(Q, G, q));
            let As = !1
              , An = !1
              , Yh = !1;
            const kt = Xn.getUniforms()
              , er = Ue.uniforms;
            if (B.useProgram(Xn.program) && (As = !0,
            An = !0,
            Yh = !0),
            Q.id !== L && (L = Q.id,
            An = !0),
            As || S !== P) {
                kt.setValue(I, "projectionMatrix", P.projectionMatrix),
                kt.setValue(I, "viewMatrix", P.matrixWorldInverse);
                const On = kt.map.cameraPosition;
                On !== void 0 && On.setValue(I, k.setFromMatrixPosition(P.matrixWorld)),
                O.logarithmicDepthBuffer && kt.setValue(I, "logDepthBufFC", 2 / (Math.log(P.far + 1) / Math.LN2)),
                (Q.isMeshPhongMaterial || Q.isMeshToonMaterial || Q.isMeshLambertMaterial || Q.isMeshBasicMaterial || Q.isMeshStandardMaterial || Q.isShaderMaterial) && kt.setValue(I, "isOrthographic", P.isOrthographicCamera === !0),
                S !== P && (S = P,
                An = !0,
                Yh = !0)
            }
            if (q.isSkinnedMesh) {
                kt.setOptional(I, q, "bindMatrix"),
                kt.setOptional(I, q, "bindMatrixInverse");
                const On = q.skeleton;
                On && (On.boneTexture === null && On.computeBoneTexture(),
                kt.setValue(I, "boneTexture", On.boneTexture, ee))
            }
            q.isBatchedMesh && (kt.setOptional(I, q, "batchingTexture"),
            kt.setValue(I, "batchingTexture", q._matricesTexture, ee),
            kt.setOptional(I, q, "batchingIdTexture"),
            kt.setValue(I, "batchingIdTexture", q._indirectTexture, ee),
            kt.setOptional(I, q, "batchingColorTexture"),
            q._colorsTexture !== null && kt.setValue(I, "batchingColorTexture", q._colorsTexture, ee));
            const jh = J.morphAttributes;
            if ((jh.position !== void 0 || jh.normal !== void 0 || jh.color !== void 0) && He.update(q, J, Xn),
            (An || Ue.receiveShadow !== q.receiveShadow) && (Ue.receiveShadow = q.receiveShadow,
            kt.setValue(I, "receiveShadow", q.receiveShadow)),
            Q.isMeshGouraudMaterial && Q.envMap !== null && (er.envMap.value = Ie,
            er.flipEnvMap.value = Ie.isCubeTexture && Ie.isRenderTargetTexture === !1 ? -1 : 1),
            Q.isMeshStandardMaterial && Q.envMap === null && G.environment !== null && (er.envMapIntensity.value = G.environmentIntensity),
            An && (kt.setValue(I, "toneMappingExposure", _.toneMappingExposure),
            Ue.needsLights && BM(er, Yh),
            ye && Q.fog === !0 && de.refreshFogUniforms(er, ye),
            de.refreshMaterialUniforms(er, Q, ie, W, g.state.transmissionRenderTarget[P.id]),
            Hc.upload(I, Am(Ue), er, ee)),
            Q.isShaderMaterial && Q.uniformsNeedUpdate === !0 && (Hc.upload(I, Am(Ue), er, ee),
            Q.uniformsNeedUpdate = !1),
            Q.isSpriteMaterial && kt.setValue(I, "center", q.center),
            kt.setValue(I, "modelViewMatrix", q.modelViewMatrix),
            kt.setValue(I, "normalMatrix", q.normalMatrix),
            kt.setValue(I, "modelMatrix", q.matrixWorld),
            Q.isShaderMaterial || Q.isRawShaderMaterial) {
                const On = Q.uniformsGroups;
                for (let Kh = 0, kM = On.length; Kh < kM; Kh++) {
                    const Cm = On[Kh];
                    et.update(Cm, Xn),
                    et.bind(Cm, Xn)
                }
            }
            return Xn
        }
        function BM(P, G) {
            P.ambientLightColor.needsUpdate = G,
            P.lightProbe.needsUpdate = G,
            P.directionalLights.needsUpdate = G,
            P.directionalLightShadows.needsUpdate = G,
            P.pointLights.needsUpdate = G,
            P.pointLightShadows.needsUpdate = G,
            P.spotLights.needsUpdate = G,
            P.spotLightShadows.needsUpdate = G,
            P.rectAreaLights.needsUpdate = G,
            P.hemisphereLights.needsUpdate = G
        }
        function zM(P) {
            return P.isMeshLambertMaterial || P.isMeshToonMaterial || P.isMeshPhongMaterial || P.isMeshStandardMaterial || P.isShadowMaterial || P.isShaderMaterial && P.lights === !0
        }
        this.getActiveCubeFace = function() {
            return C
        }
        ,
        this.getActiveMipmapLevel = function() {
            return w
        }
        ,
        this.getRenderTarget = function() {
            return E
        }
        ,
        this.setRenderTargetTextures = function(P, G, J) {
            X.get(P.texture).__webglTexture = G,
            X.get(P.depthTexture).__webglTexture = J;
            const Q = X.get(P);
            Q.__hasExternalTextures = !0,
            Q.__autoAllocateDepthBuffer = J === void 0,
            Q.__autoAllocateDepthBuffer || R.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
            Q.__useRenderToTexture = !1)
        }
        ,
        this.setRenderTargetFramebuffer = function(P, G) {
            const J = X.get(P);
            J.__webglFramebuffer = G,
            J.__useDefaultFramebuffer = G === void 0
        }
        ,
        this.setRenderTarget = function(P, G=0, J=0) {
            E = P,
            C = G,
            w = J;
            let Q = !0
              , q = null
              , ye = !1
              , Ce = !1;
            if (P) {
                const Ie = X.get(P);
                if (Ie.__useDefaultFramebuffer !== void 0)
                    B.bindFramebuffer(I.FRAMEBUFFER, null),
                    Q = !1;
                else if (Ie.__webglFramebuffer === void 0)
                    ee.setupRenderTarget(P);
                else if (Ie.__hasExternalTextures)
                    ee.rebindTextures(P, X.get(P.texture).__webglTexture, X.get(P.depthTexture).__webglTexture);
                else if (P.depthBuffer) {
                    const Ne = P.depthTexture;
                    if (Ie.__boundDepthTexture !== Ne) {
                        if (Ne !== null && X.has(Ne) && (P.width !== Ne.image.width || P.height !== Ne.image.height))
                            throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                        ee.setupDepthRenderbuffer(P)
                    }
                }
                const Ve = P.texture;
                (Ve.isData3DTexture || Ve.isDataArrayTexture || Ve.isCompressedArrayTexture) && (Ce = !0);
                const We = X.get(P).__webglFramebuffer;
                P.isWebGLCubeRenderTarget ? (Array.isArray(We[G]) ? q = We[G][J] : q = We[G],
                ye = !0) : P.samples > 0 && ee.useMultisampledRTT(P) === !1 ? q = X.get(P).__webglMultisampledFramebuffer : Array.isArray(We) ? q = We[J] : q = We,
                b.copy(P.viewport),
                D.copy(P.scissor),
                F = P.scissorTest
            } else
                b.copy(xe).multiplyScalar(ie).floor(),
                D.copy(te).multiplyScalar(ie).floor(),
                F = Se;
            if (B.bindFramebuffer(I.FRAMEBUFFER, q) && Q && B.drawBuffers(P, q),
            B.viewport(b),
            B.scissor(D),
            B.setScissorTest(F),
            ye) {
                const Ie = X.get(P.texture);
                I.framebufferTexture2D(I.FRAMEBUFFER, I.COLOR_ATTACHMENT0, I.TEXTURE_CUBE_MAP_POSITIVE_X + G, Ie.__webglTexture, J)
            } else if (Ce) {
                const Ie = X.get(P.texture)
                  , Ve = G || 0;
                I.framebufferTextureLayer(I.FRAMEBUFFER, I.COLOR_ATTACHMENT0, Ie.__webglTexture, J || 0, Ve)
            }
            L = -1
        }
        ,
        this.readRenderTargetPixels = function(P, G, J, Q, q, ye, Ce) {
            if (!(P && P.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let Pe = X.get(P).__webglFramebuffer;
            if (P.isWebGLCubeRenderTarget && Ce !== void 0 && (Pe = Pe[Ce]),
            Pe) {
                B.bindFramebuffer(I.FRAMEBUFFER, Pe);
                try {
                    const Ie = P.texture
                      , Ve = Ie.format
                      , We = Ie.type;
                    if (!O.textureFormatReadable(Ve)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    if (!O.textureTypeReadable(We)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    G >= 0 && G <= P.width - Q && J >= 0 && J <= P.height - q && I.readPixels(G, J, Q, q, Ge.convert(Ve), Ge.convert(We), ye)
                } finally {
                    const Ie = E !== null ? X.get(E).__webglFramebuffer : null;
                    B.bindFramebuffer(I.FRAMEBUFFER, Ie)
                }
            }
        }
        ,
        this.readRenderTargetPixelsAsync = async function(P, G, J, Q, q, ye, Ce) {
            if (!(P && P.isWebGLRenderTarget))
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let Pe = X.get(P).__webglFramebuffer;
            if (P.isWebGLCubeRenderTarget && Ce !== void 0 && (Pe = Pe[Ce]),
            Pe) {
                B.bindFramebuffer(I.FRAMEBUFFER, Pe);
                try {
                    const Ie = P.texture
                      , Ve = Ie.format
                      , We = Ie.type;
                    if (!O.textureFormatReadable(Ve))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!O.textureTypeReadable(We))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    if (G >= 0 && G <= P.width - Q && J >= 0 && J <= P.height - q) {
                        const Ne = I.createBuffer();
                        I.bindBuffer(I.PIXEL_PACK_BUFFER, Ne),
                        I.bufferData(I.PIXEL_PACK_BUFFER, ye.byteLength, I.STREAM_READ),
                        I.readPixels(G, J, Q, q, Ge.convert(Ve), Ge.convert(We), 0),
                        I.flush();
                        const lt = I.fenceSync(I.SYNC_GPU_COMMANDS_COMPLETE, 0);
                        await UA(I, lt, 4);
                        try {
                            I.bindBuffer(I.PIXEL_PACK_BUFFER, Ne),
                            I.getBufferSubData(I.PIXEL_PACK_BUFFER, 0, ye)
                        } finally {
                            I.deleteBuffer(Ne),
                            I.deleteSync(lt)
                        }
                        return ye
                    }
                } finally {
                    const Ie = E !== null ? X.get(E).__webglFramebuffer : null;
                    B.bindFramebuffer(I.FRAMEBUFFER, Ie)
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(P, G=null, J=0) {
            P.isTexture !== !0 && (mo("WebGLRenderer: copyFramebufferToTexture function signature has changed."),
            G = arguments[0] || null,
            P = arguments[1]);
            const Q = Math.pow(2, -J)
              , q = Math.floor(P.image.width * Q)
              , ye = Math.floor(P.image.height * Q)
              , Ce = G !== null ? G.x : 0
              , Pe = G !== null ? G.y : 0;
            ee.setTexture2D(P, 0),
            I.copyTexSubImage2D(I.TEXTURE_2D, J, 0, 0, Ce, Pe, q, ye),
            B.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(P, G, J=null, Q=null, q=0) {
            P.isTexture !== !0 && (mo("WebGLRenderer: copyTextureToTexture function signature has changed."),
            Q = arguments[0] || null,
            P = arguments[1],
            G = arguments[2],
            q = arguments[3] || 0,
            J = null);
            let ye, Ce, Pe, Ie, Ve, We;
            J !== null ? (ye = J.max.x - J.min.x,
            Ce = J.max.y - J.min.y,
            Pe = J.min.x,
            Ie = J.min.y) : (ye = P.image.width,
            Ce = P.image.height,
            Pe = 0,
            Ie = 0),
            Q !== null ? (Ve = Q.x,
            We = Q.y) : (Ve = 0,
            We = 0);
            const Ne = Ge.convert(G.format)
              , lt = Ge.convert(G.type);
            ee.setTexture2D(G, 0),
            I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL, G.flipY),
            I.pixelStorei(I.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha),
            I.pixelStorei(I.UNPACK_ALIGNMENT, G.unpackAlignment);
            const Tt = I.getParameter(I.UNPACK_ROW_LENGTH)
              , Ct = I.getParameter(I.UNPACK_IMAGE_HEIGHT)
              , En = I.getParameter(I.UNPACK_SKIP_PIXELS)
              , ct = I.getParameter(I.UNPACK_SKIP_ROWS)
              , Ue = I.getParameter(I.UNPACK_SKIP_IMAGES)
              , Jt = P.isCompressedTexture ? P.mipmaps[q] : P.image;
            I.pixelStorei(I.UNPACK_ROW_LENGTH, Jt.width),
            I.pixelStorei(I.UNPACK_IMAGE_HEIGHT, Jt.height),
            I.pixelStorei(I.UNPACK_SKIP_PIXELS, Pe),
            I.pixelStorei(I.UNPACK_SKIP_ROWS, Ie),
            P.isDataTexture ? I.texSubImage2D(I.TEXTURE_2D, q, Ve, We, ye, Ce, Ne, lt, Jt.data) : P.isCompressedTexture ? I.compressedTexSubImage2D(I.TEXTURE_2D, q, Ve, We, Jt.width, Jt.height, Ne, Jt.data) : I.texSubImage2D(I.TEXTURE_2D, q, Ve, We, ye, Ce, Ne, lt, Jt),
            I.pixelStorei(I.UNPACK_ROW_LENGTH, Tt),
            I.pixelStorei(I.UNPACK_IMAGE_HEIGHT, Ct),
            I.pixelStorei(I.UNPACK_SKIP_PIXELS, En),
            I.pixelStorei(I.UNPACK_SKIP_ROWS, ct),
            I.pixelStorei(I.UNPACK_SKIP_IMAGES, Ue),
            q === 0 && G.generateMipmaps && I.generateMipmap(I.TEXTURE_2D),
            B.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(P, G, J=null, Q=null, q=0) {
            P.isTexture !== !0 && (mo("WebGLRenderer: copyTextureToTexture3D function signature has changed."),
            J = arguments[0] || null,
            Q = arguments[1] || null,
            P = arguments[2],
            G = arguments[3],
            q = arguments[4] || 0);
            let ye, Ce, Pe, Ie, Ve, We, Ne, lt, Tt;
            const Ct = P.isCompressedTexture ? P.mipmaps[q] : P.image;
            J !== null ? (ye = J.max.x - J.min.x,
            Ce = J.max.y - J.min.y,
            Pe = J.max.z - J.min.z,
            Ie = J.min.x,
            Ve = J.min.y,
            We = J.min.z) : (ye = Ct.width,
            Ce = Ct.height,
            Pe = Ct.depth,
            Ie = 0,
            Ve = 0,
            We = 0),
            Q !== null ? (Ne = Q.x,
            lt = Q.y,
            Tt = Q.z) : (Ne = 0,
            lt = 0,
            Tt = 0);
            const En = Ge.convert(G.format)
              , ct = Ge.convert(G.type);
            let Ue;
            if (G.isData3DTexture)
                ee.setTexture3D(G, 0),
                Ue = I.TEXTURE_3D;
            else if (G.isDataArrayTexture || G.isCompressedArrayTexture)
                ee.setTexture2DArray(G, 0),
                Ue = I.TEXTURE_2D_ARRAY;
            else {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                return
            }
            I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL, G.flipY),
            I.pixelStorei(I.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha),
            I.pixelStorei(I.UNPACK_ALIGNMENT, G.unpackAlignment);
            const Jt = I.getParameter(I.UNPACK_ROW_LENGTH)
              , ut = I.getParameter(I.UNPACK_IMAGE_HEIGHT)
              , Xn = I.getParameter(I.UNPACK_SKIP_PIXELS)
              , As = I.getParameter(I.UNPACK_SKIP_ROWS)
              , An = I.getParameter(I.UNPACK_SKIP_IMAGES);
            I.pixelStorei(I.UNPACK_ROW_LENGTH, Ct.width),
            I.pixelStorei(I.UNPACK_IMAGE_HEIGHT, Ct.height),
            I.pixelStorei(I.UNPACK_SKIP_PIXELS, Ie),
            I.pixelStorei(I.UNPACK_SKIP_ROWS, Ve),
            I.pixelStorei(I.UNPACK_SKIP_IMAGES, We),
            P.isDataTexture || P.isData3DTexture ? I.texSubImage3D(Ue, q, Ne, lt, Tt, ye, Ce, Pe, En, ct, Ct.data) : G.isCompressedArrayTexture ? I.compressedTexSubImage3D(Ue, q, Ne, lt, Tt, ye, Ce, Pe, En, Ct.data) : I.texSubImage3D(Ue, q, Ne, lt, Tt, ye, Ce, Pe, En, ct, Ct),
            I.pixelStorei(I.UNPACK_ROW_LENGTH, Jt),
            I.pixelStorei(I.UNPACK_IMAGE_HEIGHT, ut),
            I.pixelStorei(I.UNPACK_SKIP_PIXELS, Xn),
            I.pixelStorei(I.UNPACK_SKIP_ROWS, As),
            I.pixelStorei(I.UNPACK_SKIP_IMAGES, An),
            q === 0 && G.generateMipmaps && I.generateMipmap(Ue),
            B.unbindTexture()
        }
        ,
        this.initRenderTarget = function(P) {
            X.get(P).__webglFramebuffer === void 0 && ee.setupRenderTarget(P)
        }
        ,
        this.initTexture = function(P) {
            P.isCubeTexture ? ee.setTextureCube(P, 0) : P.isData3DTexture ? ee.setTexture3D(P, 0) : P.isDataArrayTexture || P.isCompressedArrayTexture ? ee.setTexture2DArray(P, 0) : ee.setTexture2D(P, 0),
            B.unbindTexture()
        }
        ,
        this.resetState = function() {
            C = 0,
            w = 0,
            E = null,
            B.reset(),
            Fe.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return mi
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = e === fh ? "display-p3" : "srgb",
        t.unpackColorSpace = st.workingColorSpace === vl ? "display-p3" : "srgb"
    }
}
class vh {
    constructor(e, t=25e-5) {
        this.isFogExp2 = !0,
        this.name = "",
        this.color = new Ee(e),
        this.density = t
    }
    clone() {
        return new vh(this.color,this.density)
    }
    toJSON() {
        return {
            type: "FogExp2",
            name: this.name,
            color: this.color.getHex(),
            density: this.density
        }
    }
}
class _h {
    constructor(e, t=1, i=1e3) {
        this.isFog = !0,
        this.name = "",
        this.color = new Ee(e),
        this.near = t,
        this.far = i
    }
    clone() {
        return new _h(this.color,this.near,this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            name: this.name,
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
class yh extends tt {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.backgroundRotation = new Un,
        this.environmentIntensity = 1,
        this.environmentRotation = new Un,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        this.backgroundRotation.copy(e.backgroundRotation),
        this.environmentIntensity = e.environmentIntensity,
        this.environmentRotation.copy(e.environmentRotation),
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t.object.backgroundRotation = this.backgroundRotation.toArray(),
        this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity),
        t.object.environmentRotation = this.environmentRotation.toArray(),
        t
    }
}
class xh {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = Ya,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.version = 0,
        this.uuid = Nn()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return mo("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, i) {
        e *= this.stride,
        i *= t.stride;
        for (let r = 0, s = this.stride; r < s; r++)
            this.array[e + r] = t.array[i + r];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Nn()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , i = new this.constructor(t,this.stride);
        return i.setUsage(this.usage),
        i
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Nn()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const un = new N;
class ys {
    constructor(e, t, i, r=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = i,
        this.normalized = r
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, i = this.data.count; t < i; t++)
            un.fromBufferAttribute(this, t),
            un.applyMatrix4(e),
            this.setXYZ(t, un.x, un.y, un.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++)
            un.fromBufferAttribute(this, t),
            un.applyNormalMatrix(e),
            this.setXYZ(t, un.x, un.y, un.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++)
            un.fromBufferAttribute(this, t),
            un.transformDirection(e),
            this.setXYZ(t, un.x, un.y, un.z);
        return this
    }
    getComponent(e, t) {
        let i = this.array[e * this.data.stride + this.offset + t];
        return this.normalized && (i = gn(i, this.array)),
        i
    }
    setComponent(e, t, i) {
        return this.normalized && (i = je(i, this.array)),
        this.data.array[e * this.data.stride + this.offset + t] = i,
        this
    }
    setX(e, t) {
        return this.normalized && (t = je(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = je(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = je(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = je(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = gn(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = gn(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = gn(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = gn(t, this.array)),
        t
    }
    setXY(e, t, i) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = je(t, this.array),
        i = je(i, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this
    }
    setXYZ(e, t, i, r) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = je(t, this.array),
        i = je(i, this.array),
        r = je(r, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this.data.array[e + 2] = r,
        this
    }
    setXYZW(e, t, i, r, s) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = je(t, this.array),
        i = je(i, this.array),
        r = je(r, this.array),
        s = je(s, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = i,
        this.data.array[e + 2] = r,
        this.data.array[e + 3] = s,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[r + s])
            }
            return new pt(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new ys(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
                const r = i * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++)
                    t.push(this.data.array[r + s])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
class Gp extends cn {
    constructor(e) {
        super(),
        this.isSpriteMaterial = !0,
        this.type = "SpriteMaterial",
        this.color = new Ee(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
let Ws;
const qo = new N
  , Xs = new N
  , qs = new N
  , $s = new ae
  , $o = new ae
  , Qx = new Be
  , sc = new N
  , Yo = new N
  , oc = new N
  , ov = new ae
  , Bf = new ae
  , av = new ae;
class eb extends tt {
    constructor(e=new Gp) {
        if (super(),
        this.isSprite = !0,
        this.type = "Sprite",
        Ws === void 0) {
            Ws = new Ze;
            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
              , i = new xh(t,5);
            Ws.setIndex([0, 1, 2, 0, 2, 3]),
            Ws.setAttribute("position", new ys(i,3,0,!1)),
            Ws.setAttribute("uv", new ys(i,2,3,!1))
        }
        this.geometry = Ws,
        this.material = e,
        this.center = new ae(.5,.5)
    }
    raycast(e, t) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
        Xs.setFromMatrixScale(this.matrixWorld),
        Qx.copy(e.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
        qs.setFromMatrixPosition(this.modelViewMatrix),
        e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Xs.multiplyScalar(-qs.z);
        const i = this.material.rotation;
        let r, s;
        i !== 0 && (s = Math.cos(i),
        r = Math.sin(i));
        const o = this.center;
        ac(sc.set(-.5, -.5, 0), qs, o, Xs, r, s),
        ac(Yo.set(.5, -.5, 0), qs, o, Xs, r, s),
        ac(oc.set(.5, .5, 0), qs, o, Xs, r, s),
        ov.set(0, 0),
        Bf.set(1, 0),
        av.set(1, 1);
        let a = e.ray.intersectTriangle(sc, Yo, oc, !1, qo);
        if (a === null && (ac(Yo.set(-.5, .5, 0), qs, o, Xs, r, s),
        Bf.set(0, 1),
        a = e.ray.intersectTriangle(sc, oc, Yo, !1, qo),
        a === null))
            return;
        const l = e.ray.origin.distanceTo(qo);
        l < e.near || l > e.far || t.push({
            distance: l,
            point: qo.clone(),
            uv: In.getInterpolation(qo, sc, Yo, oc, ov, Bf, av, new ae),
            face: null,
            object: this
        })
    }
    copy(e, t) {
        return super.copy(e, t),
        e.center !== void 0 && this.center.copy(e.center),
        this.material = e.material,
        this
    }
}
function ac(n, e, t, i, r, s) {
    $s.subVectors(n, t).addScalar(.5).multiply(i),
    r !== void 0 ? ($o.x = s * $s.x - r * $s.y,
    $o.y = r * $s.x + s * $s.y) : $o.copy($s),
    n.copy(e),
    n.x += $o.x,
    n.y += $o.y,
    n.applyMatrix4(Qx)
}
const lc = new N
  , lv = new N;
class tb extends tt {
    constructor() {
        super(),
        this._currentLevel = 0,
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            },
            isLOD: {
                value: !0
            }
        }),
        this.autoUpdate = !0
    }
    copy(e) {
        super.copy(e, !1);
        const t = e.levels;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            this.addLevel(s.object.clone(), s.distance, s.hysteresis)
        }
        return this.autoUpdate = e.autoUpdate,
        this
    }
    addLevel(e, t=0, i=0) {
        t = Math.abs(t);
        const r = this.levels;
        let s;
        for (s = 0; s < r.length && !(t < r[s].distance); s++)
            ;
        return r.splice(s, 0, {
            distance: t,
            hysteresis: i,
            object: e
        }),
        this.add(e),
        this
    }
    getCurrentLevel() {
        return this._currentLevel
    }
    getObjectForDistance(e) {
        const t = this.levels;
        if (t.length > 0) {
            let i, r;
            for (i = 1,
            r = t.length; i < r; i++) {
                let s = t[i].distance;
                if (t[i].object.visible && (s -= s * t[i].hysteresis),
                e < s)
                    break
            }
            return t[i - 1].object
        }
        return null
    }
    raycast(e, t) {
        if (this.levels.length > 0) {
            lc.setFromMatrixPosition(this.matrixWorld);
            const r = e.ray.origin.distanceTo(lc);
            this.getObjectForDistance(r).raycast(e, t)
        }
    }
    update(e) {
        const t = this.levels;
        if (t.length > 1) {
            lc.setFromMatrixPosition(e.matrixWorld),
            lv.setFromMatrixPosition(this.matrixWorld);
            const i = lc.distanceTo(lv) / e.zoom;
            t[0].object.visible = !0;
            let r, s;
            for (r = 1,
            s = t.length; r < s; r++) {
                let o = t[r].distance;
                if (t[r].object.visible && (o -= o * t[r].hysteresis),
                i >= o)
                    t[r - 1].object.visible = !1,
                    t[r].object.visible = !0;
                else
                    break
            }
            for (this._currentLevel = r - 1; r < s; r++)
                t[r].object.visible = !1
        }
    }
    toJSON(e) {
        const t = super.toJSON(e);
        this.autoUpdate === !1 && (t.object.autoUpdate = !1),
        t.object.levels = [];
        const i = this.levels;
        for (let r = 0, s = i.length; r < s; r++) {
            const o = i[r];
            t.object.levels.push({
                object: o.object.uuid,
                distance: o.distance,
                hysteresis: o.hysteresis
            })
        }
        return t
    }
}
const cv = new N
  , uv = new ft
  , hv = new ft
  , YP = new N
  , fv = new Be
  , cc = new N
  , zf = new an
  , dv = new Be
  , kf = new No;
class nb extends Ot {
    constructor(e, t) {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = Ed,
        this.bindMatrix = new Be,
        this.bindMatrixInverse = new Be,
        this.boundingBox = null,
        this.boundingSphere = null
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new yn),
        this.boundingBox.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++)
            this.getVertexPosition(i, cc),
            this.boundingBox.expandByPoint(cc)
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new an),
        this.boundingSphere.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++)
            this.getVertexPosition(i, cc),
            this.boundingSphere.expandByPoint(cc)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    raycast(e, t) {
        const i = this.material
          , r = this.matrixWorld;
        i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        zf.copy(this.boundingSphere),
        zf.applyMatrix4(r),
        e.ray.intersectsSphere(zf) !== !1 && (dv.copy(r).invert(),
        kf.copy(e.ray).applyMatrix4(dv),
        !(this.boundingBox !== null && kf.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, kf)))
    }
    getVertexPosition(e, t) {
        return super.getVertexPosition(e, t),
        this.applyBoneTransform(e, t),
        t
    }
    bind(e, t) {
        this.skeleton = e,
        t === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new ft
          , t = this.geometry.attributes.skinWeight;
        for (let i = 0, r = t.count; i < r; i++) {
            e.fromBufferAttribute(t, i);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
            t.setXYZW(i, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === Ed ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === Sx ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(e, t) {
        const i = this.skeleton
          , r = this.geometry;
        uv.fromBufferAttribute(r.attributes.skinIndex, e),
        hv.fromBufferAttribute(r.attributes.skinWeight, e),
        cv.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = hv.getComponent(s);
            if (o !== 0) {
                const a = uv.getComponent(s);
                fv.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
                t.addScaledVector(YP.copy(cv).applyMatrix4(fv), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class Wp extends tt {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class _i extends Dt {
    constructor(e=null, t=1, i=1, r, s, o, a, l, c=Kt, u=Kt, h, f) {
        super(null, o, a, l, c, u, r, s, h, f),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: i
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const pv = new Be
  , jP = new Be;
class bh {
    constructor(e=[], t=[]) {
        this.uuid = Nn(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.init()
    }
    init() {
        const e = this.bones
          , t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16),
        t.length === 0)
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let i = 0, r = this.bones.length; i < r; i++)
                this.boneInverses.push(new Be)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = new Be;
            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(i)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && i.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld),
            i.matrix.decompose(i.position, i.quaternion, i.scale))
        }
    }
    update() {
        const e = this.bones
          , t = this.boneInverses
          , i = this.boneMatrices
          , r = this.boneTexture;
        for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : jP;
            pv.multiplyMatrices(a, t[s]),
            pv.toArray(i, s * 16)
        }
        r !== null && (r.needsUpdate = !0)
    }
    clone() {
        return new bh(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const i = new _i(t,e,e,vn,Mn);
        return i.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = i,
        this
    }
    getBoneByName(e) {
        for (let t = 0, i = this.bones.length; t < i; t++) {
            const r = this.bones[t];
            if (r.name === e)
                return r
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let i = 0, r = e.bones.length; i < r; i++) {
            const s = e.bones[i];
            let o = t[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s),
            o = new Wp),
            this.bones.push(o),
            this.boneInverses.push(new Be().fromArray(e.boneInverses[i]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones
          , i = this.boneInverses;
        for (let r = 0, s = t.length; r < s; r++) {
            const o = t[r];
            e.bones.push(o.uuid);
            const a = i[r];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class wo extends pt {
    constructor(e, t, i, r=1) {
        super(e, t, i),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = r
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const Ys = new Be
  , mv = new Be
  , uc = []
  , gv = new yn
  , KP = new Be
  , jo = new Ot
  , Ko = new an;
class ib extends Ot {
    constructor(e, t, i) {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new wo(new Float32Array(i * 16),16),
        this.instanceColor = null,
        this.morphTexture = null,
        this.count = i,
        this.boundingBox = null,
        this.boundingSphere = null;
        for (let r = 0; r < i; r++)
            this.setMatrixAt(r, KP)
    }
    computeBoundingBox() {
        const e = this.geometry
          , t = this.count;
        this.boundingBox === null && (this.boundingBox = new yn),
        e.boundingBox === null && e.computeBoundingBox(),
        this.boundingBox.makeEmpty();
        for (let i = 0; i < t; i++)
            this.getMatrixAt(i, Ys),
            gv.copy(e.boundingBox).applyMatrix4(Ys),
            this.boundingBox.union(gv)
    }
    computeBoundingSphere() {
        const e = this.geometry
          , t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new an),
        e.boundingSphere === null && e.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
        for (let i = 0; i < t; i++)
            this.getMatrixAt(i, Ys),
            Ko.copy(e.boundingSphere).applyMatrix4(Ys),
            this.boundingSphere.union(Ko)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    getMorphAt(e, t) {
        const i = t.morphTargetInfluences
          , r = this.morphTexture.source.data.data
          , s = i.length + 1
          , o = e * s + 1;
        for (let a = 0; a < i.length; a++)
            i[a] = r[o + a]
    }
    raycast(e, t) {
        const i = this.matrixWorld
          , r = this.count;
        if (jo.geometry = this.geometry,
        jo.material = this.material,
        jo.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        Ko.copy(this.boundingSphere),
        Ko.applyMatrix4(i),
        e.ray.intersectsSphere(Ko) !== !1))
            for (let s = 0; s < r; s++) {
                this.getMatrixAt(s, Ys),
                mv.multiplyMatrices(i, Ys),
                jo.matrixWorld = mv,
                jo.raycast(e, uc);
                for (let o = 0, a = uc.length; o < a; o++) {
                    const l = uc[o];
                    l.instanceId = s,
                    l.object = this,
                    t.push(l)
                }
                uc.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new wo(new Float32Array(this.instanceMatrix.count * 3).fill(1),3)),
        t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    setMorphAt(e, t) {
        const i = t.morphTargetInfluences
          , r = i.length + 1;
        this.morphTexture === null && (this.morphTexture = new _i(new Float32Array(r * this.count),r,this.count,lh,Mn));
        const s = this.morphTexture.source.data.data;
        let o = 0;
        for (let c = 0; c < i.length; c++)
            o += i[c];
        const a = this.geometry.morphTargetsRelative ? 1 : 1 - o
          , l = r * e;
        s[l] = a,
        s.set(i, l + 1)
    }
    updateMorphTargets() {}
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }),
        this.morphTexture !== null && (this.morphTexture.dispose(),
        this.morphTexture = null),
        this
    }
}
function ZP(n, e) {
    return n.z - e.z
}
function JP(n, e) {
    return e.z - n.z
}
class QP {
    constructor() {
        this.index = 0,
        this.pool = [],
        this.list = []
    }
    push(e, t, i) {
        const r = this.pool
          , s = this.list;
        this.index >= r.length && r.push({
            start: -1,
            count: -1,
            z: -1,
            index: -1
        });
        const o = r[this.index];
        s.push(o),
        this.index++,
        o.start = e.start,
        o.count = e.count,
        o.z = t,
        o.index = i
    }
    reset() {
        this.list.length = 0,
        this.index = 0
    }
}
const cr = new Be
  , Vf = new Be
  , eI = new Be
  , tI = new Ee(1,1,1)
  , vv = new Be
  , Hf = new xl
  , hc = new yn
  , Gr = new an
  , Zo = new N
  , _v = new N
  , nI = new N
  , Gf = new QP
  , nn = new Ot
  , fc = [];
function iI(n, e, t=0) {
    const i = e.itemSize;
    if (n.isInterleavedBufferAttribute || n.array.constructor !== e.array.constructor) {
        const r = n.count;
        for (let s = 0; s < r; s++)
            for (let o = 0; o < i; o++)
                e.setComponent(s + t, o, n.getComponent(s, o))
    } else
        e.array.set(n.array, t * i);
    e.needsUpdate = !0
}
class rb extends Ot {
    get maxInstanceCount() {
        return this._maxInstanceCount
    }
    constructor(e, t, i=t * 2, r) {
        super(new Ze, r),
        this.isBatchedMesh = !0,
        this.perObjectFrustumCulled = !0,
        this.sortObjects = !0,
        this.boundingBox = null,
        this.boundingSphere = null,
        this.customSort = null,
        this._drawInfo = [],
        this._drawRanges = [],
        this._reservedRanges = [],
        this._bounds = [],
        this._maxInstanceCount = e,
        this._maxVertexCount = t,
        this._maxIndexCount = i,
        this._geometryInitialized = !1,
        this._geometryCount = 0,
        this._multiDrawCounts = new Int32Array(e),
        this._multiDrawStarts = new Int32Array(e),
        this._multiDrawCount = 0,
        this._multiDrawInstances = null,
        this._visibilityChanged = !0,
        this._matricesTexture = null,
        this._indirectTexture = null,
        this._colorsTexture = null,
        this._initMatricesTexture(),
        this._initIndirectTexture()
    }
    _initMatricesTexture() {
        let e = Math.sqrt(this._maxInstanceCount * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4)
          , i = new _i(t,e,e,vn,Mn);
        this._matricesTexture = i
    }
    _initIndirectTexture() {
        let e = Math.sqrt(this._maxInstanceCount);
        e = Math.ceil(e);
        const t = new Uint32Array(e * e)
          , i = new _i(t,e,e,gl,qi);
        this._indirectTexture = i
    }
    _initColorsTexture() {
        let e = Math.sqrt(this._maxInstanceCount);
        e = Math.ceil(e);
        const t = new Float32Array(e * e * 4).fill(1)
          , i = new _i(t,e,e,vn,Mn);
        i.colorSpace = st.workingColorSpace,
        this._colorsTexture = i
    }
    _initializeGeometry(e) {
        const t = this.geometry
          , i = this._maxVertexCount
          , r = this._maxIndexCount;
        if (this._geometryInitialized === !1) {
            for (const s in e.attributes) {
                const o = e.getAttribute(s)
                  , {array: a, itemSize: l, normalized: c} = o
                  , u = new a.constructor(i * l)
                  , h = new pt(u,l,c);
                t.setAttribute(s, h)
            }
            if (e.getIndex() !== null) {
                const s = i > 65535 ? new Uint32Array(r) : new Uint16Array(r);
                t.setIndex(new pt(s,1))
            }
            this._geometryInitialized = !0
        }
    }
    _validateGeometry(e) {
        const t = this.geometry;
        if (!!e.getIndex() != !!t.getIndex())
            throw new Error('BatchedMesh: All geometries must consistently have "index".');
        for (const i in t.attributes) {
            if (!e.hasAttribute(i))
                throw new Error(`BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`);
            const r = e.getAttribute(i)
              , s = t.getAttribute(i);
            if (r.itemSize !== s.itemSize || r.normalized !== s.normalized)
                throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
        }
    }
    setCustomSort(e) {
        return this.customSort = e,
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new yn);
        const e = this.boundingBox
          , t = this._drawInfo;
        e.makeEmpty();
        for (let i = 0, r = t.length; i < r; i++) {
            if (t[i].active === !1)
                continue;
            const s = t[i].geometryIndex;
            this.getMatrixAt(i, cr),
            this.getBoundingBoxAt(s, hc).applyMatrix4(cr),
            e.union(hc)
        }
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new an);
        const e = this.boundingSphere
          , t = this._drawInfo;
        e.makeEmpty();
        for (let i = 0, r = t.length; i < r; i++) {
            if (t[i].active === !1)
                continue;
            const s = t[i].geometryIndex;
            this.getMatrixAt(i, cr),
            this.getBoundingSphereAt(s, Gr).applyMatrix4(cr),
            e.union(Gr)
        }
    }
    addInstance(e) {
        if (this._drawInfo.length >= this._maxInstanceCount)
            throw new Error("BatchedMesh: Maximum item count reached.");
        this._drawInfo.push({
            visible: !0,
            active: !0,
            geometryIndex: e
        });
        const t = this._drawInfo.length - 1
          , i = this._matricesTexture
          , r = i.image.data;
        eI.toArray(r, t * 16),
        i.needsUpdate = !0;
        const s = this._colorsTexture;
        return s && (tI.toArray(s.image.data, t * 4),
        s.needsUpdate = !0),
        t
    }
    addGeometry(e, t=-1, i=-1) {
        if (this._initializeGeometry(e),
        this._validateGeometry(e),
        this._drawInfo.length >= this._maxInstanceCount)
            throw new Error("BatchedMesh: Maximum item count reached.");
        const r = {
            vertexStart: -1,
            vertexCount: -1,
            indexStart: -1,
            indexCount: -1
        };
        let s = null;
        const o = this._reservedRanges
          , a = this._drawRanges
          , l = this._bounds;
        this._geometryCount !== 0 && (s = o[o.length - 1]),
        t === -1 ? r.vertexCount = e.getAttribute("position").count : r.vertexCount = t,
        s === null ? r.vertexStart = 0 : r.vertexStart = s.vertexStart + s.vertexCount;
        const c = e.getIndex()
          , u = c !== null;
        if (u && (i === -1 ? r.indexCount = c.count : r.indexCount = i,
        s === null ? r.indexStart = 0 : r.indexStart = s.indexStart + s.indexCount),
        r.indexStart !== -1 && r.indexStart + r.indexCount > this._maxIndexCount || r.vertexStart + r.vertexCount > this._maxVertexCount)
            throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
        const h = this._geometryCount;
        return this._geometryCount++,
        o.push(r),
        a.push({
            start: u ? r.indexStart : r.vertexStart,
            count: -1
        }),
        l.push({
            boxInitialized: !1,
            box: new yn,
            sphereInitialized: !1,
            sphere: new an
        }),
        this.setGeometryAt(h, e),
        h
    }
    setGeometryAt(e, t) {
        if (e >= this._geometryCount)
            throw new Error("BatchedMesh: Maximum geometry count reached.");
        this._validateGeometry(t);
        const i = this.geometry
          , r = i.getIndex() !== null
          , s = i.getIndex()
          , o = t.getIndex()
          , a = this._reservedRanges[e];
        if (r && o.count > a.indexCount || t.attributes.position.count > a.vertexCount)
            throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
        const l = a.vertexStart
          , c = a.vertexCount;
        for (const d in i.attributes) {
            const p = t.getAttribute(d)
              , v = i.getAttribute(d);
            iI(p, v, l);
            const g = p.itemSize;
            for (let m = p.count, y = c; m < y; m++) {
                const _ = l + m;
                for (let x = 0; x < g; x++)
                    v.setComponent(_, x, 0)
            }
            v.needsUpdate = !0,
            v.addUpdateRange(l * g, c * g)
        }
        if (r) {
            const d = a.indexStart;
            for (let p = 0; p < o.count; p++)
                s.setX(d + p, l + o.getX(p));
            for (let p = o.count, v = a.indexCount; p < v; p++)
                s.setX(d + p, l);
            s.needsUpdate = !0,
            s.addUpdateRange(d, a.indexCount)
        }
        const u = this._bounds[e];
        t.boundingBox !== null ? (u.box.copy(t.boundingBox),
        u.boxInitialized = !0) : u.boxInitialized = !1,
        t.boundingSphere !== null ? (u.sphere.copy(t.boundingSphere),
        u.sphereInitialized = !0) : u.sphereInitialized = !1;
        const h = this._drawRanges[e]
          , f = t.getAttribute("position");
        return h.count = r ? o.count : f.count,
        this._visibilityChanged = !0,
        e
    }
    getBoundingBoxAt(e, t) {
        if (e >= this._geometryCount)
            return null;
        const i = this._bounds[e]
          , r = i.box
          , s = this.geometry;
        if (i.boxInitialized === !1) {
            r.makeEmpty();
            const o = s.index
              , a = s.attributes.position
              , l = this._drawRanges[e];
            for (let c = l.start, u = l.start + l.count; c < u; c++) {
                let h = c;
                o && (h = o.getX(h)),
                r.expandByPoint(Zo.fromBufferAttribute(a, h))
            }
            i.boxInitialized = !0
        }
        return t.copy(r),
        t
    }
    getBoundingSphereAt(e, t) {
        if (e >= this._geometryCount)
            return null;
        const i = this._bounds[e]
          , r = i.sphere
          , s = this.geometry;
        if (i.sphereInitialized === !1) {
            r.makeEmpty(),
            this.getBoundingBoxAt(e, hc),
            hc.getCenter(r.center);
            const o = s.index
              , a = s.attributes.position
              , l = this._drawRanges[e];
            let c = 0;
            for (let u = l.start, h = l.start + l.count; u < h; u++) {
                let f = u;
                o && (f = o.getX(f)),
                Zo.fromBufferAttribute(a, f),
                c = Math.max(c, r.center.distanceToSquared(Zo))
            }
            r.radius = Math.sqrt(c),
            i.sphereInitialized = !0
        }
        return t.copy(r),
        t
    }
    setMatrixAt(e, t) {
        const i = this._drawInfo
          , r = this._matricesTexture
          , s = this._matricesTexture.image.data;
        return e >= i.length || i[e].active === !1 ? this : (t.toArray(s, e * 16),
        r.needsUpdate = !0,
        this)
    }
    getMatrixAt(e, t) {
        const i = this._drawInfo
          , r = this._matricesTexture.image.data;
        return e >= i.length || i[e].active === !1 ? null : t.fromArray(r, e * 16)
    }
    setColorAt(e, t) {
        this._colorsTexture === null && this._initColorsTexture();
        const i = this._colorsTexture
          , r = this._colorsTexture.image.data
          , s = this._drawInfo;
        return e >= s.length || s[e].active === !1 ? this : (t.toArray(r, e * 4),
        i.needsUpdate = !0,
        this)
    }
    getColorAt(e, t) {
        const i = this._colorsTexture.image.data
          , r = this._drawInfo;
        return e >= r.length || r[e].active === !1 ? null : t.fromArray(i, e * 4)
    }
    setVisibleAt(e, t) {
        const i = this._drawInfo;
        return e >= i.length || i[e].active === !1 || i[e].visible === t ? this : (i[e].visible = t,
        this._visibilityChanged = !0,
        this)
    }
    getVisibleAt(e) {
        const t = this._drawInfo;
        return e >= t.length || t[e].active === !1 ? !1 : t[e].visible
    }
    raycast(e, t) {
        const i = this._drawInfo
          , r = this._drawRanges
          , s = this.matrixWorld
          , o = this.geometry;
        nn.material = this.material,
        nn.geometry.index = o.index,
        nn.geometry.attributes = o.attributes,
        nn.geometry.boundingBox === null && (nn.geometry.boundingBox = new yn),
        nn.geometry.boundingSphere === null && (nn.geometry.boundingSphere = new an);
        for (let a = 0, l = i.length; a < l; a++) {
            if (!i[a].visible || !i[a].active)
                continue;
            const c = i[a].geometryIndex
              , u = r[c];
            nn.geometry.setDrawRange(u.start, u.count),
            this.getMatrixAt(a, nn.matrixWorld).premultiply(s),
            this.getBoundingBoxAt(c, nn.geometry.boundingBox),
            this.getBoundingSphereAt(c, nn.geometry.boundingSphere),
            nn.raycast(e, fc);
            for (let h = 0, f = fc.length; h < f; h++) {
                const d = fc[h];
                d.object = this,
                d.batchId = a,
                t.push(d)
            }
            fc.length = 0
        }
        nn.material = null,
        nn.geometry.index = null,
        nn.geometry.attributes = {},
        nn.geometry.setDrawRange(0, 1 / 0)
    }
    copy(e) {
        return super.copy(e),
        this.geometry = e.geometry.clone(),
        this.perObjectFrustumCulled = e.perObjectFrustumCulled,
        this.sortObjects = e.sortObjects,
        this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null,
        this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null,
        this._drawRanges = e._drawRanges.map(t => ({
            ...t
        })),
        this._reservedRanges = e._reservedRanges.map(t => ({
            ...t
        })),
        this._drawInfo = e._drawInfo.map(t => ({
            ...t
        })),
        this._bounds = e._bounds.map(t => ({
            boxInitialized: t.boxInitialized,
            box: t.box.clone(),
            sphereInitialized: t.sphereInitialized,
            sphere: t.sphere.clone()
        })),
        this._maxInstanceCount = e._maxInstanceCount,
        this._maxVertexCount = e._maxVertexCount,
        this._maxIndexCount = e._maxIndexCount,
        this._geometryInitialized = e._geometryInitialized,
        this._geometryCount = e._geometryCount,
        this._multiDrawCounts = e._multiDrawCounts.slice(),
        this._multiDrawStarts = e._multiDrawStarts.slice(),
        this._matricesTexture = e._matricesTexture.clone(),
        this._matricesTexture.image.data = this._matricesTexture.image.data.slice(),
        this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(),
        this._colorsTexture.image.data = this._colorsTexture.image.data.slice()),
        this
    }
    dispose() {
        return this.geometry.dispose(),
        this._matricesTexture.dispose(),
        this._matricesTexture = null,
        this._indirectTexture.dispose(),
        this._indirectTexture = null,
        this._colorsTexture !== null && (this._colorsTexture.dispose(),
        this._colorsTexture = null),
        this
    }
    onBeforeRender(e, t, i, r, s) {
        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
            return;
        const o = r.getIndex()
          , a = o === null ? 1 : o.array.BYTES_PER_ELEMENT
          , l = this._drawInfo
          , c = this._multiDrawStarts
          , u = this._multiDrawCounts
          , h = this._drawRanges
          , f = this.perObjectFrustumCulled
          , d = this._indirectTexture
          , p = d.image.data;
        f && (vv.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse).multiply(this.matrixWorld),
        Hf.setFromProjectionMatrix(vv, e.coordinateSystem));
        let v = 0;
        if (this.sortObjects) {
            Vf.copy(this.matrixWorld).invert(),
            Zo.setFromMatrixPosition(i.matrixWorld).applyMatrix4(Vf),
            _v.set(0, 0, -1).transformDirection(i.matrixWorld).transformDirection(Vf);
            for (let y = 0, _ = l.length; y < _; y++)
                if (l[y].visible && l[y].active) {
                    const x = l[y].geometryIndex;
                    this.getMatrixAt(y, cr),
                    this.getBoundingSphereAt(x, Gr).applyMatrix4(cr);
                    let C = !1;
                    if (f && (C = !Hf.intersectsSphere(Gr)),
                    !C) {
                        const w = nI.subVectors(Gr.center, Zo).dot(_v);
                        Gf.push(h[x], w, y)
                    }
                }
            const g = Gf.list
              , m = this.customSort;
            m === null ? g.sort(s.transparent ? JP : ZP) : m.call(this, g, i);
            for (let y = 0, _ = g.length; y < _; y++) {
                const x = g[y];
                c[v] = x.start * a,
                u[v] = x.count,
                p[v] = x.index,
                v++
            }
            Gf.reset()
        } else
            for (let g = 0, m = l.length; g < m; g++)
                if (l[g].visible && l[g].active) {
                    const y = l[g].geometryIndex;
                    let _ = !1;
                    if (f && (this.getMatrixAt(g, cr),
                    this.getBoundingSphereAt(y, Gr).applyMatrix4(cr),
                    _ = !Hf.intersectsSphere(Gr)),
                    !_) {
                        const x = h[y];
                        c[v] = x.start * a,
                        u[v] = x.count,
                        p[v] = g,
                        v++
                    }
                }
        d.needsUpdate = !0,
        this._multiDrawCount = v,
        this._visibilityChanged = !1
    }
    onBeforeShadow(e, t, i, r, s, o) {
        this.onBeforeRender(e, null, r, s, o)
    }
}
class xn extends cn {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new Ee(16777215),
        this.map = null,
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const Lu = new N
  , Du = new N
  , yv = new Be
  , Jo = new No
  , dc = new an
  , Wf = new N
  , xv = new N;
class Ar extends tt {
    constructor(e=new Ze, t=new xn) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , i = [0];
            for (let r = 1, s = t.count; r < s; r++)
                Lu.fromBufferAttribute(t, r - 1),
                Du.fromBufferAttribute(t, r),
                i[r] = i[r - 1],
                i[r] += Lu.distanceTo(Du);
            e.setAttribute("lineDistance", new Le(i,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.matrixWorld
          , s = e.params.Line.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        dc.copy(i.boundingSphere),
        dc.applyMatrix4(r),
        dc.radius += s,
        e.ray.intersectsSphere(dc) === !1)
            return;
        yv.copy(r).invert(),
        Jo.copy(e.ray).applyMatrix4(yv);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , c = this.isLineSegments ? 2 : 1
          , u = i.index
          , f = i.attributes.position;
        if (u !== null) {
            const d = Math.max(0, o.start)
              , p = Math.min(u.count, o.start + o.count);
            for (let v = d, g = p - 1; v < g; v += c) {
                const m = u.getX(v)
                  , y = u.getX(v + 1)
                  , _ = pc(this, e, Jo, l, m, y);
                _ && t.push(_)
            }
            if (this.isLineLoop) {
                const v = u.getX(p - 1)
                  , g = u.getX(d)
                  , m = pc(this, e, Jo, l, v, g);
                m && t.push(m)
            }
        } else {
            const d = Math.max(0, o.start)
              , p = Math.min(f.count, o.start + o.count);
            for (let v = d, g = p - 1; v < g; v += c) {
                const m = pc(this, e, Jo, l, v, v + 1);
                m && t.push(m)
            }
            if (this.isLineLoop) {
                const v = pc(this, e, Jo, l, p - 1, d);
                v && t.push(v)
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
function pc(n, e, t, i, r, s) {
    const o = n.geometry.attributes.position;
    if (Lu.fromBufferAttribute(o, r),
    Du.fromBufferAttribute(o, s),
    t.distanceSqToSegment(Lu, Du, Wf, xv) > i)
        return;
    Wf.applyMatrix4(n.matrixWorld);
    const l = e.ray.origin.distanceTo(Wf);
    if (!(l < e.near || l > e.far))
        return {
            distance: l,
            point: xv.clone().applyMatrix4(n.matrixWorld),
            index: r,
            face: null,
            faceIndex: null,
            object: n
        }
}
const bv = new N
  , Mv = new N;
class wi extends Ar {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , i = [];
            for (let r = 0, s = t.count; r < s; r += 2)
                bv.fromBufferAttribute(t, r),
                Mv.fromBufferAttribute(t, r + 1),
                i[r] = r === 0 ? 0 : i[r - 1],
                i[r + 1] = i[r] + bv.distanceTo(Mv);
            e.setAttribute("lineDistance", new Le(i,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class sb extends Ar {
    constructor(e, t) {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class Xp extends cn {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new Ee(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const Sv = new Be
  , Id = new No
  , mc = new an
  , gc = new N;
class ob extends tt {
    constructor(e=new Ze, t=new Xp) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const i = this.geometry
          , r = this.matrixWorld
          , s = e.params.Points.threshold
          , o = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(),
        mc.copy(i.boundingSphere),
        mc.applyMatrix4(r),
        mc.radius += s,
        e.ray.intersectsSphere(mc) === !1)
            return;
        Sv.copy(r).invert(),
        Id.copy(e.ray).applyMatrix4(Sv);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , c = i.index
          , h = i.attributes.position;
        if (c !== null) {
            const f = Math.max(0, o.start)
              , d = Math.min(c.count, o.start + o.count);
            for (let p = f, v = d; p < v; p++) {
                const g = c.getX(p);
                gc.fromBufferAttribute(h, g),
                wv(gc, g, l, r, e, t, this)
            }
        } else {
            const f = Math.max(0, o.start)
              , d = Math.min(h.count, o.start + o.count);
            for (let p = f, v = d; p < v; p++)
                gc.fromBufferAttribute(h, p),
                wv(gc, p, l, r, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , i = Object.keys(t);
        if (i.length > 0) {
            const r = t[i[0]];
            if (r !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let s = 0, o = r.length; s < o; s++) {
                    const a = r[s].name || String(s);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}
function wv(n, e, t, i, r, s, o) {
    const a = Id.distanceSqToPoint(n);
    if (a < t) {
        const l = new N;
        Id.closestPointToPoint(n, l),
        l.applyMatrix4(i);
        const c = r.ray.origin.distanceTo(l);
        if (c < r.near || c > r.far)
            return;
        s.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o
        })
    }
}
class rI extends Dt {
    constructor(e, t, i, r, s, o, a, l, c) {
        super(e, t, i, r, s, o, a, l, c),
        this.isVideoTexture = !0,
        this.minFilter = o !== void 0 ? o : Gt,
        this.magFilter = s !== void 0 ? s : Gt,
        this.generateMipmaps = !1;
        const u = this;
        function h() {
            u.needsUpdate = !0,
            e.requestVideoFrameCallback(h)
        }
        "requestVideoFrameCallback"in e && e.requestVideoFrameCallback(h)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback"in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class sI extends Dt {
    constructor(e, t) {
        super({
            width: e,
            height: t
        }),
        this.isFramebufferTexture = !0,
        this.magFilter = Kt,
        this.minFilter = Kt,
        this.generateMipmaps = !1,
        this.needsUpdate = !0
    }
}
class Mh extends Dt {
    constructor(e, t, i, r, s, o, a, l, c, u, h, f) {
        super(null, o, a, l, c, u, r, s, h, f),
        this.isCompressedTexture = !0,
        this.image = {
            width: t,
            height: i
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class oI extends Mh {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, s, o),
        this.isCompressedArrayTexture = !0,
        this.image.depth = r,
        this.wrapR = Gn,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class aI extends Mh {
    constructor(e, t, i) {
        super(void 0, e[0].width, e[0].height, t, i, Xi),
        this.isCompressedCubeTexture = !0,
        this.isCubeTexture = !0,
        this.image = e
    }
}
class lI extends Dt {
    constructor(e, t, i, r, s, o, a, l, c) {
        super(e, t, i, r, s, o, a, l, c),
        this.isCanvasTexture = !0,
        this.needsUpdate = !0
    }
}
class li {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getPoint(i, t)
    }
    getPoints(e=5) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPoint(i / e));
        return t
    }
    getSpacedPoints(e=5) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPointAt(i / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let i, r = this.getPoint(0), s = 0;
        t.push(0);
        for (let o = 1; o <= e; o++)
            i = this.getPoint(o / e),
            s += i.distanceTo(r),
            t.push(s),
            r = i;
        return this.cacheArcLengths = t,
        t
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, t) {
        const i = this.getLengths();
        let r = 0;
        const s = i.length;
        let o;
        t ? o = t : o = e * i[s - 1];
        let a = 0, l = s - 1, c;
        for (; a <= l; )
            if (r = Math.floor(a + (l - a) / 2),
            c = i[r] - o,
            c < 0)
                a = r + 1;
            else if (c > 0)
                l = r - 1;
            else {
                l = r;
                break
            }
        if (r = l,
        i[r] === o)
            return r / (s - 1);
        const u = i[r]
          , f = i[r + 1] - u
          , d = (o - u) / f;
        return (r + d) / (s - 1)
    }
    getTangent(e, t) {
        let r = e - 1e-4
          , s = e + 1e-4;
        r < 0 && (r = 0),
        s > 1 && (s = 1);
        const o = this.getPoint(r)
          , a = this.getPoint(s)
          , l = t || (o.isVector2 ? new ae : new N);
        return l.copy(a).sub(o).normalize(),
        l
    }
    getTangentAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getTangent(i, t)
    }
    computeFrenetFrames(e, t) {
        const i = new N
          , r = []
          , s = []
          , o = []
          , a = new N
          , l = new Be;
        for (let d = 0; d <= e; d++) {
            const p = d / e;
            r[d] = this.getTangentAt(p, new N)
        }
        s[0] = new N,
        o[0] = new N;
        let c = Number.MAX_VALUE;
        const u = Math.abs(r[0].x)
          , h = Math.abs(r[0].y)
          , f = Math.abs(r[0].z);
        u <= c && (c = u,
        i.set(1, 0, 0)),
        h <= c && (c = h,
        i.set(0, 1, 0)),
        f <= c && i.set(0, 0, 1),
        a.crossVectors(r[0], i).normalize(),
        s[0].crossVectors(r[0], a),
        o[0].crossVectors(r[0], s[0]);
        for (let d = 1; d <= e; d++) {
            if (s[d] = s[d - 1].clone(),
            o[d] = o[d - 1].clone(),
            a.crossVectors(r[d - 1], r[d]),
            a.length() > Number.EPSILON) {
                a.normalize();
                const p = Math.acos(It(r[d - 1].dot(r[d]), -1, 1));
                s[d].applyMatrix4(l.makeRotationAxis(a, p))
            }
            o[d].crossVectors(r[d], s[d])
        }
        if (t === !0) {
            let d = Math.acos(It(s[0].dot(s[e]), -1, 1));
            d /= e,
            r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (d = -d);
            for (let p = 1; p <= e; p++)
                s[p].applyMatrix4(l.makeRotationAxis(r[p], d * p)),
                o[p].crossVectors(r[p], s[p])
        }
        return {
            tangents: r,
            normals: s,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
class Sh extends li {
    constructor(e=0, t=0, i=1, r=1, s=0, o=Math.PI * 2, a=!1, l=0) {
        super(),
        this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = t,
        this.xRadius = i,
        this.yRadius = r,
        this.aStartAngle = s,
        this.aEndAngle = o,
        this.aClockwise = a,
        this.aRotation = l
    }
    getPoint(e, t=new ae) {
        const i = t
          , r = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(s) < Number.EPSILON;
        for (; s < 0; )
            s += r;
        for (; s > r; )
            s -= r;
        s < Number.EPSILON && (o ? s = 0 : s = r),
        this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r);
        const a = this.aStartAngle + e * s;
        let l = this.aX + this.xRadius * Math.cos(a)
          , c = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const u = Math.cos(this.aRotation)
              , h = Math.sin(this.aRotation)
              , f = l - this.aX
              , d = c - this.aY;
            l = f * u - d * h + this.aX,
            c = f * h + d * u + this.aY
        }
        return i.set(l, c)
    }
    copy(e) {
        return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
}
class ab extends Sh {
    constructor(e, t, i, r, s, o) {
        super(e, t, i, i, r, s, o),
        this.isArcCurve = !0,
        this.type = "ArcCurve"
    }
}
function qp() {
    let n = 0
      , e = 0
      , t = 0
      , i = 0;
    function r(s, o, a, l) {
        n = s,
        e = a,
        t = -3 * s + 3 * o - 2 * a - l,
        i = 2 * s - 2 * o + a + l
    }
    return {
        initCatmullRom: function(s, o, a, l, c) {
            r(o, a, c * (a - s), c * (l - o))
        },
        initNonuniformCatmullRom: function(s, o, a, l, c, u, h) {
            let f = (o - s) / c - (a - s) / (c + u) + (a - o) / u
              , d = (a - o) / u - (l - o) / (u + h) + (l - a) / h;
            f *= u,
            d *= u,
            r(o, a, f, d)
        },
        calc: function(s) {
            const o = s * s
              , a = o * s;
            return n + e * s + t * o + i * a
        }
    }
}
const vc = new N
  , Xf = new qp
  , qf = new qp
  , $f = new qp;
class lb extends li {
    constructor(e=[], t=!1, i="centripetal", r=.5) {
        super(),
        this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = t,
        this.curveType = i,
        this.tension = r
    }
    getPoint(e, t=new N) {
        const i = t
          , r = this.points
          , s = r.length
          , o = (s - (this.closed ? 0 : 1)) * e;
        let a = Math.floor(o)
          , l = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2,
        l = 1);
        let c, u;
        this.closed || a > 0 ? c = r[(a - 1) % s] : (vc.subVectors(r[0], r[1]).add(r[0]),
        c = vc);
        const h = r[a % s]
          , f = r[(a + 1) % s];
        if (this.closed || a + 2 < s ? u = r[(a + 2) % s] : (vc.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]),
        u = vc),
        this.curveType === "centripetal" || this.curveType === "chordal") {
            const d = this.curveType === "chordal" ? .5 : .25;
            let p = Math.pow(c.distanceToSquared(h), d)
              , v = Math.pow(h.distanceToSquared(f), d)
              , g = Math.pow(f.distanceToSquared(u), d);
            v < 1e-4 && (v = 1),
            p < 1e-4 && (p = v),
            g < 1e-4 && (g = v),
            Xf.initNonuniformCatmullRom(c.x, h.x, f.x, u.x, p, v, g),
            qf.initNonuniformCatmullRom(c.y, h.y, f.y, u.y, p, v, g),
            $f.initNonuniformCatmullRom(c.z, h.z, f.z, u.z, p, v, g)
        } else
            this.curveType === "catmullrom" && (Xf.initCatmullRom(c.x, h.x, f.x, u.x, this.tension),
            qf.initCatmullRom(c.y, h.y, f.y, u.y, this.tension),
            $f.initCatmullRom(c.z, h.z, f.z, u.z, this.tension));
        return i.set(Xf.calc(l), qf.calc(l), $f.calc(l)),
        i
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new N().fromArray(r))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
}
function Ev(n, e, t, i, r) {
    const s = (i - e) * .5
      , o = (r - t) * .5
      , a = n * n
      , l = n * a;
    return (2 * t - 2 * i + s + o) * l + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
}
function cI(n, e) {
    const t = 1 - n;
    return t * t * e
}
function uI(n, e) {
    return 2 * (1 - n) * n * e
}
function hI(n, e) {
    return n * n * e
}
function ba(n, e, t, i) {
    return cI(n, e) + uI(n, t) + hI(n, i)
}
function fI(n, e) {
    const t = 1 - n;
    return t * t * t * e
}
function dI(n, e) {
    const t = 1 - n;
    return 3 * t * t * n * e
}
function pI(n, e) {
    return 3 * (1 - n) * n * n * e
}
function mI(n, e) {
    return n * n * n * e
}
function Ma(n, e, t, i, r) {
    return fI(n, e) + dI(n, t) + pI(n, i) + mI(n, r)
}
class $p extends li {
    constructor(e=new ae, t=new ae, i=new ae, r=new ae) {
        super(),
        this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i,
        this.v3 = r
    }
    getPoint(e, t=new ae) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return i.set(Ma(e, r.x, s.x, o.x, a.x), Ma(e, r.y, s.y, o.y, a.y)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class cb extends li {
    constructor(e=new N, t=new N, i=new N, r=new N) {
        super(),
        this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i,
        this.v3 = r
    }
    getPoint(e, t=new N) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2
          , a = this.v3;
        return i.set(Ma(e, r.x, s.x, o.x, a.x), Ma(e, r.y, s.y, o.y, a.y), Ma(e, r.z, s.z, o.z, a.z)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class Yp extends li {
    constructor(e=new ae, t=new ae) {
        super(),
        this.isLineCurve = !0,
        this.type = "LineCurve",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new ae) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new ae) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class ub extends li {
    constructor(e=new N, t=new N) {
        super(),
        this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new N) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1),
        i.multiplyScalar(e).add(this.v1)),
        i
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new N) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class jp extends li {
    constructor(e=new ae, t=new ae, i=new ae) {
        super(),
        this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i
    }
    getPoint(e, t=new ae) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2;
        return i.set(ba(e, r.x, s.x, o.x), ba(e, r.y, s.y, o.y)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class Kp extends li {
    constructor(e=new N, t=new N, i=new N) {
        super(),
        this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = i
    }
    getPoint(e, t=new N) {
        const i = t
          , r = this.v0
          , s = this.v1
          , o = this.v2;
        return i.set(ba(e, r.x, s.x, o.x), ba(e, r.y, s.y, o.y), ba(e, r.z, s.z, o.z)),
        i
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class Zp extends li {
    constructor(e=[]) {
        super(),
        this.isSplineCurve = !0,
        this.type = "SplineCurve",
        this.points = e
    }
    getPoint(e, t=new ae) {
        const i = t
          , r = this.points
          , s = (r.length - 1) * e
          , o = Math.floor(s)
          , a = s - o
          , l = r[o === 0 ? o : o - 1]
          , c = r[o]
          , u = r[o > r.length - 2 ? r.length - 1 : o + 1]
          , h = r[o > r.length - 3 ? r.length - 1 : o + 2];
        return i.set(Ev(a, l.x, c.x, u.x, h.x), Ev(a, l.y, c.y, u.y, h.y)),
        i
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new ae().fromArray(r))
        }
        return this
    }
}
var Nu = Object.freeze({
    __proto__: null,
    ArcCurve: ab,
    CatmullRomCurve3: lb,
    CubicBezierCurve: $p,
    CubicBezierCurve3: cb,
    EllipseCurve: Sh,
    LineCurve: Yp,
    LineCurve3: ub,
    QuadraticBezierCurve: jp,
    QuadraticBezierCurve3: Kp,
    SplineCurve: Zp
});
class hb extends li {
    constructor() {
        super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0)
          , t = this.curves[this.curves.length - 1].getPoint(1);
        if (!e.equals(t)) {
            const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
            this.curves.push(new Nu[i](t,e))
        }
        return this
    }
    getPoint(e, t) {
        const i = e * this.getLength()
          , r = this.getCurveLengths();
        let s = 0;
        for (; s < r.length; ) {
            if (r[s] >= i) {
                const o = r[s] - i
                  , a = this.curves[s]
                  , l = a.getLength()
                  , c = l === 0 ? 0 : 1 - o / l;
                return a.getPointAt(c, t)
            }
            s++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let i = 0, r = this.curves.length; i < r; i++)
            t += this.curves[i].getLength(),
            e.push(t);
        return this.cacheLengths = e,
        e
    }
    getSpacedPoints(e=40) {
        const t = [];
        for (let i = 0; i <= e; i++)
            t.push(this.getPoint(i / e));
        return this.autoClose && t.push(t[0]),
        t
    }
    getPoints(e=12) {
        const t = [];
        let i;
        for (let r = 0, s = this.curves; r < s.length; r++) {
            const o = s[r]
              , a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e
              , l = o.getPoints(a);
            for (let c = 0; c < l.length; c++) {
                const u = l[c];
                i && i.equals(u) || (t.push(u),
                i = u)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
        t
    }
    copy(e) {
        super.copy(e),
        this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(r.clone())
        }
        return this.autoClose = e.autoClose,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose,
        e.curves = [];
        for (let t = 0, i = this.curves.length; t < i; t++) {
            const r = this.curves[t];
            e.curves.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.autoClose = e.autoClose,
        this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(new Nu[r.type]().fromJSON(r))
        }
        return this
    }
}
class Za extends hb {
    constructor(e) {
        super(),
        this.type = "Path",
        this.currentPoint = new ae,
        e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, i = e.length; t < i; t++)
            this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t),
        this
    }
    lineTo(e, t) {
        const i = new Yp(this.currentPoint.clone(),new ae(e,t));
        return this.curves.push(i),
        this.currentPoint.set(e, t),
        this
    }
    quadraticCurveTo(e, t, i, r) {
        const s = new jp(this.currentPoint.clone(),new ae(e,t),new ae(i,r));
        return this.curves.push(s),
        this.currentPoint.set(i, r),
        this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        const a = new $p(this.currentPoint.clone(),new ae(e,t),new ae(i,r),new ae(s,o));
        return this.curves.push(a),
        this.currentPoint.set(s, o),
        this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e)
          , i = new Zp(t);
        return this.curves.push(i),
        this.currentPoint.copy(e[e.length - 1]),
        this
    }
    arc(e, t, i, r, s, o) {
        const a = this.currentPoint.x
          , l = this.currentPoint.y;
        return this.absarc(e + a, t + l, i, r, s, o),
        this
    }
    absarc(e, t, i, r, s, o) {
        return this.absellipse(e, t, i, i, r, s, o),
        this
    }
    ellipse(e, t, i, r, s, o, a, l) {
        const c = this.currentPoint.x
          , u = this.currentPoint.y;
        return this.absellipse(e + c, t + u, i, r, s, o, a, l),
        this
    }
    absellipse(e, t, i, r, s, o, a, l) {
        const c = new Sh(e,t,i,r,s,o,a,l);
        if (this.curves.length > 0) {
            const h = c.getPoint(0);
            h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
        }
        this.curves.push(c);
        const u = c.getPoint(1);
        return this.currentPoint.copy(u),
        this
    }
    copy(e) {
        return super.copy(e),
        this.currentPoint.copy(e.currentPoint),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this
    }
}
class bl extends Ze {
    constructor(e=[new ae(0,-.5), new ae(.5,0), new ae(0,.5)], t=12, i=0, r=Math.PI * 2) {
        super(),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: r
        },
        t = Math.floor(t),
        r = It(r, 0, Math.PI * 2);
        const s = []
          , o = []
          , a = []
          , l = []
          , c = []
          , u = 1 / t
          , h = new N
          , f = new ae
          , d = new N
          , p = new N
          , v = new N;
        let g = 0
          , m = 0;
        for (let y = 0; y <= e.length - 1; y++)
            switch (y) {
            case 0:
                g = e[y + 1].x - e[y].x,
                m = e[y + 1].y - e[y].y,
                d.x = m * 1,
                d.y = -g,
                d.z = m * 0,
                v.copy(d),
                d.normalize(),
                l.push(d.x, d.y, d.z);
                break;
            case e.length - 1:
                l.push(v.x, v.y, v.z);
                break;
            default:
                g = e[y + 1].x - e[y].x,
                m = e[y + 1].y - e[y].y,
                d.x = m * 1,
                d.y = -g,
                d.z = m * 0,
                p.copy(d),
                d.x += v.x,
                d.y += v.y,
                d.z += v.z,
                d.normalize(),
                l.push(d.x, d.y, d.z),
                v.copy(p)
            }
        for (let y = 0; y <= t; y++) {
            const _ = i + y * u * r
              , x = Math.sin(_)
              , C = Math.cos(_);
            for (let w = 0; w <= e.length - 1; w++) {
                h.x = e[w].x * x,
                h.y = e[w].y,
                h.z = e[w].x * C,
                o.push(h.x, h.y, h.z),
                f.x = y / t,
                f.y = w / (e.length - 1),
                a.push(f.x, f.y);
                const E = l[3 * w + 0] * x
                  , L = l[3 * w + 1]
                  , S = l[3 * w + 0] * C;
                c.push(E, L, S)
            }
        }
        for (let y = 0; y < t; y++)
            for (let _ = 0; _ < e.length - 1; _++) {
                const x = _ + y * e.length
                  , C = x
                  , w = x + e.length
                  , E = x + e.length + 1
                  , L = x + 1;
                s.push(C, w, L),
                s.push(E, L, w)
            }
        this.setIndex(s),
        this.setAttribute("position", new Le(o,3)),
        this.setAttribute("uv", new Le(a,2)),
        this.setAttribute("normal", new Le(c,3))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new bl(e.points,e.segments,e.phiStart,e.phiLength)
    }
}
class wh extends bl {
    constructor(e=1, t=1, i=4, r=8) {
        const s = new Za;
        s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
        s.absarc(0, t / 2, e, 0, Math.PI * .5),
        super(s.getPoints(i), r),
        this.type = "CapsuleGeometry",
        this.parameters = {
            radius: e,
            length: t,
            capSegments: i,
            radialSegments: r
        }
    }
    static fromJSON(e) {
        return new wh(e.radius,e.length,e.capSegments,e.radialSegments)
    }
}
class Eh extends Ze {
    constructor(e=1, t=32, i=0, r=Math.PI * 2) {
        super(),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: r
        },
        t = Math.max(3, t);
        const s = []
          , o = []
          , a = []
          , l = []
          , c = new N
          , u = new ae;
        o.push(0, 0, 0),
        a.push(0, 0, 1),
        l.push(.5, .5);
        for (let h = 0, f = 3; h <= t; h++,
        f += 3) {
            const d = i + h / t * r;
            c.x = e * Math.cos(d),
            c.y = e * Math.sin(d),
            o.push(c.x, c.y, c.z),
            a.push(0, 0, 1),
            u.x = (o[f] / e + 1) / 2,
            u.y = (o[f + 1] / e + 1) / 2,
            l.push(u.x, u.y)
        }
        for (let h = 1; h <= t; h++)
            s.push(h, h + 1, 0);
        this.setIndex(s),
        this.setAttribute("position", new Le(o,3)),
        this.setAttribute("normal", new Le(a,3)),
        this.setAttribute("uv", new Le(l,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Eh(e.radius,e.segments,e.thetaStart,e.thetaLength)
    }
}
class Fo extends Ze {
    constructor(e=1, t=1, i=1, r=32, s=1, o=!1, a=0, l=Math.PI * 2) {
        super(),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: r,
            heightSegments: s,
            openEnded: o,
            thetaStart: a,
            thetaLength: l
        };
        const c = this;
        r = Math.floor(r),
        s = Math.floor(s);
        const u = []
          , h = []
          , f = []
          , d = [];
        let p = 0;
        const v = []
          , g = i / 2;
        let m = 0;
        y(),
        o === !1 && (e > 0 && _(!0),
        t > 0 && _(!1)),
        this.setIndex(u),
        this.setAttribute("position", new Le(h,3)),
        this.setAttribute("normal", new Le(f,3)),
        this.setAttribute("uv", new Le(d,2));
        function y() {
            const x = new N
              , C = new N;
            let w = 0;
            const E = (t - e) / i;
            for (let L = 0; L <= s; L++) {
                const S = []
                  , b = L / s
                  , D = b * (t - e) + e;
                for (let F = 0; F <= r; F++) {
                    const z = F / r
                      , $ = z * l + a
                      , ne = Math.sin($)
                      , W = Math.cos($);
                    C.x = D * ne,
                    C.y = -b * i + g,
                    C.z = D * W,
                    h.push(C.x, C.y, C.z),
                    x.set(ne, E, W).normalize(),
                    f.push(x.x, x.y, x.z),
                    d.push(z, 1 - b),
                    S.push(p++)
                }
                v.push(S)
            }
            for (let L = 0; L < r; L++)
                for (let S = 0; S < s; S++) {
                    const b = v[S][L]
                      , D = v[S + 1][L]
                      , F = v[S + 1][L + 1]
                      , z = v[S][L + 1];
                    u.push(b, D, z),
                    u.push(D, F, z),
                    w += 6
                }
            c.addGroup(m, w, 0),
            m += w
        }
        function _(x) {
            const C = p
              , w = new ae
              , E = new N;
            let L = 0;
            const S = x === !0 ? e : t
              , b = x === !0 ? 1 : -1;
            for (let F = 1; F <= r; F++)
                h.push(0, g * b, 0),
                f.push(0, b, 0),
                d.push(.5, .5),
                p++;
            const D = p;
            for (let F = 0; F <= r; F++) {
                const $ = F / r * l + a
                  , ne = Math.cos($)
                  , W = Math.sin($);
                E.x = S * W,
                E.y = g * b,
                E.z = S * ne,
                h.push(E.x, E.y, E.z),
                f.push(0, b, 0),
                w.x = ne * .5 + .5,
                w.y = W * .5 * b + .5,
                d.push(w.x, w.y),
                p++
            }
            for (let F = 0; F < r; F++) {
                const z = C + F
                  , $ = D + F;
                x === !0 ? u.push($, $ + 1, z) : u.push($ + 1, $, z),
                L += 3
            }
            c.addGroup(m, L, x === !0 ? 1 : 2),
            m += L
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Fo(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class Ah extends Fo {
    constructor(e=1, t=1, i=32, r=1, s=!1, o=0, a=Math.PI * 2) {
        super(0, e, t, i, r, s, o, a),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: r,
            openEnded: s,
            thetaStart: o,
            thetaLength: a
        }
    }
    static fromJSON(e) {
        return new Ah(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class Ir extends Ze {
    constructor(e=[], t=[], i=1, r=0) {
        super(),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: r
        };
        const s = []
          , o = [];
        a(r),
        c(i),
        u(),
        this.setAttribute("position", new Le(s,3)),
        this.setAttribute("normal", new Le(s.slice(),3)),
        this.setAttribute("uv", new Le(o,2)),
        r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
        function a(y) {
            const _ = new N
              , x = new N
              , C = new N;
            for (let w = 0; w < t.length; w += 3)
                d(t[w + 0], _),
                d(t[w + 1], x),
                d(t[w + 2], C),
                l(_, x, C, y)
        }
        function l(y, _, x, C) {
            const w = C + 1
              , E = [];
            for (let L = 0; L <= w; L++) {
                E[L] = [];
                const S = y.clone().lerp(x, L / w)
                  , b = _.clone().lerp(x, L / w)
                  , D = w - L;
                for (let F = 0; F <= D; F++)
                    F === 0 && L === w ? E[L][F] = S : E[L][F] = S.clone().lerp(b, F / D)
            }
            for (let L = 0; L < w; L++)
                for (let S = 0; S < 2 * (w - L) - 1; S++) {
                    const b = Math.floor(S / 2);
                    S % 2 === 0 ? (f(E[L][b + 1]),
                    f(E[L + 1][b]),
                    f(E[L][b])) : (f(E[L][b + 1]),
                    f(E[L + 1][b + 1]),
                    f(E[L + 1][b]))
                }
        }
        function c(y) {
            const _ = new N;
            for (let x = 0; x < s.length; x += 3)
                _.x = s[x + 0],
                _.y = s[x + 1],
                _.z = s[x + 2],
                _.normalize().multiplyScalar(y),
                s[x + 0] = _.x,
                s[x + 1] = _.y,
                s[x + 2] = _.z
        }
        function u() {
            const y = new N;
            for (let _ = 0; _ < s.length; _ += 3) {
                y.x = s[_ + 0],
                y.y = s[_ + 1],
                y.z = s[_ + 2];
                const x = g(y) / 2 / Math.PI + .5
                  , C = m(y) / Math.PI + .5;
                o.push(x, 1 - C)
            }
            p(),
            h()
        }
        function h() {
            for (let y = 0; y < o.length; y += 6) {
                const _ = o[y + 0]
                  , x = o[y + 2]
                  , C = o[y + 4]
                  , w = Math.max(_, x, C)
                  , E = Math.min(_, x, C);
                w > .9 && E < .1 && (_ < .2 && (o[y + 0] += 1),
                x < .2 && (o[y + 2] += 1),
                C < .2 && (o[y + 4] += 1))
            }
        }
        function f(y) {
            s.push(y.x, y.y, y.z)
        }
        function d(y, _) {
            const x = y * 3;
            _.x = e[x + 0],
            _.y = e[x + 1],
            _.z = e[x + 2]
        }
        function p() {
            const y = new N
              , _ = new N
              , x = new N
              , C = new N
              , w = new ae
              , E = new ae
              , L = new ae;
            for (let S = 0, b = 0; S < s.length; S += 9,
            b += 6) {
                y.set(s[S + 0], s[S + 1], s[S + 2]),
                _.set(s[S + 3], s[S + 4], s[S + 5]),
                x.set(s[S + 6], s[S + 7], s[S + 8]),
                w.set(o[b + 0], o[b + 1]),
                E.set(o[b + 2], o[b + 3]),
                L.set(o[b + 4], o[b + 5]),
                C.copy(y).add(_).add(x).divideScalar(3);
                const D = g(C);
                v(w, b + 0, y, D),
                v(E, b + 2, _, D),
                v(L, b + 4, x, D)
            }
        }
        function v(y, _, x, C) {
            C < 0 && y.x === 1 && (o[_] = y.x - 1),
            x.x === 0 && x.z === 0 && (o[_] = C / 2 / Math.PI + .5)
        }
        function g(y) {
            return Math.atan2(y.z, -y.x)
        }
        function m(y) {
            return Math.atan2(-y.y, Math.sqrt(y.x * y.x + y.z * y.z))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Ir(e.vertices,e.indices,e.radius,e.details)
    }
}
class Th extends Ir {
    constructor(e=1, t=0) {
        const i = (1 + Math.sqrt(5)) / 2
          , r = 1 / i
          , s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r]
          , o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        super(s, o, e, t),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Th(e.radius,e.detail)
    }
}
const _c = new N
  , yc = new N
  , Yf = new N
  , xc = new In;
class fb extends Ze {
    constructor(e=null, t=1) {
        if (super(),
        this.type = "EdgesGeometry",
        this.parameters = {
            geometry: e,
            thresholdAngle: t
        },
        e !== null) {
            const r = Math.pow(10, 4)
              , s = Math.cos(fs * t)
              , o = e.getIndex()
              , a = e.getAttribute("position")
              , l = o ? o.count : a.count
              , c = [0, 0, 0]
              , u = ["a", "b", "c"]
              , h = new Array(3)
              , f = {}
              , d = [];
            for (let p = 0; p < l; p += 3) {
                o ? (c[0] = o.getX(p),
                c[1] = o.getX(p + 1),
                c[2] = o.getX(p + 2)) : (c[0] = p,
                c[1] = p + 1,
                c[2] = p + 2);
                const {a: v, b: g, c: m} = xc;
                if (v.fromBufferAttribute(a, c[0]),
                g.fromBufferAttribute(a, c[1]),
                m.fromBufferAttribute(a, c[2]),
                xc.getNormal(Yf),
                h[0] = `${Math.round(v.x * r)},${Math.round(v.y * r)},${Math.round(v.z * r)}`,
                h[1] = `${Math.round(g.x * r)},${Math.round(g.y * r)},${Math.round(g.z * r)}`,
                h[2] = `${Math.round(m.x * r)},${Math.round(m.y * r)},${Math.round(m.z * r)}`,
                !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
                    for (let y = 0; y < 3; y++) {
                        const _ = (y + 1) % 3
                          , x = h[y]
                          , C = h[_]
                          , w = xc[u[y]]
                          , E = xc[u[_]]
                          , L = `${x}_${C}`
                          , S = `${C}_${x}`;
                        S in f && f[S] ? (Yf.dot(f[S].normal) <= s && (d.push(w.x, w.y, w.z),
                        d.push(E.x, E.y, E.z)),
                        f[S] = null) : L in f || (f[L] = {
                            index0: c[y],
                            index1: c[_],
                            normal: Yf.clone()
                        })
                    }
            }
            for (const p in f)
                if (f[p]) {
                    const {index0: v, index1: g} = f[p];
                    _c.fromBufferAttribute(a, v),
                    yc.fromBufferAttribute(a, g),
                    d.push(_c.x, _c.y, _c.z),
                    d.push(yc.x, yc.y, yc.z)
                }
            this.setAttribute("position", new Le(d,3))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
}
class ds extends Za {
    constructor(e) {
        super(e),
        this.uuid = Nn(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let i = 0, r = this.holes.length; i < r; i++)
            t[i] = this.holes[i].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e),
        this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(r.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid,
        e.holes = [];
        for (let t = 0, i = this.holes.length; t < i; t++) {
            const r = this.holes[t];
            e.holes.push(r.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.uuid = e.uuid,
        this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(new Za().fromJSON(r))
        }
        return this
    }
}
const gI = {
    triangulate: function(n, e, t=2) {
        const i = e && e.length
          , r = i ? e[0] * t : n.length;
        let s = db(n, 0, r, t, !0);
        const o = [];
        if (!s || s.next === s.prev)
            return o;
        let a, l, c, u, h, f, d;
        if (i && (s = bI(n, e, s, t)),
        n.length > 80 * t) {
            a = c = n[0],
            l = u = n[1];
            for (let p = t; p < r; p += t)
                h = n[p],
                f = n[p + 1],
                h < a && (a = h),
                f < l && (l = f),
                h > c && (c = h),
                f > u && (u = f);
            d = Math.max(c - a, u - l),
            d = d !== 0 ? 32767 / d : 0
        }
        return Ja(s, o, t, a, l, d, 0),
        o
    }
};
function db(n, e, t, i, r) {
    let s, o;
    if (r === LI(n, e, t, i) > 0)
        for (s = e; s < t; s += i)
            o = Av(s, n[s], n[s + 1], o);
    else
        for (s = t - i; s >= e; s -= i)
            o = Av(s, n[s], n[s + 1], o);
    return o && Ch(o, o.next) && (el(o),
    o = o.next),
    o
}
function xs(n, e) {
    if (!n)
        return n;
    e || (e = n);
    let t = n, i;
    do
        if (i = !1,
        !t.steiner && (Ch(t, t.next) || At(t.prev, t, t.next) === 0)) {
            if (el(t),
            t = e = t.prev,
            t === t.next)
                break;
            i = !0
        } else
            t = t.next;
    while (i || t !== e);
    return e
}
function Ja(n, e, t, i, r, s, o) {
    if (!n)
        return;
    !o && s && AI(n, i, r, s);
    let a = n, l, c;
    for (; n.prev !== n.next; ) {
        if (l = n.prev,
        c = n.next,
        s ? _I(n, i, r, s) : vI(n)) {
            e.push(l.i / t | 0),
            e.push(n.i / t | 0),
            e.push(c.i / t | 0),
            el(n),
            n = c.next,
            a = c.next;
            continue
        }
        if (n = c,
        n === a) {
            o ? o === 1 ? (n = yI(xs(n), e, t),
            Ja(n, e, t, i, r, s, 2)) : o === 2 && xI(n, e, t, i, r, s) : Ja(xs(n), e, t, i, r, s, 1);
            break
        }
    }
}
function vI(n) {
    const e = n.prev
      , t = n
      , i = n.next;
    if (At(e, t, i) >= 0)
        return !1;
    const r = e.x
      , s = t.x
      , o = i.x
      , a = e.y
      , l = t.y
      , c = i.y
      , u = r < s ? r < o ? r : o : s < o ? s : o
      , h = a < l ? a < c ? a : c : l < c ? l : c
      , f = r > s ? r > o ? r : o : s > o ? s : o
      , d = a > l ? a > c ? a : c : l > c ? l : c;
    let p = i.next;
    for (; p !== e; ) {
        if (p.x >= u && p.x <= f && p.y >= h && p.y <= d && io(r, a, s, l, o, c, p.x, p.y) && At(p.prev, p, p.next) >= 0)
            return !1;
        p = p.next
    }
    return !0
}
function _I(n, e, t, i) {
    const r = n.prev
      , s = n
      , o = n.next;
    if (At(r, s, o) >= 0)
        return !1;
    const a = r.x
      , l = s.x
      , c = o.x
      , u = r.y
      , h = s.y
      , f = o.y
      , d = a < l ? a < c ? a : c : l < c ? l : c
      , p = u < h ? u < f ? u : f : h < f ? h : f
      , v = a > l ? a > c ? a : c : l > c ? l : c
      , g = u > h ? u > f ? u : f : h > f ? h : f
      , m = Ld(d, p, e, t, i)
      , y = Ld(v, g, e, t, i);
    let _ = n.prevZ
      , x = n.nextZ;
    for (; _ && _.z >= m && x && x.z <= y; ) {
        if (_.x >= d && _.x <= v && _.y >= p && _.y <= g && _ !== r && _ !== o && io(a, u, l, h, c, f, _.x, _.y) && At(_.prev, _, _.next) >= 0 || (_ = _.prevZ,
        x.x >= d && x.x <= v && x.y >= p && x.y <= g && x !== r && x !== o && io(a, u, l, h, c, f, x.x, x.y) && At(x.prev, x, x.next) >= 0))
            return !1;
        x = x.nextZ
    }
    for (; _ && _.z >= m; ) {
        if (_.x >= d && _.x <= v && _.y >= p && _.y <= g && _ !== r && _ !== o && io(a, u, l, h, c, f, _.x, _.y) && At(_.prev, _, _.next) >= 0)
            return !1;
        _ = _.prevZ
    }
    for (; x && x.z <= y; ) {
        if (x.x >= d && x.x <= v && x.y >= p && x.y <= g && x !== r && x !== o && io(a, u, l, h, c, f, x.x, x.y) && At(x.prev, x, x.next) >= 0)
            return !1;
        x = x.nextZ
    }
    return !0
}
function yI(n, e, t) {
    let i = n;
    do {
        const r = i.prev
          , s = i.next.next;
        !Ch(r, s) && pb(r, i, i.next, s) && Qa(r, s) && Qa(s, r) && (e.push(r.i / t | 0),
        e.push(i.i / t | 0),
        e.push(s.i / t | 0),
        el(i),
        el(i.next),
        i = n = s),
        i = i.next
    } while (i !== n);
    return xs(i)
}
function xI(n, e, t, i, r, s) {
    let o = n;
    do {
        let a = o.next.next;
        for (; a !== o.prev; ) {
            if (o.i !== a.i && RI(o, a)) {
                let l = mb(o, a);
                o = xs(o, o.next),
                l = xs(l, l.next),
                Ja(o, e, t, i, r, s, 0),
                Ja(l, e, t, i, r, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== n)
}
function bI(n, e, t, i) {
    const r = [];
    let s, o, a, l, c;
    for (s = 0,
    o = e.length; s < o; s++)
        a = e[s] * i,
        l = s < o - 1 ? e[s + 1] * i : n.length,
        c = db(n, a, l, i, !1),
        c === c.next && (c.steiner = !0),
        r.push(CI(c));
    for (r.sort(MI),
    s = 0; s < r.length; s++)
        t = SI(r[s], t);
    return t
}
function MI(n, e) {
    return n.x - e.x
}
function SI(n, e) {
    const t = wI(n, e);
    if (!t)
        return e;
    const i = mb(t, n);
    return xs(i, i.next),
    xs(t, t.next)
}
function wI(n, e) {
    let t = e, i = -1 / 0, r;
    const s = n.x
      , o = n.y;
    do {
        if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
            const f = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (f <= s && f > i && (i = f,
            r = t.x < t.next.x ? t : t.next,
            f === s))
                return r
        }
        t = t.next
    } while (t !== e);
    if (!r)
        return null;
    const a = r
      , l = r.x
      , c = r.y;
    let u = 1 / 0, h;
    t = r;
    do
        s >= t.x && t.x >= l && s !== t.x && io(o < c ? s : i, o, l, c, o < c ? i : s, o, t.x, t.y) && (h = Math.abs(o - t.y) / (s - t.x),
        Qa(t, n) && (h < u || h === u && (t.x > r.x || t.x === r.x && EI(r, t))) && (r = t,
        u = h)),
        t = t.next;
    while (t !== a);
    return r
}
function EI(n, e) {
    return At(n.prev, n, e.prev) < 0 && At(e.next, n, n.next) < 0
}
function AI(n, e, t, i) {
    let r = n;
    do
        r.z === 0 && (r.z = Ld(r.x, r.y, e, t, i)),
        r.prevZ = r.prev,
        r.nextZ = r.next,
        r = r.next;
    while (r !== n);
    r.prevZ.nextZ = null,
    r.prevZ = null,
    TI(r)
}
function TI(n) {
    let e, t, i, r, s, o, a, l, c = 1;
    do {
        for (t = n,
        n = null,
        s = null,
        o = 0; t; ) {
            for (o++,
            i = t,
            a = 0,
            e = 0; e < c && (a++,
            i = i.nextZ,
            !!i); e++)
                ;
            for (l = c; a > 0 || l > 0 && i; )
                a !== 0 && (l === 0 || !i || t.z <= i.z) ? (r = t,
                t = t.nextZ,
                a--) : (r = i,
                i = i.nextZ,
                l--),
                s ? s.nextZ = r : n = r,
                r.prevZ = s,
                s = r;
            t = i
        }
        s.nextZ = null,
        c *= 2
    } while (o > 1);
    return n
}
function Ld(n, e, t, i, r) {
    return n = (n - t) * r | 0,
    e = (e - i) * r | 0,
    n = (n | n << 8) & 16711935,
    n = (n | n << 4) & 252645135,
    n = (n | n << 2) & 858993459,
    n = (n | n << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    n | e << 1
}
function CI(n) {
    let e = n
      , t = n;
    do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
        e = e.next;
    while (e !== n);
    return t
}
function io(n, e, t, i, r, s, o, a) {
    return (r - o) * (e - a) >= (n - o) * (s - a) && (n - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (r - o) * (i - a)
}
function RI(n, e) {
    return n.next.i !== e.i && n.prev.i !== e.i && !PI(n, e) && (Qa(n, e) && Qa(e, n) && II(n, e) && (At(n.prev, n, e.prev) || At(n, e.prev, e)) || Ch(n, e) && At(n.prev, n, n.next) > 0 && At(e.prev, e, e.next) > 0)
}
function At(n, e, t) {
    return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}
function Ch(n, e) {
    return n.x === e.x && n.y === e.y
}
function pb(n, e, t, i) {
    const r = Mc(At(n, e, t))
      , s = Mc(At(n, e, i))
      , o = Mc(At(t, i, n))
      , a = Mc(At(t, i, e));
    return !!(r !== s && o !== a || r === 0 && bc(n, t, e) || s === 0 && bc(n, i, e) || o === 0 && bc(t, n, i) || a === 0 && bc(t, e, i))
}
function bc(n, e, t) {
    return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y)
}
function Mc(n) {
    return n > 0 ? 1 : n < 0 ? -1 : 0
}
function PI(n, e) {
    let t = n;
    do {
        if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && pb(t, t.next, n, e))
            return !0;
        t = t.next
    } while (t !== n);
    return !1
}
function Qa(n, e) {
    return At(n.prev, n, n.next) < 0 ? At(n, e, n.next) >= 0 && At(n, n.prev, e) >= 0 : At(n, e, n.prev) < 0 || At(n, n.next, e) < 0
}
function II(n, e) {
    let t = n
      , i = !1;
    const r = (n.x + e.x) / 2
      , s = (n.y + e.y) / 2;
    do
        t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i),
        t = t.next;
    while (t !== n);
    return i
}
function mb(n, e) {
    const t = new Dd(n.i,n.x,n.y)
      , i = new Dd(e.i,e.x,e.y)
      , r = n.next
      , s = e.prev;
    return n.next = e,
    e.prev = n,
    t.next = r,
    r.prev = t,
    i.next = t,
    t.prev = i,
    s.next = i,
    i.prev = s,
    i
}
function Av(n, e, t, i) {
    const r = new Dd(n,e,t);
    return i ? (r.next = i.next,
    r.prev = i,
    i.next.prev = r,
    i.next = r) : (r.prev = r,
    r.next = r),
    r
}
function el(n) {
    n.next.prev = n.prev,
    n.prev.next = n.next,
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ)
}
function Dd(n, e, t) {
    this.i = n,
    this.x = e,
    this.y = t,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function LI(n, e, t, i) {
    let r = 0;
    for (let s = e, o = t - i; s < t; s += i)
        r += (n[o] - n[s]) * (n[s + 1] + n[o + 1]),
        o = s;
    return r
}
class yi {
    static area(e) {
        const t = e.length;
        let i = 0;
        for (let r = t - 1, s = 0; s < t; r = s++)
            i += e[r].x * e[s].y - e[s].x * e[r].y;
        return i * .5
    }
    static isClockWise(e) {
        return yi.area(e) < 0
    }
    static triangulateShape(e, t) {
        const i = []
          , r = []
          , s = [];
        Tv(e),
        Cv(i, e);
        let o = e.length;
        t.forEach(Tv);
        for (let l = 0; l < t.length; l++)
            r.push(o),
            o += t[l].length,
            Cv(i, t[l]);
        const a = gI.triangulate(i, r);
        for (let l = 0; l < a.length; l += 3)
            s.push(a.slice(l, l + 3));
        return s
    }
}
function Tv(n) {
    const e = n.length;
    e > 2 && n[e - 1].equals(n[0]) && n.pop()
}
function Cv(n, e) {
    for (let t = 0; t < e.length; t++)
        n.push(e[t].x),
        n.push(e[t].y)
}
class Rh extends Ze {
    constructor(e=new ds([new ae(.5,.5), new ae(-.5,.5), new ae(-.5,-.5), new ae(.5,-.5)]), t={}) {
        super(),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        const i = this
          , r = []
          , s = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a];
            o(c)
        }
        this.setAttribute("position", new Le(r,3)),
        this.setAttribute("uv", new Le(s,2)),
        this.computeVertexNormals();
        function o(a) {
            const l = []
              , c = t.curveSegments !== void 0 ? t.curveSegments : 12
              , u = t.steps !== void 0 ? t.steps : 1
              , h = t.depth !== void 0 ? t.depth : 1;
            let f = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0
              , d = t.bevelThickness !== void 0 ? t.bevelThickness : .2
              , p = t.bevelSize !== void 0 ? t.bevelSize : d - .1
              , v = t.bevelOffset !== void 0 ? t.bevelOffset : 0
              , g = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const m = t.extrudePath
              , y = t.UVGenerator !== void 0 ? t.UVGenerator : DI;
            let _, x = !1, C, w, E, L;
            m && (_ = m.getSpacedPoints(u),
            x = !0,
            f = !1,
            C = m.computeFrenetFrames(u, !1),
            w = new N,
            E = new N,
            L = new N),
            f || (g = 0,
            d = 0,
            p = 0,
            v = 0);
            const S = a.extractPoints(c);
            let b = S.shape;
            const D = S.holes;
            if (!yi.isClockWise(b)) {
                b = b.reverse();
                for (let I = 0, A = D.length; I < A; I++) {
                    const R = D[I];
                    yi.isClockWise(R) && (D[I] = R.reverse())
                }
            }
            const z = yi.triangulateShape(b, D)
              , $ = b;
            for (let I = 0, A = D.length; I < A; I++) {
                const R = D[I];
                b = b.concat(R)
            }
            function ne(I, A, R) {
                return A || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                I.clone().addScaledVector(A, R)
            }
            const W = b.length
              , ie = z.length;
            function Z(I, A, R) {
                let O, B, Y;
                const X = I.x - A.x
                  , ee = I.y - A.y
                  , T = R.x - I.x
                  , M = R.y - I.y
                  , U = X * X + ee * ee
                  , K = X * M - ee * T;
                if (Math.abs(K) > Number.EPSILON) {
                    const H = Math.sqrt(U)
                      , j = Math.sqrt(T * T + M * M)
                      , de = A.x - ee / H
                      , le = A.y + X / H
                      , me = R.x - M / j
                      , Ae = R.y + T / j
                      , fe = ((me - de) * M - (Ae - le) * T) / (X * M - ee * T);
                    O = de + X * fe - I.x,
                    B = le + ee * fe - I.y;
                    const ge = O * O + B * B;
                    if (ge <= 2)
                        return new ae(O,B);
                    Y = Math.sqrt(ge / 2)
                } else {
                    let H = !1;
                    X > Number.EPSILON ? T > Number.EPSILON && (H = !0) : X < -Number.EPSILON ? T < -Number.EPSILON && (H = !0) : Math.sign(ee) === Math.sign(M) && (H = !0),
                    H ? (O = -ee,
                    B = X,
                    Y = Math.sqrt(U)) : (O = X,
                    B = ee,
                    Y = Math.sqrt(U / 2))
                }
                return new ae(O / Y,B / Y)
            }
            const ve = [];
            for (let I = 0, A = $.length, R = A - 1, O = I + 1; I < A; I++,
            R++,
            O++)
                R === A && (R = 0),
                O === A && (O = 0),
                ve[I] = Z($[I], $[R], $[O]);
            const xe = [];
            let te, Se = ve.concat();
            for (let I = 0, A = D.length; I < A; I++) {
                const R = D[I];
                te = [];
                for (let O = 0, B = R.length, Y = B - 1, X = O + 1; O < B; O++,
                Y++,
                X++)
                    Y === B && (Y = 0),
                    X === B && (X = 0),
                    te[O] = Z(R[O], R[Y], R[X]);
                xe.push(te),
                Se = Se.concat(te)
            }
            for (let I = 0; I < g; I++) {
                const A = I / g
                  , R = d * Math.cos(A * Math.PI / 2)
                  , O = p * Math.sin(A * Math.PI / 2) + v;
                for (let B = 0, Y = $.length; B < Y; B++) {
                    const X = ne($[B], ve[B], O);
                    k(X.x, X.y, -R)
                }
                for (let B = 0, Y = D.length; B < Y; B++) {
                    const X = D[B];
                    te = xe[B];
                    for (let ee = 0, T = X.length; ee < T; ee++) {
                        const M = ne(X[ee], te[ee], O);
                        k(M.x, M.y, -R)
                    }
                }
            }
            const ze = p + v;
            for (let I = 0; I < W; I++) {
                const A = f ? ne(b[I], Se[I], ze) : b[I];
                x ? (E.copy(C.normals[0]).multiplyScalar(A.x),
                w.copy(C.binormals[0]).multiplyScalar(A.y),
                L.copy(_[0]).add(E).add(w),
                k(L.x, L.y, L.z)) : k(A.x, A.y, 0)
            }
            for (let I = 1; I <= u; I++)
                for (let A = 0; A < W; A++) {
                    const R = f ? ne(b[A], Se[A], ze) : b[A];
                    x ? (E.copy(C.normals[I]).multiplyScalar(R.x),
                    w.copy(C.binormals[I]).multiplyScalar(R.y),
                    L.copy(_[I]).add(E).add(w),
                    k(L.x, L.y, L.z)) : k(R.x, R.y, h / u * I)
                }
            for (let I = g - 1; I >= 0; I--) {
                const A = I / g
                  , R = d * Math.cos(A * Math.PI / 2)
                  , O = p * Math.sin(A * Math.PI / 2) + v;
                for (let B = 0, Y = $.length; B < Y; B++) {
                    const X = ne($[B], ve[B], O);
                    k(X.x, X.y, h + R)
                }
                for (let B = 0, Y = D.length; B < Y; B++) {
                    const X = D[B];
                    te = xe[B];
                    for (let ee = 0, T = X.length; ee < T; ee++) {
                        const M = ne(X[ee], te[ee], O);
                        x ? k(M.x, M.y + _[u - 1].y, _[u - 1].x + R) : k(M.x, M.y, h + R)
                    }
                }
            }
            re(),
            pe();
            function re() {
                const I = r.length / 3;
                if (f) {
                    let A = 0
                      , R = W * A;
                    for (let O = 0; O < ie; O++) {
                        const B = z[O];
                        se(B[2] + R, B[1] + R, B[0] + R)
                    }
                    A = u + g * 2,
                    R = W * A;
                    for (let O = 0; O < ie; O++) {
                        const B = z[O];
                        se(B[0] + R, B[1] + R, B[2] + R)
                    }
                } else {
                    for (let A = 0; A < ie; A++) {
                        const R = z[A];
                        se(R[2], R[1], R[0])
                    }
                    for (let A = 0; A < ie; A++) {
                        const R = z[A];
                        se(R[0] + W * u, R[1] + W * u, R[2] + W * u)
                    }
                }
                i.addGroup(I, r.length / 3 - I, 0)
            }
            function pe() {
                const I = r.length / 3;
                let A = 0;
                Me($, A),
                A += $.length;
                for (let R = 0, O = D.length; R < O; R++) {
                    const B = D[R];
                    Me(B, A),
                    A += B.length
                }
                i.addGroup(I, r.length / 3 - I, 1)
            }
            function Me(I, A) {
                let R = I.length;
                for (; --R >= 0; ) {
                    const O = R;
                    let B = R - 1;
                    B < 0 && (B = I.length - 1);
                    for (let Y = 0, X = u + g * 2; Y < X; Y++) {
                        const ee = W * Y
                          , T = W * (Y + 1)
                          , M = A + O + ee
                          , U = A + B + ee
                          , K = A + B + T
                          , H = A + O + T;
                        oe(M, U, K, H)
                    }
                }
            }
            function k(I, A, R) {
                l.push(I),
                l.push(A),
                l.push(R)
            }
            function se(I, A, R) {
                he(I),
                he(A),
                he(R);
                const O = r.length / 3
                  , B = y.generateTopUV(i, r, O - 3, O - 2, O - 1);
                Re(B[0]),
                Re(B[1]),
                Re(B[2])
            }
            function oe(I, A, R, O) {
                he(I),
                he(A),
                he(O),
                he(A),
                he(R),
                he(O);
                const B = r.length / 3
                  , Y = y.generateSideWallUV(i, r, B - 6, B - 3, B - 2, B - 1);
                Re(Y[0]),
                Re(Y[1]),
                Re(Y[3]),
                Re(Y[1]),
                Re(Y[2]),
                Re(Y[3])
            }
            function he(I) {
                r.push(l[I * 3 + 0]),
                r.push(l[I * 3 + 1]),
                r.push(l[I * 3 + 2])
            }
            function Re(I) {
                s.push(I.x),
                s.push(I.y)
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes
          , i = this.parameters.options;
        return NI(t, i, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let s = 0, o = e.shapes.length; s < o; s++) {
            const a = t[e.shapes[s]];
            i.push(a)
        }
        const r = e.options.extrudePath;
        return r !== void 0 && (e.options.extrudePath = new Nu[r.type]().fromJSON(r)),
        new Rh(i,e.options)
    }
}
const DI = {
    generateTopUV: function(n, e, t, i, r) {
        const s = e[t * 3]
          , o = e[t * 3 + 1]
          , a = e[i * 3]
          , l = e[i * 3 + 1]
          , c = e[r * 3]
          , u = e[r * 3 + 1];
        return [new ae(s,o), new ae(a,l), new ae(c,u)]
    },
    generateSideWallUV: function(n, e, t, i, r, s) {
        const o = e[t * 3]
          , a = e[t * 3 + 1]
          , l = e[t * 3 + 2]
          , c = e[i * 3]
          , u = e[i * 3 + 1]
          , h = e[i * 3 + 2]
          , f = e[r * 3]
          , d = e[r * 3 + 1]
          , p = e[r * 3 + 2]
          , v = e[s * 3]
          , g = e[s * 3 + 1]
          , m = e[s * 3 + 2];
        return Math.abs(a - u) < Math.abs(o - c) ? [new ae(o,1 - l), new ae(c,1 - h), new ae(f,1 - p), new ae(v,1 - m)] : [new ae(a,1 - l), new ae(u,1 - h), new ae(d,1 - p), new ae(g,1 - m)]
    }
};
function NI(n, e, t) {
    if (t.shapes = [],
    Array.isArray(n))
        for (let i = 0, r = n.length; i < r; i++) {
            const s = n[i];
            t.shapes.push(s.uuid)
        }
    else
        t.shapes.push(n.uuid);
    return t.options = Object.assign({}, e),
    e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()),
    t
}
class Ph extends Ir {
    constructor(e=1, t=0) {
        const i = (1 + Math.sqrt(5)) / 2
          , r = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1]
          , s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        super(r, s, e, t),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Ph(e.radius,e.detail)
    }
}
class Ml extends Ir {
    constructor(e=1, t=0) {
        const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
          , r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(i, r, e, t),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Ml(e.radius,e.detail)
    }
}
class Ih extends Ze {
    constructor(e=.5, t=1, i=32, r=1, s=0, o=Math.PI * 2) {
        super(),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: r,
            thetaStart: s,
            thetaLength: o
        },
        i = Math.max(3, i),
        r = Math.max(1, r);
        const a = []
          , l = []
          , c = []
          , u = [];
        let h = e;
        const f = (t - e) / r
          , d = new N
          , p = new ae;
        for (let v = 0; v <= r; v++) {
            for (let g = 0; g <= i; g++) {
                const m = s + g / i * o;
                d.x = h * Math.cos(m),
                d.y = h * Math.sin(m),
                l.push(d.x, d.y, d.z),
                c.push(0, 0, 1),
                p.x = (d.x / t + 1) / 2,
                p.y = (d.y / t + 1) / 2,
                u.push(p.x, p.y)
            }
            h += f
        }
        for (let v = 0; v < r; v++) {
            const g = v * (i + 1);
            for (let m = 0; m < i; m++) {
                const y = m + g
                  , _ = y
                  , x = y + i + 1
                  , C = y + i + 2
                  , w = y + 1;
                a.push(_, x, w),
                a.push(x, C, w)
            }
        }
        this.setIndex(a),
        this.setAttribute("position", new Le(l,3)),
        this.setAttribute("normal", new Le(c,3)),
        this.setAttribute("uv", new Le(u,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Ih(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)
    }
}
class Lh extends Ze {
    constructor(e=new ds([new ae(0,.5), new ae(-.5,-.5), new ae(.5,-.5)]), t=12) {
        super(),
        this.type = "ShapeGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        };
        const i = []
          , r = []
          , s = []
          , o = [];
        let a = 0
          , l = 0;
        if (Array.isArray(e) === !1)
            c(e);
        else
            for (let u = 0; u < e.length; u++)
                c(e[u]),
                this.addGroup(a, l, u),
                a += l,
                l = 0;
        this.setIndex(i),
        this.setAttribute("position", new Le(r,3)),
        this.setAttribute("normal", new Le(s,3)),
        this.setAttribute("uv", new Le(o,2));
        function c(u) {
            const h = r.length / 3
              , f = u.extractPoints(t);
            let d = f.shape;
            const p = f.holes;
            yi.isClockWise(d) === !1 && (d = d.reverse());
            for (let g = 0, m = p.length; g < m; g++) {
                const y = p[g];
                yi.isClockWise(y) === !0 && (p[g] = y.reverse())
            }
            const v = yi.triangulateShape(d, p);
            for (let g = 0, m = p.length; g < m; g++) {
                const y = p[g];
                d = d.concat(y)
            }
            for (let g = 0, m = d.length; g < m; g++) {
                const y = d[g];
                r.push(y.x, y.y, 0),
                s.push(0, 0, 1),
                o.push(y.x, y.y)
            }
            for (let g = 0, m = v.length; g < m; g++) {
                const y = v[g]
                  , _ = y[0] + h
                  , x = y[1] + h
                  , C = y[2] + h;
                i.push(_, x, C),
                l += 3
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes;
        return UI(t, e)
    }
    static fromJSON(e, t) {
        const i = [];
        for (let r = 0, s = e.shapes.length; r < s; r++) {
            const o = t[e.shapes[r]];
            i.push(o)
        }
        return new Lh(i,e.curveSegments)
    }
}
function UI(n, e) {
    if (e.shapes = [],
    Array.isArray(n))
        for (let t = 0, i = n.length; t < i; t++) {
            const r = n[t];
            e.shapes.push(r.uuid)
        }
    else
        e.shapes.push(n.uuid);
    return e
}
class Sl extends Ze {
    constructor(e=1, t=32, i=16, r=0, s=Math.PI * 2, o=0, a=Math.PI) {
        super(),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: r,
            phiLength: s,
            thetaStart: o,
            thetaLength: a
        },
        t = Math.max(3, Math.floor(t)),
        i = Math.max(2, Math.floor(i));
        const l = Math.min(o + a, Math.PI);
        let c = 0;
        const u = []
          , h = new N
          , f = new N
          , d = []
          , p = []
          , v = []
          , g = [];
        for (let m = 0; m <= i; m++) {
            const y = []
              , _ = m / i;
            let x = 0;
            m === 0 && o === 0 ? x = .5 / t : m === i && l === Math.PI && (x = -.5 / t);
            for (let C = 0; C <= t; C++) {
                const w = C / t;
                h.x = -e * Math.cos(r + w * s) * Math.sin(o + _ * a),
                h.y = e * Math.cos(o + _ * a),
                h.z = e * Math.sin(r + w * s) * Math.sin(o + _ * a),
                p.push(h.x, h.y, h.z),
                f.copy(h).normalize(),
                v.push(f.x, f.y, f.z),
                g.push(w + x, 1 - _),
                y.push(c++)
            }
            u.push(y)
        }
        for (let m = 0; m < i; m++)
            for (let y = 0; y < t; y++) {
                const _ = u[m][y + 1]
                  , x = u[m][y]
                  , C = u[m + 1][y]
                  , w = u[m + 1][y + 1];
                (m !== 0 || o > 0) && d.push(_, x, w),
                (m !== i - 1 || l < Math.PI) && d.push(x, C, w)
            }
        this.setIndex(d),
        this.setAttribute("position", new Le(p,3)),
        this.setAttribute("normal", new Le(v,3)),
        this.setAttribute("uv", new Le(g,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Sl(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
    }
}
class Dh extends Ir {
    constructor(e=1, t=0) {
        const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]
          , r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(i, r, e, t),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Dh(e.radius,e.detail)
    }
}
class Nh extends Ze {
    constructor(e=1, t=.4, i=12, r=48, s=Math.PI * 2) {
        super(),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: r,
            arc: s
        },
        i = Math.floor(i),
        r = Math.floor(r);
        const o = []
          , a = []
          , l = []
          , c = []
          , u = new N
          , h = new N
          , f = new N;
        for (let d = 0; d <= i; d++)
            for (let p = 0; p <= r; p++) {
                const v = p / r * s
                  , g = d / i * Math.PI * 2;
                h.x = (e + t * Math.cos(g)) * Math.cos(v),
                h.y = (e + t * Math.cos(g)) * Math.sin(v),
                h.z = t * Math.sin(g),
                a.push(h.x, h.y, h.z),
                u.x = e * Math.cos(v),
                u.y = e * Math.sin(v),
                f.subVectors(h, u).normalize(),
                l.push(f.x, f.y, f.z),
                c.push(p / r),
                c.push(d / i)
            }
        for (let d = 1; d <= i; d++)
            for (let p = 1; p <= r; p++) {
                const v = (r + 1) * d + p - 1
                  , g = (r + 1) * (d - 1) + p - 1
                  , m = (r + 1) * (d - 1) + p
                  , y = (r + 1) * d + p;
                o.push(v, g, y),
                o.push(g, m, y)
            }
        this.setIndex(o),
        this.setAttribute("position", new Le(a,3)),
        this.setAttribute("normal", new Le(l,3)),
        this.setAttribute("uv", new Le(c,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Nh(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)
    }
}
class Uh extends Ze {
    constructor(e=1, t=.4, i=64, r=8, s=2, o=3) {
        super(),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: r,
            p: s,
            q: o
        },
        i = Math.floor(i),
        r = Math.floor(r);
        const a = []
          , l = []
          , c = []
          , u = []
          , h = new N
          , f = new N
          , d = new N
          , p = new N
          , v = new N
          , g = new N
          , m = new N;
        for (let _ = 0; _ <= i; ++_) {
            const x = _ / i * s * Math.PI * 2;
            y(x, s, o, e, d),
            y(x + .01, s, o, e, p),
            g.subVectors(p, d),
            m.addVectors(p, d),
            v.crossVectors(g, m),
            m.crossVectors(v, g),
            v.normalize(),
            m.normalize();
            for (let C = 0; C <= r; ++C) {
                const w = C / r * Math.PI * 2
                  , E = -t * Math.cos(w)
                  , L = t * Math.sin(w);
                h.x = d.x + (E * m.x + L * v.x),
                h.y = d.y + (E * m.y + L * v.y),
                h.z = d.z + (E * m.z + L * v.z),
                l.push(h.x, h.y, h.z),
                f.subVectors(h, d).normalize(),
                c.push(f.x, f.y, f.z),
                u.push(_ / i),
                u.push(C / r)
            }
        }
        for (let _ = 1; _ <= i; _++)
            for (let x = 1; x <= r; x++) {
                const C = (r + 1) * (_ - 1) + (x - 1)
                  , w = (r + 1) * _ + (x - 1)
                  , E = (r + 1) * _ + x
                  , L = (r + 1) * (_ - 1) + x;
                a.push(C, w, L),
                a.push(w, E, L)
            }
        this.setIndex(a),
        this.setAttribute("position", new Le(l,3)),
        this.setAttribute("normal", new Le(c,3)),
        this.setAttribute("uv", new Le(u,2));
        function y(_, x, C, w, E) {
            const L = Math.cos(_)
              , S = Math.sin(_)
              , b = C / x * _
              , D = Math.cos(b);
            E.x = w * (2 + D) * .5 * L,
            E.y = w * (2 + D) * S * .5,
            E.z = w * Math.sin(b) * .5
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new Uh(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)
    }
}
class Oh extends Ze {
    constructor(e=new Kp(new N(-1,-1,0),new N(-1,1,0),new N(1,1,0)), t=64, i=1, r=8, s=!1) {
        super(),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: r,
            closed: s
        };
        const o = e.computeFrenetFrames(t, s);
        this.tangents = o.tangents,
        this.normals = o.normals,
        this.binormals = o.binormals;
        const a = new N
          , l = new N
          , c = new ae;
        let u = new N;
        const h = []
          , f = []
          , d = []
          , p = [];
        v(),
        this.setIndex(p),
        this.setAttribute("position", new Le(h,3)),
        this.setAttribute("normal", new Le(f,3)),
        this.setAttribute("uv", new Le(d,2));
        function v() {
            for (let _ = 0; _ < t; _++)
                g(_);
            g(s === !1 ? t : 0),
            y(),
            m()
        }
        function g(_) {
            u = e.getPointAt(_ / t, u);
            const x = o.normals[_]
              , C = o.binormals[_];
            for (let w = 0; w <= r; w++) {
                const E = w / r * Math.PI * 2
                  , L = Math.sin(E)
                  , S = -Math.cos(E);
                l.x = S * x.x + L * C.x,
                l.y = S * x.y + L * C.y,
                l.z = S * x.z + L * C.z,
                l.normalize(),
                f.push(l.x, l.y, l.z),
                a.x = u.x + i * l.x,
                a.y = u.y + i * l.y,
                a.z = u.z + i * l.z,
                h.push(a.x, a.y, a.z)
            }
        }
        function m() {
            for (let _ = 1; _ <= t; _++)
                for (let x = 1; x <= r; x++) {
                    const C = (r + 1) * (_ - 1) + (x - 1)
                      , w = (r + 1) * _ + (x - 1)
                      , E = (r + 1) * _ + x
                      , L = (r + 1) * (_ - 1) + x;
                    p.push(C, w, L),
                    p.push(w, E, L)
                }
        }
        function y() {
            for (let _ = 0; _ <= t; _++)
                for (let x = 0; x <= r; x++)
                    c.x = _ / t,
                    c.y = x / r,
                    d.push(c.x, c.y)
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(),
        e
    }
    static fromJSON(e) {
        return new Oh(new Nu[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)
    }
}
class gb extends Ze {
    constructor(e=null) {
        if (super(),
        this.type = "WireframeGeometry",
        this.parameters = {
            geometry: e
        },
        e !== null) {
            const t = []
              , i = new Set
              , r = new N
              , s = new N;
            if (e.index !== null) {
                const o = e.attributes.position
                  , a = e.index;
                let l = e.groups;
                l.length === 0 && (l = [{
                    start: 0,
                    count: a.count,
                    materialIndex: 0
                }]);
                for (let c = 0, u = l.length; c < u; ++c) {
                    const h = l[c]
                      , f = h.start
                      , d = h.count;
                    for (let p = f, v = f + d; p < v; p += 3)
                        for (let g = 0; g < 3; g++) {
                            const m = a.getX(p + g)
                              , y = a.getX(p + (g + 1) % 3);
                            r.fromBufferAttribute(o, m),
                            s.fromBufferAttribute(o, y),
                            Rv(r, s, i) === !0 && (t.push(r.x, r.y, r.z),
                            t.push(s.x, s.y, s.z))
                        }
                }
            } else {
                const o = e.attributes.position;
                for (let a = 0, l = o.count / 3; a < l; a++)
                    for (let c = 0; c < 3; c++) {
                        const u = 3 * a + c
                          , h = 3 * a + (c + 1) % 3;
                        r.fromBufferAttribute(o, u),
                        s.fromBufferAttribute(o, h),
                        Rv(r, s, i) === !0 && (t.push(r.x, r.y, r.z),
                        t.push(s.x, s.y, s.z))
                    }
            }
            this.setAttribute("position", new Le(t,3))
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
}
function Rv(n, e, t) {
    const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`
      , r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
    return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i),
    t.add(r),
    !0)
}
var Pv = Object.freeze({
    __proto__: null,
    BoxGeometry: Ss,
    CapsuleGeometry: wh,
    CircleGeometry: Eh,
    ConeGeometry: Ah,
    CylinderGeometry: Fo,
    DodecahedronGeometry: Th,
    EdgesGeometry: fb,
    ExtrudeGeometry: Rh,
    IcosahedronGeometry: Ph,
    LatheGeometry: bl,
    OctahedronGeometry: Ml,
    PlaneGeometry: Uo,
    PolyhedronGeometry: Ir,
    RingGeometry: Ih,
    ShapeGeometry: Lh,
    SphereGeometry: Sl,
    TetrahedronGeometry: Dh,
    TorusGeometry: Nh,
    TorusKnotGeometry: Uh,
    TubeGeometry: Oh,
    WireframeGeometry: gb
});
class vb extends cn {
    constructor(e) {
        super(),
        this.isShadowMaterial = !0,
        this.type = "ShadowMaterial",
        this.color = new Ee(0),
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.fog = e.fog,
        this
    }
}
class _b extends oi {
    constructor(e) {
        super(e),
        this.isRawShaderMaterial = !0,
        this.type = "RawShaderMaterial"
    }
}
class Jp extends cn {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Ee(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ee(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Pr,
        this.normalScale = new ae(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Un,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class yb extends Jp {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.anisotropyRotation = 0,
        this.anisotropyMap = null,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new ae(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return It(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new Ee(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new Ee(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new Ee(1,1,1),
        this.specularColorMap = null,
        this._anisotropy = 0,
        this._clearcoat = 0,
        this._dispersion = 0,
        this._iridescence = 0,
        this._sheen = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++,
        this._anisotropy = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get dispersion() {
        return this._dispersion
    }
    set dispersion(e) {
        this._dispersion > 0 != e > 0 && this.version++,
        this._dispersion = e
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.anisotropy = e.anisotropy,
        this.anisotropyRotation = e.anisotropyRotation,
        this.anisotropyMap = e.anisotropyMap,
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.dispersion = e.dispersion,
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
class xb extends cn {
    constructor(e) {
        super(),
        this.isMeshPhongMaterial = !0,
        this.type = "MeshPhongMaterial",
        this.color = new Ee(16777215),
        this.specular = new Ee(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ee(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Pr,
        this.normalScale = new ae(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Un,
        this.combine = ml,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class bb extends cn {
    constructor(e) {
        super(),
        this.isMeshToonMaterial = !0,
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new Ee(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ee(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Pr,
        this.normalScale = new ae(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.gradientMap = e.gradientMap,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
class Mb extends cn {
    constructor(e) {
        super(),
        this.isMeshNormalMaterial = !0,
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Pr,
        this.normalScale = new ae(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.flatShading = e.flatShading,
        this
    }
}
class Sb extends cn {
    constructor(e) {
        super(),
        this.isMeshLambertMaterial = !0,
        this.type = "MeshLambertMaterial",
        this.color = new Ee(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ee(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Pr,
        this.normalScale = new ae(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Un,
        this.combine = ml,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class wb extends cn {
    constructor(e) {
        super(),
        this.isMeshMatcapMaterial = !0,
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new Ee(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Pr,
        this.normalScale = new ae(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class Eb extends xn {
    constructor(e) {
        super(),
        this.isLineDashedMaterial = !0,
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
}
function ss(n, e, t) {
    return !n || !t && n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n)
}
function Ab(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView)
}
function Tb(n) {
    function e(r, s) {
        return n[r] - n[s]
    }
    const t = n.length
      , i = new Array(t);
    for (let r = 0; r !== t; ++r)
        i[r] = r;
    return i.sort(e),
    i
}
function Nd(n, e, t) {
    const i = n.length
      , r = new n.constructor(i);
    for (let s = 0, o = 0; o !== i; ++s) {
        const a = t[s] * e;
        for (let l = 0; l !== e; ++l)
            r[o++] = n[a + l]
    }
    return r
}
function Qp(n, e, t, i) {
    let r = 1
      , s = n[0];
    for (; s !== void 0 && s[i] === void 0; )
        s = n[r++];
    if (s === void 0)
        return;
    let o = s[i];
    if (o !== void 0)
        if (Array.isArray(o))
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                t.push.apply(t, o)),
                s = n[r++];
            while (s !== void 0);
        else if (o.toArray !== void 0)
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                o.toArray(t, t.length)),
                s = n[r++];
            while (s !== void 0);
        else
            do
                o = s[i],
                o !== void 0 && (e.push(s.time),
                t.push(o)),
                s = n[r++];
            while (s !== void 0)
}
function OI(n, e, t, i, r=30) {
    const s = n.clone();
    s.name = e;
    const o = [];
    for (let l = 0; l < s.tracks.length; ++l) {
        const c = s.tracks[l]
          , u = c.getValueSize()
          , h = []
          , f = [];
        for (let d = 0; d < c.times.length; ++d) {
            const p = c.times[d] * r;
            if (!(p < t || p >= i)) {
                h.push(c.times[d]);
                for (let v = 0; v < u; ++v)
                    f.push(c.values[d * u + v])
            }
        }
        h.length !== 0 && (c.times = ss(h, c.times.constructor),
        c.values = ss(f, c.values.constructor),
        o.push(c))
    }
    s.tracks = o;
    let a = 1 / 0;
    for (let l = 0; l < s.tracks.length; ++l)
        a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
    for (let l = 0; l < s.tracks.length; ++l)
        s.tracks[l].shift(-1 * a);
    return s.resetDuration(),
    s
}
function FI(n, e=0, t=n, i=30) {
    i <= 0 && (i = 30);
    const r = t.tracks.length
      , s = e / i;
    for (let o = 0; o < r; ++o) {
        const a = t.tracks[o]
          , l = a.ValueTypeName;
        if (l === "bool" || l === "string")
            continue;
        const c = n.tracks.find(function(m) {
            return m.name === a.name && m.ValueTypeName === l
        });
        if (c === void 0)
            continue;
        let u = 0;
        const h = a.getValueSize();
        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = h / 3);
        let f = 0;
        const d = c.getValueSize();
        c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (f = d / 3);
        const p = a.times.length - 1;
        let v;
        if (s <= a.times[0]) {
            const m = u
              , y = h - u;
            v = a.values.slice(m, y)
        } else if (s >= a.times[p]) {
            const m = p * h + u
              , y = m + h - u;
            v = a.values.slice(m, y)
        } else {
            const m = a.createInterpolant()
              , y = u
              , _ = h - u;
            m.evaluate(s),
            v = m.resultBuffer.slice(y, _)
        }
        l === "quaternion" && new Sn().fromArray(v).normalize().conjugate().toArray(v);
        const g = c.times.length;
        for (let m = 0; m < g; ++m) {
            const y = m * d + f;
            if (l === "quaternion")
                Sn.multiplyQuaternionsFlat(c.values, y, v, 0, c.values, y);
            else {
                const _ = d - f * 2;
                for (let x = 0; x < _; ++x)
                    c.values[y + x] -= v[x]
            }
        }
    }
    return n.blendMode = Lp,
    n
}
const BI = {
    convertArray: ss,
    isTypedArray: Ab,
    getKeyframeOrder: Tb,
    sortedArray: Nd,
    flattenJSON: Qp,
    subclip: OI,
    makeClipAdditive: FI
};
class wl {
    constructor(e, t, i, r) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = r !== void 0 ? r : new t.constructor(i),
        this.sampleValues = t,
        this.valueSize = i,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let i = this._cachedIndex
          , r = t[i]
          , s = t[i - 1];
        e: {
            t: {
                let o;
                n: {
                    i: if (!(e < r)) {
                        for (let a = i + 2; ; ) {
                            if (r === void 0) {
                                if (e < s)
                                    break i;
                                return i = t.length,
                                this._cachedIndex = i,
                                this.copySampleValue_(i - 1)
                            }
                            if (i === a)
                                break;
                            if (s = r,
                            r = t[++i],
                            e < r)
                                break t
                        }
                        o = t.length;
                        break n
                    }
                    if (!(e >= s)) {
                        const a = t[1];
                        e < a && (i = 2,
                        s = a);
                        for (let l = i - 2; ; ) {
                            if (s === void 0)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (i === l)
                                break;
                            if (r = s,
                            s = t[--i - 1],
                            e >= s)
                                break t
                        }
                        o = i,
                        i = 0;
                        break n
                    }
                    break e
                }
                for (; i < o; ) {
                    const a = i + o >>> 1;
                    e < t[a] ? o = a : i = a + 1
                }
                if (r = t[i],
                s = t[i - 1],
                s === void 0)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (r === void 0)
                    return i = t.length,
                    this._cachedIndex = i,
                    this.copySampleValue_(i - 1)
            }
            this._cachedIndex = i,
            this.intervalChanged_(i, s, r)
        }
        return this.interpolate_(i, s, e, r)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , i = this.sampleValues
          , r = this.valueSize
          , s = e * r;
        for (let o = 0; o !== r; ++o)
            t[o] = i[s + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class Cb extends wl {
    constructor(e, t, i, r) {
        super(e, t, i, r),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: ns,
            endingEnd: ns
        }
    }
    intervalChanged_(e, t, i) {
        const r = this.parameterPositions;
        let s = e - 2
          , o = e + 1
          , a = r[s]
          , l = r[o];
        if (a === void 0)
            switch (this.getSettings_().endingStart) {
            case is:
                s = e,
                a = 2 * t - i;
                break;
            case Wa:
                s = r.length - 2,
                a = t + r[s] - r[s + 1];
                break;
            default:
                s = e,
                a = i
            }
        if (l === void 0)
            switch (this.getSettings_().endingEnd) {
            case is:
                o = e,
                l = 2 * i - t;
                break;
            case Wa:
                o = 1,
                l = i + r[1] - r[0];
                break;
            default:
                o = e - 1,
                l = t
            }
        const c = (i - t) * .5
          , u = this.valueSize;
        this._weightPrev = c / (t - a),
        this._weightNext = c / (l - i),
        this._offsetPrev = s * u,
        this._offsetNext = o * u
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , c = l - a
          , u = this._offsetPrev
          , h = this._offsetNext
          , f = this._weightPrev
          , d = this._weightNext
          , p = (i - t) / (r - t)
          , v = p * p
          , g = v * p
          , m = -f * g + 2 * f * v - f * p
          , y = (1 + f) * g + (-1.5 - 2 * f) * v + (-.5 + f) * p + 1
          , _ = (-1 - d) * g + (1.5 + d) * v + .5 * p
          , x = d * g - d * v;
        for (let C = 0; C !== a; ++C)
            s[C] = m * o[u + C] + y * o[c + C] + _ * o[l + C] + x * o[h + C];
        return s
    }
}
class em extends wl {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , c = l - a
          , u = (i - t) / (r - t)
          , h = 1 - u;
        for (let f = 0; f !== a; ++f)
            s[f] = o[c + f] * h + o[l + f] * u;
        return s
    }
}
class Rb extends wl {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class ci {
    constructor(e, t, i, r) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = ss(t, this.TimeBufferType),
        this.values = ss(i, this.ValueBufferType),
        this.setInterpolation(r || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let i;
        if (t.toJSON !== this.toJSON)
            i = t.toJSON(e);
        else {
            i = {
                name: e.name,
                times: ss(e.times, Array),
                values: ss(e.values, Array)
            };
            const r = e.getInterpolation();
            r !== e.DefaultInterpolation && (i.interpolation = r)
        }
        return i.type = e.ValueTypeName,
        i
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new Rb(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new em(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new Cb(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case Ga:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case Iu:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case Vc:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(i);
            return console.warn("THREE.KeyframeTrack:", i),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return Ga;
        case this.InterpolantFactoryMethodLinear:
            return Iu;
        case this.InterpolantFactoryMethodSmooth:
            return Vc
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i)
                t[i] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i)
                t[i] *= e
        }
        return this
    }
    trim(e, t) {
        const i = this.times
          , r = i.length;
        let s = 0
          , o = r - 1;
        for (; s !== r && i[s] < e; )
            ++s;
        for (; o !== -1 && i[o] > t; )
            --o;
        if (++o,
        s !== 0 || o !== r) {
            s >= o && (o = Math.max(o, 1),
            s = o - 1);
            const a = this.getValueSize();
            this.times = i.slice(s, o),
            this.values = this.values.slice(s * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const i = this.times
          , r = this.values
          , s = i.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let o = null;
        for (let a = 0; a !== s; a++) {
            const l = i[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l),
                e = !1;
                break
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
                e = !1;
                break
            }
            o = l
        }
        if (r !== void 0 && Ab(r))
            for (let a = 0, l = r.length; a !== l; ++a) {
                const c = r[a];
                if (isNaN(c)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = this.times.slice()
          , t = this.values.slice()
          , i = this.getValueSize()
          , r = this.getInterpolation() === Vc
          , s = e.length - 1;
        let o = 1;
        for (let a = 1; a < s; ++a) {
            let l = !1;
            const c = e[a]
              , u = e[a + 1];
            if (c !== u && (a !== 1 || c !== e[0]))
                if (r)
                    l = !0;
                else {
                    const h = a * i
                      , f = h - i
                      , d = h + i;
                    for (let p = 0; p !== i; ++p) {
                        const v = t[h + p];
                        if (v !== t[f + p] || v !== t[d + p]) {
                            l = !0;
                            break
                        }
                    }
                }
            if (l) {
                if (a !== o) {
                    e[o] = e[a];
                    const h = a * i
                      , f = o * i;
                    for (let d = 0; d !== i; ++d)
                        t[f + d] = t[h + d]
                }
                ++o
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for (let a = s * i, l = o * i, c = 0; c !== i; ++c)
                t[l + c] = t[a + c];
            ++o
        }
        return o !== e.length ? (this.times = e.slice(0, o),
        this.values = t.slice(0, o * i)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        const e = this.times.slice()
          , t = this.values.slice()
          , i = this.constructor
          , r = new i(this.name,e,t);
        return r.createInterpolant = this.createInterpolant,
        r
    }
}
ci.prototype.TimeBufferType = Float32Array;
ci.prototype.ValueBufferType = Float32Array;
ci.prototype.DefaultInterpolation = Iu;
class ws extends ci {
    constructor(e, t, i) {
        super(e, t, i)
    }
}
ws.prototype.ValueTypeName = "bool";
ws.prototype.ValueBufferType = Array;
ws.prototype.DefaultInterpolation = Ga;
ws.prototype.InterpolantFactoryMethodLinear = void 0;
ws.prototype.InterpolantFactoryMethodSmooth = void 0;
class tm extends ci {
}
tm.prototype.ValueTypeName = "color";
class tl extends ci {
}
tl.prototype.ValueTypeName = "number";
class Pb extends wl {
    constructor(e, t, i, r) {
        super(e, t, i, r)
    }
    interpolate_(e, t, i, r) {
        const s = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = (i - t) / (r - t);
        let c = e * a;
        for (let u = c + a; c !== u; c += 4)
            Sn.slerpFlat(s, 0, o, c - a, o, c, l);
        return s
    }
}
class El extends ci {
    InterpolantFactoryMethodLinear(e) {
        return new Pb(this.times,this.values,this.getValueSize(),e)
    }
}
El.prototype.ValueTypeName = "quaternion";
El.prototype.InterpolantFactoryMethodSmooth = void 0;
class Es extends ci {
    constructor(e, t, i) {
        super(e, t, i)
    }
}
Es.prototype.ValueTypeName = "string";
Es.prototype.ValueBufferType = Array;
Es.prototype.DefaultInterpolation = Ga;
Es.prototype.InterpolantFactoryMethodLinear = void 0;
Es.prototype.InterpolantFactoryMethodSmooth = void 0;
class nl extends ci {
}
nl.prototype.ValueTypeName = "vector";
class il {
    constructor(e="", t=-1, i=[], r=hh) {
        this.name = e,
        this.tracks = i,
        this.duration = t,
        this.blendMode = r,
        this.uuid = Nn(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = []
          , i = e.tracks
          , r = 1 / (e.fps || 1);
        for (let o = 0, a = i.length; o !== a; ++o)
            t.push(kI(i[o]).scale(r));
        const s = new this(e.name,e.duration,t,e.blendMode);
        return s.uuid = e.uuid,
        s
    }
    static toJSON(e) {
        const t = []
          , i = e.tracks
          , r = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let s = 0, o = i.length; s !== o; ++s)
            t.push(ci.toJSON(i[s]));
        return r
    }
    static CreateFromMorphTargetSequence(e, t, i, r) {
        const s = t.length
          , o = [];
        for (let a = 0; a < s; a++) {
            let l = []
              , c = [];
            l.push((a + s - 1) % s, a, (a + 1) % s),
            c.push(0, 1, 0);
            const u = Tb(l);
            l = Nd(l, 1, u),
            c = Nd(c, 1, u),
            !r && l[0] === 0 && (l.push(s),
            c.push(c[0])),
            o.push(new tl(".morphTargetInfluences[" + t[a].name + "]",l,c).scale(1 / i))
        }
        return new this(e,-1,o)
    }
    static findByName(e, t) {
        let i = e;
        if (!Array.isArray(e)) {
            const r = e;
            i = r.geometry && r.geometry.animations || r.animations
        }
        for (let r = 0; r < i.length; r++)
            if (i[r].name === t)
                return i[r];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, i) {
        const r = {}
          , s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a]
              , u = c.name.match(s);
            if (u && u.length > 1) {
                const h = u[1];
                let f = r[h];
                f || (r[h] = f = []),
                f.push(c)
            }
        }
        const o = [];
        for (const a in r)
            o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
        return o
    }
    static parseAnimation(e, t) {
        if (!e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const i = function(h, f, d, p, v) {
            if (d.length !== 0) {
                const g = []
                  , m = [];
                Qp(d, g, m, p),
                g.length !== 0 && v.push(new h(f,g,m))
            }
        }
          , r = []
          , s = e.name || "default"
          , o = e.fps || 30
          , a = e.blendMode;
        let l = e.length || -1;
        const c = e.hierarchy || [];
        for (let h = 0; h < c.length; h++) {
            const f = c[h].keys;
            if (!(!f || f.length === 0))
                if (f[0].morphTargets) {
                    const d = {};
                    let p;
                    for (p = 0; p < f.length; p++)
                        if (f[p].morphTargets)
                            for (let v = 0; v < f[p].morphTargets.length; v++)
                                d[f[p].morphTargets[v]] = -1;
                    for (const v in d) {
                        const g = []
                          , m = [];
                        for (let y = 0; y !== f[p].morphTargets.length; ++y) {
                            const _ = f[p];
                            g.push(_.time),
                            m.push(_.morphTarget === v ? 1 : 0)
                        }
                        r.push(new tl(".morphTargetInfluence[" + v + "]",g,m))
                    }
                    l = d.length * o
                } else {
                    const d = ".bones[" + t[h].name + "]";
                    i(nl, d + ".position", f, "pos", r),
                    i(El, d + ".quaternion", f, "rot", r),
                    i(nl, d + ".scale", f, "scl", r)
                }
        }
        return r.length === 0 ? null : new this(s,l,r,a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let i = 0, r = e.length; i !== r; ++i) {
            const s = this.tracks[i];
            t = Math.max(t, s.times[s.times.length - 1])
        }
        return this.duration = t,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function zI(n) {
    switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return tl;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return nl;
    case "color":
        return tm;
    case "quaternion":
        return El;
    case "bool":
    case "boolean":
        return ws;
    case "string":
        return Es
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n)
}
function kI(n) {
    if (n.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = zI(n.type);
    if (n.times === void 0) {
        const t = []
          , i = [];
        Qp(n.keys, t, i, "value"),
        n.times = t,
        n.values = i
    }
    return e.parse !== void 0 ? e.parse(n) : new e(n.name,n.times,n.values,n.interpolation)
}
const zi = {
    enabled: !1,
    files: {},
    add: function(n, e) {
        this.enabled !== !1 && (this.files[n] = e)
    },
    get: function(n) {
        if (this.enabled !== !1)
            return this.files[n]
    },
    remove: function(n) {
        delete this.files[n]
    },
    clear: function() {
        this.files = {}
    }
};
class nm {
    constructor(e, t, i) {
        const r = this;
        let s = !1, o = 0, a = 0, l;
        const c = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = i,
        this.itemStart = function(u) {
            a++,
            s === !1 && r.onStart !== void 0 && r.onStart(u, o, a),
            s = !0
        }
        ,
        this.itemEnd = function(u) {
            o++,
            r.onProgress !== void 0 && r.onProgress(u, o, a),
            o === a && (s = !1,
            r.onLoad !== void 0 && r.onLoad())
        }
        ,
        this.itemError = function(u) {
            r.onError !== void 0 && r.onError(u)
        }
        ,
        this.resolveURL = function(u) {
            return l ? l(u) : u
        }
        ,
        this.setURLModifier = function(u) {
            return l = u,
            this
        }
        ,
        this.addHandler = function(u, h) {
            return c.push(u, h),
            this
        }
        ,
        this.removeHandler = function(u) {
            const h = c.indexOf(u);
            return h !== -1 && c.splice(h, 2),
            this
        }
        ,
        this.getHandler = function(u) {
            for (let h = 0, f = c.length; h < f; h += 2) {
                const d = c[h]
                  , p = c[h + 1];
                if (d.global && (d.lastIndex = 0),
                d.test(u))
                    return p
            }
            return null
        }
    }
}
const Ib = new nm;
class wn {
    constructor(e) {
        this.manager = e !== void 0 ? e : Ib,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const i = this;
        return new Promise(function(r, s) {
            i.load(e, r, t, s)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
wn.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Li = {};
class VI extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class $i extends wn {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = zi.get(e);
        if (s !== void 0)
            return this.manager.itemStart(e),
            setTimeout( () => {
                t && t(s),
                this.manager.itemEnd(e)
            }
            , 0),
            s;
        if (Li[e] !== void 0) {
            Li[e].push({
                onLoad: t,
                onProgress: i,
                onError: r
            });
            return
        }
        Li[e] = [],
        Li[e].push({
            onLoad: t,
            onProgress: i,
            onError: r
        });
        const o = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , a = this.mimeType
          , l = this.responseType;
        fetch(o).then(c => {
            if (c.status === 200 || c.status === 0) {
                if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
                    return c;
                const u = Li[e]
                  , h = c.body.getReader()
                  , f = c.headers.get("X-File-Size") || c.headers.get("Content-Length")
                  , d = f ? parseInt(f) : 0
                  , p = d !== 0;
                let v = 0;
                const g = new ReadableStream({
                    start(m) {
                        y();
                        function y() {
                            h.read().then( ({done: _, value: x}) => {
                                if (_)
                                    m.close();
                                else {
                                    v += x.byteLength;
                                    const C = new ProgressEvent("progress",{
                                        lengthComputable: p,
                                        loaded: v,
                                        total: d
                                    });
                                    for (let w = 0, E = u.length; w < E; w++) {
                                        const L = u[w];
                                        L.onProgress && L.onProgress(C)
                                    }
                                    m.enqueue(x),
                                    y()
                                }
                            }
                            , _ => {
                                m.error(_)
                            }
                            )
                        }
                    }
                });
                return new Response(g)
            } else
                throw new VI(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)
        }
        ).then(c => {
            switch (l) {
            case "arraybuffer":
                return c.arrayBuffer();
            case "blob":
                return c.blob();
            case "document":
                return c.text().then(u => new DOMParser().parseFromString(u, a));
            case "json":
                return c.json();
            default:
                if (a === void 0)
                    return c.text();
                {
                    const h = /charset="?([^;"\s]*)"?/i.exec(a)
                      , f = h && h[1] ? h[1].toLowerCase() : void 0
                      , d = new TextDecoder(f);
                    return c.arrayBuffer().then(p => d.decode(p))
                }
            }
        }
        ).then(c => {
            zi.add(e, c);
            const u = Li[e];
            delete Li[e];
            for (let h = 0, f = u.length; h < f; h++) {
                const d = u[h];
                d.onLoad && d.onLoad(c)
            }
        }
        ).catch(c => {
            const u = Li[e];
            if (u === void 0)
                throw this.manager.itemError(e),
                c;
            delete Li[e];
            for (let h = 0, f = u.length; h < f; h++) {
                const d = u[h];
                d.onError && d.onError(c)
            }
            this.manager.itemError(e)
        }
        ).finally( () => {
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class HI extends wn {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new $i(this.manager);
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = [];
        for (let i = 0; i < e.length; i++) {
            const r = il.parse(e[i]);
            t.push(r)
        }
        return t
    }
}
class GI extends wn {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = []
          , a = new Mh
          , l = new $i(this.manager);
        l.setPath(this.path),
        l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(s.withCredentials);
        let c = 0;
        function u(h) {
            l.load(e[h], function(f) {
                const d = s.parse(f, !0);
                o[h] = {
                    width: d.width,
                    height: d.height,
                    format: d.format,
                    mipmaps: d.mipmaps
                },
                c += 1,
                c === 6 && (d.mipmapCount === 1 && (a.minFilter = Gt),
                a.image = o,
                a.format = d.format,
                a.needsUpdate = !0,
                t && t(a))
            }, i, r)
        }
        if (Array.isArray(e))
            for (let h = 0, f = e.length; h < f; ++h)
                u(h);
        else
            l.load(e, function(h) {
                const f = s.parse(h, !0);
                if (f.isCubemap) {
                    const d = f.mipmaps.length / f.mipmapCount;
                    for (let p = 0; p < d; p++) {
                        o[p] = {
                            mipmaps: []
                        };
                        for (let v = 0; v < f.mipmapCount; v++)
                            o[p].mipmaps.push(f.mipmaps[p * f.mipmapCount + v]),
                            o[p].format = f.format,
                            o[p].width = f.width,
                            o[p].height = f.height
                    }
                    a.image = o
                } else
                    a.image.width = f.width,
                    a.image.height = f.height,
                    a.mipmaps = f.mipmaps;
                f.mipmapCount === 1 && (a.minFilter = Gt),
                a.format = f.format,
                a.needsUpdate = !0,
                t && t(a)
            }, i, r);
        return a
    }
}
class rl extends wn {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = zi.get(e);
        if (o !== void 0)
            return s.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o;
        const a = Ka("img");
        function l() {
            u(),
            zi.add(e, this),
            t && t(this),
            s.manager.itemEnd(e)
        }
        function c(h) {
            u(),
            r && r(h),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        }
        function u() {
            a.removeEventListener("load", l, !1),
            a.removeEventListener("error", c, !1)
        }
        return a.addEventListener("load", l, !1),
        a.addEventListener("error", c, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        s.manager.itemStart(e),
        a.src = e,
        a
    }
}
class WI extends wn {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new yl;
        s.colorSpace = Rn;
        const o = new rl(this.manager);
        o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path);
        let a = 0;
        function l(c) {
            o.load(e[c], function(u) {
                s.images[c] = u,
                a++,
                a === 6 && (s.needsUpdate = !0,
                t && t(s))
            }, void 0, r)
        }
        for (let c = 0; c < e.length; ++c)
            l(c);
        return s
    }
}
class XI extends wn {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new _i
          , a = new $i(this.manager);
        return a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader),
        a.setPath(this.path),
        a.setWithCredentials(s.withCredentials),
        a.load(e, function(l) {
            let c;
            try {
                c = s.parse(l)
            } catch (u) {
                if (r !== void 0)
                    r(u);
                else {
                    console.error(u);
                    return
                }
            }
            c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width,
            o.image.height = c.height,
            o.image.data = c.data),
            o.wrapS = c.wrapS !== void 0 ? c.wrapS : Gn,
            o.wrapT = c.wrapT !== void 0 ? c.wrapT : Gn,
            o.magFilter = c.magFilter !== void 0 ? c.magFilter : Gt,
            o.minFilter = c.minFilter !== void 0 ? c.minFilter : Gt,
            o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1,
            c.colorSpace !== void 0 && (o.colorSpace = c.colorSpace),
            c.flipY !== void 0 && (o.flipY = c.flipY),
            c.format !== void 0 && (o.format = c.format),
            c.type !== void 0 && (o.type = c.type),
            c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps,
            o.minFilter = pi),
            c.mipmapCount === 1 && (o.minFilter = Gt),
            c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps),
            o.needsUpdate = !0,
            t && t(o, c)
        }, i, r),
        o
    }
}
class qI extends wn {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = new Dt
          , o = new rl(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(a) {
            s.image = a,
            s.needsUpdate = !0,
            t !== void 0 && t(s)
        }, i, r),
        s
    }
}
class Lr extends tt {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new Ee(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        this.target !== void 0 && (t.object.target = this.target.uuid),
        t
    }
}
class Lb extends Lr {
    constructor(e, t, i) {
        super(e, i),
        this.isHemisphereLight = !0,
        this.type = "HemisphereLight",
        this.position.copy(tt.DEFAULT_UP),
        this.updateMatrix(),
        this.groundColor = new Ee(t)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.groundColor.copy(e.groundColor),
        this
    }
}
const jf = new Be
  , Iv = new N
  , Lv = new N;
class im {
    constructor(e) {
        this.camera = e,
        this.intensity = 1,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new ae(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new Be,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new xl,
        this._frameExtents = new ae(1,1),
        this._viewportCount = 1,
        this._viewports = [new ft(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , i = this.matrix;
        Iv.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(Iv),
        Lv.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(Lv),
        t.updateMatrixWorld(),
        jf.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(jf),
        i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        i.multiply(jf)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.intensity = e.intensity,
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.intensity !== 1 && (e.intensity = this.intensity),
        this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class $I extends im {
    constructor() {
        super(new Ht(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera
          , i = Mo * 2 * e.angle * this.focus
          , r = this.mapSize.width / this.mapSize.height
          , s = e.distance || t.far;
        (i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i,
        t.aspect = r,
        t.far = s,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class Db extends Lr {
    constructor(e, t, i=0, r=Math.PI / 3, s=0, o=2) {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(tt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new tt,
        this.distance = i,
        this.angle = r,
        this.penumbra = s,
        this.decay = o,
        this.map = null,
        this.shadow = new $I
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const Dv = new Be
  , Qo = new N
  , Kf = new N;
class YI extends im {
    constructor() {
        super(new Ht(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new ae(4,2),
        this._viewportCount = 6,
        this._viewports = [new ft(2,1,1,1), new ft(0,1,1,1), new ft(3,1,1,1), new ft(1,1,1,1), new ft(3,0,1,1), new ft(1,0,1,1)],
        this._cubeDirections = [new N(1,0,0), new N(-1,0,0), new N(0,0,1), new N(0,0,-1), new N(0,1,0), new N(0,-1,0)],
        this._cubeUps = [new N(0,1,0), new N(0,1,0), new N(0,1,0), new N(0,1,0), new N(0,0,1), new N(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        const i = this.camera
          , r = this.matrix
          , s = e.distance || i.far;
        s !== i.far && (i.far = s,
        i.updateProjectionMatrix()),
        Qo.setFromMatrixPosition(e.matrixWorld),
        i.position.copy(Qo),
        Kf.copy(i.position),
        Kf.add(this._cubeDirections[t]),
        i.up.copy(this._cubeUps[t]),
        i.lookAt(Kf),
        i.updateMatrixWorld(),
        r.makeTranslation(-Qo.x, -Qo.y, -Qo.z),
        Dv.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Dv)
    }
}
class Nb extends Lr {
    constructor(e, t, i=0, r=2) {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = i,
        this.decay = r,
        this.shadow = new YI
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class jI extends im {
    constructor() {
        super(new mh(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class Ub extends Lr {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(tt.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new tt,
        this.shadow = new jI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class Ob extends Lr {
    constructor(e, t) {
        super(e, t),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
class Fb extends Lr {
    constructor(e, t, i=10, r=10) {
        super(e, t),
        this.isRectAreaLight = !0,
        this.type = "RectAreaLight",
        this.width = i,
        this.height = r
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI)
    }
    copy(e) {
        return super.copy(e),
        this.width = e.width,
        this.height = e.height,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.width = this.width,
        t.object.height = this.height,
        t
    }
}
class Bb {
    constructor() {
        this.isSphericalHarmonics3 = !0,
        this.coefficients = [];
        for (let e = 0; e < 9; e++)
            this.coefficients.push(new N)
    }
    set(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].copy(e[t]);
        return this
    }
    zero() {
        for (let e = 0; e < 9; e++)
            this.coefficients[e].set(0, 0, 0);
        return this
    }
    getAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.282095),
        t.addScaledVector(o[1], .488603 * r),
        t.addScaledVector(o[2], .488603 * s),
        t.addScaledVector(o[3], .488603 * i),
        t.addScaledVector(o[4], 1.092548 * (i * r)),
        t.addScaledVector(o[5], 1.092548 * (r * s)),
        t.addScaledVector(o[6], .315392 * (3 * s * s - 1)),
        t.addScaledVector(o[7], 1.092548 * (i * s)),
        t.addScaledVector(o[8], .546274 * (i * i - r * r)),
        t
    }
    getIrradianceAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z
          , o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.886227),
        t.addScaledVector(o[1], 2 * .511664 * r),
        t.addScaledVector(o[2], 2 * .511664 * s),
        t.addScaledVector(o[3], 2 * .511664 * i),
        t.addScaledVector(o[4], 2 * .429043 * i * r),
        t.addScaledVector(o[5], 2 * .429043 * r * s),
        t.addScaledVector(o[6], .743125 * s * s - .247708),
        t.addScaledVector(o[7], 2 * .429043 * i * s),
        t.addScaledVector(o[8], .429043 * (i * i - r * r)),
        t
    }
    add(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
        return this
    }
    addScaledSH(e, t) {
        for (let i = 0; i < 9; i++)
            this.coefficients[i].addScaledVector(e.coefficients[i], t);
        return this
    }
    scale(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].multiplyScalar(e);
        return this
    }
    lerp(e, t) {
        for (let i = 0; i < 9; i++)
            this.coefficients[i].lerp(e.coefficients[i], t);
        return this
    }
    equals(e) {
        for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t]))
                return !1;
        return !0
    }
    copy(e) {
        return this.set(e.coefficients)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    fromArray(e, t=0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++)
            i[r].fromArray(e, t + r * 3);
        return this
    }
    toArray(e=[], t=0) {
        const i = this.coefficients;
        for (let r = 0; r < 9; r++)
            i[r].toArray(e, t + r * 3);
        return e
    }
    static getBasisAt(e, t) {
        const i = e.x
          , r = e.y
          , s = e.z;
        t[0] = .282095,
        t[1] = .488603 * r,
        t[2] = .488603 * s,
        t[3] = .488603 * i,
        t[4] = 1.092548 * i * r,
        t[5] = 1.092548 * r * s,
        t[6] = .315392 * (3 * s * s - 1),
        t[7] = 1.092548 * i * s,
        t[8] = .546274 * (i * i - r * r)
    }
}
class zb extends Lr {
    constructor(e=new Bb, t=1) {
        super(void 0, t),
        this.isLightProbe = !0,
        this.sh = e
    }
    copy(e) {
        return super.copy(e),
        this.sh.copy(e.sh),
        this
    }
    fromJSON(e) {
        return this.intensity = e.intensity,
        this.sh.fromArray(e.sh),
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.sh = this.sh.toArray(),
        t
    }
}
class Fh extends wn {
    constructor(e) {
        super(e),
        this.textures = {}
    }
    load(e, t, i, r) {
        const s = this
          , o = new $i(s.manager);
        o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = this.textures;
        function i(s) {
            return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s),
            t[s]
        }
        const r = Fh.createMaterialFromType(e.type);
        if (e.uuid !== void 0 && (r.uuid = e.uuid),
        e.name !== void 0 && (r.name = e.name),
        e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
        e.roughness !== void 0 && (r.roughness = e.roughness),
        e.metalness !== void 0 && (r.metalness = e.metalness),
        e.sheen !== void 0 && (r.sheen = e.sheen),
        e.sheenColor !== void 0 && (r.sheenColor = new Ee().setHex(e.sheenColor)),
        e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
        e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive),
        e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular),
        e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity),
        e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor),
        e.shininess !== void 0 && (r.shininess = e.shininess),
        e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
        e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness),
        e.dispersion !== void 0 && (r.dispersion = e.dispersion),
        e.iridescence !== void 0 && (r.iridescence = e.iridescence),
        e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
        e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
        e.transmission !== void 0 && (r.transmission = e.transmission),
        e.thickness !== void 0 && (r.thickness = e.thickness),
        e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance),
        e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor),
        e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy),
        e.anisotropyRotation !== void 0 && (r.anisotropyRotation = e.anisotropyRotation),
        e.fog !== void 0 && (r.fog = e.fog),
        e.flatShading !== void 0 && (r.flatShading = e.flatShading),
        e.blending !== void 0 && (r.blending = e.blending),
        e.combine !== void 0 && (r.combine = e.combine),
        e.side !== void 0 && (r.side = e.side),
        e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
        e.opacity !== void 0 && (r.opacity = e.opacity),
        e.transparent !== void 0 && (r.transparent = e.transparent),
        e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
        e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash),
        e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc),
        e.depthTest !== void 0 && (r.depthTest = e.depthTest),
        e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
        e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
        e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc),
        e.blendDst !== void 0 && (r.blendDst = e.blendDst),
        e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation),
        e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha),
        e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha),
        e.blendEquationAlpha !== void 0 && (r.blendEquationAlpha = e.blendEquationAlpha),
        e.blendColor !== void 0 && r.blendColor !== void 0 && r.blendColor.setHex(e.blendColor),
        e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha),
        e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask),
        e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
        e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
        e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
        e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
        e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
        e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
        e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
        e.wireframe !== void 0 && (r.wireframe = e.wireframe),
        e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth),
        e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap),
        e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin),
        e.rotation !== void 0 && (r.rotation = e.rotation),
        e.linewidth !== void 0 && (r.linewidth = e.linewidth),
        e.dashSize !== void 0 && (r.dashSize = e.dashSize),
        e.gapSize !== void 0 && (r.gapSize = e.gapSize),
        e.scale !== void 0 && (r.scale = e.scale),
        e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
        e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor),
        e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits),
        e.dithering !== void 0 && (r.dithering = e.dithering),
        e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
        e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha),
        e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
        e.visible !== void 0 && (r.visible = e.visible),
        e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
        e.userData !== void 0 && (r.userData = e.userData),
        e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors),
        e.uniforms !== void 0)
            for (const s in e.uniforms) {
                const o = e.uniforms[s];
                switch (r.uniforms[s] = {},
                o.type) {
                case "t":
                    r.uniforms[s].value = i(o.value);
                    break;
                case "c":
                    r.uniforms[s].value = new Ee().setHex(o.value);
                    break;
                case "v2":
                    r.uniforms[s].value = new ae().fromArray(o.value);
                    break;
                case "v3":
                    r.uniforms[s].value = new N().fromArray(o.value);
                    break;
                case "v4":
                    r.uniforms[s].value = new ft().fromArray(o.value);
                    break;
                case "m3":
                    r.uniforms[s].value = new Ye().fromArray(o.value);
                    break;
                case "m4":
                    r.uniforms[s].value = new Be().fromArray(o.value);
                    break;
                default:
                    r.uniforms[s].value = o.value
                }
            }
        if (e.defines !== void 0 && (r.defines = e.defines),
        e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
        e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
        e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
        e.extensions !== void 0)
            for (const s in e.extensions)
                r.extensions[s] = e.extensions[s];
        if (e.lights !== void 0 && (r.lights = e.lights),
        e.clipping !== void 0 && (r.clipping = e.clipping),
        e.size !== void 0 && (r.size = e.size),
        e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
        e.map !== void 0 && (r.map = i(e.map)),
        e.matcap !== void 0 && (r.matcap = i(e.matcap)),
        e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
        e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
        e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
        e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
        e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
        e.normalScale !== void 0) {
            let s = e.normalScale;
            Array.isArray(s) === !1 && (s = [s, s]),
            r.normalScale = new ae().fromArray(s)
        }
        return e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)),
        e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale),
        e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias),
        e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
        e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
        e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
        e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity),
        e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
        e.specularIntensityMap !== void 0 && (r.specularIntensityMap = i(e.specularIntensityMap)),
        e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)),
        e.envMap !== void 0 && (r.envMap = i(e.envMap)),
        e.envMapRotation !== void 0 && r.envMapRotation.fromArray(e.envMapRotation),
        e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
        e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
        e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
        e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
        e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity),
        e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
        e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
        e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
        e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
        e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
        e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
        e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new ae().fromArray(e.clearcoatNormalScale)),
        e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)),
        e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
        e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)),
        e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
        e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)),
        e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
        e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
        r
    }
    setTextures(e) {
        return this.textures = e,
        this
    }
    static createMaterialFromType(e) {
        const t = {
            ShadowMaterial: vb,
            SpriteMaterial: Gp,
            RawShaderMaterial: _b,
            ShaderMaterial: oi,
            PointsMaterial: Xp,
            MeshPhysicalMaterial: yb,
            MeshStandardMaterial: Jp,
            MeshPhongMaterial: xb,
            MeshToonMaterial: bb,
            MeshNormalMaterial: Mb,
            MeshLambertMaterial: Sb,
            MeshDepthMaterial: Vp,
            MeshDistanceMaterial: Hp,
            MeshBasicMaterial: Zi,
            MeshMatcapMaterial: wb,
            LineDashedMaterial: Eb,
            LineBasicMaterial: xn,
            Material: cn
        };
        return new t[e]
    }
}
class Ud {
    static decodeText(e) {
        if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),
        typeof TextDecoder < "u")
            return new TextDecoder().decode(e);
        let t = "";
        for (let i = 0, r = e.length; i < r; i++)
            t += String.fromCharCode(e[i]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class kb extends Ze {
    constructor() {
        super(),
        this.isInstancedBufferGeometry = !0,
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e),
        this.instanceCount = e.instanceCount,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount,
        e.isInstancedBufferGeometry = !0,
        e
    }
}
class Vb extends wn {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new $i(s.manager);
        o.setPath(s.path),
        o.setRequestHeader(s.requestHeader),
        o.setWithCredentials(s.withCredentials),
        o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                r ? r(l) : console.error(l),
                s.manager.itemError(e)
            }
        }, i, r)
    }
    parse(e) {
        const t = {}
          , i = {};
        function r(d, p) {
            if (t[p] !== void 0)
                return t[p];
            const g = d.interleavedBuffers[p]
              , m = s(d, g.buffer)
              , y = eo(g.type, m)
              , _ = new xh(y,g.stride);
            return _.uuid = g.uuid,
            t[p] = _,
            _
        }
        function s(d, p) {
            if (i[p] !== void 0)
                return i[p];
            const g = d.arrayBuffers[p]
              , m = new Uint32Array(g).buffer;
            return i[p] = m,
            m
        }
        const o = e.isInstancedBufferGeometry ? new kb : new Ze
          , a = e.data.index;
        if (a !== void 0) {
            const d = eo(a.type, a.array);
            o.setIndex(new pt(d,1))
        }
        const l = e.data.attributes;
        for (const d in l) {
            const p = l[d];
            let v;
            if (p.isInterleavedBufferAttribute) {
                const g = r(e.data, p.data);
                v = new ys(g,p.itemSize,p.offset,p.normalized)
            } else {
                const g = eo(p.type, p.array)
                  , m = p.isInstancedBufferAttribute ? wo : pt;
                v = new m(g,p.itemSize,p.normalized)
            }
            p.name !== void 0 && (v.name = p.name),
            p.usage !== void 0 && v.setUsage(p.usage),
            o.setAttribute(d, v)
        }
        const c = e.data.morphAttributes;
        if (c)
            for (const d in c) {
                const p = c[d]
                  , v = [];
                for (let g = 0, m = p.length; g < m; g++) {
                    const y = p[g];
                    let _;
                    if (y.isInterleavedBufferAttribute) {
                        const x = r(e.data, y.data);
                        _ = new ys(x,y.itemSize,y.offset,y.normalized)
                    } else {
                        const x = eo(y.type, y.array);
                        _ = new pt(x,y.itemSize,y.normalized)
                    }
                    y.name !== void 0 && (_.name = y.name),
                    v.push(_)
                }
                o.morphAttributes[d] = v
            }
        e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
        const h = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (h !== void 0)
            for (let d = 0, p = h.length; d !== p; ++d) {
                const v = h[d];
                o.addGroup(v.start, v.count, v.materialIndex)
            }
        const f = e.data.boundingSphere;
        if (f !== void 0) {
            const d = new N;
            f.center !== void 0 && d.fromArray(f.center),
            o.boundingSphere = new an(d,f.radius)
        }
        return e.name && (o.name = e.name),
        e.userData && (o.userData = e.userData),
        o
    }
}
class KI extends wn {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = this.path === "" ? Ud.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || o;
        const a = new $i(this.manager);
        a.setPath(this.path),
        a.setRequestHeader(this.requestHeader),
        a.setWithCredentials(this.withCredentials),
        a.load(e, function(l) {
            let c = null;
            try {
                c = JSON.parse(l)
            } catch (h) {
                r !== void 0 && r(h),
                console.error("THREE:ObjectLoader: Can't parse " + e + ".", h.message);
                return
            }
            const u = c.metadata;
            if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry") {
                r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)),
                console.error("THREE.ObjectLoader: Can't load " + e);
                return
            }
            s.parse(c, t)
        }, i, r)
    }
    async loadAsync(e, t) {
        const i = this
          , r = this.path === "" ? Ud.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || r;
        const s = new $i(this.manager);
        s.setPath(this.path),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials);
        const o = await s.loadAsync(e, t)
          , a = JSON.parse(o)
          , l = a.metadata;
        if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
            throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await i.parseAsync(a)
    }
    parse(e, t) {
        const i = this.parseAnimations(e.animations)
          , r = this.parseShapes(e.shapes)
          , s = this.parseGeometries(e.geometries, r)
          , o = this.parseImages(e.images, function() {
            t !== void 0 && t(c)
        })
          , a = this.parseTextures(e.textures, o)
          , l = this.parseMaterials(e.materials, a)
          , c = this.parseObject(e.object, s, l, a, i)
          , u = this.parseSkeletons(e.skeletons, c);
        if (this.bindSkeletons(c, u),
        this.bindLightTargets(c),
        t !== void 0) {
            let h = !1;
            for (const f in o)
                if (o[f].data instanceof HTMLImageElement) {
                    h = !0;
                    break
                }
            h === !1 && t(c)
        }
        return c
    }
    async parseAsync(e) {
        const t = this.parseAnimations(e.animations)
          , i = this.parseShapes(e.shapes)
          , r = this.parseGeometries(e.geometries, i)
          , s = await this.parseImagesAsync(e.images)
          , o = this.parseTextures(e.textures, s)
          , a = this.parseMaterials(e.materials, o)
          , l = this.parseObject(e.object, r, a, o, t)
          , c = this.parseSkeletons(e.skeletons, l);
        return this.bindSkeletons(l, c),
        this.bindLightTargets(l),
        l
    }
    parseShapes(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0, r = e.length; i < r; i++) {
                const s = new ds().fromJSON(e[i]);
                t[s.uuid] = s
            }
        return t
    }
    parseSkeletons(e, t) {
        const i = {}
          , r = {};
        if (t.traverse(function(s) {
            s.isBone && (r[s.uuid] = s)
        }),
        e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = new bh().fromJSON(e[s], r);
                i[a.uuid] = a
            }
        return i
    }
    parseGeometries(e, t) {
        const i = {};
        if (e !== void 0) {
            const r = new Vb;
            for (let s = 0, o = e.length; s < o; s++) {
                let a;
                const l = e[s];
                switch (l.type) {
                case "BufferGeometry":
                case "InstancedBufferGeometry":
                    a = r.parse(l);
                    break;
                default:
                    l.type in Pv ? a = Pv[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)
                }
                a.uuid = l.uuid,
                l.name !== void 0 && (a.name = l.name),
                l.userData !== void 0 && (a.userData = l.userData),
                i[l.uuid] = a
            }
        }
        return i
    }
    parseMaterials(e, t) {
        const i = {}
          , r = {};
        if (e !== void 0) {
            const s = new Fh;
            s.setTextures(t);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o];
                i[l.uuid] === void 0 && (i[l.uuid] = s.parse(l)),
                r[l.uuid] = i[l.uuid]
            }
        }
        return r
    }
    parseAnimations(e) {
        const t = {};
        if (e !== void 0)
            for (let i = 0; i < e.length; i++) {
                const r = e[i]
                  , s = il.parse(r);
                t[s.uuid] = s
            }
        return t
    }
    parseImages(e, t) {
        const i = this
          , r = {};
        let s;
        function o(l) {
            return i.manager.itemStart(l),
            s.load(l, function() {
                i.manager.itemEnd(l)
            }, void 0, function() {
                i.manager.itemError(l),
                i.manager.itemEnd(l)
            })
        }
        function a(l) {
            if (typeof l == "string") {
                const c = l
                  , u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : i.resourcePath + c;
                return o(u)
            } else
                return l.data ? {
                    data: eo(l.type, l.data),
                    width: l.width,
                    height: l.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            const l = new nm(t);
            s = new rl(l),
            s.setCrossOrigin(this.crossOrigin);
            for (let c = 0, u = e.length; c < u; c++) {
                const h = e[c]
                  , f = h.url;
                if (Array.isArray(f)) {
                    const d = [];
                    for (let p = 0, v = f.length; p < v; p++) {
                        const g = f[p]
                          , m = a(g);
                        m !== null && (m instanceof HTMLImageElement ? d.push(m) : d.push(new _i(m.data,m.width,m.height)))
                    }
                    r[h.uuid] = new rs(d)
                } else {
                    const d = a(h.url);
                    r[h.uuid] = new rs(d)
                }
            }
        }
        return r
    }
    async parseImagesAsync(e) {
        const t = this
          , i = {};
        let r;
        async function s(o) {
            if (typeof o == "string") {
                const a = o
                  , l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
                return await r.loadAsync(l)
            } else
                return o.data ? {
                    data: eo(o.type, o.data),
                    width: o.width,
                    height: o.height
                } : null
        }
        if (e !== void 0 && e.length > 0) {
            r = new rl(this.manager),
            r.setCrossOrigin(this.crossOrigin);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o]
                  , c = l.url;
                if (Array.isArray(c)) {
                    const u = [];
                    for (let h = 0, f = c.length; h < f; h++) {
                        const d = c[h]
                          , p = await s(d);
                        p !== null && (p instanceof HTMLImageElement ? u.push(p) : u.push(new _i(p.data,p.width,p.height)))
                    }
                    i[l.uuid] = new rs(u)
                } else {
                    const u = await s(l.url);
                    i[l.uuid] = new rs(u)
                }
            }
        }
        return i
    }
    parseTextures(e, t) {
        function i(s, o) {
            return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s),
            o[s])
        }
        const r = {};
        if (e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = e[s];
                a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
                t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                const l = t[a.image]
                  , c = l.data;
                let u;
                Array.isArray(c) ? (u = new yl,
                c.length === 6 && (u.needsUpdate = !0)) : (c && c.data ? u = new _i : u = new Dt,
                c && (u.needsUpdate = !0)),
                u.source = l,
                u.uuid = a.uuid,
                a.name !== void 0 && (u.name = a.name),
                a.mapping !== void 0 && (u.mapping = i(a.mapping, ZI)),
                a.channel !== void 0 && (u.channel = a.channel),
                a.offset !== void 0 && u.offset.fromArray(a.offset),
                a.repeat !== void 0 && u.repeat.fromArray(a.repeat),
                a.center !== void 0 && u.center.fromArray(a.center),
                a.rotation !== void 0 && (u.rotation = a.rotation),
                a.wrap !== void 0 && (u.wrapS = i(a.wrap[0], Nv),
                u.wrapT = i(a.wrap[1], Nv)),
                a.format !== void 0 && (u.format = a.format),
                a.internalFormat !== void 0 && (u.internalFormat = a.internalFormat),
                a.type !== void 0 && (u.type = a.type),
                a.colorSpace !== void 0 && (u.colorSpace = a.colorSpace),
                a.minFilter !== void 0 && (u.minFilter = i(a.minFilter, Uv)),
                a.magFilter !== void 0 && (u.magFilter = i(a.magFilter, Uv)),
                a.anisotropy !== void 0 && (u.anisotropy = a.anisotropy),
                a.flipY !== void 0 && (u.flipY = a.flipY),
                a.generateMipmaps !== void 0 && (u.generateMipmaps = a.generateMipmaps),
                a.premultiplyAlpha !== void 0 && (u.premultiplyAlpha = a.premultiplyAlpha),
                a.unpackAlignment !== void 0 && (u.unpackAlignment = a.unpackAlignment),
                a.compareFunction !== void 0 && (u.compareFunction = a.compareFunction),
                a.userData !== void 0 && (u.userData = a.userData),
                r[a.uuid] = u
            }
        return r
    }
    parseObject(e, t, i, r, s) {
        let o;
        function a(f) {
            return t[f] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", f),
            t[f]
        }
        function l(f) {
            if (f !== void 0) {
                if (Array.isArray(f)) {
                    const d = [];
                    for (let p = 0, v = f.length; p < v; p++) {
                        const g = f[p];
                        i[g] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", g),
                        d.push(i[g])
                    }
                    return d
                }
                return i[f] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", f),
                i[f]
            }
        }
        function c(f) {
            return r[f] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", f),
            r[f]
        }
        let u, h;
        switch (e.type) {
        case "Scene":
            o = new yh,
            e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new Ee(e.background) : o.background = c(e.background)),
            e.environment !== void 0 && (o.environment = c(e.environment)),
            e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new _h(e.fog.color,e.fog.near,e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new vh(e.fog.color,e.fog.density)),
            e.fog.name !== "" && (o.fog.name = e.fog.name)),
            e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness),
            e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity),
            e.backgroundRotation !== void 0 && o.backgroundRotation.fromArray(e.backgroundRotation),
            e.environmentIntensity !== void 0 && (o.environmentIntensity = e.environmentIntensity),
            e.environmentRotation !== void 0 && o.environmentRotation.fromArray(e.environmentRotation);
            break;
        case "PerspectiveCamera":
            o = new Ht(e.fov,e.aspect,e.near,e.far),
            e.focus !== void 0 && (o.focus = e.focus),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
            e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "OrthographicCamera":
            o = new mh(e.left,e.right,e.top,e.bottom,e.near,e.far),
            e.zoom !== void 0 && (o.zoom = e.zoom),
            e.view !== void 0 && (o.view = Object.assign({}, e.view));
            break;
        case "AmbientLight":
            o = new Ob(e.color,e.intensity);
            break;
        case "DirectionalLight":
            o = new Ub(e.color,e.intensity),
            o.target = e.target || "";
            break;
        case "PointLight":
            o = new Nb(e.color,e.intensity,e.distance,e.decay);
            break;
        case "RectAreaLight":
            o = new Fb(e.color,e.intensity,e.width,e.height);
            break;
        case "SpotLight":
            o = new Db(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay),
            o.target = e.target || "";
            break;
        case "HemisphereLight":
            o = new Lb(e.color,e.groundColor,e.intensity);
            break;
        case "LightProbe":
            o = new zb().fromJSON(e);
            break;
        case "SkinnedMesh":
            u = a(e.geometry),
            h = l(e.material),
            o = new nb(u,h),
            e.bindMode !== void 0 && (o.bindMode = e.bindMode),
            e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
            e.skeleton !== void 0 && (o.skeleton = e.skeleton);
            break;
        case "Mesh":
            u = a(e.geometry),
            h = l(e.material),
            o = new Ot(u,h);
            break;
        case "InstancedMesh":
            u = a(e.geometry),
            h = l(e.material);
            const f = e.count
              , d = e.instanceMatrix
              , p = e.instanceColor;
            o = new ib(u,h,f),
            o.instanceMatrix = new wo(new Float32Array(d.array),16),
            p !== void 0 && (o.instanceColor = new wo(new Float32Array(p.array),p.itemSize));
            break;
        case "BatchedMesh":
            u = a(e.geometry),
            h = l(e.material),
            o = new rb(e.maxInstanceCount,e.maxVertexCount,e.maxIndexCount,h),
            o.geometry = u,
            o.perObjectFrustumCulled = e.perObjectFrustumCulled,
            o.sortObjects = e.sortObjects,
            o._drawRanges = e.drawRanges,
            o._reservedRanges = e.reservedRanges,
            o._visibility = e.visibility,
            o._active = e.active,
            o._bounds = e.bounds.map(v => {
                const g = new yn;
                g.min.fromArray(v.boxMin),
                g.max.fromArray(v.boxMax);
                const m = new an;
                return m.radius = v.sphereRadius,
                m.center.fromArray(v.sphereCenter),
                {
                    boxInitialized: v.boxInitialized,
                    box: g,
                    sphereInitialized: v.sphereInitialized,
                    sphere: m
                }
            }
            ),
            o._maxInstanceCount = e.maxInstanceCount,
            o._maxVertexCount = e.maxVertexCount,
            o._maxIndexCount = e.maxIndexCount,
            o._geometryInitialized = e.geometryInitialized,
            o._geometryCount = e.geometryCount,
            o._matricesTexture = c(e.matricesTexture.uuid),
            e.colorsTexture !== void 0 && (o._colorsTexture = c(e.colorsTexture.uuid));
            break;
        case "LOD":
            o = new tb;
            break;
        case "Line":
            o = new Ar(a(e.geometry),l(e.material));
            break;
        case "LineLoop":
            o = new sb(a(e.geometry),l(e.material));
            break;
        case "LineSegments":
            o = new wi(a(e.geometry),l(e.material));
            break;
        case "PointCloud":
        case "Points":
            o = new ob(a(e.geometry),l(e.material));
            break;
        case "Sprite":
            o = new eb(l(e.material));
            break;
        case "Group":
            o = new no;
            break;
        case "Bone":
            o = new Wp;
            break;
        default:
            o = new tt
        }
        if (o.uuid = e.uuid,
        e.name !== void 0 && (o.name = e.name),
        e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix),
        e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate),
        o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position),
        e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
        e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
        e.scale !== void 0 && o.scale.fromArray(e.scale)),
        e.up !== void 0 && o.up.fromArray(e.up),
        e.castShadow !== void 0 && (o.castShadow = e.castShadow),
        e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
        e.shadow && (e.shadow.intensity !== void 0 && (o.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))),
        e.visible !== void 0 && (o.visible = e.visible),
        e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
        e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
        e.userData !== void 0 && (o.userData = e.userData),
        e.layers !== void 0 && (o.layers.mask = e.layers),
        e.children !== void 0) {
            const f = e.children;
            for (let d = 0; d < f.length; d++)
                o.add(this.parseObject(f[d], t, i, r, s))
        }
        if (e.animations !== void 0) {
            const f = e.animations;
            for (let d = 0; d < f.length; d++) {
                const p = f[d];
                o.animations.push(s[p])
            }
        }
        if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
            const f = e.levels;
            for (let d = 0; d < f.length; d++) {
                const p = f[d]
                  , v = o.getObjectByProperty("uuid", p.object);
                v !== void 0 && o.addLevel(v, p.distance, p.hysteresis)
            }
        }
        return o
    }
    bindSkeletons(e, t) {
        Object.keys(t).length !== 0 && e.traverse(function(i) {
            if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
                const r = t[i.skeleton];
                r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(r, i.bindMatrix)
            }
        })
    }
    bindLightTargets(e) {
        e.traverse(function(t) {
            if (t.isDirectionalLight || t.isSpotLight) {
                const i = t.target
                  , r = e.getObjectByProperty("uuid", i);
                r !== void 0 ? t.target = r : t.target = new tt
            }
        })
    }
}
const ZI = {
    UVMapping: rh,
    CubeReflectionMapping: Xi,
    CubeRefractionMapping: Er,
    EquirectangularReflectionMapping: za,
    EquirectangularRefractionMapping: ka,
    CubeUVReflectionMapping: Lo
}
  , Nv = {
    RepeatWrapping: Va,
    ClampToEdgeWrapping: Gn,
    MirroredRepeatWrapping: Ha
}
  , Uv = {
    NearestFilter: Kt,
    NearestMipmapNearestFilter: Mp,
    NearestMipmapLinearFilter: Qs,
    LinearFilter: Gt,
    LinearMipmapNearestFilter: pa,
    LinearMipmapLinearFilter: pi
};
class JI extends wn {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, i, r) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const s = this
          , o = zi.get(e);
        if (o !== void 0) {
            if (s.manager.itemStart(e),
            o.then) {
                o.then(c => {
                    t && t(c),
                    s.manager.itemEnd(e)
                }
                ).catch(c => {
                    r && r(c)
                }
                );
                return
            }
            return setTimeout(function() {
                t && t(o),
                s.manager.itemEnd(e)
            }, 0),
            o
        }
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        a.headers = this.requestHeader;
        const l = fetch(e, a).then(function(c) {
            return c.blob()
        }).then(function(c) {
            return createImageBitmap(c, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(c) {
            return zi.add(e, c),
            t && t(c),
            s.manager.itemEnd(e),
            c
        }).catch(function(c) {
            r && r(c),
            zi.remove(e),
            s.manager.itemError(e),
            s.manager.itemEnd(e)
        });
        zi.add(e, l),
        s.manager.itemStart(e)
    }
}
let Sc;
class rm {
    static getContext() {
        return Sc === void 0 && (Sc = new (window.AudioContext || window.webkitAudioContext)),
        Sc
    }
    static setContext(e) {
        Sc = e
    }
}
class QI extends wn {
    constructor(e) {
        super(e)
    }
    load(e, t, i, r) {
        const s = this
          , o = new $i(this.manager);
        o.setResponseType("arraybuffer"),
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(l) {
            try {
                const c = l.slice(0);
                rm.getContext().decodeAudioData(c, function(h) {
                    t(h)
                }).catch(a)
            } catch (c) {
                a(c)
            }
        }, i, r);
        function a(l) {
            r ? r(l) : console.error(l),
            s.manager.itemError(e)
        }
    }
}
const Ov = new Be
  , Fv = new Be
  , Wr = new Be;
class eL {
    constructor() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new Ht,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new Ht,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1,
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    update(e) {
        const t = this._cache;
        if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
            t.focus = e.focus,
            t.fov = e.fov,
            t.aspect = e.aspect * this.aspect,
            t.near = e.near,
            t.far = e.far,
            t.zoom = e.zoom,
            t.eyeSep = this.eyeSep,
            Wr.copy(e.projectionMatrix);
            const r = t.eyeSep / 2
              , s = r * t.near / t.focus
              , o = t.near * Math.tan(fs * t.fov * .5) / t.zoom;
            let a, l;
            Fv.elements[12] = -r,
            Ov.elements[12] = r,
            a = -o * t.aspect + s,
            l = o * t.aspect + s,
            Wr.elements[0] = 2 * t.near / (l - a),
            Wr.elements[8] = (l + a) / (l - a),
            this.cameraL.projectionMatrix.copy(Wr),
            a = -o * t.aspect - s,
            l = o * t.aspect - s,
            Wr.elements[0] = 2 * t.near / (l - a),
            Wr.elements[8] = (l + a) / (l - a),
            this.cameraR.projectionMatrix.copy(Wr)
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Fv),
        this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Ov)
    }
}
class Bh {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = Bv(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const t = Bv();
            e = (t - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
}
function Bv() {
    return (typeof performance > "u" ? Date : performance).now()
}
const Xr = new N
  , zv = new Sn
  , tL = new N
  , qr = new N;
class nL extends tt {
    constructor() {
        super(),
        this.type = "AudioListener",
        this.context = rm.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0,
        this._clock = new Bh
    }
    getInput() {
        return this.gain
    }
    removeFilter() {
        return this.filter !== null && (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        this.filter = null),
        this
    }
    getFilter() {
        return this.filter
    }
    setFilter(e) {
        return this.filter !== null ? (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
        this.filter = e,
        this.gain.connect(this.filter),
        this.filter.connect(this.context.destination),
        this
    }
    getMasterVolume() {
        return this.gain.gain.value
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener
          , i = this.up;
        if (this.timeDelta = this._clock.getDelta(),
        this.matrixWorld.decompose(Xr, zv, tL),
        qr.set(0, 0, -1).applyQuaternion(zv),
        t.positionX) {
            const r = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(Xr.x, r),
            t.positionY.linearRampToValueAtTime(Xr.y, r),
            t.positionZ.linearRampToValueAtTime(Xr.z, r),
            t.forwardX.linearRampToValueAtTime(qr.x, r),
            t.forwardY.linearRampToValueAtTime(qr.y, r),
            t.forwardZ.linearRampToValueAtTime(qr.z, r),
            t.upX.linearRampToValueAtTime(i.x, r),
            t.upY.linearRampToValueAtTime(i.y, r),
            t.upZ.linearRampToValueAtTime(i.z, r)
        } else
            t.setPosition(Xr.x, Xr.y, Xr.z),
            t.setOrientation(qr.x, qr.y, qr.z, i.x, i.y, i.z)
    }
}
class Hb extends tt {
    constructor(e) {
        super(),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.source = null,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this._connected = !1,
        this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "audioNode",
        this.source = e,
        this.connect(),
        this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaNode",
        this.source = this.context.createMediaElementSource(e),
        this.connect(),
        this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaStreamNode",
        this.source = this.context.createMediaStreamSource(e),
        this.connect(),
        this
    }
    setBuffer(e) {
        return this.buffer = e,
        this.sourceType = "buffer",
        this.autoplay && this.play(),
        this
    }
    play(e=0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return t.buffer = this.buffer,
        t.loop = this.loop,
        t.loopStart = this.loopStart,
        t.loopEnd = this.loopEnd,
        t.onended = this.onEnded.bind(this),
        t.start(this._startedAt, this._progress + this.offset, this.duration),
        this.isPlaying = !0,
        this.source = t,
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
        this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        this.source.onended = null,
        this.isPlaying = !1),
        this
    }
    stop() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0,
        this.source !== null && (this.source.stop(),
        this.source.onended = null),
        this.isPlaying = !1,
        this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else
            this.source.connect(this.getOutput());
        return this._connected = !0,
        this
    }
    disconnect() {
        if (this._connected !== !1) {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this._connected = !1,
            this
        }
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []),
        this._connected === !0 ? (this.disconnect(),
        this.filters = e.slice(),
        this.connect()) : this.filters = e.slice(),
        this
    }
    setDetune(e) {
        return this.detune = e,
        this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
        this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = e,
        this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
        this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
        !1) : this.loop
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = e,
        this.isPlaying === !0 && (this.source.loop = this.loop),
        this
    }
    setLoopStart(e) {
        return this.loopStart = e,
        this
    }
    setLoopEnd(e) {
        return this.loopEnd = e,
        this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
}
const $r = new N
  , kv = new Sn
  , iL = new N
  , Yr = new N;
class rL extends Hb {
    constructor(e) {
        super(e),
        this.panner = this.context.createPanner(),
        this.panner.panningModel = "HRTF",
        this.panner.connect(this.gain)
    }
    connect() {
        super.connect(),
        this.panner.connect(this.gain)
    }
    disconnect() {
        super.disconnect(),
        this.panner.disconnect(this.gain)
    }
    getOutput() {
        return this.panner
    }
    getRefDistance() {
        return this.panner.refDistance
    }
    setRefDistance(e) {
        return this.panner.refDistance = e,
        this
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor
    }
    setRolloffFactor(e) {
        return this.panner.rolloffFactor = e,
        this
    }
    getDistanceModel() {
        return this.panner.distanceModel
    }
    setDistanceModel(e) {
        return this.panner.distanceModel = e,
        this
    }
    getMaxDistance() {
        return this.panner.maxDistance
    }
    setMaxDistance(e) {
        return this.panner.maxDistance = e,
        this
    }
    setDirectionalCone(e, t, i) {
        return this.panner.coneInnerAngle = e,
        this.panner.coneOuterAngle = t,
        this.panner.coneOuterGain = i,
        this
    }
    updateMatrixWorld(e) {
        if (super.updateMatrixWorld(e),
        this.hasPlaybackControl === !0 && this.isPlaying === !1)
            return;
        this.matrixWorld.decompose($r, kv, iL),
        Yr.set(0, 0, 1).applyQuaternion(kv);
        const t = this.panner;
        if (t.positionX) {
            const i = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime($r.x, i),
            t.positionY.linearRampToValueAtTime($r.y, i),
            t.positionZ.linearRampToValueAtTime($r.z, i),
            t.orientationX.linearRampToValueAtTime(Yr.x, i),
            t.orientationY.linearRampToValueAtTime(Yr.y, i),
            t.orientationZ.linearRampToValueAtTime(Yr.z, i)
        } else
            t.setPosition($r.x, $r.y, $r.z),
            t.setOrientation(Yr.x, Yr.y, Yr.z)
    }
}
class sL {
    constructor(e, t=2048) {
        this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = t,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser)
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data),
        this.data
    }
    getAverageFrequency() {
        let e = 0;
        const t = this.getFrequencyData();
        for (let i = 0; i < t.length; i++)
            e += t[i];
        return e / t.length
    }
}
class Gb {
    constructor(e, t, i) {
        this.binding = e,
        this.valueSize = i;
        let r, s, o;
        switch (t) {
        case "quaternion":
            r = this._slerp,
            s = this._slerpAdditive,
            o = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(i * 6),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            r = this._select,
            s = this._select,
            o = this._setAdditiveIdentityOther,
            this.buffer = new Array(i * 5);
            break;
        default:
            r = this._lerp,
            s = this._lerpAdditive,
            o = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(i * 5)
        }
        this._mixBufferRegion = r,
        this._mixBufferRegionAdditive = s,
        this._setIdentity = o,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    accumulate(e, t) {
        const i = this.buffer
          , r = this.valueSize
          , s = e * r + r;
        let o = this.cumulativeWeight;
        if (o === 0) {
            for (let a = 0; a !== r; ++a)
                i[s + a] = i[a];
            o = t
        } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(i, s, 0, a, r)
        }
        this.cumulativeWeight = o
    }
    accumulateAdditive(e) {
        const t = this.buffer
          , i = this.valueSize
          , r = i * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(),
        this._mixBufferRegionAdditive(t, r, 0, e, i),
        this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const t = this.valueSize
          , i = this.buffer
          , r = e * t + t
          , s = this.cumulativeWeight
          , o = this.cumulativeWeightAdditive
          , a = this.binding;
        if (this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        s < 1) {
            const l = t * this._origIndex;
            this._mixBufferRegion(i, r, l, 1 - s, t)
        }
        o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
        for (let l = t, c = t + t; l !== c; ++l)
            if (i[l] !== i[l + t]) {
                a.setValue(i, r);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding
          , t = this.buffer
          , i = this.valueSize
          , r = i * this._origIndex;
        e.getValue(t, r);
        for (let s = i, o = r; s !== o; ++s)
            t[s] = t[r + s % i];
        this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize
          , t = e + this.valueSize;
        for (let i = e; i < t; i++)
            this.buffer[i] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize
          , t = this._addIndex * this.valueSize;
        for (let i = 0; i < this.valueSize; i++)
            this.buffer[t + i] = this.buffer[e + i]
    }
    _select(e, t, i, r, s) {
        if (r >= .5)
            for (let o = 0; o !== s; ++o)
                e[t + o] = e[i + o]
    }
    _slerp(e, t, i, r) {
        Sn.slerpFlat(e, t, e, t, e, i, r)
    }
    _slerpAdditive(e, t, i, r, s) {
        const o = this._workIndex * s;
        Sn.multiplyQuaternionsFlat(e, o, e, t, e, i),
        Sn.slerpFlat(e, t, e, t, e, o, r)
    }
    _lerp(e, t, i, r, s) {
        const o = 1 - r;
        for (let a = 0; a !== s; ++a) {
            const l = t + a;
            e[l] = e[l] * o + e[i + a] * r
        }
    }
    _lerpAdditive(e, t, i, r, s) {
        for (let o = 0; o !== s; ++o) {
            const a = t + o;
            e[a] = e[a] + e[i + o] * r
        }
    }
}
const sm = "\\[\\]\\.:\\/"
  , oL = new RegExp("[" + sm + "]","g")
  , om = "[^" + sm + "]"
  , aL = "[^" + sm.replace("\\.", "") + "]"
  , lL = /((?:WC+[\/:])*)/.source.replace("WC", om)
  , cL = /(WCOD+)?/.source.replace("WCOD", aL)
  , uL = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", om)
  , hL = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", om)
  , fL = new RegExp("^" + lL + cL + uL + hL + "$")
  , dL = ["material", "materials", "bones", "map"];
class pL {
    constructor(e, t, i) {
        const r = i || it.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, r)
    }
    getValue(e, t) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_
          , r = this._bindings[i];
        r !== void 0 && r.getValue(e, t)
    }
    setValue(e, t) {
        const i = this._bindings;
        for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
            i[r].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
            e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
            e[t].unbind()
    }
}
class it {
    constructor(e, t, i) {
        this.path = t,
        this.parsedPath = i || it.parseTrackName(t),
        this.node = it.findNode(e, this.parsedPath.nodeName),
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, i) {
        return e && e.isAnimationObjectGroup ? new it.Composite(e,t,i) : new it(e,t,i)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(oL, "")
    }
    static parseTrackName(e) {
        const t = fL.exec(e);
        if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const i = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , r = i.nodeName && i.nodeName.lastIndexOf(".");
        if (r !== void 0 && r !== -1) {
            const s = i.nodeName.substring(r + 1);
            dL.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r),
            i.objectName = s)
        }
        if (i.propertyName === null || i.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return i
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const i = e.skeleton.getBoneByName(t);
            if (i !== void 0)
                return i
        }
        if (e.children) {
            const i = function(s) {
                for (let o = 0; o < s.length; o++) {
                    const a = s[o];
                    if (a.name === t || a.uuid === t)
                        return a;
                    const l = i(a.children);
                    if (l)
                        return l
                }
                return null
            }
              , r = i(e.children);
            if (r)
                return r
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            e[t++] = i[r]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let r = 0, s = i.length; r !== s; ++r)
            i[r] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath
          , i = t.objectName
          , r = t.propertyName;
        let s = t.propertyIndex;
        if (e || (e = it.findNode(this.rootNode, t.nodeName),
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (i) {
            let c = t.objectIndex;
            switch (i) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let u = 0; u < e.length; u++)
                    if (e[u].name === c) {
                        c = u;
                        break
                    }
                break;
            case "map":
                if ("map"in e) {
                    e = e.map;
                    break
                }
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[i] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[i]
            }
            if (c !== void 0) {
                if (e[c] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[c]
            }
        }
        const o = e[r];
        if (o === void 0) {
            const c = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e,
        e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (s !== void 0) {
            if (r === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
            }
            l = this.BindingType.ArrayElement,
            this.resolvedProperty = o,
            this.propertyIndex = s
        } else
            o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray,
            this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray,
            this.resolvedProperty = o) : this.propertyName = r;
        this.getValue = this.GetterByBindingType[l],
        this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
it.Composite = pL;
it.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
it.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
it.prototype.GetterByBindingType = [it.prototype._getValue_direct, it.prototype._getValue_array, it.prototype._getValue_arrayElement, it.prototype._getValue_toArray];
it.prototype.SetterByBindingTypeAndVersioning = [[it.prototype._setValue_direct, it.prototype._setValue_direct_setNeedsUpdate, it.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [it.prototype._setValue_array, it.prototype._setValue_array_setNeedsUpdate, it.prototype._setValue_array_setMatrixWorldNeedsUpdate], [it.prototype._setValue_arrayElement, it.prototype._setValue_arrayElement_setNeedsUpdate, it.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [it.prototype._setValue_fromArray, it.prototype._setValue_fromArray_setNeedsUpdate, it.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class mL {
    constructor() {
        this.isAnimationObjectGroup = !0,
        this.uuid = Nn(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        const e = {};
        this._indicesByUUID = e;
        for (let i = 0, r = arguments.length; i !== r; ++i)
            e[arguments[i].uuid] = i;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        const t = this;
        this.stats = {
            objects: {
                get total() {
                    return t._objects.length
                },
                get inUse() {
                    return this.total - t.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return t._bindings.length
            }
        }
    }
    add() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._paths
          , r = this._parsedPaths
          , s = this._bindings
          , o = s.length;
        let a, l = e.length, c = this.nCachedObjects_;
        for (let u = 0, h = arguments.length; u !== h; ++u) {
            const f = arguments[u]
              , d = f.uuid;
            let p = t[d];
            if (p === void 0) {
                p = l++,
                t[d] = p,
                e.push(f);
                for (let v = 0, g = o; v !== g; ++v)
                    s[v].push(new it(f,i[v],r[v]))
            } else if (p < c) {
                a = e[p];
                const v = --c
                  , g = e[v];
                t[g.uuid] = p,
                e[p] = g,
                t[d] = v,
                e[v] = f;
                for (let m = 0, y = o; m !== y; ++m) {
                    const _ = s[m]
                      , x = _[v];
                    let C = _[p];
                    _[p] = x,
                    C === void 0 && (C = new it(f,i[m],r[m])),
                    _[v] = C
                }
            } else
                e[p] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = c
    }
    remove() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._bindings
          , r = i.length;
        let s = this.nCachedObjects_;
        for (let o = 0, a = arguments.length; o !== a; ++o) {
            const l = arguments[o]
              , c = l.uuid
              , u = t[c];
            if (u !== void 0 && u >= s) {
                const h = s++
                  , f = e[h];
                t[f.uuid] = u,
                e[u] = f,
                t[c] = h,
                e[h] = l;
                for (let d = 0, p = r; d !== p; ++d) {
                    const v = i[d]
                      , g = v[h]
                      , m = v[u];
                    v[u] = g,
                    v[h] = m
                }
            }
        }
        this.nCachedObjects_ = s
    }
    uncache() {
        const e = this._objects
          , t = this._indicesByUUID
          , i = this._bindings
          , r = i.length;
        let s = this.nCachedObjects_
          , o = e.length;
        for (let a = 0, l = arguments.length; a !== l; ++a) {
            const c = arguments[a]
              , u = c.uuid
              , h = t[u];
            if (h !== void 0)
                if (delete t[u],
                h < s) {
                    const f = --s
                      , d = e[f]
                      , p = --o
                      , v = e[p];
                    t[d.uuid] = h,
                    e[h] = d,
                    t[v.uuid] = f,
                    e[f] = v,
                    e.pop();
                    for (let g = 0, m = r; g !== m; ++g) {
                        const y = i[g]
                          , _ = y[f]
                          , x = y[p];
                        y[h] = _,
                        y[f] = x,
                        y.pop()
                    }
                } else {
                    const f = --o
                      , d = e[f];
                    f > 0 && (t[d.uuid] = h),
                    e[h] = d,
                    e.pop();
                    for (let p = 0, v = r; p !== v; ++p) {
                        const g = i[p];
                        g[h] = g[f],
                        g.pop()
                    }
                }
        }
        this.nCachedObjects_ = s
    }
    subscribe_(e, t) {
        const i = this._bindingsIndicesByPath;
        let r = i[e];
        const s = this._bindings;
        if (r !== void 0)
            return s[r];
        const o = this._paths
          , a = this._parsedPaths
          , l = this._objects
          , c = l.length
          , u = this.nCachedObjects_
          , h = new Array(c);
        r = s.length,
        i[e] = r,
        o.push(e),
        a.push(t),
        s.push(h);
        for (let f = u, d = l.length; f !== d; ++f) {
            const p = l[f];
            h[f] = new it(p,e,t)
        }
        return h
    }
    unsubscribe_(e) {
        const t = this._bindingsIndicesByPath
          , i = t[e];
        if (i !== void 0) {
            const r = this._paths
              , s = this._parsedPaths
              , o = this._bindings
              , a = o.length - 1
              , l = o[a]
              , c = e[a];
            t[c] = i,
            o[i] = l,
            o.pop(),
            s[i] = s[a],
            s.pop(),
            r[i] = r[a],
            r.pop()
        }
    }
}
class Wb {
    constructor(e, t, i=null, r=t.blendMode) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = i,
        this.blendMode = r;
        const s = t.tracks
          , o = s.length
          , a = new Array(o)
          , l = {
            endingStart: ns,
            endingEnd: ns
        };
        for (let c = 0; c !== o; ++c) {
            const u = s[c].createInterpolant(null);
            a[c] = u,
            u.settings = l
        }
        this._interpolantSettings = l,
        this._interpolants = a,
        this._propertyBindings = new Array(o),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = Ex,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this),
        this
    }
    stop() {
        return this._mixer._deactivateAction(this),
        this.reset()
    }
    reset() {
        return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e,
        this
    }
    setLoop(e, t) {
        return this.loop = e,
        this.repetitions = t,
        this
    }
    setEffectiveWeight(e) {
        return this.weight = e,
        this._effectiveWeight = this.enabled ? e : 0,
        this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, t, i) {
        if (e.fadeOut(t),
        this.fadeIn(t),
        i) {
            const r = this._clip.duration
              , s = e._clip.duration
              , o = s / r
              , a = r / s;
            e.warp(1, o, t),
            this.warp(a, 1, t)
        }
        return this
    }
    crossFadeTo(e, t, i) {
        return e.crossFadeFrom(this, t, i)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e,
        this._effectiveTimeScale = this.paused ? 0 : e,
        this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e,
        this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time,
        this.timeScale = e.timeScale,
        this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, t, i) {
        const r = this._mixer
          , s = r.time
          , o = this.timeScale;
        let a = this._timeScaleInterpolant;
        a === null && (a = r._lendControlInterpolant(),
        this._timeScaleInterpolant = a);
        const l = a.parameterPositions
          , c = a.sampleValues;
        return l[0] = s,
        l[1] = s + i,
        c[0] = e / o,
        c[1] = t / o,
        this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, t, i, r) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        const s = this._startTime;
        if (s !== null) {
            const l = (e - s) * i;
            l < 0 || i === 0 ? t = 0 : (this._startTime = null,
            t = i * l)
        }
        t *= this._updateTimeScale(e);
        const o = this._updateTime(t)
          , a = this._updateWeight(e);
        if (a > 0) {
            const l = this._interpolants
              , c = this._propertyBindings;
            switch (this.blendMode) {
            case Lp:
                for (let u = 0, h = l.length; u !== h; ++u)
                    l[u].evaluate(o),
                    c[u].accumulateAdditive(a);
                break;
            case hh:
            default:
                for (let u = 0, h = l.length; u !== h; ++u)
                    l[u].evaluate(o),
                    c[u].accumulate(r, a)
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const i = this._weightInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                t *= r,
                e > i.parameterPositions[1] && (this.stopFading(),
                r === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t,
        t
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const i = this._timeScaleInterpolant;
            if (i !== null) {
                const r = i.evaluate(e)[0];
                t *= r,
                e > i.parameterPositions[1] && (this.stopWarping(),
                t === 0 ? this.paused = !0 : this.timeScale = t)
            }
        }
        return this._effectiveTimeScale = t,
        t
    }
    _updateTime(e) {
        const t = this._clip.duration
          , i = this.loop;
        let r = this.time + e
          , s = this._loopCount;
        const o = i === Ax;
        if (e === 0)
            return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
        if (i === wx) {
            s === -1 && (this._loopCount = 0,
            this._setEndings(!0, !0, !1));
            e: {
                if (r >= t)
                    r = t;
                else if (r < 0)
                    r = 0;
                else {
                    this.time = r;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = r,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (s === -1 && (e >= 0 ? (s = 0,
            this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)),
            r >= t || r < 0) {
                const a = Math.floor(r / t);
                r -= t * a,
                s += Math.abs(a);
                const l = this.repetitions - s;
                if (l <= 0)
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    r = e > 0 ? t : 0,
                    this.time = r,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                else {
                    if (l === 1) {
                        const c = e < 0;
                        this._setEndings(c, !c, o)
                    } else
                        this._setEndings(!1, !1, o);
                    this._loopCount = s,
                    this.time = r,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: a
                    })
                }
            } else
                this.time = r;
            if (o && (s & 1) === 1)
                return t - r
        }
        return r
    }
    _setEndings(e, t, i) {
        const r = this._interpolantSettings;
        i ? (r.endingStart = is,
        r.endingEnd = is) : (e ? r.endingStart = this.zeroSlopeAtStart ? is : ns : r.endingStart = Wa,
        t ? r.endingEnd = this.zeroSlopeAtEnd ? is : ns : r.endingEnd = Wa)
    }
    _scheduleFading(e, t, i) {
        const r = this._mixer
          , s = r.time;
        let o = this._weightInterpolant;
        o === null && (o = r._lendControlInterpolant(),
        this._weightInterpolant = o);
        const a = o.parameterPositions
          , l = o.sampleValues;
        return a[0] = s,
        l[0] = t,
        a[1] = s + e,
        l[1] = i,
        this
    }
}
const gL = new Float32Array(1);
class vL extends Si {
    constructor(e) {
        super(),
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    _bindAction(e, t) {
        const i = e._localRoot || this._root
          , r = e._clip.tracks
          , s = r.length
          , o = e._propertyBindings
          , a = e._interpolants
          , l = i.uuid
          , c = this._bindingsByRootAndName;
        let u = c[l];
        u === void 0 && (u = {},
        c[l] = u);
        for (let h = 0; h !== s; ++h) {
            const f = r[h]
              , d = f.name;
            let p = u[d];
            if (p !== void 0)
                ++p.referenceCount,
                o[h] = p;
            else {
                if (p = o[h],
                p !== void 0) {
                    p._cacheIndex === null && (++p.referenceCount,
                    this._addInactiveBinding(p, l, d));
                    continue
                }
                const v = t && t._propertyBindings[h].binding.parsedPath;
                p = new Gb(it.create(i, d, v),f.ValueTypeName,f.getValueSize()),
                ++p.referenceCount,
                this._addInactiveBinding(p, l, d),
                o[h] = p
            }
            a[h].resultBuffer = p.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const i = (e._localRoot || this._root).uuid
                  , r = e._clip.uuid
                  , s = this._actionsByClip[r];
                this._bindAction(e, s && s.knownActions[0]),
                this._addInactiveAction(e, r, i)
            }
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                s.useCount++ === 0 && (this._lendBinding(s),
                s.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let i = 0, r = t.length; i !== r; ++i) {
                const s = t[i];
                --s.useCount === 0 && (s.restoreOriginalState(),
                this._takeBackBinding(s))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return t !== null && t < this._nActiveActions
    }
    _addInactiveAction(e, t, i) {
        const r = this._actions
          , s = this._actionsByClip;
        let o = s[t];
        if (o === void 0)
            o = {
                knownActions: [e],
                actionByRoot: {}
            },
            e._byClipCacheIndex = 0,
            s[t] = o;
        else {
            const a = o.knownActions;
            e._byClipCacheIndex = a.length,
            a.push(e)
        }
        e._cacheIndex = r.length,
        r.push(e),
        o.actionByRoot[i] = e
    }
    _removeInactiveAction(e) {
        const t = this._actions
          , i = t[t.length - 1]
          , r = e._cacheIndex;
        i._cacheIndex = r,
        t[r] = i,
        t.pop(),
        e._cacheIndex = null;
        const s = e._clip.uuid
          , o = this._actionsByClip
          , a = o[s]
          , l = a.knownActions
          , c = l[l.length - 1]
          , u = e._byClipCacheIndex;
        c._byClipCacheIndex = u,
        l[u] = c,
        l.pop(),
        e._byClipCacheIndex = null;
        const h = a.actionByRoot
          , f = (e._localRoot || this._root).uuid;
        delete h[f],
        l.length === 0 && delete o[s],
        this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let i = 0, r = t.length; i !== r; ++i) {
            const s = t[i];
            --s.referenceCount === 0 && this._removeInactiveBinding(s)
        }
    }
    _lendAction(e) {
        const t = this._actions
          , i = e._cacheIndex
          , r = this._nActiveActions++
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _takeBackAction(e) {
        const t = this._actions
          , i = e._cacheIndex
          , r = --this._nActiveActions
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _addInactiveBinding(e, t, i) {
        const r = this._bindingsByRootAndName
          , s = this._bindings;
        let o = r[t];
        o === void 0 && (o = {},
        r[t] = o),
        o[i] = e,
        e._cacheIndex = s.length,
        s.push(e)
    }
    _removeInactiveBinding(e) {
        const t = this._bindings
          , i = e.binding
          , r = i.rootNode.uuid
          , s = i.path
          , o = this._bindingsByRootAndName
          , a = o[r]
          , l = t[t.length - 1]
          , c = e._cacheIndex;
        l._cacheIndex = c,
        t[c] = l,
        t.pop(),
        delete a[s],
        Object.keys(a).length === 0 && delete o[r]
    }
    _lendBinding(e) {
        const t = this._bindings
          , i = e._cacheIndex
          , r = this._nActiveBindings++
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _takeBackBinding(e) {
        const t = this._bindings
          , i = e._cacheIndex
          , r = --this._nActiveBindings
          , s = t[r];
        e._cacheIndex = r,
        t[r] = e,
        s._cacheIndex = i,
        t[i] = s
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants
          , t = this._nActiveControlInterpolants++;
        let i = e[t];
        return i === void 0 && (i = new em(new Float32Array(2),new Float32Array(2),1,gL),
        i.__cacheIndex = t,
        e[t] = i),
        i
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants
          , i = e.__cacheIndex
          , r = --this._nActiveControlInterpolants
          , s = t[r];
        e.__cacheIndex = r,
        t[r] = e,
        s.__cacheIndex = i,
        t[i] = s
    }
    clipAction(e, t, i) {
        const r = t || this._root
          , s = r.uuid;
        let o = typeof e == "string" ? il.findByName(r, e) : e;
        const a = o !== null ? o.uuid : e
          , l = this._actionsByClip[a];
        let c = null;
        if (i === void 0 && (o !== null ? i = o.blendMode : i = hh),
        l !== void 0) {
            const h = l.actionByRoot[s];
            if (h !== void 0 && h.blendMode === i)
                return h;
            c = l.knownActions[0],
            o === null && (o = c._clip)
        }
        if (o === null)
            return null;
        const u = new Wb(this,o,t,i);
        return this._bindAction(u, c),
        this._addInactiveAction(u, a, s),
        u
    }
    existingAction(e, t) {
        const i = t || this._root
          , r = i.uuid
          , s = typeof e == "string" ? il.findByName(i, e) : e
          , o = s ? s.uuid : e
          , a = this._actionsByClip[o];
        return a !== void 0 && a.actionByRoot[r] || null
    }
    stopAllAction() {
        const e = this._actions
          , t = this._nActiveActions;
        for (let i = t - 1; i >= 0; --i)
            e[i].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions
          , i = this._nActiveActions
          , r = this.time += e
          , s = Math.sign(e)
          , o = this._accuIndex ^= 1;
        for (let c = 0; c !== i; ++c)
            t[c]._update(r, e, s, o);
        const a = this._bindings
          , l = this._nActiveBindings;
        for (let c = 0; c !== l; ++c)
            a[c].apply(o);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++)
            this._actions[t].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const t = this._actions
          , i = e.uuid
          , r = this._actionsByClip
          , s = r[i];
        if (s !== void 0) {
            const o = s.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
                const c = o[a];
                this._deactivateAction(c);
                const u = c._cacheIndex
                  , h = t[t.length - 1];
                c._cacheIndex = null,
                c._byClipCacheIndex = null,
                h._cacheIndex = u,
                t[u] = h,
                t.pop(),
                this._removeInactiveBindingsForAction(c)
            }
            delete r[i]
        }
    }
    uncacheRoot(e) {
        const t = e.uuid
          , i = this._actionsByClip;
        for (const o in i) {
            const a = i[o].actionByRoot
              , l = a[t];
            l !== void 0 && (this._deactivateAction(l),
            this._removeInactiveAction(l))
        }
        const r = this._bindingsByRootAndName
          , s = r[t];
        if (s !== void 0)
            for (const o in s) {
                const a = s[o];
                a.restoreOriginalState(),
                this._removeInactiveBinding(a)
            }
    }
    uncacheAction(e, t) {
        const i = this.existingAction(e, t);
        i !== null && (this._deactivateAction(i),
        this._removeInactiveAction(i))
    }
}
class am {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new am(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
let _L = 0;
class yL extends Si {
    constructor() {
        super(),
        this.isUniformsGroup = !0,
        Object.defineProperty(this, "id", {
            value: _L++
        }),
        this.name = "",
        this.usage = Ya,
        this.uniforms = []
    }
    add(e) {
        return this.uniforms.push(e),
        this
    }
    remove(e) {
        const t = this.uniforms.indexOf(e);
        return t !== -1 && this.uniforms.splice(t, 1),
        this
    }
    setName(e) {
        return this.name = e,
        this
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }),
        this
    }
    copy(e) {
        this.name = e.name,
        this.usage = e.usage;
        const t = e.uniforms;
        this.uniforms.length = 0;
        for (let i = 0, r = t.length; i < r; i++) {
            const s = Array.isArray(t[i]) ? t[i] : [t[i]];
            for (let o = 0; o < s.length; o++)
                this.uniforms.push(s[o].clone())
        }
        return this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class xL extends xh {
    constructor(e, t, i=1) {
        super(e, t),
        this.isInstancedInterleavedBuffer = !0,
        this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    clone(e) {
        const t = super.clone(e);
        return t.meshPerAttribute = this.meshPerAttribute,
        t
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.isInstancedInterleavedBuffer = !0,
        t.meshPerAttribute = this.meshPerAttribute,
        t
    }
}
class bL {
    constructor(e, t, i, r, s) {
        this.isGLBufferAttribute = !0,
        this.name = "",
        this.buffer = e,
        this.type = t,
        this.itemSize = i,
        this.elementSize = r,
        this.count = s,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setBuffer(e) {
        return this.buffer = e,
        this
    }
    setType(e, t) {
        return this.type = e,
        this.elementSize = t,
        this
    }
    setItemSize(e) {
        return this.itemSize = e,
        this
    }
    setCount(e) {
        return this.count = e,
        this
    }
}
const Vv = new Be;
class Xb {
    constructor(e, t, i=0, r=1 / 0) {
        this.ray = new No(e,t),
        this.near = i,
        this.far = r,
        this.camera = null,
        this.layers = new ph,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, t) {
        this.ray.set(e, t)
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
    }
    setFromXRController(e) {
        return Vv.identity().extractRotation(e.matrixWorld),
        this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction.set(0, 0, -1).applyMatrix4(Vv),
        this
    }
    intersectObject(e, t=!0, i=[]) {
        return Od(e, this, i, t),
        i.sort(Hv),
        i
    }
    intersectObjects(e, t=!0, i=[]) {
        for (let r = 0, s = e.length; r < s; r++)
            Od(e[r], this, i, t);
        return i.sort(Hv),
        i
    }
}
function Hv(n, e) {
    return n.distance - e.distance
}
function Od(n, e, t, i) {
    let r = !0;
    if (n.layers.test(e.layers) && n.raycast(e, t) === !1 && (r = !1),
    r === !0 && i === !0) {
        const s = n.children;
        for (let o = 0, a = s.length; o < a; o++)
            Od(s[o], e, t, !0)
    }
}
class ML {
    constructor(e=1, t=0, i=0) {
        return this.radius = e,
        this.phi = t,
        this.theta = i,
        this
    }
    set(e, t, i) {
        return this.radius = e,
        this.phi = t,
        this.theta = i,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + t * t + i * i),
        this.radius === 0 ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(e, i),
        this.phi = Math.acos(It(t / this.radius, -1, 1))),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class SL {
    constructor(e=1, t=0, i=0) {
        return this.radius = e,
        this.theta = t,
        this.y = i,
        this
    }
    set(e, t, i) {
        return this.radius = e,
        this.theta = t,
        this.y = i,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.theta = e.theta,
        this.y = e.y,
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, i) {
        return this.radius = Math.sqrt(e * e + i * i),
        this.theta = Math.atan2(e, i),
        this.y = t,
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class lm {
    constructor(e, t, i, r) {
        lm.prototype.isMatrix2 = !0,
        this.elements = [1, 0, 0, 1],
        e !== void 0 && this.set(e, t, i, r)
    }
    identity() {
        return this.set(1, 0, 0, 1),
        this
    }
    fromArray(e, t=0) {
        for (let i = 0; i < 4; i++)
            this.elements[i] = e[i + t];
        return this
    }
    set(e, t, i, r) {
        const s = this.elements;
        return s[0] = e,
        s[2] = t,
        s[1] = i,
        s[3] = r,
        this
    }
}
const Gv = new ae;
class wL {
    constructor(e=new ae(1 / 0,1 / 0), t=new ae(-1 / 0,-1 / 0)) {
        this.isBox2 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const i = Gv.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(i),
        this.max.copy(e).add(i),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0,
        this.max.x = this.max.y = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, Gv).distanceTo(e)
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const Wv = new N
  , wc = new N;
class EL {
    constructor(e=new N, t=new N) {
        this.start = e,
        this.end = t
    }
    set(e, t) {
        return this.start.copy(e),
        this.end.copy(t),
        this
    }
    copy(e) {
        return this.start.copy(e.start),
        this.end.copy(e.end),
        this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, t) {
        Wv.subVectors(e, this.start),
        wc.subVectors(this.end, this.start);
        const i = wc.dot(wc);
        let s = wc.dot(Wv) / i;
        return t && (s = It(s, 0, 1)),
        s
    }
    closestPointToPoint(e, t, i) {
        const r = this.closestPointToPointParameter(e, t);
        return this.delta(i).multiplyScalar(r).add(this.start)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e),
        this.end.applyMatrix4(e),
        this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Xv = new N;
class AL extends tt {
    constructor(e, t) {
        super(),
        this.light = e,
        this.matrixAutoUpdate = !1,
        this.color = t,
        this.type = "SpotLightHelper";
        const i = new Ze
          , r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let o = 0, a = 1, l = 32; o < l; o++,
        a++) {
            const c = o / l * Math.PI * 2
              , u = a / l * Math.PI * 2;
            r.push(Math.cos(c), Math.sin(c), 1, Math.cos(u), Math.sin(u), 1)
        }
        i.setAttribute("position", new Le(r,3));
        const s = new xn({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new wi(i,s),
        this.add(this.cone),
        this.update()
    }
    dispose() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1),
        this.parent ? (this.parent.updateWorldMatrix(!0),
        this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld),
        this.matrixWorld.copy(this.light.matrixWorld);
        const e = this.light.distance ? this.light.distance : 1e3
          , t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e),
        Xv.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(Xv),
        this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
}
const ur = new N
  , Ec = new Be
  , Zf = new Be;
class TL extends wi {
    constructor(e) {
        const t = qb(e)
          , i = new Ze
          , r = []
          , s = []
          , o = new Ee(0,0,1)
          , a = new Ee(0,1,0);
        for (let c = 0; c < t.length; c++) {
            const u = t[c];
            u.parent && u.parent.isBone && (r.push(0, 0, 0),
            r.push(0, 0, 0),
            s.push(o.r, o.g, o.b),
            s.push(a.r, a.g, a.b))
        }
        i.setAttribute("position", new Le(r,3)),
        i.setAttribute("color", new Le(s,3));
        const l = new xn({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        super(i, l),
        this.isSkeletonHelper = !0,
        this.type = "SkeletonHelper",
        this.root = e,
        this.bones = t,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    updateMatrixWorld(e) {
        const t = this.bones
          , i = this.geometry
          , r = i.getAttribute("position");
        Zf.copy(this.root.matrixWorld).invert();
        for (let s = 0, o = 0; s < t.length; s++) {
            const a = t[s];
            a.parent && a.parent.isBone && (Ec.multiplyMatrices(Zf, a.matrixWorld),
            ur.setFromMatrixPosition(Ec),
            r.setXYZ(o, ur.x, ur.y, ur.z),
            Ec.multiplyMatrices(Zf, a.parent.matrixWorld),
            ur.setFromMatrixPosition(Ec),
            r.setXYZ(o + 1, ur.x, ur.y, ur.z),
            o += 2)
        }
        i.getAttribute("position").needsUpdate = !0,
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function qb(n) {
    const e = [];
    n.isBone === !0 && e.push(n);
    for (let t = 0; t < n.children.length; t++)
        e.push.apply(e, qb(n.children[t]));
    return e
}
class CL extends Ot {
    constructor(e, t, i) {
        const r = new Sl(t,4,2)
          , s = new Zi({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        });
        super(r, s),
        this.light = e,
        this.color = i,
        this.type = "PointLightHelper",
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
}
const RL = new N
  , qv = new Ee
  , $v = new Ee;
class PL extends tt {
    constructor(e, t, i) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        this.type = "HemisphereLightHelper";
        const r = new Ml(t);
        r.rotateY(Math.PI * .5),
        this.material = new Zi({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }),
        this.color === void 0 && (this.material.vertexColors = !0);
        const s = r.getAttribute("position")
          , o = new Float32Array(s.count * 3);
        r.setAttribute("color", new pt(o,3)),
        this.add(new Ot(r,this.material)),
        this.update()
    }
    dispose() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    update() {
        const e = this.children[0];
        if (this.color !== void 0)
            this.material.color.set(this.color);
        else {
            const t = e.geometry.getAttribute("color");
            qv.copy(this.light.color),
            $v.copy(this.light.groundColor);
            for (let i = 0, r = t.count; i < r; i++) {
                const s = i < r / 2 ? qv : $v;
                t.setXYZ(i, s.r, s.g, s.b)
            }
            t.needsUpdate = !0
        }
        this.light.updateWorldMatrix(!0, !1),
        e.lookAt(RL.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
}
class IL extends wi {
    constructor(e=10, t=10, i=4473924, r=8947848) {
        i = new Ee(i),
        r = new Ee(r);
        const s = t / 2
          , o = e / t
          , a = e / 2
          , l = []
          , c = [];
        for (let f = 0, d = 0, p = -a; f <= t; f++,
        p += o) {
            l.push(-a, 0, p, a, 0, p),
            l.push(p, 0, -a, p, 0, a);
            const v = f === s ? i : r;
            v.toArray(c, d),
            d += 3,
            v.toArray(c, d),
            d += 3,
            v.toArray(c, d),
            d += 3,
            v.toArray(c, d),
            d += 3
        }
        const u = new Ze;
        u.setAttribute("position", new Le(l,3)),
        u.setAttribute("color", new Le(c,3));
        const h = new xn({
            vertexColors: !0,
            toneMapped: !1
        });
        super(u, h),
        this.type = "GridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class LL extends wi {
    constructor(e=10, t=16, i=8, r=64, s=4473924, o=8947848) {
        s = new Ee(s),
        o = new Ee(o);
        const a = []
          , l = [];
        if (t > 1)
            for (let h = 0; h < t; h++) {
                const f = h / t * (Math.PI * 2)
                  , d = Math.sin(f) * e
                  , p = Math.cos(f) * e;
                a.push(0, 0, 0),
                a.push(d, 0, p);
                const v = h & 1 ? s : o;
                l.push(v.r, v.g, v.b),
                l.push(v.r, v.g, v.b)
            }
        for (let h = 0; h < i; h++) {
            const f = h & 1 ? s : o
              , d = e - e / i * h;
            for (let p = 0; p < r; p++) {
                let v = p / r * (Math.PI * 2)
                  , g = Math.sin(v) * d
                  , m = Math.cos(v) * d;
                a.push(g, 0, m),
                l.push(f.r, f.g, f.b),
                v = (p + 1) / r * (Math.PI * 2),
                g = Math.sin(v) * d,
                m = Math.cos(v) * d,
                a.push(g, 0, m),
                l.push(f.r, f.g, f.b)
            }
        }
        const c = new Ze;
        c.setAttribute("position", new Le(a,3)),
        c.setAttribute("color", new Le(l,3));
        const u = new xn({
            vertexColors: !0,
            toneMapped: !1
        });
        super(c, u),
        this.type = "PolarGridHelper"
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
const Yv = new N
  , Ac = new N
  , jv = new N;
class DL extends tt {
    constructor(e, t, i) {
        super(),
        this.light = e,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        this.type = "DirectionalLightHelper",
        t === void 0 && (t = 1);
        let r = new Ze;
        r.setAttribute("position", new Le([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
        const s = new xn({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new Ar(r,s),
        this.add(this.lightPlane),
        r = new Ze,
        r.setAttribute("position", new Le([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new Ar(r,s),
        this.add(this.targetLine),
        this.update()
    }
    dispose() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1),
        Yv.setFromMatrixPosition(this.light.matrixWorld),
        Ac.setFromMatrixPosition(this.light.target.matrixWorld),
        jv.subVectors(Ac, Yv),
        this.lightPlane.lookAt(Ac),
        this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(Ac),
        this.targetLine.scale.z = jv.length()
    }
}
const Tc = new N
  , Rt = new _l;
class NL extends wi {
    constructor(e) {
        const t = new Ze
          , i = new xn({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1
        })
          , r = []
          , s = []
          , o = {};
        a("n1", "n2"),
        a("n2", "n4"),
        a("n4", "n3"),
        a("n3", "n1"),
        a("f1", "f2"),
        a("f2", "f4"),
        a("f4", "f3"),
        a("f3", "f1"),
        a("n1", "f1"),
        a("n2", "f2"),
        a("n3", "f3"),
        a("n4", "f4"),
        a("p", "n1"),
        a("p", "n2"),
        a("p", "n3"),
        a("p", "n4"),
        a("u1", "u2"),
        a("u2", "u3"),
        a("u3", "u1"),
        a("c", "t"),
        a("p", "c"),
        a("cn1", "cn2"),
        a("cn3", "cn4"),
        a("cf1", "cf2"),
        a("cf3", "cf4");
        function a(p, v) {
            l(p),
            l(v)
        }
        function l(p) {
            r.push(0, 0, 0),
            s.push(0, 0, 0),
            o[p] === void 0 && (o[p] = []),
            o[p].push(r.length / 3 - 1)
        }
        t.setAttribute("position", new Le(r,3)),
        t.setAttribute("color", new Le(s,3)),
        super(t, i),
        this.type = "CameraHelper",
        this.camera = e,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = o,
        this.update();
        const c = new Ee(16755200)
          , u = new Ee(16711680)
          , h = new Ee(43775)
          , f = new Ee(16777215)
          , d = new Ee(3355443);
        this.setColors(c, u, h, f, d)
    }
    setColors(e, t, i, r, s) {
        const a = this.geometry.getAttribute("color");
        a.setXYZ(0, e.r, e.g, e.b),
        a.setXYZ(1, e.r, e.g, e.b),
        a.setXYZ(2, e.r, e.g, e.b),
        a.setXYZ(3, e.r, e.g, e.b),
        a.setXYZ(4, e.r, e.g, e.b),
        a.setXYZ(5, e.r, e.g, e.b),
        a.setXYZ(6, e.r, e.g, e.b),
        a.setXYZ(7, e.r, e.g, e.b),
        a.setXYZ(8, e.r, e.g, e.b),
        a.setXYZ(9, e.r, e.g, e.b),
        a.setXYZ(10, e.r, e.g, e.b),
        a.setXYZ(11, e.r, e.g, e.b),
        a.setXYZ(12, e.r, e.g, e.b),
        a.setXYZ(13, e.r, e.g, e.b),
        a.setXYZ(14, e.r, e.g, e.b),
        a.setXYZ(15, e.r, e.g, e.b),
        a.setXYZ(16, e.r, e.g, e.b),
        a.setXYZ(17, e.r, e.g, e.b),
        a.setXYZ(18, e.r, e.g, e.b),
        a.setXYZ(19, e.r, e.g, e.b),
        a.setXYZ(20, e.r, e.g, e.b),
        a.setXYZ(21, e.r, e.g, e.b),
        a.setXYZ(22, e.r, e.g, e.b),
        a.setXYZ(23, e.r, e.g, e.b),
        a.setXYZ(24, t.r, t.g, t.b),
        a.setXYZ(25, t.r, t.g, t.b),
        a.setXYZ(26, t.r, t.g, t.b),
        a.setXYZ(27, t.r, t.g, t.b),
        a.setXYZ(28, t.r, t.g, t.b),
        a.setXYZ(29, t.r, t.g, t.b),
        a.setXYZ(30, t.r, t.g, t.b),
        a.setXYZ(31, t.r, t.g, t.b),
        a.setXYZ(32, i.r, i.g, i.b),
        a.setXYZ(33, i.r, i.g, i.b),
        a.setXYZ(34, i.r, i.g, i.b),
        a.setXYZ(35, i.r, i.g, i.b),
        a.setXYZ(36, i.r, i.g, i.b),
        a.setXYZ(37, i.r, i.g, i.b),
        a.setXYZ(38, r.r, r.g, r.b),
        a.setXYZ(39, r.r, r.g, r.b),
        a.setXYZ(40, s.r, s.g, s.b),
        a.setXYZ(41, s.r, s.g, s.b),
        a.setXYZ(42, s.r, s.g, s.b),
        a.setXYZ(43, s.r, s.g, s.b),
        a.setXYZ(44, s.r, s.g, s.b),
        a.setXYZ(45, s.r, s.g, s.b),
        a.setXYZ(46, s.r, s.g, s.b),
        a.setXYZ(47, s.r, s.g, s.b),
        a.setXYZ(48, s.r, s.g, s.b),
        a.setXYZ(49, s.r, s.g, s.b),
        a.needsUpdate = !0
    }
    update() {
        const e = this.geometry
          , t = this.pointMap
          , i = 1
          , r = 1;
        Rt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        Nt("c", t, e, Rt, 0, 0, -1),
        Nt("t", t, e, Rt, 0, 0, 1),
        Nt("n1", t, e, Rt, -i, -r, -1),
        Nt("n2", t, e, Rt, i, -r, -1),
        Nt("n3", t, e, Rt, -i, r, -1),
        Nt("n4", t, e, Rt, i, r, -1),
        Nt("f1", t, e, Rt, -i, -r, 1),
        Nt("f2", t, e, Rt, i, -r, 1),
        Nt("f3", t, e, Rt, -i, r, 1),
        Nt("f4", t, e, Rt, i, r, 1),
        Nt("u1", t, e, Rt, i * .7, r * 1.1, -1),
        Nt("u2", t, e, Rt, -i * .7, r * 1.1, -1),
        Nt("u3", t, e, Rt, 0, r * 2, -1),
        Nt("cf1", t, e, Rt, -i, 0, 1),
        Nt("cf2", t, e, Rt, i, 0, 1),
        Nt("cf3", t, e, Rt, 0, -r, 1),
        Nt("cf4", t, e, Rt, 0, r, 1),
        Nt("cn1", t, e, Rt, -i, 0, -1),
        Nt("cn2", t, e, Rt, i, 0, -1),
        Nt("cn3", t, e, Rt, 0, -r, -1),
        Nt("cn4", t, e, Rt, 0, r, -1),
        e.getAttribute("position").needsUpdate = !0
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
function Nt(n, e, t, i, r, s, o) {
    Tc.set(r, s, o).unproject(i);
    const a = e[n];
    if (a !== void 0) {
        const l = t.getAttribute("position");
        for (let c = 0, u = a.length; c < u; c++)
            l.setXYZ(a[c], Tc.x, Tc.y, Tc.z)
    }
}
const Cc = new yn;
class UL extends wi {
    constructor(e, t=16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , r = new Float32Array(8 * 3)
          , s = new Ze;
        s.setIndex(new pt(i,1)),
        s.setAttribute("position", new pt(r,3)),
        super(s, new xn({
            color: t,
            toneMapped: !1
        })),
        this.object = e,
        this.type = "BoxHelper",
        this.matrixAutoUpdate = !1,
        this.update()
    }
    update(e) {
        if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
        this.object !== void 0 && Cc.setFromObject(this.object),
        Cc.isEmpty())
            return;
        const t = Cc.min
          , i = Cc.max
          , r = this.geometry.attributes.position
          , s = r.array;
        s[0] = i.x,
        s[1] = i.y,
        s[2] = i.z,
        s[3] = t.x,
        s[4] = i.y,
        s[5] = i.z,
        s[6] = t.x,
        s[7] = t.y,
        s[8] = i.z,
        s[9] = i.x,
        s[10] = t.y,
        s[11] = i.z,
        s[12] = i.x,
        s[13] = i.y,
        s[14] = t.z,
        s[15] = t.x,
        s[16] = i.y,
        s[17] = t.z,
        s[18] = t.x,
        s[19] = t.y,
        s[20] = t.z,
        s[21] = i.x,
        s[22] = t.y,
        s[23] = t.z,
        r.needsUpdate = !0,
        this.geometry.computeBoundingSphere()
    }
    setFromObject(e) {
        return this.object = e,
        this.update(),
        this
    }
    copy(e, t) {
        return super.copy(e, t),
        this.object = e.object,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class OL extends wi {
    constructor(e, t=16776960) {
        const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
          , r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1]
          , s = new Ze;
        s.setIndex(new pt(i,1)),
        s.setAttribute("position", new Le(r,3)),
        super(s, new xn({
            color: t,
            toneMapped: !1
        })),
        this.box = e,
        this.type = "Box3Helper",
        this.geometry.computeBoundingSphere()
    }
    updateMatrixWorld(e) {
        const t = this.box;
        t.isEmpty() || (t.getCenter(this.position),
        t.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        super.updateMatrixWorld(e))
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class FL extends Ar {
    constructor(e, t=1, i=16776960) {
        const r = i
          , s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0]
          , o = new Ze;
        o.setAttribute("position", new Le(s,3)),
        o.computeBoundingSphere(),
        super(o, new xn({
            color: r,
            toneMapped: !1
        })),
        this.type = "PlaneHelper",
        this.plane = e,
        this.size = t;
        const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]
          , l = new Ze;
        l.setAttribute("position", new Le(a,3)),
        l.computeBoundingSphere(),
        this.add(new Ot(l,new Zi({
            color: r,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }
    updateMatrixWorld(e) {
        this.position.set(0, 0, 0),
        this.scale.set(.5 * this.size, .5 * this.size, 1),
        this.lookAt(this.plane.normal),
        this.translateZ(-this.plane.constant),
        super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose(),
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
}
const Kv = new N;
let Rc, Jf;
class BL extends tt {
    constructor(e=new N(0,0,1), t=new N(0,0,0), i=1, r=16776960, s=i * .2, o=s * .2) {
        super(),
        this.type = "ArrowHelper",
        Rc === void 0 && (Rc = new Ze,
        Rc.setAttribute("position", new Le([0, 0, 0, 0, 1, 0],3)),
        Jf = new Fo(0,.5,1,5,1),
        Jf.translate(0, -.5, 0)),
        this.position.copy(t),
        this.line = new Ar(Rc,new xn({
            color: r,
            toneMapped: !1
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new Ot(Jf,new Zi({
            color: r,
            toneMapped: !1
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(i, s, o)
    }
    setDirection(e) {
        if (e.y > .99999)
            this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -.99999)
            this.quaternion.set(1, 0, 0, 0);
        else {
            Kv.set(e.z, 0, -e.x).normalize();
            const t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(Kv, t)
        }
    }
    setLength(e, t=e * .2, i=t * .2) {
        this.line.scale.set(1, Math.max(1e-4, e - t), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(i, t, i),
        this.cone.position.y = e,
        this.cone.updateMatrix()
    }
    setColor(e) {
        this.line.material.color.set(e),
        this.cone.material.color.set(e)
    }
    copy(e) {
        return super.copy(e, !1),
        this.line.copy(e.line),
        this.cone.copy(e.cone),
        this
    }
    dispose() {
        this.line.geometry.dispose(),
        this.line.material.dispose(),
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
}
class zL extends wi {
    constructor(e=1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
          , i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]
          , r = new Ze;
        r.setAttribute("position", new Le(t,3)),
        r.setAttribute("color", new Le(i,3));
        const s = new xn({
            vertexColors: !0,
            toneMapped: !1
        });
        super(r, s),
        this.type = "AxesHelper"
    }
    setColors(e, t, i) {
        const r = new Ee
          , s = this.geometry.attributes.color.array;
        return r.set(e),
        r.toArray(s, 0),
        r.toArray(s, 3),
        r.set(t),
        r.toArray(s, 6),
        r.toArray(s, 9),
        r.set(i),
        r.toArray(s, 12),
        r.toArray(s, 15),
        this.geometry.attributes.color.needsUpdate = !0,
        this
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
}
class kL {
    constructor() {
        this.type = "ShapePath",
        this.color = new Ee,
        this.subPaths = [],
        this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new Za,
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t),
        this
    }
    quadraticCurveTo(e, t, i, r) {
        return this.currentPath.quadraticCurveTo(e, t, i, r),
        this
    }
    bezierCurveTo(e, t, i, r, s, o) {
        return this.currentPath.bezierCurveTo(e, t, i, r, s, o),
        this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e),
        this
    }
    toShapes(e) {
        function t(m) {
            const y = [];
            for (let _ = 0, x = m.length; _ < x; _++) {
                const C = m[_]
                  , w = new ds;
                w.curves = C.curves,
                y.push(w)
            }
            return y
        }
        function i(m, y) {
            const _ = y.length;
            let x = !1;
            for (let C = _ - 1, w = 0; w < _; C = w++) {
                let E = y[C]
                  , L = y[w]
                  , S = L.x - E.x
                  , b = L.y - E.y;
                if (Math.abs(b) > Number.EPSILON) {
                    if (b < 0 && (E = y[w],
                    S = -S,
                    L = y[C],
                    b = -b),
                    m.y < E.y || m.y > L.y)
                        continue;
                    if (m.y === E.y) {
                        if (m.x === E.x)
                            return !0
                    } else {
                        const D = b * (m.x - E.x) - S * (m.y - E.y);
                        if (D === 0)
                            return !0;
                        if (D < 0)
                            continue;
                        x = !x
                    }
                } else {
                    if (m.y !== E.y)
                        continue;
                    if (L.x <= m.x && m.x <= E.x || E.x <= m.x && m.x <= L.x)
                        return !0
                }
            }
            return x
        }
        const r = yi.isClockWise
          , s = this.subPaths;
        if (s.length === 0)
            return [];
        let o, a, l;
        const c = [];
        if (s.length === 1)
            return a = s[0],
            l = new ds,
            l.curves = a.curves,
            c.push(l),
            c;
        let u = !r(s[0].getPoints());
        u = e ? !u : u;
        const h = []
          , f = [];
        let d = [], p = 0, v;
        f[p] = void 0,
        d[p] = [];
        for (let m = 0, y = s.length; m < y; m++)
            a = s[m],
            v = a.getPoints(),
            o = r(v),
            o = e ? !o : o,
            o ? (!u && f[p] && p++,
            f[p] = {
                s: new ds,
                p: v
            },
            f[p].s.curves = a.curves,
            u && p++,
            d[p] = []) : d[p].push({
                h: a,
                p: v[0]
            });
        if (!f[0])
            return t(s);
        if (f.length > 1) {
            let m = !1
              , y = 0;
            for (let _ = 0, x = f.length; _ < x; _++)
                h[_] = [];
            for (let _ = 0, x = f.length; _ < x; _++) {
                const C = d[_];
                for (let w = 0; w < C.length; w++) {
                    const E = C[w];
                    let L = !0;
                    for (let S = 0; S < f.length; S++)
                        i(E.p, f[S].p) && (_ !== S && y++,
                        L ? (L = !1,
                        h[S].push(E)) : m = !0);
                    L && h[_].push(E)
                }
            }
            y > 0 && m === !1 && (d = h)
        }
        let g;
        for (let m = 0, y = f.length; m < y; m++) {
            l = f[m].s,
            c.push(l),
            g = d[m];
            for (let _ = 0, x = g.length; _ < x; _++)
                l.holes.push(g[_].h)
        }
        return c
    }
}
class VL extends Si {
    constructor(e, t) {
        super(),
        this.object = e,
        this.domElement = t,
        this.enabled = !0,
        this.state = -1,
        this.keys = {},
        this.mouseButtons = {
            LEFT: null,
            MIDDLE: null,
            RIGHT: null
        },
        this.touches = {
            ONE: null,
            TWO: null
        }
    }
    connect() {}
    disconnect() {}
    dispose() {}
    update() {}
}
class HL extends si {
    constructor(e=1, t=1, i=1, r={}) {
        console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'),
        super(e, t, {
            ...r,
            count: i
        }),
        this.isWebGLMultipleRenderTargets = !0
    }
    get texture() {
        return this.textures
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: pl
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = pl);
const GL = Object.freeze(Object.defineProperty({
    __proto__: null,
    ACESFilmicToneMapping: ih,
    AddEquation: yr,
    AddOperation: gx,
    AdditiveAnimationBlendMode: Lp,
    AdditiveBlending: Md,
    AgXToneMapping: bx,
    AlphaFormat: Ap,
    AlwaysCompare: Ox,
    AlwaysDepth: cx,
    AlwaysStencilFunc: Ad,
    AmbientLight: Ob,
    AnimationAction: Wb,
    AnimationClip: il,
    AnimationLoader: HI,
    AnimationMixer: vL,
    AnimationObjectGroup: mL,
    AnimationUtils: BI,
    ArcCurve: ab,
    ArrayCamera: Jx,
    ArrowHelper: BL,
    AttachedBindMode: Ed,
    Audio: Hb,
    AudioAnalyser: sL,
    AudioContext: rm,
    AudioListener: nL,
    AudioLoader: QI,
    AxesHelper: zL,
    BackSide: _n,
    BasicDepthPacking: Tx,
    BasicShadowMap: BE,
    BatchedMesh: rb,
    Bone: Wp,
    BooleanKeyframeTrack: ws,
    Box2: wL,
    Box3: yn,
    Box3Helper: OL,
    BoxGeometry: Ss,
    BoxHelper: UL,
    BufferAttribute: pt,
    BufferGeometry: Ze,
    BufferGeometryLoader: Vb,
    ByteType: Sp,
    Cache: zi,
    Camera: _l,
    CameraHelper: NL,
    CanvasTexture: lI,
    CapsuleGeometry: wh,
    CatmullRomCurve3: lb,
    CineonToneMapping: yx,
    CircleGeometry: Eh,
    ClampToEdgeWrapping: Gn,
    Clock: Bh,
    Color: Ee,
    ColorKeyframeTrack: tm,
    ColorManagement: st,
    CompressedArrayTexture: oI,
    CompressedCubeTexture: aI,
    CompressedTexture: Mh,
    CompressedTextureLoader: GI,
    ConeGeometry: Ah,
    ConstantAlphaFactor: ox,
    ConstantColorFactor: rx,
    Controls: VL,
    CubeCamera: Wx,
    CubeReflectionMapping: Xi,
    CubeRefractionMapping: Er,
    CubeTexture: yl,
    CubeTextureLoader: WI,
    CubeUVReflectionMapping: Lo,
    CubicBezierCurve: $p,
    CubicBezierCurve3: cb,
    CubicInterpolant: Cb,
    CullFaceBack: bd,
    CullFaceFront: Gy,
    CullFaceFrontBack: FE,
    CullFaceNone: Hy,
    Curve: li,
    CurvePath: hb,
    CustomBlending: Wy,
    CustomToneMapping: xx,
    CylinderGeometry: Fo,
    Cylindrical: SL,
    Data3DTexture: Op,
    DataArrayTexture: dh,
    DataTexture: _i,
    DataTextureLoader: XI,
    DataUtils: KA,
    DecrementStencilOp: JE,
    DecrementWrapStencilOp: eA,
    DefaultLoadingManager: Ib,
    DepthFormat: hs,
    DepthStencilFormat: _s,
    DepthTexture: kp,
    DetachedBindMode: Sx,
    DirectionalLight: Ub,
    DirectionalLightHelper: DL,
    DiscreteInterpolant: Rb,
    DisplayP3ColorSpace: fh,
    DodecahedronGeometry: Th,
    DoubleSide: Zn,
    DstAlphaFactor: Qy,
    DstColorFactor: tx,
    DynamicCopyUsage: mA,
    DynamicDrawUsage: cA,
    DynamicReadUsage: fA,
    EdgesGeometry: fb,
    EllipseCurve: Sh,
    EqualCompare: Lx,
    EqualDepth: hx,
    EqualStencilFunc: rA,
    EquirectangularReflectionMapping: za,
    EquirectangularRefractionMapping: ka,
    Euler: Un,
    EventDispatcher: Si,
    ExtrudeGeometry: Rh,
    FileLoader: $i,
    Float16BufferAttribute: nT,
    Float32BufferAttribute: Le,
    FloatType: Mn,
    Fog: _h,
    FogExp2: vh,
    FramebufferTexture: sI,
    FrontSide: Wi,
    Frustum: xl,
    GLBufferAttribute: bL,
    GLSL1: vA,
    GLSL3: Td,
    GreaterCompare: Dx,
    GreaterDepth: dx,
    GreaterEqualCompare: Ux,
    GreaterEqualDepth: fx,
    GreaterEqualStencilFunc: lA,
    GreaterStencilFunc: oA,
    GridHelper: IL,
    Group: no,
    HalfFloatType: Do,
    HemisphereLight: Lb,
    HemisphereLightHelper: PL,
    IcosahedronGeometry: Ph,
    ImageBitmapLoader: JI,
    ImageLoader: rl,
    ImageUtils: zx,
    IncrementStencilOp: ZE,
    IncrementWrapStencilOp: QE,
    InstancedBufferAttribute: wo,
    InstancedBufferGeometry: kb,
    InstancedInterleavedBuffer: xL,
    InstancedMesh: ib,
    Int16BufferAttribute: eT,
    Int32BufferAttribute: tT,
    Int8BufferAttribute: ZA,
    IntType: sh,
    InterleavedBuffer: xh,
    InterleavedBufferAttribute: ys,
    Interpolant: wl,
    InterpolateDiscrete: Ga,
    InterpolateLinear: Iu,
    InterpolateSmooth: Vc,
    InvertStencilOp: tA,
    KeepStencilOp: Kr,
    KeyframeTrack: ci,
    LOD: tb,
    LatheGeometry: bl,
    Layers: ph,
    LessCompare: Ix,
    LessDepth: ux,
    LessEqualCompare: Dp,
    LessEqualDepth: Ba,
    LessEqualStencilFunc: sA,
    LessStencilFunc: iA,
    Light: Lr,
    LightProbe: zb,
    Line: Ar,
    Line3: EL,
    LineBasicMaterial: xn,
    LineCurve: Yp,
    LineCurve3: ub,
    LineDashedMaterial: Eb,
    LineLoop: sb,
    LineSegments: wi,
    LinearDisplayP3ColorSpace: vl,
    LinearFilter: Gt,
    LinearInterpolant: em,
    LinearMipMapLinearFilter: HE,
    LinearMipMapNearestFilter: VE,
    LinearMipmapLinearFilter: pi,
    LinearMipmapNearestFilter: pa,
    LinearSRGBColorSpace: Ki,
    LinearToneMapping: vx,
    LinearTransfer: Xa,
    Loader: wn,
    LoaderUtils: Ud,
    LoadingManager: nm,
    LoopOnce: wx,
    LoopPingPong: Ax,
    LoopRepeat: Ex,
    LuminanceAlphaFormat: Rp,
    LuminanceFormat: Cp,
    MOUSE: UE,
    Material: cn,
    MaterialLoader: Fh,
    MathUtils: Up,
    Matrix2: lm,
    Matrix3: Ye,
    Matrix4: Be,
    MaxEquation: Yy,
    Mesh: Ot,
    MeshBasicMaterial: Zi,
    MeshDepthMaterial: Vp,
    MeshDistanceMaterial: Hp,
    MeshLambertMaterial: Sb,
    MeshMatcapMaterial: wb,
    MeshNormalMaterial: Mb,
    MeshPhongMaterial: xb,
    MeshPhysicalMaterial: yb,
    MeshStandardMaterial: Jp,
    MeshToonMaterial: bb,
    MinEquation: $y,
    MirroredRepeatWrapping: Ha,
    MixOperation: mx,
    MultiplyBlending: wd,
    MultiplyOperation: ml,
    NearestFilter: Kt,
    NearestMipMapLinearFilter: kE,
    NearestMipMapNearestFilter: zE,
    NearestMipmapLinearFilter: Qs,
    NearestMipmapNearestFilter: Mp,
    NeutralToneMapping: Mx,
    NeverCompare: Px,
    NeverDepth: lx,
    NeverStencilFunc: nA,
    NoBlending: Vi,
    NoColorSpace: Fi,
    NoToneMapping: vi,
    NormalAnimationBlendMode: hh,
    NormalBlending: us,
    NotEqualCompare: Nx,
    NotEqualDepth: px,
    NotEqualStencilFunc: aA,
    NumberKeyframeTrack: tl,
    Object3D: tt,
    ObjectLoader: KI,
    ObjectSpaceNormalMap: Rx,
    OctahedronGeometry: Ml,
    OneFactor: Ky,
    OneMinusConstantAlphaFactor: ax,
    OneMinusConstantColorFactor: sx,
    OneMinusDstAlphaFactor: ex,
    OneMinusDstColorFactor: nx,
    OneMinusSrcAlphaFactor: ru,
    OneMinusSrcColorFactor: Jy,
    OrthographicCamera: mh,
    P3Primaries: $a,
    PCFShadowMap: xp,
    PCFSoftShadowMap: bp,
    PMREMGenerator: Cd,
    Path: Za,
    PerspectiveCamera: Ht,
    Plane: gr,
    PlaneGeometry: Uo,
    PlaneHelper: FL,
    PointLight: Nb,
    PointLightHelper: CL,
    Points: ob,
    PointsMaterial: Xp,
    PolarGridHelper: LL,
    PolyhedronGeometry: Ir,
    PositionalAudio: rL,
    PropertyBinding: it,
    PropertyMixer: Gb,
    QuadraticBezierCurve: jp,
    QuadraticBezierCurve3: Kp,
    Quaternion: Sn,
    QuaternionKeyframeTrack: El,
    QuaternionLinearInterpolant: Pb,
    RED_GREEN_RGTC2_Format: Ru,
    RED_RGTC1_Format: Ip,
    REVISION: pl,
    RGBADepthPacking: Cx,
    RGBAFormat: vn,
    RGBAIntegerFormat: uh,
    RGBA_ASTC_10x10_Format: Su,
    RGBA_ASTC_10x5_Format: xu,
    RGBA_ASTC_10x6_Format: bu,
    RGBA_ASTC_10x8_Format: Mu,
    RGBA_ASTC_12x10_Format: wu,
    RGBA_ASTC_12x12_Format: Eu,
    RGBA_ASTC_4x4_Format: fu,
    RGBA_ASTC_5x4_Format: du,
    RGBA_ASTC_5x5_Format: pu,
    RGBA_ASTC_6x5_Format: mu,
    RGBA_ASTC_6x6_Format: gu,
    RGBA_ASTC_8x5_Format: vu,
    RGBA_ASTC_8x6_Format: _u,
    RGBA_ASTC_8x8_Format: yu,
    RGBA_BPTC_Format: ya,
    RGBA_ETC2_EAC_Format: hu,
    RGBA_PVRTC_2BPPV1_Format: lu,
    RGBA_PVRTC_4BPPV1_Format: au,
    RGBA_S3TC_DXT1_Format: ga,
    RGBA_S3TC_DXT3_Format: va,
    RGBA_S3TC_DXT5_Format: _a,
    RGBDepthPacking: $E,
    RGBFormat: Tp,
    RGBIntegerFormat: GE,
    RGB_BPTC_SIGNED_Format: Au,
    RGB_BPTC_UNSIGNED_Format: Tu,
    RGB_ETC1_Format: cu,
    RGB_ETC2_Format: uu,
    RGB_PVRTC_2BPPV1_Format: ou,
    RGB_PVRTC_4BPPV1_Format: su,
    RGB_S3TC_DXT1_Format: ma,
    RGDepthPacking: YE,
    RGFormat: Pp,
    RGIntegerFormat: ch,
    RawShaderMaterial: _b,
    Ray: No,
    Raycaster: Xb,
    Rec709Primaries: qa,
    RectAreaLight: Fb,
    RedFormat: lh,
    RedIntegerFormat: gl,
    ReinhardToneMapping: _x,
    RenderTarget: kx,
    RepeatWrapping: Va,
    ReplaceStencilOp: KE,
    ReverseSubtractEquation: qy,
    RingGeometry: Ih,
    SIGNED_RED_GREEN_RGTC2_Format: Pu,
    SIGNED_RED_RGTC1_Format: Cu,
    SRGBColorSpace: Rn,
    SRGBTransfer: xt,
    Scene: yh,
    ShaderChunk: Ke,
    ShaderLib: Kn,
    ShaderMaterial: oi,
    ShadowMaterial: vb,
    Shape: ds,
    ShapeGeometry: Lh,
    ShapePath: kL,
    ShapeUtils: yi,
    ShortType: wp,
    Skeleton: bh,
    SkeletonHelper: TL,
    SkinnedMesh: nb,
    Source: rs,
    Sphere: an,
    SphereGeometry: Sl,
    Spherical: ML,
    SphericalHarmonics3: Bb,
    SplineCurve: Zp,
    SpotLight: Db,
    SpotLightHelper: AL,
    Sprite: eb,
    SpriteMaterial: Gp,
    SrcAlphaFactor: iu,
    SrcAlphaSaturateFactor: ix,
    SrcColorFactor: Zy,
    StaticCopyUsage: pA,
    StaticDrawUsage: Ya,
    StaticReadUsage: hA,
    StereoCamera: eL,
    StreamCopyUsage: gA,
    StreamDrawUsage: uA,
    StreamReadUsage: dA,
    StringKeyframeTrack: Es,
    SubtractEquation: Xy,
    SubtractiveBlending: Sd,
    TOUCH: OE,
    TangentSpaceNormalMap: Pr,
    TetrahedronGeometry: Dh,
    Texture: Dt,
    TextureLoader: qI,
    TextureUtils: BP,
    TorusGeometry: Nh,
    TorusKnotGeometry: Uh,
    Triangle: In,
    TriangleFanDrawMode: qE,
    TriangleStripDrawMode: XE,
    TrianglesDrawMode: WE,
    TubeGeometry: Oh,
    UVMapping: rh,
    Uint16BufferAttribute: Fp,
    Uint32BufferAttribute: Bp,
    Uint8BufferAttribute: JA,
    Uint8ClampedBufferAttribute: QA,
    Uniform: am,
    UniformsGroup: yL,
    UniformsLib: we,
    UniformsUtils: Gx,
    UnsignedByteType: bi,
    UnsignedInt248Type: vs,
    UnsignedInt5999Type: Ep,
    UnsignedIntType: qi,
    UnsignedShort4444Type: oh,
    UnsignedShort5551Type: ah,
    UnsignedShortType: bo,
    VSMShadowMap: fi,
    Vector2: ae,
    Vector3: N,
    Vector4: ft,
    VectorKeyframeTrack: nl,
    VideoTexture: rI,
    WebGL3DRenderTarget: kA,
    WebGLArrayRenderTarget: zA,
    WebGLCoordinateSystem: mi,
    WebGLCubeRenderTarget: Xx,
    WebGLMultipleRenderTargets: HL,
    WebGLRenderTarget: si,
    WebGLRenderer: Gc,
    WebGLUtils: Zx,
    WebGPUCoordinateSystem: ja,
    WireframeGeometry: gb,
    WrapAroundEnding: Wa,
    ZeroCurvatureEnding: ns,
    ZeroFactor: jy,
    ZeroSlopeEnding: is,
    ZeroStencilOp: jE,
    createCanvasElement: Bx
}, Symbol.toStringTag, {
    value: "Module"
}));
function Mi(n) {
    return M0() ? (aS(n),
    !0) : !1
}
function Vn() {
    const n = new Set
      , e = r => {
        n.delete(r)
    }
    ;
    return {
        on: r => {
            n.add(r);
            const s = () => e(r);
            return Mi(s),
            {
                off: s
            }
        }
        ,
        off: e,
        trigger: (...r) => Promise.all(Array.from(n).map(s => s(...r)))
    }
}
function Mt(n) {
    return typeof n == "function" ? n() : Pn(n)
}
const Fd = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const WL = n => n != null
  , XL = Object.prototype.toString
  , qL = n => XL.call(n) === "[object Object]"
  , Bd = () => {}
;
function $L(n, e) {
    function t(...i) {
        return new Promise( (r, s) => {
            Promise.resolve(n( () => e.apply(this, i), {
                fn: e,
                thisArg: this,
                args: i
            })).then(r).catch(s)
        }
        )
    }
    return t
}
function YL(n, e={}) {
    let t, i, r = Bd;
    const s = a => {
        clearTimeout(a),
        r(),
        r = Bd
    }
    ;
    return a => {
        const l = Mt(n)
          , c = Mt(e.maxWait);
        return t && s(t),
        l <= 0 || c !== void 0 && c <= 0 ? (i && (s(i),
        i = null),
        Promise.resolve(a())) : new Promise( (u, h) => {
            r = e.rejectOnCancel ? h : u,
            c && !i && (i = setTimeout( () => {
                t && s(t),
                i = null,
                u(a())
            }
            , c)),
            t = setTimeout( () => {
                i && s(i),
                i = null,
                u(a())
            }
            , l)
        }
        )
    }
}
function jL(n, e, t=!1) {
    return e.reduce( (i, r) => (r in n && (!t || n[r] !== void 0) && (i[r] = n[r]),
    i), {})
}
function KL(n) {
    return wr()
}
function ZL(n, e=200, t={}) {
    return $L(YL(e, t), n)
}
function Zv(n, e=200, t={}) {
    const i = Qe(n.value)
      , r = ZL( () => {
        i.value = n.value
    }
    , e, t);
    return Bt(n, () => r()),
    i
}
function JL(n, e={}) {
    if (!Ft(n))
        return NS(n);
    const t = Array.isArray(n.value) ? Array.from({
        length: n.value.length
    }) : {};
    for (const i in n.value)
        t[i] = DS( () => ({
            get() {
                return n.value[i]
            },
            set(r) {
                var s;
                if ((s = Mt(e.replaceRef)) != null ? s : !0)
                    if (Array.isArray(n.value)) {
                        const a = [...n.value];
                        a[i] = r,
                        n.value = a
                    } else {
                        const a = {
                            ...n.value,
                            [i]: r
                        };
                        Object.setPrototypeOf(a, Object.getPrototypeOf(n.value)),
                        n.value = a
                    }
                else
                    n.value[i] = r
            }
        }));
    return t
}
function cm(n, e=!0, t) {
    KL() ? Ms(n, t) : e ? n() : as(n)
}
function QL(n, e=1e3, t={}) {
    const {immediate: i=!0, immediateCallback: r=!1} = t;
    let s = null;
    const o = Qe(!1);
    function a() {
        s && (clearInterval(s),
        s = null)
    }
    function l() {
        o.value = !1,
        a()
    }
    function c() {
        const u = Mt(e);
        u <= 0 || (o.value = !0,
        r && n(),
        a(),
        s = setInterval(n, u))
    }
    if (i && Fd && c(),
    Ft(e) || typeof e == "function") {
        const u = Bt(e, () => {
            o.value && Fd && c()
        }
        );
        Mi(u)
    }
    return Mi(l),
    {
        isActive: o,
        pause: l,
        resume: c
    }
}
function Jn(n) {
    var e;
    const t = Mt(n);
    return (e = t == null ? void 0 : t.$el) != null ? e : t
}
const Ji = Fd ? window : void 0;
function sl(...n) {
    let e, t, i, r;
    if (typeof n[0] == "string" || Array.isArray(n[0]) ? ([t,i,r] = n,
    e = Ji) : [e,t,i,r] = n,
    !e)
        return Bd;
    Array.isArray(t) || (t = [t]),
    Array.isArray(i) || (i = [i]);
    const s = []
      , o = () => {
        s.forEach(u => u()),
        s.length = 0
    }
      , a = (u, h, f, d) => (u.addEventListener(h, f, d),
    () => u.removeEventListener(h, f, d))
      , l = Bt( () => [Jn(e), Mt(r)], ([u,h]) => {
        if (o(),
        !u)
            return;
        const f = qL(h) ? {
            ...h
        } : h;
        s.push(...t.flatMap(d => i.map(p => a(u, d, p, f))))
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , c = () => {
        l(),
        o()
    }
    ;
    return Mi(c),
    c
}
function eD() {
    const n = Qe(!1)
      , e = wr();
    return e && Ms( () => {
        n.value = !0
    }
    , e),
    n
}
function zh(n) {
    const e = eD();
    return Lt( () => (e.value,
    !!n()))
}
function tD(n, e, t={}) {
    const {window: i=Ji, ...r} = t;
    let s;
    const o = zh( () => i && "MutationObserver"in i)
      , a = () => {
        s && (s.disconnect(),
        s = void 0)
    }
      , l = Lt( () => {
        const f = Mt(n)
          , d = (Array.isArray(f) ? f : [f]).map(Jn).filter(WL);
        return new Set(d)
    }
    )
      , c = Bt( () => l.value, f => {
        a(),
        o.value && f.size && (s = new MutationObserver(e),
        f.forEach(d => s.observe(d, r)))
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , u = () => s == null ? void 0 : s.takeRecords()
      , h = () => {
        a(),
        c()
    }
    ;
    return Mi(h),
    {
        isSupported: o,
        stop: h,
        takeRecords: u
    }
}
function um(n, e={}) {
    const {immediate: t=!0, fpsLimit: i=void 0, window: r=Ji} = e
      , s = Qe(!1)
      , o = i ? 1e3 / i : null;
    let a = 0
      , l = null;
    function c(f) {
        if (!s.value || !r)
            return;
        a || (a = f);
        const d = f - a;
        if (o && d < o) {
            l = r.requestAnimationFrame(c);
            return
        }
        a = f,
        n({
            delta: d,
            timestamp: f
        }),
        l = r.requestAnimationFrame(c)
    }
    function u() {
        !s.value && r && (s.value = !0,
        a = 0,
        l = r.requestAnimationFrame(c))
    }
    function h() {
        s.value = !1,
        l != null && r && (r.cancelAnimationFrame(l),
        l = null)
    }
    return t && u(),
    Mi(h),
    {
        isActive: yo(s),
        pause: h,
        resume: u
    }
}
function nD(n, e={}) {
    const {window: t=Ji} = e
      , i = zh( () => t && "matchMedia"in t && typeof t.matchMedia == "function");
    let r;
    const s = Qe(!1)
      , o = c => {
        s.value = c.matches
    }
      , a = () => {
        r && ("removeEventListener"in r ? r.removeEventListener("change", o) : r.removeListener(o))
    }
      , l = Ju( () => {
        i.value && (a(),
        r = t.matchMedia(Mt(n)),
        "addEventListener"in r ? r.addEventListener("change", o) : r.addListener(o),
        s.value = r.matches)
    }
    );
    return Mi( () => {
        l(),
        a(),
        r = void 0
    }
    ),
    s
}
function iD(n={}) {
    const {window: e=Ji} = n
      , t = Qe(1);
    if (e) {
        let i = function() {
            t.value = e.devicePixelRatio,
            r(),
            s = e.matchMedia(`(resolution: ${t.value}dppx)`),
            s.addEventListener("change", i, {
                once: !0
            })
        }, r = function() {
            s == null || s.removeEventListener("change", i)
        }, s;
        i(),
        Mi(r)
    }
    return {
        pixelRatio: t
    }
}
function $b(n, e, t={}) {
    const {window: i=Ji, ...r} = t;
    let s;
    const o = zh( () => i && "ResizeObserver"in i)
      , a = () => {
        s && (s.disconnect(),
        s = void 0)
    }
      , l = Lt( () => Array.isArray(n) ? n.map(h => Jn(h)) : [Jn(n)])
      , c = Bt(l, h => {
        if (a(),
        o.value && i) {
            s = new ResizeObserver(e);
            for (const f of h)
                f && s.observe(f, r)
        }
    }
    , {
        immediate: !0,
        flush: "post"
    })
      , u = () => {
        a(),
        c()
    }
    ;
    return Mi(u),
    {
        isSupported: o,
        stop: u
    }
}
function rD(n, e={}) {
    const {reset: t=!0, windowResize: i=!0, windowScroll: r=!0, immediate: s=!0} = e
      , o = Qe(0)
      , a = Qe(0)
      , l = Qe(0)
      , c = Qe(0)
      , u = Qe(0)
      , h = Qe(0)
      , f = Qe(0)
      , d = Qe(0);
    function p() {
        const v = Jn(n);
        if (!v) {
            t && (o.value = 0,
            a.value = 0,
            l.value = 0,
            c.value = 0,
            u.value = 0,
            h.value = 0,
            f.value = 0,
            d.value = 0);
            return
        }
        const g = v.getBoundingClientRect();
        o.value = g.height,
        a.value = g.bottom,
        l.value = g.left,
        c.value = g.right,
        u.value = g.top,
        h.value = g.width,
        f.value = g.x,
        d.value = g.y
    }
    return $b(n, p),
    Bt( () => Jn(n), v => !v && p()),
    tD(n, p, {
        attributeFilter: ["style", "class"]
    }),
    r && sl("scroll", p, {
        capture: !0,
        passive: !0
    }),
    i && sl("resize", p, {
        passive: !0
    }),
    cm( () => {
        s && p()
    }
    ),
    {
        height: o,
        bottom: a,
        left: l,
        right: c,
        top: u,
        width: h,
        x: f,
        y: d,
        update: p
    }
}
function sD(n, e={
    width: 0,
    height: 0
}, t={}) {
    const {window: i=Ji, box: r="content-box"} = t
      , s = Lt( () => {
        var h, f;
        return (f = (h = Jn(n)) == null ? void 0 : h.namespaceURI) == null ? void 0 : f.includes("svg")
    }
    )
      , o = Qe(e.width)
      , a = Qe(e.height)
      , {stop: l} = $b(n, ([h]) => {
        const f = r === "border-box" ? h.borderBoxSize : r === "content-box" ? h.contentBoxSize : h.devicePixelContentBoxSize;
        if (i && s.value) {
            const d = Jn(n);
            if (d) {
                const p = d.getBoundingClientRect();
                o.value = p.width,
                a.value = p.height
            }
        } else if (f) {
            const d = Array.isArray(f) ? f : [f];
            o.value = d.reduce( (p, {inlineSize: v}) => p + v, 0),
            a.value = d.reduce( (p, {blockSize: v}) => p + v, 0)
        } else
            o.value = h.contentRect.width,
            a.value = h.contentRect.height
    }
    , t);
    cm( () => {
        const h = Jn(n);
        h && (o.value = "offsetWidth"in h ? h.offsetWidth : e.width,
        a.value = "offsetHeight"in h ? h.offsetHeight : e.height)
    }
    );
    const c = Bt( () => Jn(n), h => {
        o.value = h ? e.width : 0,
        a.value = h ? e.height : 0
    }
    );
    function u() {
        l(),
        c()
    }
    return {
        width: o,
        height: a,
        stop: u
    }
}
function oD(n) {
    var e;
    const t = Qe(0);
    if (typeof performance > "u")
        return t;
    const i = (e = n == null ? void 0 : n.every) != null ? e : 10;
    let r = performance.now()
      , s = 0;
    return um( () => {
        if (s += 1,
        s >= i) {
            const o = performance.now()
              , a = o - r;
            t.value = Math.round(1e3 / (a / s)),
            r = o,
            s = 0
        }
    }
    ),
    t
}
function aD(n={}) {
    const e = Qe()
      , t = zh( () => typeof performance < "u" && "memory"in performance);
    if (t.value) {
        const {interval: i=1e3} = n;
        QL( () => {
            e.value = performance.memory
        }
        , i, {
            immediate: n.immediate,
            immediateCallback: n.immediateCallback
        })
    }
    return {
        isSupported: t,
        memory: e
    }
}
const Yb = {
    x: 0,
    y: 0,
    pointerId: 0,
    pressure: 0,
    tiltX: 0,
    tiltY: 0,
    width: 0,
    height: 0,
    twist: 0,
    pointerType: null
}
  , lD = Object.keys(Yb);
function cD(n={}) {
    const {target: e=Ji} = n
      , t = Qe(!1)
      , i = Qe(n.initialValue || {});
    Object.assign(i.value, Yb, i.value);
    const r = s => {
        t.value = !0,
        !(n.pointerTypes && !n.pointerTypes.includes(s.pointerType)) && (i.value = jL(s, lD, !1))
    }
    ;
    if (e) {
        const s = {
            passive: !0
        };
        sl(e, ["pointerdown", "pointermove", "pointerup"], r, s),
        sl(e, "pointerleave", () => t.value = !1, s)
    }
    return {
        ...JL(i),
        isInside: t
    }
}
function uD(n={}) {
    const {window: e=Ji, initialWidth: t=Number.POSITIVE_INFINITY, initialHeight: i=Number.POSITIVE_INFINITY, listenOrientation: r=!0, includeScrollbar: s=!0} = n
      , o = Qe(t)
      , a = Qe(i)
      , l = () => {
        e && (s ? (o.value = e.innerWidth,
        a.value = e.innerHeight) : (o.value = e.document.documentElement.clientWidth,
        a.value = e.document.documentElement.clientHeight))
    }
    ;
    if (l(),
    cm(l),
    sl("resize", l, {
        passive: !0
    }),
    r) {
        const c = nD("(orientation: portrait)");
        Bt(c, () => l())
    }
    return {
        width: o,
        height: a
    }
}
var hD = Object.defineProperty
  , fD = (n, e, t) => e in n ? hD(n, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : n[e] = t
  , Jv = (n, e, t) => fD(n, typeof e != "symbol" ? e + "" : e, t);
const dD = "@tresjs/core"
  , pD = "module"
  , mD = "4.2.10"
  , gD = "pnpm@9.1.4"
  , vD = "Declarative ThreeJS using Vue Components"
  , _D = "Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)"
  , yD = "MIT"
  , xD = {
    type: "git",
    url: "git+https://github.com/Tresjs/tres.git"
}
  , bD = ["vue", "3d", "threejs", "three", "threejs-vue"]
  , MD = !1
  , SD = {
    ".": {
        types: "./dist/index.d.ts",
        import: "./dist/tres.js",
        require: "./dist/tres.umd.cjs"
    },
    "./components": {
        types: "./dist/src/components/index.d.ts"
    },
    "./composables": {
        types: "./dist/src/composables/index.d.ts"
    },
    "./types": {
        types: "./dist/src/types/index.d.ts"
    },
    "./utils": {
        types: "./dist/src/utils/index.d.ts"
    },
    "./*": "./*"
}
  , wD = "./dist/tres.js"
  , ED = "./dist/tres.js"
  , AD = "./dist/index.d.ts"
  , TD = ["*.d.ts", "dist"]
  , CD = {
    access: "public"
}
  , RD = {
    dev: "cd playground/vue && npm run dev",
    "dev:nuxt": "cd playground/nuxt && npm run dev",
    build: "vite build",
    test: "vitest",
    "test:ci": "vitest run",
    "test:ui": "vitest --ui --coverage.enabled=true",
    release: "release-it",
    coverage: "vitest run --coverage",
    lint: "eslint .",
    "lint:fix": "eslint . --fix",
    "docs:dev": "vitepress dev docs",
    "docs:build": "vitepress build docs",
    "docs:serve": "vitepress serve docs",
    "docs:preview": "vitepress preview docs",
    "docs:contributors": "esno scripts/update-contributors.ts",
    prepare: "node .husky/install.mjs"
}
  , PD = {
    three: ">=0.133",
    vue: ">=3.4"
}
  , ID = {
    "@alvarosabu/utils": "^3.2.0",
    "@vue/devtools-api": "^6.6.3",
    "@vueuse/core": "^10.11.0"
}
  , LD = {
    "@release-it/conventional-changelog": "^8.0.1",
    "@stackblitz/sdk": "^1.11.0",
    "@tresjs/cientos": "4.0.2",
    "@tresjs/eslint-config": "^1.1.0",
    "@types/three": "^0.168.0",
    "@typescript-eslint/eslint-plugin": "^8.4.0",
    "@typescript-eslint/parser": "^8.4.0",
    "@vitejs/plugin-vue": "^5.0.5",
    "@vitest/coverage-c8": "^0.33.0",
    "@vitest/coverage-v8": "^2.0.2",
    "@vitest/ui": "^2.0.2",
    "@vue/test-utils": "^2.4.6",
    eslint: "^9.6.0",
    "eslint-plugin-vue": "^9.28.0",
    esno: "^4.7.0",
    gsap: "^3.12.5",
    husky: "^9.0.11",
    jsdom: "^25.0.0",
    kolorist: "^1.8.0",
    ohmyfetch: "^0.4.21",
    pathe: "^1.1.2",
    "release-it": "^17.5.0",
    "rollup-plugin-analyzer": "^4.0.0",
    "rollup-plugin-copy": "^3.5.0",
    "rollup-plugin-visualizer": "^5.12.0",
    sponsorkit: "^0.15.4",
    three: "^0.168.0",
    unocss: "^0.62.3",
    unplugin: "^1.13.1",
    "unplugin-vue-components": "^0.27.2",
    vite: "^5.4.3",
    "vite-plugin-banner": "^0.8.0",
    "vite-plugin-dts": "4.1.0",
    "vite-plugin-inspect": "^0.8.4",
    "vite-plugin-require-transform": "^1.0.21",
    "vite-svg-loader": "^5.1.0",
    vitepress: "1.3.4",
    vitest: "^2.0.2",
    vue: "3.5.0",
    "vue-demi": "^0.14.8"
}
  , DD = {
    name: dD,
    type: pD,
    version: mD,
    packageManager: gD,
    description: vD,
    author: _D,
    license: yD,
    repository: xD,
    keywords: bD,
    sideEffects: MD,
    exports: SD,
    main: wD,
    module: ED,
    types: AD,
    files: TD,
    publishConfig: CD,
    scripts: RD,
    peerDependencies: PD,
    dependencies: ID,
    devDependencies: LD
};
function zd(n) {
    return typeof n > "u"
}
function Uu(n) {
    return Array.isArray(n)
}
function ND(n) {
    return typeof n == "number"
}
function jb(n) {
    return typeof n == "string"
}
function es(n) {
    return typeof n == "function"
}
function Qi(n) {
    return n === Object(n) && !Uu(n) && !es(n)
}
function xr(n) {
    return Qi(n) && "isObject3D"in n && !!n.isObject3D
}
function Qv(n) {
    return Qi(n) && "isCamera"in n && !!n.isCamera
}
function UD(n) {
    return Qi(n) && "isBufferGeometry"in n && !!n.isBufferGeometry
}
function OD(n) {
    return Qi(n) && "isMaterial"in n && !!n.isMaterial
}
function FD(n) {
    return Qi(n) && "isLight"in n && !!n.isLight
}
function BD(n) {
    return Qi(n) && "isFog"in n && !!n.isFog
}
function zD(n) {
    return Qi(n) && "isScene"in n && !!n.isScene
}
function Pc(n) {
    return xr(n) || UD(n) || OD(n) || BD(n)
}
function kD(n) {
    return Qi(n) && !!n.isPrimitive
}
const VD = ({sizes: n}) => {
    const e = Qe([])
      , t = Lt( () => e.value[0])
      , i = o => {
        const a = o instanceof _l ? o : e.value.find(c => c.uuid === o);
        if (!a)
            return;
        const l = e.value.filter( ({uuid: c}) => c !== a.uuid);
        e.value = [a, ...l]
    }
      , r = (o, a=!1) => {
        if (Qv(o)) {
            const l = o;
            if (e.value.some( ({uuid: c}) => c === l.uuid))
                return;
            a ? i(l) : e.value.push(l)
        }
    }
      , s = o => {
        if (Qv(o)) {
            const a = o;
            e.value = e.value.filter( ({uuid: l}) => l !== a.uuid)
        }
    }
    ;
    return Ju( () => {
        n.aspectRatio.value && e.value.forEach(o => {
            !o.manual && (o instanceof Ht || HD(o)) && (o instanceof Ht ? o.aspect = n.aspectRatio.value : (o.left = n.width.value * -.5,
            o.right = n.width.value * .5,
            o.top = n.height.value * .5,
            o.bottom = n.height.value * -.5),
            o.updateProjectionMatrix())
        }
        )
    }
    ),
    Hi( () => {
        e.value = []
    }
    ),
    {
        camera: t,
        cameras: e,
        registerCamera: r,
        deregisterCamera: s,
        setCameraActive: i
    }
}
;
function HD(n) {
    return n.hasOwnProperty("isOrthographicCamera") && n.isOrthographicCamera
}
const GD = Vn()
  , WD = Vn()
  , Kb = Vn()
  , Sa = new Bh;
let Wc = 0
  , Xc = 0;
um( () => {
    GD.trigger({
        delta: Wc,
        elapsed: Xc,
        clock: Sa
    }),
    WD.trigger({
        delta: Wc,
        elapsed: Xc,
        clock: Sa
    }),
    Kb.trigger({
        delta: Wc,
        elapsed: Xc,
        clock: Sa
    })
}
, {
    immediate: !1
});
Kb.on( () => {
    Wc = Sa.getDelta(),
    Xc = Sa.getElapsedTime()
}
);
const Ic = "[TresJS ▲ ■ ●] ";
function hm() {
    function n(...i) {
        typeof i[0] == "string" ? i[0] = Ic + i[0] : i.unshift(Ic),
        console.error(...i)
    }
    function e(...i) {
        typeof i[0] == "string" ? i[0] = Ic + i[0] : i.unshift(Ic),
        console.warn(...i)
    }
    function t(i, r) {}
    return {
        logError: n,
        logWarning: e,
        logMessage: t
    }
}
function XD(n) {
    return n instanceof Ee ? n : Array.isArray(n) ? new Ee(...n) : new Ee(n)
}
class qD extends Ot {
    constructor(...e) {
        super(...e),
        Jv(this, "type", "HightlightMesh"),
        Jv(this, "createTime"),
        this.createTime = Date.now()
    }
    onBeforeRender() {
        const e = (Date.now() - this.createTime) / 1e3
          , t = 1 + .07 * Math.sin(2.5 * e);
        this.scale.set(t, t, t)
    }
}
const Zb = (n, e) => {
    for (const t of Object.keys(e))
        e[t]instanceof Object && Object.assign(e[t], Zb(n[t], e[t]));
    return Object.assign(n || {}, e),
    n
}
  , $D = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot"
  , YD = ZD($D);
function e_(n) {
    return n && n.nodeType === 1
}
function Lc(n) {
    return n.replace(/-([a-z])/g, (e, t) => t.toUpperCase())
}
const jD = /\B([A-Z])/g;
function KD(n) {
    return n.replace(jD, "-$1").toLowerCase()
}
function ZD(n, e) {
    const t = Object.create(null)
      , i = n.split(",");
    for (let r = 0; r < i.length; r++)
        t[i[r]] = !0;
    return r => !!t[r]
}
const t_ = (n, e) => {
    if (!e)
        return;
    const t = Array.isArray(e) ? e : e.match(/([^[.\]])+/g);
    return t == null ? void 0 : t.reduce( (i, r) => i && i[r], n)
}
  , JD = (n, e, t) => {
    const i = Array.isArray(e) ? e : e.match(/([^[.\]])+/g);
    i && i.reduce( (r, s, o) => (r[s] === void 0 && (r[s] = {}),
    o === i.length - 1 && (r[s] = t),
    r[s]), n)
}
;
function Jb(n, e) {
    if (e_(n) && e_(e)) {
        const r = n.attributes
          , s = e.attributes;
        return r.length !== s.length ? !1 : Array.from(r).every( ({name: o, value: a}) => e.getAttribute(o) === a)
    }
    if (n === e)
        return !0;
    if (n === null || typeof n != "object" || e === null || typeof e != "object")
        return !1;
    const t = Object.keys(n)
      , i = Object.keys(e);
    if (t.length !== i.length)
        return !1;
    for (const r of t)
        if (!i.includes(r) || !Jb(n[r], e[r]))
            return !1;
    return !0
}
function QD(n, e) {
    if (!Array.isArray(n) || !Array.isArray(e) || n.length !== e.length)
        return !1;
    for (let t = 0; t < n.length; t++)
        if (!Jb(n[t], e[t]))
            return !1;
    return !0
}
function e2(n, e, t, i) {
    const r = l => {
        if (l.uuid === e)
            return l;
        for (const c of l.children) {
            const u = r(c);
            if (u)
                return u
        }
    }
      , s = r(n);
    if (!s) {
        console.warn("Object with UUID not found in the scene.");
        return
    }
    let o = s;
    for (let l = 0; l < t.length - 1; l++)
        if (o[t[l]] !== void 0)
            o = o[t[l]];
        else {
            console.warn(`Property path is not valid: ${t.join(".")}`);
            return
        }
    const a = t[t.length - 1];
    o[a] !== void 0 ? o[a] = i : console.warn(`Property path is not valid: ${t.join(".")}`)
}
function t2(n) {
    const e = new Zi({
        color: 11003607,
        transparent: !0,
        opacity: .2,
        depthTest: !1,
        side: Zn
    });
    return new qD(n.geometry.clone(),e)
}
function n2(n) {
    return "map"in n
}
function n_(n) {
    n2(n) && n.map && n.map.dispose(),
    n.dispose()
}
function Qb(n) {
    var e, t;
    if (n.parent && ((e = n.removeFromParent) == null || e.call(n)),
    delete n.__tres,
    [...n.children].forEach(i => Qb(i)),
    !(n instanceof yh)) {
        const i = n;
        n && ((t = n.dispose) == null || t.call(n)),
        i.geometry && (i.geometry.dispose(),
        delete i.geometry),
        Array.isArray(i.material) ? (i.material.forEach(r => n_(r)),
        delete i.material) : i.material && (n_(i.material),
        delete i.material)
    }
}
function i2(n, e) {
    let t = 0;
    for (let i = 0; i < n.length; i++)
        e(n[i], i) && (n[t] = n[i],
        t++);
    return n.length = t,
    n
}
function kd(n, e) {
    let t = n;
    if (e.includes("-")) {
        const i = e.split("-");
        let r = i.shift();
        for (; t && i.length; )
            r in t ? (t = t[r],
            r = i.shift()) : r = i_(r, i.shift());
        return {
            target: t,
            key: i_(r, ...i)
        }
    } else
        return {
            target: t,
            key: e
        }
}
function i_(...n) {
    return n.map( (e, t) => t === 0 ? e : e.charAt(0).toUpperCase() + e.slice(1)).join("")
}
const r_ = /-\d+$/;
function r2(n, e, t) {
    if (jb(t)) {
        if (r_.test(t)) {
            const s = t.replace(r_, "")
              , {target: o, key: a} = kd(n, s);
            if (!Array.isArray(o[a])) {
                const l = o[a]
                  , c = [];
                c.__tresDetach = () => {
                    c.every(u => zd(u)) && (o[a] = l)
                }
                ,
                o[a] = c
            }
        }
        const {target: i, key: r} = kd(n, t);
        e.__tres.previousAttach = i[r],
        i[r] = Eo(e)
    } else
        e.__tres.previousAttach = t(n, e)
}
function s2(n, e, t) {
    var i, r, s;
    if (jb(t)) {
        const {target: o, key: a} = kd(n, t)
          , l = e.__tres.previousAttach;
        l === void 0 ? delete o[a] : o[a] = l,
        "__tresDetach"in o && o.__tresDetach()
    } else
        (r = (i = e.__tres) == null ? void 0 : i.previousAttach) == null || r.call(i, n, e);
    (s = e.__tres) == null || delete s.previousAttach
}
function Jr(n, e, t) {
    const i = n;
    return i.__tres = {
        type: "unknown",
        eventCount: 0,
        root: t,
        handlers: {},
        memoizedProps: {},
        objects: [],
        parent: null,
        previousAttach: null,
        ...e
    },
    i.__tres.attach || (i.isMaterial ? i.__tres.attach = "material" : i.isBufferGeometry ? i.__tres.attach = "geometry" : i.isFog && (i.__tres.attach = "fog")),
    i
}
function eM(n) {
    var e;
    const t = (e = n == null ? void 0 : n.__tres) == null ? void 0 : e.root;
    t && t.render && t.render.canBeInvalidated.value && t.invalidate()
}
function o2(n, e, t) {
    var i;
    if (!es(n.setPixelRatio))
        return;
    let r = 0;
    if (Uu(t) && t.length >= 2) {
        const [s,o] = t;
        r = Up.clamp(e, s, o)
    } else
        ND(t) ? r = t : r = e;
    r !== ((i = n.getPixelRatio) == null ? void 0 : i.call(n)) && n.setPixelRatio(r)
}
function a2(n, e, t, i, r) {
    const s = [...e.__tres.objects]
      , o = Eo(e);
    if (n = Eo(n),
    o === n)
        return !0;
    const a = Jr(n, e.__tres ?? {}, r)
      , l = e.parent ?? e.__tres.parent ?? null
      , c = {
        ...e.__tres.memoizedProps
    };
    delete c.object;
    for (const u of s)
        tM(u, r),
        nM(u, r);
    o.__tres.objects = [],
    i.remove(e);
    for (const [u,h] of Object.entries(c))
        i.patchProp(a, u, a[u], h);
    t(n),
    i.insert(e, l);
    for (const u of s)
        i.insert(u, e);
    return !0
}
function Eo(n) {
    return kD(n) ? (n.object.__tres = n.__tres,
    n.object) : n
}
function tM(n, e) {
    var t, i, r, s;
    const o = ((t = n.__tres) == null ? void 0 : t.parent) || e.scene.value;
    n.__tres && (n.__tres.parent = null),
    o && o.__tres && "objects"in o.__tres && i2(o.__tres.objects, a => a !== n),
    (i = n.__tres) != null && i.attach ? s2(o, n, n.__tres.attach) : ((s = (r = n.parent) == null ? void 0 : r.remove) == null || s.call(r, Eo(n)),
    n.parent = null)
}
function nM(n, e) {
    var t;
    (t = n.traverse) == null || t.call(n, i => {
        var r;
        e.deregisterCamera(i),
        (r = e.eventManager) == null || r.deregisterPointerMissedObject(i)
    }
    ),
    e.deregisterCamera(n),
    eM(n)
}
const l2 = Number.parseInt(pl.replace("dev", ""))
  , Dc = {
    realistic: {
        shadows: !0,
        physicallyCorrectLights: !0,
        outputColorSpace: Rn,
        toneMapping: ih,
        toneMappingExposure: 3,
        shadowMap: {
            enabled: !0,
            type: bp
        }
    },
    flat: {
        toneMapping: vi,
        toneMappingExposure: 1
    }
};
function c2({canvas: n, options: e, contextParts: {sizes: t, render: i, invalidate: r, advance: s}}) {
    const o = Lt( () => ({
        alpha: Mt(e.alpha) ?? !0,
        depth: Mt(e.depth),
        canvas: Jn(n),
        context: Mt(e.context),
        stencil: Mt(e.stencil),
        antialias: Mt(e.antialias) ?? !0,
        precision: Mt(e.precision),
        powerPreference: Mt(e.powerPreference),
        premultipliedAlpha: Mt(e.premultipliedAlpha),
        preserveDrawingBuffer: Mt(e.preserveDrawingBuffer),
        logarithmicDepthBuffer: Mt(e.logarithmicDepthBuffer),
        failIfMajorPerformanceCaveat: Mt(e.failIfMajorPerformanceCaveat)
    }))
      , a = gi(new Gc(o.value));
    function l() {
        e.renderMode === "on-demand" && r()
    }
    Bt(o, () => {
        a.value.dispose(),
        a.value = new Gc(o.value),
        l()
    }
    ),
    Bt([t.width, t.height], () => {
        a.value.setSize(t.width.value, t.height.value),
        l()
    }
    , {
        immediate: !0
    }),
    Bt( () => e.clearColor, l);
    const {pixelRatio: c} = iD()
      , {logError: u} = hm()
      , h = ( () => {
        const d = new Gc
          , p = {
            shadowMap: {
                enabled: d.shadowMap.enabled,
                type: d.shadowMap.type
            },
            toneMapping: d.toneMapping,
            toneMappingExposure: d.toneMappingExposure,
            outputColorSpace: d.outputColorSpace
        };
        return d.dispose(),
        p
    }
    )()
      , f = Mt(e.renderMode);
    return f === "on-demand" && r(),
    f === "manual" && setTimeout( () => {
        s()
    }
    , 100),
    Ju( () => {
        const d = Mt(e.preset);
        d && (d in Dc || u(`Renderer Preset must be one of these: ${Object.keys(Dc).join(", ")}`),
        Zb(a.value, Dc[d])),
        o2(a.value, c.value, Mt(e.dpr)),
        f === "always" && (i.frames.value = Math.max(1, i.frames.value));
        const p = (m, y) => {
            const _ = Mt(m)
              , x = () => {
                if (d)
                    return t_(Dc[d], y)
            }
            ;
            if (_ !== void 0)
                return _;
            const C = x();
            return C !== void 0 ? C : t_(h, y)
        }
          , v = (m, y) => JD(a.value, y, p(m, y));
        v(e.shadows, "shadowMap.enabled"),
        v(e.toneMapping ?? ih, "toneMapping"),
        v(e.shadowMapType, "shadowMap.type"),
        l2 < 150 && v(!e.useLegacyLights, "physicallyCorrectLights"),
        v(e.outputColorSpace, "outputColorSpace"),
        v(e.toneMappingExposure, "toneMappingExposure");
        const g = p(e.clearColor, "clearColor");
        g && a.value.setClearColor(g ? XD(g) : new Ee(0))
    }
    ),
    Hi( () => {
        a.value.dispose(),
        a.value.forceContextLoss()
    }
    ),
    {
        renderer: a
    }
}
const u2 = (n, e) => {
    const t = Lt( () => e.renderer.value.domElement)
      , i = gi([])
      , {x: r, y: s} = cD({
        target: t
    });
    let o = 0;
    const {width: a, height: l, top: c, left: u} = rD(t)
      , h = ({x: te, y: Se}) => {
        if (t.value)
            return {
                x: (te - u.value) / a.value * 2 - 1,
                y: -((Se - c.value) / l.value) * 2 + 1
            }
    }
      , f = ({x: te, y: Se}) => {
        if (e.camera.value)
            return e.raycaster.value.setFromCamera(new ae(te,Se), e.camera.value),
            i.value = e.raycaster.value.intersectObjects(n.value, !0),
            i.value
    }
      , d = te => {
        const Se = h({
            x: (te == null ? void 0 : te.clientX) ?? r.value,
            y: (te == null ? void 0 : te.clientY) ?? s.value
        });
        return Se ? f(Se) || [] : []
    }
      , p = Vn()
      , v = Vn()
      , g = Vn()
      , m = Vn()
      , y = Vn()
      , _ = Vn()
      , x = Vn()
      , C = Vn();
    function w(te) {
        const Se = {};
        for (const ze in te)
            typeof ze != "function" && (Se[ze] = te[ze]);
        return Se
    }
    const E = (te, Se) => {
        var ze, re, pe;
        const Me = w(Se)
          , k = new N(Se == null ? void 0 : Se.clientX,Se == null ? void 0 : Se.clientY,0).unproject((ze = e.camera) == null ? void 0 : ze.value);
        te.trigger({
            ...Me,
            intersections: i.value,
            unprojectedPoint: k,
            ray: (re = e.raycaster) == null ? void 0 : re.value.ray,
            camera: (pe = e.camera) == null ? void 0 : pe.value,
            sourceEvent: Se,
            delta: o,
            stopPropagating: !1
        })
    }
    ;
    let L;
    const S = te => {
        d(te),
        E(g, te),
        L = te
    }
      , b = () => {
        L && S(L)
    }
    ;
    let D, F, z;
    const $ = te => {
        var Se;
        D = (Se = i.value[0]) == null ? void 0 : Se.object,
        o = 0,
        F = new ae((te == null ? void 0 : te.clientX) ?? r.value,(te == null ? void 0 : te.clientY) ?? s.value),
        E(y, te)
    }
    ;
    let ne, W = !1;
    const ie = te => {
        var Se, ze, re;
        te instanceof PointerEvent && (i.value.length === 0 && E(_, te),
        D === ((Se = i.value[0]) == null ? void 0 : Se.object) && (z = new ae((te == null ? void 0 : te.clientX) ?? r.value,(te == null ? void 0 : te.clientY) ?? s.value),
        o = F == null ? void 0 : F.distanceTo(z),
        te.button === 0 ? (E(p, te),
        ne === ((ze = i.value[0]) == null ? void 0 : ze.object) ? W = !0 : (ne = (re = i.value[0]) == null ? void 0 : re.object,
        W = !1)) : te.button === 2 && E(x, te)),
        E(m, te))
    }
      , Z = te => {
        W && (E(v, te),
        ne = void 0,
        W = !1)
    }
      , ve = te => E(g, te)
      , xe = te => E(C, te);
    return t.value.addEventListener("pointerup", ie),
    t.value.addEventListener("pointerdown", $),
    t.value.addEventListener("pointermove", S),
    t.value.addEventListener("pointerleave", ve),
    t.value.addEventListener("dblclick", Z),
    t.value.addEventListener("wheel", xe),
    Hi( () => {
        t != null && t.value && (t.value.removeEventListener("pointerup", ie),
        t.value.removeEventListener("pointerdown", $),
        t.value.removeEventListener("pointermove", S),
        t.value.removeEventListener("pointerleave", ve),
        t.value.removeEventListener("dblclick", Z),
        t.value.removeEventListener("wheel", xe))
    }
    ),
    {
        intersects: i,
        onClick: te => p.on(te).off,
        onDblClick: te => v.on(te).off,
        onContextMenu: te => x.on(te).off,
        onPointerMove: te => g.on(te).off,
        onPointerUp: te => m.on(te).off,
        onPointerDown: te => y.on(te).off,
        onPointerMissed: te => _.on(te).off,
        onWheel: te => C.on(te).off,
        forceUpdate: b
    }
}
;
function fm(n) {
    let e = 0;
    return n.traverse(t => {
        if (t.isMesh && t.geometry && t.type !== "HightlightMesh") {
            const i = t.geometry
              , r = i.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT
              , s = i.index ? i.index.count * Uint32Array.BYTES_PER_ELEMENT : 0
              , o = i.attributes.normal ? i.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0
              , a = i.attributes.uv ? i.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0
              , l = r + s + o + a;
            e += l
        }
    }
    ),
    e
}
function h2(n) {
    return (n / 1024).toFixed(2)
}
const Vd = Qe({})
  , Hd = n => Object.assign(Vd.value, n);
function f2(n, e, t) {
    var i;
    const r = gi()
      , s = gi();
    n && (r.value = n),
    e && (s.value = e);
    const o = b => {
        var D;
        return ((D = b.__tres) == null ? void 0 : D.eventCount) > 0
    }
      , a = b => {
        var D;
        return ((D = b.children) == null ? void 0 : D.some(F => a(F))) || o(b)
    }
      , l = gi(((i = r.value) == null ? void 0 : i.children).filter(a) || []);
    function c(b, D) {
        if (Array.isArray(b))
            for (const F of b)
                F(D);
        typeof b == "function" && b(D)
    }
    function u(b, D) {
        const F = []
          , z = () => D.stopPropagating = !0;
        D.stopPropagation = z;
        for (const $ of D == null ? void 0 : D.intersections) {
            if (D.stopPropagating)
                return;
            D = {
                ...D,
                ...$
            };
            const {object: ne} = $;
            D.eventObject = ne,
            c(ne[b], D),
            F.push(ne);
            let W = ne.parent;
            for (; W !== null && !D.stopPropagating && !F.includes(W); )
                D.eventObject = W,
                c(W[b], D),
                F.push(W),
                W = W.parent;
            const ie = KD(b.slice(2));
            t(ie, {
                intersection: $,
                event: D
            })
        }
    }
    const {onClick: h, onDblClick: f, onContextMenu: d, onPointerMove: p, onPointerDown: v, onPointerUp: g, onPointerMissed: m, onWheel: y, forceUpdate: _} = u2(l, e);
    g(b => u("onPointerUp", b)),
    v(b => u("onPointerDown", b)),
    h(b => u("onClick", b)),
    f(b => u("onDoubleClick", b)),
    d(b => u("onContextMenu", b)),
    y(b => u("onWheel", b));
    let x = [];
    p(b => {
        const D = b.intersections.map( ({object: z}) => z)
          , F = b.intersections;
        x.forEach( ({object: z}) => {
            D.includes(z) || (b.intersections = x,
            u("onPointerLeave", b),
            u("onPointerOut", b))
        }
        ),
        b.intersections = F,
        b.intersections.forEach( ({object: z}) => {
            x.includes(z) || (u("onPointerEnter", b),
            u("onPointerOver", b))
        }
        ),
        u("onPointerMove", b),
        x = b.intersections
    }
    );
    const C = [];
    m(b => {
        const D = () => b.stopPropagating = !0;
        b.stopPropagation = D,
        C.forEach(F => {
            b.stopPropagating || (b.eventObject = F,
            c(F.onPointerMissed, b))
        }
        ),
        t("pointer-missed", {
            event: b
        })
    }
    );
    function w(b) {
        Pc(b) && xr(b) && l.value.push(b)
    }
    function E(b) {
        if (Pc(b) && xr(b)) {
            const D = l.value.indexOf(b);
            D > -1 && l.value.splice(D, 1)
        }
    }
    function L(b) {
        Pc(b) && xr(b) && b.onPointerMissed && C.push(b)
    }
    function S(b) {
        if (Pc(b) && xr(b)) {
            const D = C.indexOf(b);
            D > -1 && C.splice(D, 1)
        }
    }
    return e.eventManager = {
        forceUpdate: _,
        registerObject: w,
        deregisterObject: E,
        registerPointerMissedObject: L,
        deregisterPointerMissedObject: S
    },
    {
        forceUpdate: _,
        registerObject: w,
        deregisterObject: E,
        registerPointerMissedObject: L,
        deregisterPointerMissedObject: S
    }
}
function d2(n, e, t=10) {
    const i = Mt(n) ? uD() : sD(Lt( () => Mt(e).parentElement))
      , r = yo(Zv(i.width, t))
      , s = yo(Zv(i.height, t))
      , o = Lt( () => r.value / s.value);
    return {
        height: s,
        width: r,
        aspectRatio: o
    }
}
function Qf() {
    const n = new Map
      , e = new Set;
    let t = 0
      , i = !1;
    const r = () => {
        const o = Array.from(n.entries()).sort( (a, l) => {
            const c = a[1].priority - l[1].priority;
            return c === 0 ? a[1].addI - l[1].addI : c
        }
        );
        e.clear(),
        o.forEach(a => e.add(a[0]))
    }
      , s = o => {
        n.delete(o),
        e.delete(o)
    }
    ;
    return {
        on: (o, a=0) => {
            n.set(o, {
                priority: a,
                addI: t++
            });
            const l = () => s(o);
            return Mi(l),
            i = !0,
            {
                off: l
            }
        }
        ,
        off: s,
        trigger: (...o) => {
            i && (r(),
            i = !1),
            e.forEach(a => a(...o))
        }
        ,
        dispose: () => {
            n.clear(),
            e.clear()
        }
        ,
        get count() {
            return n.size
        }
    }
}
function p2() {
    let n = !0
      , e = !0
      , t = !1;
    const i = new Bh(!1)
      , r = Qe(i.running)
      , s = Qe(!1);
    let o;
    const a = Up.generateUUID();
    let l = null;
    const c = Qf()
      , u = Qf()
      , h = Qf();
    w();
    let f = {};
    function d(E) {
        f = E
    }
    function p(E, L, S=0) {
        switch (L) {
        case "before":
            return c.on(E, S);
        case "render":
            return l || (l = E),
            u.dispose(),
            u.on(E);
        case "after":
            return h.on(E, S)
        }
    }
    function v() {
        e && (e = !1,
        w(),
        C())
    }
    function g() {
        e = !0,
        w(),
        cancelAnimationFrame(o)
    }
    function m() {
        t = !1,
        w()
    }
    function y() {
        t = !0,
        w()
    }
    function _() {
        s.value = !0
    }
    function x() {
        s.value = !1
    }
    function C() {
        if (!n) {
            o = requestAnimationFrame(C);
            return
        }
        const E = i.getDelta()
          , L = i.getElapsedTime()
          , S = {
            camera: Pn(f.camera),
            scene: Pn(f.scene),
            renderer: Pn(f.renderer),
            raycaster: Pn(f.raycaster),
            controls: Pn(f.controls),
            invalidate: f.invalidate,
            advance: f.advance
        }
          , b = {
            delta: E,
            elapsed: L,
            clock: i,
            ...S
        };
        r.value && c.trigger(b),
        s.value || (u.count ? u.trigger(b) : l && l(b)),
        r.value && h.trigger(b),
        o = requestAnimationFrame(C)
    }
    function w() {
        const E = !e && !t;
        i.running !== E && (i.running ? i.stop() : i.start()),
        r.value = i.running
    }
    return {
        loopId: a,
        register: (E, L, S) => p(E, L, S),
        start: v,
        stop: g,
        pause: y,
        resume: m,
        pauseRender: _,
        resumeRender: x,
        isRenderPaused: s,
        isActive: r,
        setContext: d,
        setReady: E => n = E
    }
}
function m2(n, e, t=100) {
    t = t <= 0 ? 100 : t;
    const i = Vn()
      , r = new Set;
    let s = !1
      , o = !1
      , a = null;
    function l() {
        a && clearTimeout(a),
        !o && !s && n() ? (i.trigger(e),
        r.forEach(h => h()),
        r.clear(),
        s = !0) : !o && !s && (a = setTimeout(l, t))
    }
    function c() {
        o = !0,
        a && clearTimeout(a)
    }
    l();
    const u = (h, ...f) => {
        h(...f)
    }
    ;
    return {
        on: h => {
            if (s)
                return u(h, e),
                {
                    off: () => {}
                };
            {
                const f = i.on(h);
                return r.add(f.off),
                i.on(h)
            }
        }
        ,
        off: i.off,
        trigger: i.trigger,
        cancel: c
    }
}
const ed = new WeakMap;
function g2(n) {
    if (n = n || _2(),
    ed.has(n))
        return ed.get(n);
    const e = 100
      , t = Date.now()
      , i = m2( () => {
        if (Date.now() - t >= e)
            return !0;
        {
            const r = n.renderer.value
              , s = (r == null ? void 0 : r.domElement) || {
                width: 0,
                height: 0
            };
            return !!(r && s.width > 0 && s.height > 0)
        }
    }
    , n);
    return ed.set(n, i),
    i
}
function v2({scene: n, canvas: e, windowSize: t, disableRender: i, rendererOptions: r, emit: s}) {
    const o = gi(n)
      , a = d2(t, e)
      , {camera: l, cameras: c, registerCamera: u, deregisterCamera: h, setCameraActive: f} = VD({
        sizes: a,
        scene: n
    })
      , d = {
        mode: Qe(r.renderMode || "always"),
        priority: Qe(0),
        frames: Qe(0),
        maxFrames: 60,
        canBeInvalidated: Lt( () => d.mode.value === "on-demand" && d.frames.value === 0)
    };
    function p($=1) {
        r.renderMode === "on-demand" && (d.frames.value = Math.min(d.maxFrames, d.frames.value + $))
    }
    function v() {
        r.renderMode === "manual" && (d.frames.value = 1)
    }
    const {renderer: g} = c2({
        scene: n,
        canvas: e,
        options: r,
        emit: s,
        contextParts: {
            sizes: a,
            camera: l,
            render: d,
            invalidate: p,
            advance: v
        },
        disableRender: i
    })
      , m = {
        sizes: a,
        scene: o,
        camera: l,
        cameras: yo(c),
        renderer: g,
        raycaster: gi(new Xb),
        controls: Qe(null),
        perf: {
            maxFrames: 160,
            fps: {
                value: 0,
                accumulator: []
            },
            memory: {
                currentMem: 0,
                allocatedMem: 0,
                accumulator: []
            }
        },
        render: d,
        advance: v,
        extend: Hd,
        invalidate: p,
        registerCamera: u,
        setCameraActive: f,
        deregisterCamera: h,
        loop: p2()
    };
    cs("useTres", m),
    m.scene.value.__tres = {
        root: m
    },
    m.loop.register( () => {
        l.value && d.frames.value > 0 && (g.value.render(n, l.value),
        s("render", m.renderer.value)),
        d.priority.value = 0,
        d.mode.value === "always" ? d.frames.value = 1 : d.frames.value = Math.max(0, d.frames.value - 1)
    }
    , "render");
    const {on: y, cancel: _} = g2(m);
    m.loop.setReady(!1),
    m.loop.start(),
    y( () => {
        s("ready", m),
        m.loop.setReady(!0),
        f2(n, m, s)
    }
    ),
    Hi( () => {
        _(),
        m.loop.stop()
    }
    );
    const x = 100
      , C = oD({
        every: x
    })
      , {isSupported: w, memory: E} = aD({
        interval: x
    })
      , L = 160;
    let S = performance.now();
    const b = ({timestamp: $}) => {
        m.scene.value && (m.perf.memory.allocatedMem = fm(m.scene.value)),
        $ - S >= x && (S = $,
        m.perf.fps.accumulator.push(C.value),
        m.perf.fps.accumulator.length > L && m.perf.fps.accumulator.shift(),
        m.perf.fps.value = C.value,
        w.value && E.value && (m.perf.memory.accumulator.push(E.value.usedJSHeapSize / 1024 / 1024),
        m.perf.memory.accumulator.length > L && m.perf.memory.accumulator.shift(),
        m.perf.memory.currentMem = m.perf.memory.accumulator.reduce( (ne, W) => ne + W, 0) / m.perf.memory.accumulator.length))
    }
    ;
    let D = 0;
    const F = 1
      , {pause: z} = um( ({delta: $}) => {
        window.__TRES__DEVTOOLS__ && (b({
            timestamp: performance.now()
        }),
        D += $,
        D >= F && (window.__TRES__DEVTOOLS__.cb(m),
        D = 0))
    }
    , {
        immediate: !0
    });
    return Hi( () => {
        z()
    }
    ),
    m
}
function _2() {
    const n = ni("useTres");
    if (!n)
        throw new Error("useTresContext must be used together with useTresContextProvider");
    return n
}
function y2(n, e={}, t={}) {
    let i = n;
    const r = a => {
        i = a
    }
    ;
    let s = new Proxy({},{});
    const o = {
        has(a, l) {
            return l in e || l in i
        },
        get(a, l, c) {
            return l in e ? e[l](i) : i[l]
        },
        set(a, l, c) {
            return t[l] ? t[l](c, i, s, r) : i[l] = c,
            !0
        }
    };
    return s = new Proxy({},o),
    s
}
const {logError: s_} = hm()
  , o_ = ["onClick", "onContextMenu", "onPointerMove", "onPointerEnter", "onPointerLeave", "onPointerOver", "onPointerOut", "onDoubleClick", "onPointerDown", "onPointerUp", "onPointerCancel", "onPointerMissed", "onLostPointerCapture", "onWheel"]
  , x2 = n => {
    const e = n.scene.value;
    function t(c, u, h, f) {
        if (f || (f = {}),
        f.args || (f.args = []),
        c === "template" || YD(c))
            return null;
        let d = c.replace("Tres", ""), p;
        if (c === "primitive") {
            (!Qi(f.object) || Ft(f.object)) && s_("Tres primitives need an 'object' prop, whose value is an object or shallowRef<object>"),
            d = f.object.type;
            const v = {};
            p = y2(f.object, {
                object: g => g,
                isPrimitive: () => !0,
                __tres: () => v
            }, {
                object: (g, m, y, _) => {
                    a2(g, y, _, {
                        patchProp: s,
                        remove: r,
                        insert: i
                    }, n)
                }
                ,
                __tres: g => {
                    Object.assign(v, g)
                }
            })
        } else {
            const v = Vd.value[d];
            v || s_(`${d} is not defined on the THREE namespace. Use extend to add it to the catalog.`),
            p = new v(...f.args)
        }
        return p ? (p.isCamera && (f != null && f.position || p.position.set(3, 3, 3),
        f != null && f.lookAt || p.lookAt(0, 0, 0)),
        p = Jr(p, {
            ...p.__tres,
            type: d,
            memoizedProps: f,
            eventCount: 0,
            primitive: c === "primitive",
            attach: f.attach
        }, n),
        p) : null
    }
    function i(c, u) {
        var h, f, d;
        if (!c)
            return;
        u = u || e;
        const p = c.__tres ? c : Jr(c, {}, n)
          , v = u.__tres ? u : Jr(u, {}, n);
        c = Eo(p),
        u = Eo(v),
        c.__tres && ((h = c.__tres) == null ? void 0 : h.eventCount) > 0 && ((f = n.eventManager) == null || f.registerObject(c)),
        n.registerCamera(c),
        (d = n.eventManager) == null || d.registerPointerMissedObject(c),
        p.__tres.attach ? r2(v, p, p.__tres.attach) : xr(c) && xr(v) && (v.add(c),
        c.dispatchEvent({
            type: "added"
        })),
        p.__tres.parent = v,
        v.__tres.objects && !v.__tres.objects.includes(p) && v.__tres.objects.push(p)
    }
    function r(c, u) {
        var h, f, d, p;
        if (!c)
            return;
        c != null && c.__tres && ((h = c.__tres) == null ? void 0 : h.eventCount) > 0 && ((f = n.eventManager) == null || f.deregisterObject(c)),
        u = zd(u) ? "default" : u;
        const v = (d = c.__tres) == null ? void 0 : d.dispose;
        zd(v) || (v === null ? u = !1 : u = v);
        const g = (p = c.__tres) == null ? void 0 : p.primitive
          , m = u === "default" ? !g : !!u;
        if (c.__tres && "objects"in c.__tres && [...c.__tres.objects].forEach(y => r(y, u)),
        m && c.children && [...c.children].forEach(y => r(y, u)),
        tM(c, n),
        nM(c, n),
        m && !zD(c)) {
            if (es(u))
                u(c);
            else if (es(c.dispose))
                try {
                    c.dispose()
                } catch {}
        }
        "__tres"in c && delete c.__tres
    }
    function s(c, u, h, f) {
        var d, p;
        if (!c)
            return;
        let v = c
          , g = u;
        if (c.__tres && (c.__tres.memoizedProps[u] = f),
        u === "attach") {
            const x = ((d = c.__tres) == null ? void 0 : d.parent) || c.parent;
            r(c),
            Jr(c, {
                attach: f
            }, n),
            x && i(c, x);
            return
        }
        if (u === "dispose") {
            c.__tres || (c = Jr(c, {}, n)),
            c.__tres.dispose = f;
            return
        }
        if (xr(c) && g === "blocks-pointer-events") {
            f || f === "" ? c[g] = f : delete c[g];
            return
        }
        o_.includes(u) && c.__tres && (c.__tres.eventCount += 1);
        let m = Lc(g)
          , y = v == null ? void 0 : v[m];
        if (g === "args") {
            const x = c
              , C = h ?? []
              , w = f ?? []
              , E = ((p = c.__tres) == null ? void 0 : p.type) || c.type;
            E && C.length && !QD(C, w) && (v = Object.assign(x, new Vd.value[E](...f)));
            return
        }
        if (v.type === "BufferGeometry") {
            if (g === "args")
                return;
            v.setAttribute(Lc(g), new pt(...f));
            return
        }
        if (g.includes("-") && y === void 0) {
            const x = g.split("-");
            y = x.reduce( (C, w) => C[Lc(w)], v),
            g = x.pop(),
            m = g,
            y != null && y.set || (v = x.reduce( (C, w) => C[Lc(w)], v))
        }
        let _ = f;
        if (_ === "" && (_ = !0),
        es(y)) {
            o_.includes(u) || (Uu(_) ? c[m](..._) : c[m](_)),
            m.startsWith("on") && es(_) && (v[m] = _);
            return
        }
        !(y != null && y.set) && !es(y) ? v[m] = _ : y.constructor === _.constructor && y != null && y.copy ? y == null || y.copy(_) : Uu(_) ? y.set(..._) : !y.isColor && y.setScalar ? y.setScalar(_) : y.set(_),
        eM(c)
    }
    function o(c) {
        var u;
        return ((u = c == null ? void 0 : c.__tres) == null ? void 0 : u.parent) || null
    }
    function a(c) {
        const u = Jr(new tt, {
            type: "Comment"
        }, n);
        return u.name = c,
        u
    }
    function l(c) {
        var u;
        const h = o(c)
          , f = ((u = h == null ? void 0 : h.__tres) == null ? void 0 : u.objects) || []
          , d = f.indexOf(c);
        return d < 0 || d >= f.length - 1 ? null : f[d + 1]
    }
    return {
        insert: i,
        remove: r,
        createElement: t,
        patchProp: s,
        parentNode: o,
        createText: () => {}
        ,
        createComment: a,
        setText: () => {}
        ,
        setElementText: () => {}
        ,
        nextSibling: l,
        querySelector: () => {}
        ,
        setScopeId: () => {}
        ,
        cloneNode: () => {}
        ,
        insertStaticContent: () => {}
    }
}
;
function b2() {
    return iM().__VUE_DEVTOOLS_GLOBAL_HOOK__
}
function iM() {
    return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {}
}
const M2 = typeof Proxy == "function"
  , S2 = "devtools-plugin:setup"
  , w2 = "plugin:settings:set";
let ea, Gd;
function E2() {
    var n;
    return ea !== void 0 || (typeof window < "u" && window.performance ? (ea = !0,
    Gd = window.performance) : typeof globalThis < "u" && !((n = globalThis.perf_hooks) === null || n === void 0) && n.performance ? (ea = !0,
    Gd = globalThis.perf_hooks.performance) : ea = !1),
    ea
}
function A2() {
    return E2() ? Gd.now() : Date.now()
}
let T2 = class {
    constructor(e, t) {
        this.target = null,
        this.targetQueue = [],
        this.onQueue = [],
        this.plugin = e,
        this.hook = t;
        const i = {};
        if (e.settings)
            for (const o in e.settings) {
                const a = e.settings[o];
                i[o] = a.defaultValue
            }
        const r = `__vue-devtools-plugin-settings__${e.id}`;
        let s = Object.assign({}, i);
        try {
            const o = localStorage.getItem(r)
              , a = JSON.parse(o);
            Object.assign(s, a)
        } catch {}
        this.fallbacks = {
            getSettings() {
                return s
            },
            setSettings(o) {
                try {
                    localStorage.setItem(r, JSON.stringify(o))
                } catch {}
                s = o
            },
            now() {
                return A2()
            }
        },
        t && t.on(w2, (o, a) => {
            o === this.plugin.id && this.fallbacks.setSettings(a)
        }
        ),
        this.proxiedOn = new Proxy({},{
            get: (o, a) => this.target ? this.target.on[a] : (...l) => {
                this.onQueue.push({
                    method: a,
                    args: l
                })
            }
        }),
        this.proxiedTarget = new Proxy({},{
            get: (o, a) => this.target ? this.target[a] : a === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(a) ? (...l) => (this.targetQueue.push({
                method: a,
                args: l,
                resolve: () => {}
            }),
            this.fallbacks[a](...l)) : (...l) => new Promise(c => {
                this.targetQueue.push({
                    method: a,
                    args: l,
                    resolve: c
                })
            }
            )
        })
    }
    async setRealTarget(e) {
        this.target = e;
        for (const t of this.onQueue)
            this.target.on[t.method](...t.args);
        for (const t of this.targetQueue)
            t.resolve(await this.target[t.method](...t.args))
    }
}
;
function C2(n, e) {
    const t = n
      , i = iM()
      , r = b2()
      , s = M2 && t.enableEarlyProxy;
    if (r && (i.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !s))
        r.emit(S2, n, e);
    else {
        const o = s ? new T2(t,r) : null;
        (i.__VUE_DEVTOOLS_PLUGINS__ = i.__VUE_DEVTOOLS_PLUGINS__ || []).push({
            pluginDescriptor: t,
            setupFn: e,
            proxy: o
        }),
        o && e(o.proxiedTarget)
    }
}
function R2(n, e) {
    const t = `▲ ■ ●${n}`;
    typeof a_ == "function" ? a_(t, e) : console.log(t)
}
function a_(n, e) {
    throw new Error(n + e)
}
const rM = n => {
    const e = {
        id: n.uuid,
        label: n.type,
        children: [],
        tags: []
    };
    n.name !== "" && e.tags.push({
        label: n.name,
        textColor: 5750629,
        backgroundColor: 15793395
    });
    const t = fm(n);
    return t > 0 && e.tags.push({
        label: `${h2(t)} KB`,
        textColor: 15707189,
        backgroundColor: 16775644,
        tooltip: "Memory usage"
    }),
    n.type.includes("Light") && (FD(n) && e.tags.push({
        label: `${n.intensity}`,
        textColor: 9738662,
        backgroundColor: 16316922,
        tooltip: "Intensity"
    }),
    e.tags.push({
        label: `#${new Ee(n.color).getHexString()}`,
        textColor: 9738662,
        backgroundColor: 16316922,
        tooltip: "Color"
    })),
    n.type.includes("Camera") && (e.tags.push({
        label: `${n.fov}°`,
        textColor: 9738662,
        backgroundColor: 16316922,
        tooltip: "Field of view"
    }),
    e.tags.push({
        label: `x: ${Math.round(n.position.x)} y: ${Math.round(n.position.y)} z: ${Math.round(n.position.z)}`,
        textColor: 9738662,
        backgroundColor: 16316922,
        tooltip: "Position"
    })),
    e
}
;
function sM(n, e, t="") {
    n.children.forEach(i => {
        if (i.type === "HightlightMesh" || t && !i.type.includes(t) && !i.name.includes(t))
            return;
        const r = rM(i);
        e.children.push(r),
        sM(i, r, t)
    }
    )
}
const P2 = []
  , ta = "tres:inspector"
  , I2 = hl({
    sceneGraph: null
});
function L2(n, e) {
    C2({
        id: "dev.esm.tres",
        label: "TresJS 🪐",
        logo: "https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",
        packageName: "tresjs",
        homepage: "https://tresjs.org",
        componentStateTypes: P2,
        app: n
    }, t => {
        typeof t.now != "function" && R2("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."),
        t.addInspector({
            id: ta,
            label: "TresJS 🪐",
            icon: "account_tree",
            treeFilterPlaceholder: "Search instances"
        }),
        setInterval( () => {
            t.sendInspectorTree(ta)
        }
        , 1e3),
        setInterval( () => {
            t.notifyComponentUpdate()
        }
        , 5e3),
        t.on.getInspectorTree(s => {
            if (s.inspectorId === ta) {
                const o = rM(e.scene.value);
                sM(e.scene.value, o, s.filter),
                I2.sceneGraph = o,
                s.rootNodes = [o]
            }
        }
        );
        let i = null
          , r = null;
        t.on.getInspectorState(s => {
            var o;
            if (s.inspectorId === ta) {
                const [a] = e.scene.value.getObjectsByProperty("uuid", s.nodeId);
                if (!a)
                    return;
                if (r && i && i.parent && r.remove(i),
                a.isMesh) {
                    const l = t2(a);
                    a.add(l),
                    i = l,
                    r = a
                }
                s.state = {
                    object: Object.entries(a).map( ([l,c]) => l === "children" ? {
                        key: l,
                        value: c.filter(u => u.type !== "HightlightMesh")
                    } : {
                        key: l,
                        value: c,
                        editable: !0
                    }).filter( ({key: l}) => l !== "parent")
                },
                a.isScene && (s.state.info = {
                    memory: fm(a),
                    objects: a.children.length,
                    calls: e.renderer.value.info.render.calls,
                    triangles: e.renderer.value.info.render.triangles,
                    points: e.renderer.value.info.render.points,
                    lines: e.renderer.value.info.render.lines
                },
                s.state.programs = ((o = e.renderer.value.info.programs) == null ? void 0 : o.map(l => ({
                    key: l.name,
                    value: {
                        ...l,
                        vertexShader: l.vertexShader,
                        attributes: l.getAttributes(),
                        uniforms: l.getUniforms()
                    }
                }))) || [])
            }
        }
        ),
        t.on.editInspectorState(s => {
            s.inspectorId === ta && e2(e.scene.value, s.nodeId, s.path, s.state.value)
        }
        )
    }
    )
}
const D2 = ["data-scene", "data-tres"]
  , N2 = Ua({
    __name: "TresCanvas",
    props: {
        shadows: {
            type: Boolean,
            default: void 0
        },
        clearColor: {},
        toneMapping: {},
        shadowMapType: {},
        useLegacyLights: {
            type: Boolean,
            default: void 0
        },
        outputColorSpace: {},
        toneMappingExposure: {},
        renderMode: {
            default: "always"
        },
        dpr: {},
        camera: {},
        preset: {},
        windowSize: {
            type: Boolean,
            default: void 0
        },
        disableRender: {
            type: Boolean,
            default: void 0
        },
        context: {},
        precision: {},
        alpha: {
            type: Boolean,
            default: void 0
        },
        premultipliedAlpha: {
            type: Boolean
        },
        antialias: {
            type: Boolean,
            default: void 0
        },
        stencil: {
            type: Boolean,
            default: void 0
        },
        preserveDrawingBuffer: {
            type: Boolean,
            default: void 0
        },
        powerPreference: {},
        depth: {
            type: Boolean,
            default: void 0
        },
        logarithmicDepthBuffer: {
            type: Boolean,
            default: void 0
        },
        failIfMajorPerformanceCaveat: {
            type: Boolean,
            default: void 0
        }
    },
    emits: ["render", "click", "double-click", "context-menu", "pointer-move", "pointer-up", "pointer-down", "pointer-enter", "pointer-leave", "pointer-over", "pointer-out", "pointer-missed", "wheel", "ready"],
    setup(n, {expose: e, emit: t}) {
        var i;
        const r = n
          , s = t
          , o = uw()
          , {logWarning: a} = hm()
          , l = Qe()
          , c = gi(new yh)
          , u = (i = wr()) == null ? void 0 : i.appContext.app;
        Hd(GL);
        const h = (m, y=!1) => Ua({
            setup() {
                var _;
                const x = (_ = wr()) == null ? void 0 : _.appContext;
                return x && (x.app = u),
                cs("useTres", m),
                cs("extend", Hd),
                typeof window < "u" && L2(x == null ? void 0 : x.app, m),
                () => gs(mn, null, y ? [] : o.default())
            }
        })
          , f = (m, y=!1) => {
            const _ = h(m, y)
              , {render: x} = yy(x2(m));
            x(gs(_), c.value)
        }
          , d = (m, y=!1) => {
            Qb(m.scene.value),
            y && (m.renderer.value.dispose(),
            m.renderer.value.renderLists.dispose(),
            m.renderer.value.forceContextLoss()),
            c.value.__tres = {
                root: m
            }
        }
          , p = Lt( () => r.disableRender)
          , v = gi(null);
        e({
            context: v,
            dispose: () => d(v.value, !0)
        });
        const g = () => {
            d(v.value),
            f(v.value, !0)
        }
        ;
        return Ms( () => {
            const m = l;
            v.value = v2({
                scene: c.value,
                canvas: m,
                windowSize: r.windowSize ?? !1,
                disableRender: p.value ?? !1,
                rendererOptions: r,
                emit: s
            });
            const {registerCamera: y, camera: _, cameras: x, deregisterCamera: C} = v.value;
            f(v.value);
            const w = () => {
                const E = new Ht(45,window.innerWidth / window.innerHeight,.1,1e3);
                E.position.set(3, 3, 3),
                E.lookAt(0, 0, 0),
                y(E);
                const L = Ju( () => {
                    x.value.length >= 2 && (E.removeFromParent(),
                    C(E),
                    L == null || L())
                }
                )
            }
            ;
            Bt( () => r.camera, (E, L) => {
                E && y(E),
                L && (L.removeFromParent(),
                C(L))
            }
            , {
                immediate: !0
            }),
            _.value || (a("No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."),
            w())
        }
        ),
        Hi(g),
        (m, y) => (br(),
        wy("canvas", {
            ref_key: "canvas",
            ref: l,
            "data-scene": c.value.uuid,
            class: Wu(m.$attrs.class),
            "data-tres": `tresjs ${Pn(DD).version}`,
            style: Gu({
                display: "block",
                width: "100%",
                height: "100%",
                position: m.windowSize ? "fixed" : "relative",
                top: 0,
                left: 0,
                pointerEvents: "auto",
                touchAction: "none",
                ...m.$attrs.style
            })
        }, null, 14, D2))
    }
})
  , U2 = {
    install(n) {
        n.component("TresCanvas", N2)
    }
};
/*!
 * Viewer.js v1.11.6
 * https://fengyuanchen.github.io/viewerjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2023-09-17T03:16:38.052Z
 */
function l_(n, e) {
    var t = Object.keys(n);
    if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(n);
        e && (i = i.filter(function(r) {
            return Object.getOwnPropertyDescriptor(n, r).enumerable
        })),
        t.push.apply(t, i)
    }
    return t
}
function dm(n) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? l_(Object(t), !0).forEach(function(i) {
            B2(n, i, t[i])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : l_(Object(t)).forEach(function(i) {
            Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i))
        })
    }
    return n
}
function Wd(n) {
    "@babel/helpers - typeof";
    return Wd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ,
    Wd(n)
}
function O2(n, e) {
    if (!(n instanceof e))
        throw new TypeError("Cannot call a class as a function")
}
function c_(n, e) {
    for (var t = 0; t < e.length; t++) {
        var i = e[t];
        i.enumerable = i.enumerable || !1,
        i.configurable = !0,
        "value"in i && (i.writable = !0),
        Object.defineProperty(n, oM(i.key), i)
    }
}
function F2(n, e, t) {
    return e && c_(n.prototype, e),
    t && c_(n, t),
    Object.defineProperty(n, "prototype", {
        writable: !1
    }),
    n
}
function B2(n, e, t) {
    return e = oM(e),
    e in n ? Object.defineProperty(n, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : n[e] = t,
    n
}
function z2(n, e) {
    if (typeof n != "object" || n === null)
        return n;
    var t = n[Symbol.toPrimitive];
    if (t !== void 0) {
        var i = t.call(n, e || "default");
        if (typeof i != "object")
            return i;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(n)
}
function oM(n) {
    var e = z2(n, "string");
    return typeof e == "symbol" ? e : String(e)
}
var u_ = {
    backdrop: !0,
    button: !0,
    navbar: !0,
    title: !0,
    toolbar: !0,
    className: "",
    container: "body",
    filter: null,
    fullscreen: !0,
    inheritedAttributes: ["crossOrigin", "decoding", "isMap", "loading", "referrerPolicy", "sizes", "srcset", "useMap"],
    initialCoverage: .9,
    initialViewIndex: 0,
    inline: !1,
    interval: 5e3,
    keyboard: !0,
    focus: !0,
    loading: !0,
    loop: !0,
    minWidth: 200,
    minHeight: 100,
    movable: !0,
    rotatable: !0,
    scalable: !0,
    zoomable: !0,
    zoomOnTouch: !0,
    zoomOnWheel: !0,
    slideOnTouch: !0,
    toggleOnDblclick: !0,
    tooltip: !0,
    transition: !0,
    zIndex: 2015,
    zIndexInline: 0,
    zoomRatio: .1,
    minZoomRatio: .01,
    maxZoomRatio: 100,
    url: "src",
    ready: null,
    show: null,
    shown: null,
    hide: null,
    hidden: null,
    view: null,
    viewed: null,
    move: null,
    moved: null,
    rotate: null,
    rotated: null,
    scale: null,
    scaled: null,
    zoom: null,
    zoomed: null,
    play: null,
    stop: null
}
  , k2 = '<div class="viewer-container" tabindex="-1" touch-action="none"><div class="viewer-canvas"></div><div class="viewer-footer"><div class="viewer-title"></div><div class="viewer-toolbar"></div><div class="viewer-navbar"><ul class="viewer-list" role="navigation"></ul></div></div><div class="viewer-tooltip" role="alert" aria-hidden="true"></div><div class="viewer-button" data-viewer-action="mix" role="button"></div><div class="viewer-player"></div></div>'
  , kh = typeof window < "u" && typeof window.document < "u"
  , Yi = kh ? window : {}
  , vo = kh && Yi.document.documentElement ? "ontouchstart"in Yi.document.documentElement : !1
  , pm = kh ? "PointerEvent"in Yi : !1
  , Je = "viewer"
  , qc = "move"
  , aM = "switch"
  , la = "zoom"
  , Nc = "".concat(Je, "-active")
  , V2 = "".concat(Je, "-close")
  , $c = "".concat(Je, "-fade")
  , Xd = "".concat(Je, "-fixed")
  , H2 = "".concat(Je, "-fullscreen")
  , h_ = "".concat(Je, "-fullscreen-exit")
  , ts = "".concat(Je, "-hide")
  , G2 = "".concat(Je, "-hide-md-down")
  , W2 = "".concat(Je, "-hide-sm-down")
  , X2 = "".concat(Je, "-hide-xs-down")
  , zn = "".concat(Je, "-in")
  , wa = "".concat(Je, "-invisible")
  , _o = "".concat(Je, "-loading")
  , q2 = "".concat(Je, "-move")
  , f_ = "".concat(Je, "-open")
  , js = "".concat(Je, "-show")
  , Pt = "".concat(Je, "-transition")
  , Ao = "click"
  , qd = "dblclick"
  , d_ = "dragstart"
  , p_ = "focusin"
  , m_ = "keydown"
  , Hn = "load"
  , ps = "error"
  , $2 = vo ? "touchend touchcancel" : "mouseup"
  , Y2 = vo ? "touchmove" : "mousemove"
  , j2 = vo ? "touchstart" : "mousedown"
  , g_ = pm ? "pointerdown" : j2
  , v_ = pm ? "pointermove" : Y2
  , __ = pm ? "pointerup pointercancel" : $2
  , y_ = "resize"
  , jn = "transitionend"
  , x_ = "wheel"
  , b_ = "ready"
  , M_ = "show"
  , S_ = "shown"
  , w_ = "hide"
  , E_ = "hidden"
  , A_ = "view"
  , ol = "viewed"
  , T_ = "move"
  , C_ = "moved"
  , R_ = "rotate"
  , P_ = "rotated"
  , I_ = "scale"
  , L_ = "scaled"
  , D_ = "zoom"
  , N_ = "zoomed"
  , U_ = "play"
  , O_ = "stop"
  , Ou = "".concat(Je, "Action")
  , mm = /\s\s*/
  , Uc = ["zoom-in", "zoom-out", "one-to-one", "reset", "prev", "play", "next", "rotate-left", "rotate-right", "flip-horizontal", "flip-vertical"];
function al(n) {
    return typeof n == "string"
}
var K2 = Number.isNaN || Yi.isNaN;
function Et(n) {
    return typeof n == "number" && !K2(n)
}
function ro(n) {
    return typeof n > "u"
}
function To(n) {
    return Wd(n) === "object" && n !== null
}
var Z2 = Object.prototype.hasOwnProperty;
function so(n) {
    if (!To(n))
        return !1;
    try {
        var e = n.constructor
          , t = e.prototype;
        return e && t && Z2.call(t, "isPrototypeOf")
    } catch {
        return !1
    }
}
function vt(n) {
    return typeof n == "function"
}
function bt(n, e) {
    if (n && vt(e))
        if (Array.isArray(n) || Et(n.length)) {
            var t = n.length, i;
            for (i = 0; i < t && e.call(n, n[i], i, n) !== !1; i += 1)
                ;
        } else
            To(n) && Object.keys(n).forEach(function(r) {
                e.call(n, n[r], r, n)
            });
    return n
}
var Dn = Object.assign || function(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
        i[r - 1] = arguments[r];
    return To(e) && i.length > 0 && i.forEach(function(s) {
        To(s) && Object.keys(s).forEach(function(o) {
            e[o] = s[o]
        })
    }),
    e
}
  , J2 = /^(?:width|height|left|top|marginLeft|marginTop)$/;
function Qn(n, e) {
    var t = n.style;
    bt(e, function(i, r) {
        J2.test(r) && Et(i) && (i += "px"),
        t[r] = i
    })
}
function Q2(n) {
    return al(n) ? n.replace(/&(?!amp;|quot;|#39;|lt;|gt;)/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;") : n
}
function Zs(n, e) {
    return !n || !e ? !1 : n.classList ? n.classList.contains(e) : n.className.indexOf(e) > -1
}
function Xe(n, e) {
    if (!(!n || !e)) {
        if (Et(n.length)) {
            bt(n, function(i) {
                Xe(i, e)
            });
            return
        }
        if (n.classList) {
            n.classList.add(e);
            return
        }
        var t = n.className.trim();
        t ? t.indexOf(e) < 0 && (n.className = "".concat(t, " ").concat(e)) : n.className = e
    }
}
function ot(n, e) {
    if (!(!n || !e)) {
        if (Et(n.length)) {
            bt(n, function(t) {
                ot(t, e)
            });
            return
        }
        if (n.classList) {
            n.classList.remove(e);
            return
        }
        n.className.indexOf(e) >= 0 && (n.className = n.className.replace(e, ""))
    }
}
function ll(n, e, t) {
    if (e) {
        if (Et(n.length)) {
            bt(n, function(i) {
                ll(i, e, t)
            });
            return
        }
        t ? Xe(n, e) : ot(n, e)
    }
}
var eN = /([a-z\d])([A-Z])/g;
function gm(n) {
    return n.replace(eN, "$1-$2").toLowerCase()
}
function oo(n, e) {
    return To(n[e]) ? n[e] : n.dataset ? n.dataset[e] : n.getAttribute("data-".concat(gm(e)))
}
function $d(n, e, t) {
    To(t) ? n[e] = t : n.dataset ? n.dataset[e] = t : n.setAttribute("data-".concat(gm(e)), t)
}
var lM = function() {
    var n = !1;
    if (kh) {
        var e = !1
          , t = function() {}
          , i = Object.defineProperty({}, "once", {
            get: function() {
                return n = !0,
                e
            },
            set: function(s) {
                e = s
            }
        });
        Yi.addEventListener("test", t, i),
        Yi.removeEventListener("test", t, i)
    }
    return n
}();
function _t(n, e, t) {
    var i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}
      , r = t;
    e.trim().split(mm).forEach(function(s) {
        if (!lM) {
            var o = n.listeners;
            o && o[s] && o[s][t] && (r = o[s][t],
            delete o[s][t],
            Object.keys(o[s]).length === 0 && delete o[s],
            Object.keys(o).length === 0 && delete n.listeners)
        }
        n.removeEventListener(s, r, i)
    })
}
function $e(n, e, t) {
    var i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}
      , r = t;
    e.trim().split(mm).forEach(function(s) {
        if (i.once && !lM) {
            var o = n.listeners
              , a = o === void 0 ? {} : o;
            r = function() {
                delete a[s][t],
                n.removeEventListener(s, r, i);
                for (var c = arguments.length, u = new Array(c), h = 0; h < c; h++)
                    u[h] = arguments[h];
                t.apply(n, u)
            }
            ,
            a[s] || (a[s] = {}),
            a[s][t] && n.removeEventListener(s, a[s][t], i),
            a[s][t] = r,
            n.listeners = a
        }
        n.addEventListener(s, r, i)
    })
}
function Ut(n, e, t, i) {
    var r;
    return vt(Event) && vt(CustomEvent) ? r = new CustomEvent(e,dm({
        bubbles: !0,
        cancelable: !0,
        detail: t
    }, i)) : (r = document.createEvent("CustomEvent"),
    r.initCustomEvent(e, !0, !0, t)),
    n.dispatchEvent(r)
}
function tN(n) {
    var e = n.getBoundingClientRect();
    return {
        left: e.left + (window.pageXOffset - document.documentElement.clientLeft),
        top: e.top + (window.pageYOffset - document.documentElement.clientTop)
    }
}
function Yc(n) {
    var e = n.rotate
      , t = n.scaleX
      , i = n.scaleY
      , r = n.translateX
      , s = n.translateY
      , o = [];
    Et(r) && r !== 0 && o.push("translateX(".concat(r, "px)")),
    Et(s) && s !== 0 && o.push("translateY(".concat(s, "px)")),
    Et(e) && e !== 0 && o.push("rotate(".concat(e, "deg)")),
    Et(t) && t !== 1 && o.push("scaleX(".concat(t, ")")),
    Et(i) && i !== 1 && o.push("scaleY(".concat(i, ")"));
    var a = o.length ? o.join(" ") : "none";
    return {
        WebkitTransform: a,
        msTransform: a,
        transform: a
    }
}
function nN(n) {
    return al(n) ? decodeURIComponent(n.replace(/^.*\//, "").replace(/[?&#].*$/, "")) : ""
}
var td = Yi.navigator && /Version\/\d+(\.\d+)+?\s+Safari/i.test(Yi.navigator.userAgent);
function cM(n, e, t) {
    var i = document.createElement("img");
    if (n.naturalWidth && !td)
        return t(n.naturalWidth, n.naturalHeight),
        i;
    var r = document.body || document.documentElement;
    return i.onload = function() {
        t(i.width, i.height),
        td || r.removeChild(i)
    }
    ,
    bt(e.inheritedAttributes, function(s) {
        var o = n.getAttribute(s);
        o !== null && i.setAttribute(s, o)
    }),
    i.src = n.src,
    td || (i.style.cssText = "left:0;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;opacity:0;position:absolute;top:0;z-index:-1;",
    r.appendChild(i)),
    i
}
function Oc(n) {
    switch (n) {
    case 2:
        return X2;
    case 3:
        return W2;
    case 4:
        return G2;
    default:
        return ""
    }
}
function iN(n) {
    var e = dm({}, n)
      , t = [];
    return bt(n, function(i, r) {
        delete e[r],
        bt(e, function(s) {
            var o = Math.abs(i.startX - s.startX)
              , a = Math.abs(i.startY - s.startY)
              , l = Math.abs(i.endX - s.endX)
              , c = Math.abs(i.endY - s.endY)
              , u = Math.sqrt(o * o + a * a)
              , h = Math.sqrt(l * l + c * c)
              , f = (h - u) / u;
            t.push(f)
        })
    }),
    t.sort(function(i, r) {
        return Math.abs(i) < Math.abs(r)
    }),
    t[0]
}
function Fc(n, e) {
    var t = n.pageX
      , i = n.pageY
      , r = {
        endX: t,
        endY: i
    };
    return e ? r : dm({
        timeStamp: Date.now(),
        startX: t,
        startY: i
    }, r)
}
function rN(n) {
    var e = 0
      , t = 0
      , i = 0;
    return bt(n, function(r) {
        var s = r.startX
          , o = r.startY;
        e += s,
        t += o,
        i += 1
    }),
    e /= i,
    t /= i,
    {
        pageX: e,
        pageY: t
    }
}
var sN = {
    render: function() {
        this.initContainer(),
        this.initViewer(),
        this.initList(),
        this.renderViewer()
    },
    initBody: function() {
        var e = this.element.ownerDocument
          , t = e.body || e.documentElement;
        this.body = t,
        this.scrollbarWidth = window.innerWidth - e.documentElement.clientWidth,
        this.initialBodyPaddingRight = t.style.paddingRight,
        this.initialBodyComputedPaddingRight = window.getComputedStyle(t).paddingRight
    },
    initContainer: function() {
        this.containerData = {
            width: window.innerWidth,
            height: window.innerHeight
        }
    },
    initViewer: function() {
        var e = this.options, t = this.parent, i;
        e.inline && (i = {
            width: Math.max(t.offsetWidth, e.minWidth),
            height: Math.max(t.offsetHeight, e.minHeight)
        },
        this.parentData = i),
        (this.fulled || !i) && (i = this.containerData),
        this.viewerData = Dn({}, i)
    },
    renderViewer: function() {
        this.options.inline && !this.fulled && Qn(this.viewer, this.viewerData)
    },
    initList: function() {
        var e = this
          , t = this.element
          , i = this.options
          , r = this.list
          , s = [];
        r.innerHTML = "",
        bt(this.images, function(o, a) {
            var l = o.src
              , c = o.alt || nN(l)
              , u = e.getImageURL(o);
            if (l || u) {
                var h = document.createElement("li")
                  , f = document.createElement("img");
                bt(i.inheritedAttributes, function(d) {
                    var p = o.getAttribute(d);
                    p !== null && f.setAttribute(d, p)
                }),
                i.navbar && (f.src = l || u),
                f.alt = c,
                f.setAttribute("data-original-url", u || l),
                h.setAttribute("data-index", a),
                h.setAttribute("data-viewer-action", "view"),
                h.setAttribute("role", "button"),
                i.keyboard && h.setAttribute("tabindex", 0),
                h.appendChild(f),
                r.appendChild(h),
                s.push(h)
            }
        }),
        this.items = s,
        bt(s, function(o) {
            var a = o.firstElementChild, l, c;
            $d(a, "filled", !0),
            i.loading && Xe(o, _o),
            $e(a, Hn, l = function(h) {
                _t(a, ps, c),
                i.loading && ot(o, _o),
                e.loadImage(h)
            }
            , {
                once: !0
            }),
            $e(a, ps, c = function() {
                _t(a, Hn, l),
                i.loading && ot(o, _o)
            }
            , {
                once: !0
            })
        }),
        i.transition && $e(t, ol, function() {
            Xe(r, Pt)
        }, {
            once: !0
        })
    },
    renderList: function() {
        var e = this.index
          , t = this.items[e];
        if (t) {
            var i = t.nextElementSibling
              , r = parseInt(window.getComputedStyle(i || t).marginLeft, 10)
              , s = t.offsetWidth
              , o = s + r;
            Qn(this.list, Dn({
                width: o * this.length - r
            }, Yc({
                translateX: (this.viewerData.width - s) / 2 - o * e
            })))
        }
    },
    resetList: function() {
        var e = this.list;
        e.innerHTML = "",
        ot(e, Pt),
        Qn(e, Yc({
            translateX: 0
        }))
    },
    initImage: function(e) {
        var t = this, i = this.options, r = this.image, s = this.viewerData, o = this.footer.offsetHeight, a = s.width, l = Math.max(s.height - o, o), c = this.imageData || {}, u;
        this.imageInitializing = {
            abort: function() {
                u.onload = null
            }
        },
        u = cM(r, i, function(h, f) {
            var d = h / f
              , p = Math.max(0, Math.min(1, i.initialCoverage))
              , v = a
              , g = l;
            t.imageInitializing = !1,
            l * d > a ? g = a / d : v = l * d,
            p = Et(p) ? p : .9,
            v = Math.min(v * p, h),
            g = Math.min(g * p, f);
            var m = (a - v) / 2
              , y = (l - g) / 2
              , _ = {
                left: m,
                top: y,
                x: m,
                y,
                width: v,
                height: g,
                oldRatio: 1,
                ratio: v / h,
                aspectRatio: d,
                naturalWidth: h,
                naturalHeight: f
            }
              , x = Dn({}, _);
            i.rotatable && (_.rotate = c.rotate || 0,
            x.rotate = 0),
            i.scalable && (_.scaleX = c.scaleX || 1,
            _.scaleY = c.scaleY || 1,
            x.scaleX = 1,
            x.scaleY = 1),
            t.imageData = _,
            t.initialImageData = x,
            e && e()
        })
    },
    renderImage: function(e) {
        var t = this
          , i = this.image
          , r = this.imageData;
        if (Qn(i, Dn({
            width: r.width,
            height: r.height,
            marginLeft: r.x,
            marginTop: r.y
        }, Yc(r))),
        e)
            if ((this.viewing || this.moving || this.rotating || this.scaling || this.zooming) && this.options.transition && Zs(i, Pt)) {
                var s = function() {
                    t.imageRendering = !1,
                    e()
                };
                this.imageRendering = {
                    abort: function() {
                        _t(i, jn, s)
                    }
                },
                $e(i, jn, s, {
                    once: !0
                })
            } else
                e()
    },
    resetImage: function() {
        var e = this.image;
        e && (this.viewing && this.viewing.abort(),
        e.parentNode.removeChild(e),
        this.image = null,
        this.title.innerHTML = "")
    }
}
  , oN = {
    bind: function() {
        var e = this.options
          , t = this.viewer
          , i = this.canvas
          , r = this.element.ownerDocument;
        $e(t, Ao, this.onClick = this.click.bind(this)),
        $e(t, d_, this.onDragStart = this.dragstart.bind(this)),
        $e(i, g_, this.onPointerDown = this.pointerdown.bind(this)),
        $e(r, v_, this.onPointerMove = this.pointermove.bind(this)),
        $e(r, __, this.onPointerUp = this.pointerup.bind(this)),
        $e(r, m_, this.onKeyDown = this.keydown.bind(this)),
        $e(window, y_, this.onResize = this.resize.bind(this)),
        e.zoomable && e.zoomOnWheel && $e(t, x_, this.onWheel = this.wheel.bind(this), {
            passive: !1,
            capture: !0
        }),
        e.toggleOnDblclick && $e(i, qd, this.onDblclick = this.dblclick.bind(this))
    },
    unbind: function() {
        var e = this.options
          , t = this.viewer
          , i = this.canvas
          , r = this.element.ownerDocument;
        _t(t, Ao, this.onClick),
        _t(t, d_, this.onDragStart),
        _t(i, g_, this.onPointerDown),
        _t(r, v_, this.onPointerMove),
        _t(r, __, this.onPointerUp),
        _t(r, m_, this.onKeyDown),
        _t(window, y_, this.onResize),
        e.zoomable && e.zoomOnWheel && _t(t, x_, this.onWheel, {
            passive: !1,
            capture: !0
        }),
        e.toggleOnDblclick && _t(i, qd, this.onDblclick)
    }
}
  , aN = {
    click: function(e) {
        var t = this.options
          , i = this.imageData
          , r = e.target
          , s = oo(r, Ou);
        switch (!s && r.localName === "img" && r.parentElement.localName === "li" && (r = r.parentElement,
        s = oo(r, Ou)),
        vo && e.isTrusted && r === this.canvas && clearTimeout(this.clickCanvasTimeout),
        s) {
        case "mix":
            this.played ? this.stop() : t.inline ? this.fulled ? this.exit() : this.full() : this.hide();
            break;
        case "hide":
            this.pointerMoved || this.hide();
            break;
        case "view":
            this.view(oo(r, "index"));
            break;
        case "zoom-in":
            this.zoom(.1, !0);
            break;
        case "zoom-out":
            this.zoom(-.1, !0);
            break;
        case "one-to-one":
            this.toggle();
            break;
        case "reset":
            this.reset();
            break;
        case "prev":
            this.prev(t.loop);
            break;
        case "play":
            this.play(t.fullscreen);
            break;
        case "next":
            this.next(t.loop);
            break;
        case "rotate-left":
            this.rotate(-90);
            break;
        case "rotate-right":
            this.rotate(90);
            break;
        case "flip-horizontal":
            this.scaleX(-i.scaleX || -1);
            break;
        case "flip-vertical":
            this.scaleY(-i.scaleY || -1);
            break;
        default:
            this.played && this.stop()
        }
    },
    dblclick: function(e) {
        e.preventDefault(),
        this.viewed && e.target === this.image && (vo && e.isTrusted && clearTimeout(this.doubleClickImageTimeout),
        this.toggle(e.isTrusted ? e : e.detail && e.detail.originalEvent))
    },
    load: function() {
        var e = this;
        this.timeout && (clearTimeout(this.timeout),
        this.timeout = !1);
        var t = this.element
          , i = this.options
          , r = this.image
          , s = this.index
          , o = this.viewerData;
        ot(r, wa),
        i.loading && ot(this.canvas, _o),
        r.style.cssText = "height:0;" + "margin-left:".concat(o.width / 2, "px;") + "margin-top:".concat(o.height / 2, "px;") + "max-width:none!important;position:relative;width:0;",
        this.initImage(function() {
            ll(r, q2, i.movable),
            ll(r, Pt, i.transition),
            e.renderImage(function() {
                e.viewed = !0,
                e.viewing = !1,
                vt(i.viewed) && $e(t, ol, i.viewed, {
                    once: !0
                }),
                Ut(t, ol, {
                    originalImage: e.images[s],
                    index: s,
                    image: r
                }, {
                    cancelable: !1
                })
            })
        })
    },
    loadImage: function(e) {
        var t = e.target
          , i = t.parentNode
          , r = i.offsetWidth || 30
          , s = i.offsetHeight || 50
          , o = !!oo(t, "filled");
        cM(t, this.options, function(a, l) {
            var c = a / l
              , u = r
              , h = s;
            s * c > r ? o ? u = s * c : h = r / c : o ? h = r / c : u = s * c,
            Qn(t, Dn({
                width: u,
                height: h
            }, Yc({
                translateX: (r - u) / 2,
                translateY: (s - h) / 2
            })))
        })
    },
    keydown: function(e) {
        var t = this.options;
        if (t.keyboard) {
            var i = e.keyCode || e.which || e.charCode;
            switch (i) {
            case 13:
                this.viewer.contains(e.target) && this.click(e);
                break
            }
            if (this.fulled)
                switch (i) {
                case 27:
                    this.played ? this.stop() : t.inline ? this.fulled && this.exit() : this.hide();
                    break;
                case 32:
                    this.played && this.stop();
                    break;
                case 37:
                    this.played && this.playing ? this.playing.prev() : this.prev(t.loop);
                    break;
                case 38:
                    e.preventDefault(),
                    this.zoom(t.zoomRatio, !0);
                    break;
                case 39:
                    this.played && this.playing ? this.playing.next() : this.next(t.loop);
                    break;
                case 40:
                    e.preventDefault(),
                    this.zoom(-t.zoomRatio, !0);
                    break;
                case 48:
                case 49:
                    e.ctrlKey && (e.preventDefault(),
                    this.toggle());
                    break
                }
        }
    },
    dragstart: function(e) {
        e.target.localName === "img" && e.preventDefault()
    },
    pointerdown: function(e) {
        var t = this.options
          , i = this.pointers
          , r = e.buttons
          , s = e.button;
        if (this.pointerMoved = !1,
        !(!this.viewed || this.showing || this.viewing || this.hiding || (e.type === "mousedown" || e.type === "pointerdown" && e.pointerType === "mouse") && (Et(r) && r !== 1 || Et(s) && s !== 0 || e.ctrlKey))) {
            e.preventDefault(),
            e.changedTouches ? bt(e.changedTouches, function(a) {
                i[a.identifier] = Fc(a)
            }) : i[e.pointerId || 0] = Fc(e);
            var o = t.movable ? qc : !1;
            t.zoomOnTouch && t.zoomable && Object.keys(i).length > 1 ? o = la : t.slideOnTouch && (e.pointerType === "touch" || e.type === "touchstart") && this.isSwitchable() && (o = aM),
            t.transition && (o === qc || o === la) && ot(this.image, Pt),
            this.action = o
        }
    },
    pointermove: function(e) {
        var t = this.pointers
          , i = this.action;
        !this.viewed || !i || (e.preventDefault(),
        e.changedTouches ? bt(e.changedTouches, function(r) {
            Dn(t[r.identifier] || {}, Fc(r, !0))
        }) : Dn(t[e.pointerId || 0] || {}, Fc(e, !0)),
        this.change(e))
    },
    pointerup: function(e) {
        var t = this, i = this.options, r = this.action, s = this.pointers, o;
        e.changedTouches ? bt(e.changedTouches, function(a) {
            o = s[a.identifier],
            delete s[a.identifier]
        }) : (o = s[e.pointerId || 0],
        delete s[e.pointerId || 0]),
        r && (e.preventDefault(),
        i.transition && (r === qc || r === la) && Xe(this.image, Pt),
        this.action = !1,
        vo && r !== la && o && Date.now() - o.timeStamp < 500 && (clearTimeout(this.clickCanvasTimeout),
        clearTimeout(this.doubleClickImageTimeout),
        i.toggleOnDblclick && this.viewed && e.target === this.image ? this.imageClicked ? (this.imageClicked = !1,
        this.doubleClickImageTimeout = setTimeout(function() {
            Ut(t.image, qd, {
                originalEvent: e
            })
        }, 50)) : (this.imageClicked = !0,
        this.doubleClickImageTimeout = setTimeout(function() {
            t.imageClicked = !1
        }, 500)) : (this.imageClicked = !1,
        i.backdrop && i.backdrop !== "static" && e.target === this.canvas && (this.clickCanvasTimeout = setTimeout(function() {
            Ut(t.canvas, Ao, {
                originalEvent: e
            })
        }, 50)))))
    },
    resize: function() {
        var e = this;
        if (!(!this.isShown || this.hiding) && (this.fulled && (this.close(),
        this.initBody(),
        this.open()),
        this.initContainer(),
        this.initViewer(),
        this.renderViewer(),
        this.renderList(),
        this.viewed && this.initImage(function() {
            e.renderImage()
        }),
        this.played)) {
            if (this.options.fullscreen && this.fulled && !(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
                this.stop();
                return
            }
            bt(this.player.getElementsByTagName("img"), function(t) {
                $e(t, Hn, e.loadImage.bind(e), {
                    once: !0
                }),
                Ut(t, Hn)
            })
        }
    },
    wheel: function(e) {
        var t = this;
        if (this.viewed && (e.preventDefault(),
        !this.wheeling)) {
            this.wheeling = !0,
            setTimeout(function() {
                t.wheeling = !1
            }, 50);
            var i = Number(this.options.zoomRatio) || .1
              , r = 1;
            e.deltaY ? r = e.deltaY > 0 ? 1 : -1 : e.wheelDelta ? r = -e.wheelDelta / 120 : e.detail && (r = e.detail > 0 ? 1 : -1),
            this.zoom(-r * i, !0, null, e)
        }
    }
}
  , lN = {
    show: function() {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1
          , t = this.element
          , i = this.options;
        if (i.inline || this.showing || this.isShown || this.showing)
            return this;
        if (!this.ready)
            return this.build(),
            this.ready && this.show(e),
            this;
        if (vt(i.show) && $e(t, M_, i.show, {
            once: !0
        }),
        Ut(t, M_) === !1 || !this.ready)
            return this;
        this.hiding && this.transitioning.abort(),
        this.showing = !0,
        this.open();
        var r = this.viewer;
        if (ot(r, ts),
        r.setAttribute("role", "dialog"),
        r.setAttribute("aria-labelledby", this.title.id),
        r.setAttribute("aria-modal", !0),
        r.removeAttribute("aria-hidden"),
        i.transition && !e) {
            var s = this.shown.bind(this);
            this.transitioning = {
                abort: function() {
                    _t(r, jn, s),
                    ot(r, zn)
                }
            },
            Xe(r, Pt),
            r.initialOffsetWidth = r.offsetWidth,
            $e(r, jn, s, {
                once: !0
            }),
            Xe(r, zn)
        } else
            Xe(r, zn),
            this.shown();
        return this
    },
    hide: function() {
        var e = this
          , t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1
          , i = this.element
          , r = this.options;
        if (r.inline || this.hiding || !(this.isShown || this.showing))
            return this;
        if (vt(r.hide) && $e(i, w_, r.hide, {
            once: !0
        }),
        Ut(i, w_) === !1)
            return this;
        this.showing && this.transitioning.abort(),
        this.hiding = !0,
        this.played ? this.stop() : this.viewing && this.viewing.abort();
        var s = this.viewer
          , o = this.image
          , a = function() {
            ot(s, zn),
            e.hidden()
        };
        if (r.transition && !t) {
            var l = function u(h) {
                h && h.target === s && (_t(s, jn, u),
                e.hidden())
            }
              , c = function() {
                Zs(s, Pt) ? ($e(s, jn, l),
                ot(s, zn)) : a()
            };
            this.transitioning = {
                abort: function() {
                    e.viewed && Zs(o, Pt) ? _t(o, jn, c) : Zs(s, Pt) && _t(s, jn, l)
                }
            },
            this.viewed && Zs(o, Pt) ? ($e(o, jn, c, {
                once: !0
            }),
            this.zoomTo(0, !1, null, null, !0)) : c()
        } else
            a();
        return this
    },
    view: function() {
        var e = this
          , t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.initialViewIndex;
        if (t = Number(t) || 0,
        this.hiding || this.played || t < 0 || t >= this.length || this.viewed && t === this.index)
            return this;
        if (!this.isShown)
            return this.index = t,
            this.show();
        this.viewing && this.viewing.abort();
        var i = this.element
          , r = this.options
          , s = this.title
          , o = this.canvas
          , a = this.items[t]
          , l = a.querySelector("img")
          , c = oo(l, "originalUrl")
          , u = l.getAttribute("alt")
          , h = document.createElement("img");
        if (bt(r.inheritedAttributes, function(g) {
            var m = l.getAttribute(g);
            m !== null && h.setAttribute(g, m)
        }),
        h.src = c,
        h.alt = u,
        vt(r.view) && $e(i, A_, r.view, {
            once: !0
        }),
        Ut(i, A_, {
            originalImage: this.images[t],
            index: t,
            image: h
        }) === !1 || !this.isShown || this.hiding || this.played)
            return this;
        var f = this.items[this.index];
        f && (ot(f, Nc),
        f.removeAttribute("aria-selected")),
        Xe(a, Nc),
        a.setAttribute("aria-selected", !0),
        r.focus && a.focus(),
        this.image = h,
        this.viewed = !1,
        this.index = t,
        this.imageData = {},
        Xe(h, wa),
        r.loading && Xe(o, _o),
        o.innerHTML = "",
        o.appendChild(h),
        this.renderList(),
        s.innerHTML = "";
        var d = function() {
            var m = e.imageData
              , y = Array.isArray(r.title) ? r.title[1] : r.title;
            s.innerHTML = Q2(vt(y) ? y.call(e, h, m) : "".concat(u, " (").concat(m.naturalWidth, " × ").concat(m.naturalHeight, ")"))
        }, p, v;
        return $e(i, ol, d, {
            once: !0
        }),
        this.viewing = {
            abort: function() {
                _t(i, ol, d),
                h.complete ? e.imageRendering ? e.imageRendering.abort() : e.imageInitializing && e.imageInitializing.abort() : (h.src = "",
                _t(h, Hn, p),
                e.timeout && clearTimeout(e.timeout))
            }
        },
        h.complete ? this.load() : ($e(h, Hn, p = function() {
            _t(h, ps, v),
            e.load()
        }
        , {
            once: !0
        }),
        $e(h, ps, v = function() {
            _t(h, Hn, p),
            e.timeout && (clearTimeout(e.timeout),
            e.timeout = !1),
            ot(h, wa),
            r.loading && ot(e.canvas, _o)
        }
        , {
            once: !0
        }),
        this.timeout && clearTimeout(this.timeout),
        this.timeout = setTimeout(function() {
            ot(h, wa),
            e.timeout = !1
        }, 1e3)),
        this
    },
    prev: function() {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1
          , t = this.index - 1;
        return t < 0 && (t = e ? this.length - 1 : 0),
        this.view(t),
        this
    },
    next: function() {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1
          , t = this.length - 1
          , i = this.index + 1;
        return i > t && (i = e ? 0 : t),
        this.view(i),
        this
    },
    move: function(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e
          , i = this.imageData;
        return this.moveTo(ro(e) ? e : i.x + Number(e), ro(t) ? t : i.y + Number(t)),
        this
    },
    moveTo: function(e) {
        var t = this
          , i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e
          , r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null
          , s = this.element
          , o = this.options
          , a = this.imageData;
        if (e = Number(e),
        i = Number(i),
        this.viewed && !this.played && o.movable) {
            var l = a.x
              , c = a.y
              , u = !1;
            if (Et(e) ? u = !0 : e = l,
            Et(i) ? u = !0 : i = c,
            u) {
                if (vt(o.move) && $e(s, T_, o.move, {
                    once: !0
                }),
                Ut(s, T_, {
                    x: e,
                    y: i,
                    oldX: l,
                    oldY: c,
                    originalEvent: r
                }) === !1)
                    return this;
                a.x = e,
                a.y = i,
                a.left = e,
                a.top = i,
                this.moving = !0,
                this.renderImage(function() {
                    t.moving = !1,
                    vt(o.moved) && $e(s, C_, o.moved, {
                        once: !0
                    }),
                    Ut(s, C_, {
                        x: e,
                        y: i,
                        oldX: l,
                        oldY: c,
                        originalEvent: r
                    }, {
                        cancelable: !1
                    })
                })
            }
        }
        return this
    },
    rotate: function(e) {
        return this.rotateTo((this.imageData.rotate || 0) + Number(e)),
        this
    },
    rotateTo: function(e) {
        var t = this
          , i = this.element
          , r = this.options
          , s = this.imageData;
        if (e = Number(e),
        Et(e) && this.viewed && !this.played && r.rotatable) {
            var o = s.rotate;
            if (vt(r.rotate) && $e(i, R_, r.rotate, {
                once: !0
            }),
            Ut(i, R_, {
                degree: e,
                oldDegree: o
            }) === !1)
                return this;
            s.rotate = e,
            this.rotating = !0,
            this.renderImage(function() {
                t.rotating = !1,
                vt(r.rotated) && $e(i, P_, r.rotated, {
                    once: !0
                }),
                Ut(i, P_, {
                    degree: e,
                    oldDegree: o
                }, {
                    cancelable: !1
                })
            })
        }
        return this
    },
    scaleX: function(e) {
        return this.scale(e, this.imageData.scaleY),
        this
    },
    scaleY: function(e) {
        return this.scale(this.imageData.scaleX, e),
        this
    },
    scale: function(e) {
        var t = this
          , i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e
          , r = this.element
          , s = this.options
          , o = this.imageData;
        if (e = Number(e),
        i = Number(i),
        this.viewed && !this.played && s.scalable) {
            var a = o.scaleX
              , l = o.scaleY
              , c = !1;
            if (Et(e) ? c = !0 : e = a,
            Et(i) ? c = !0 : i = l,
            c) {
                if (vt(s.scale) && $e(r, I_, s.scale, {
                    once: !0
                }),
                Ut(r, I_, {
                    scaleX: e,
                    scaleY: i,
                    oldScaleX: a,
                    oldScaleY: l
                }) === !1)
                    return this;
                o.scaleX = e,
                o.scaleY = i,
                this.scaling = !0,
                this.renderImage(function() {
                    t.scaling = !1,
                    vt(s.scaled) && $e(r, L_, s.scaled, {
                        once: !0
                    }),
                    Ut(r, L_, {
                        scaleX: e,
                        scaleY: i,
                        oldScaleX: a,
                        oldScaleY: l
                    }, {
                        cancelable: !1
                    })
                })
            }
        }
        return this
    },
    zoom: function(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1
          , i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null
          , r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null
          , s = this.imageData;
        return e = Number(e),
        e < 0 ? e = 1 / (1 - e) : e = 1 + e,
        this.zoomTo(s.width * e / s.naturalWidth, t, i, r),
        this
    },
    zoomTo: function(e) {
        var t = this
          , i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1
          , r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null
          , s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null
          , o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1
          , a = this.element
          , l = this.options
          , c = this.pointers
          , u = this.imageData
          , h = u.x
          , f = u.y
          , d = u.width
          , p = u.height
          , v = u.naturalWidth
          , g = u.naturalHeight;
        if (e = Math.max(0, e),
        Et(e) && this.viewed && !this.played && (o || l.zoomable)) {
            if (!o) {
                var m = Math.max(.01, l.minZoomRatio)
                  , y = Math.min(100, l.maxZoomRatio);
                e = Math.min(Math.max(e, m), y)
            }
            if (s)
                switch (s.type) {
                case "wheel":
                    l.zoomRatio >= .055 && e > .95 && e < 1.05 && (e = 1);
                    break;
                case "pointermove":
                case "touchmove":
                case "mousemove":
                    e > .99 && e < 1.01 && (e = 1);
                    break
                }
            var _ = v * e
              , x = g * e
              , C = _ - d
              , w = x - p
              , E = u.ratio;
            if (vt(l.zoom) && $e(a, D_, l.zoom, {
                once: !0
            }),
            Ut(a, D_, {
                ratio: e,
                oldRatio: E,
                originalEvent: s
            }) === !1)
                return this;
            if (this.zooming = !0,
            s) {
                var L = tN(this.viewer)
                  , S = c && Object.keys(c).length > 0 ? rN(c) : {
                    pageX: s.pageX,
                    pageY: s.pageY
                };
                u.x -= C * ((S.pageX - L.left - h) / d),
                u.y -= w * ((S.pageY - L.top - f) / p)
            } else
                so(r) && Et(r.x) && Et(r.y) ? (u.x -= C * ((r.x - h) / d),
                u.y -= w * ((r.y - f) / p)) : (u.x -= C / 2,
                u.y -= w / 2);
            u.left = u.x,
            u.top = u.y,
            u.width = _,
            u.height = x,
            u.oldRatio = E,
            u.ratio = e,
            this.renderImage(function() {
                t.zooming = !1,
                vt(l.zoomed) && $e(a, N_, l.zoomed, {
                    once: !0
                }),
                Ut(a, N_, {
                    ratio: e,
                    oldRatio: E,
                    originalEvent: s
                }, {
                    cancelable: !1
                })
            }),
            i && this.tooltip()
        }
        return this
    },
    play: function() {
        var e = this
          , t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
        if (!this.isShown || this.played)
            return this;
        var i = this.element
          , r = this.options;
        if (vt(r.play) && $e(i, U_, r.play, {
            once: !0
        }),
        Ut(i, U_) === !1)
            return this;
        var s = this.player
          , o = this.loadImage.bind(this)
          , a = []
          , l = 0
          , c = 0;
        if (this.played = !0,
        this.onLoadWhenPlay = o,
        t && this.requestFullscreen(t),
        Xe(s, js),
        bt(this.items, function(f, d) {
            var p = f.querySelector("img")
              , v = document.createElement("img");
            v.src = oo(p, "originalUrl"),
            v.alt = p.getAttribute("alt"),
            v.referrerPolicy = p.referrerPolicy,
            l += 1,
            Xe(v, $c),
            ll(v, Pt, r.transition),
            Zs(f, Nc) && (Xe(v, zn),
            c = d),
            a.push(v),
            $e(v, Hn, o, {
                once: !0
            }),
            s.appendChild(v)
        }),
        Et(r.interval) && r.interval > 0) {
            var u = function f() {
                clearTimeout(e.playing.timeout),
                ot(a[c], zn),
                c -= 1,
                c = c >= 0 ? c : l - 1,
                Xe(a[c], zn),
                e.playing.timeout = setTimeout(f, r.interval)
            }
              , h = function f() {
                clearTimeout(e.playing.timeout),
                ot(a[c], zn),
                c += 1,
                c = c < l ? c : 0,
                Xe(a[c], zn),
                e.playing.timeout = setTimeout(f, r.interval)
            };
            l > 1 && (this.playing = {
                prev: u,
                next: h,
                timeout: setTimeout(h, r.interval)
            })
        }
        return this
    },
    stop: function() {
        var e = this;
        if (!this.played)
            return this;
        var t = this.element
          , i = this.options;
        if (vt(i.stop) && $e(t, O_, i.stop, {
            once: !0
        }),
        Ut(t, O_) === !1)
            return this;
        var r = this.player;
        return clearTimeout(this.playing.timeout),
        this.playing = !1,
        this.played = !1,
        bt(r.getElementsByTagName("img"), function(s) {
            _t(s, Hn, e.onLoadWhenPlay)
        }),
        ot(r, js),
        r.innerHTML = "",
        this.exitFullscreen(),
        this
    },
    full: function() {
        var e = this
          , t = this.options
          , i = this.viewer
          , r = this.image
          , s = this.list;
        return !this.isShown || this.played || this.fulled || !t.inline ? this : (this.fulled = !0,
        this.open(),
        Xe(this.button, h_),
        t.transition && (ot(s, Pt),
        this.viewed && ot(r, Pt)),
        Xe(i, Xd),
        i.setAttribute("role", "dialog"),
        i.setAttribute("aria-labelledby", this.title.id),
        i.setAttribute("aria-modal", !0),
        i.removeAttribute("style"),
        Qn(i, {
            zIndex: t.zIndex
        }),
        t.focus && this.enforceFocus(),
        this.initContainer(),
        this.viewerData = Dn({}, this.containerData),
        this.renderList(),
        this.viewed && this.initImage(function() {
            e.renderImage(function() {
                t.transition && setTimeout(function() {
                    Xe(r, Pt),
                    Xe(s, Pt)
                }, 0)
            })
        }),
        this)
    },
    exit: function() {
        var e = this
          , t = this.options
          , i = this.viewer
          , r = this.image
          , s = this.list;
        return !this.isShown || this.played || !this.fulled || !t.inline ? this : (this.fulled = !1,
        this.close(),
        ot(this.button, h_),
        t.transition && (ot(s, Pt),
        this.viewed && ot(r, Pt)),
        t.focus && this.clearEnforceFocus(),
        i.removeAttribute("role"),
        i.removeAttribute("aria-labelledby"),
        i.removeAttribute("aria-modal"),
        ot(i, Xd),
        Qn(i, {
            zIndex: t.zIndexInline
        }),
        this.viewerData = Dn({}, this.parentData),
        this.renderViewer(),
        this.renderList(),
        this.viewed && this.initImage(function() {
            e.renderImage(function() {
                t.transition && setTimeout(function() {
                    Xe(r, Pt),
                    Xe(s, Pt)
                }, 0)
            })
        }),
        this)
    },
    tooltip: function() {
        var e = this
          , t = this.options
          , i = this.tooltipBox
          , r = this.imageData;
        return !this.viewed || this.played || !t.tooltip ? this : (i.textContent = "".concat(Math.round(r.ratio * 100), "%"),
        this.tooltipping ? clearTimeout(this.tooltipping) : t.transition ? (this.fading && Ut(i, jn),
        Xe(i, js),
        Xe(i, $c),
        Xe(i, Pt),
        i.removeAttribute("aria-hidden"),
        i.initialOffsetWidth = i.offsetWidth,
        Xe(i, zn)) : (Xe(i, js),
        i.removeAttribute("aria-hidden")),
        this.tooltipping = setTimeout(function() {
            t.transition ? ($e(i, jn, function() {
                ot(i, js),
                ot(i, $c),
                ot(i, Pt),
                i.setAttribute("aria-hidden", !0),
                e.fading = !1
            }, {
                once: !0
            }),
            ot(i, zn),
            e.fading = !0) : (ot(i, js),
            i.setAttribute("aria-hidden", !0)),
            e.tooltipping = !1
        }, 1e3),
        this)
    },
    toggle: function() {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return this.imageData.ratio === 1 ? this.zoomTo(this.imageData.oldRatio, !0, null, e) : this.zoomTo(1, !0, null, e),
        this
    },
    reset: function() {
        return this.viewed && !this.played && (this.imageData = Dn({}, this.initialImageData),
        this.renderImage()),
        this
    },
    update: function() {
        var e = this
          , t = this.element
          , i = this.options
          , r = this.isImg;
        if (r && !t.parentNode)
            return this.destroy();
        var s = [];
        if (bt(r ? [t] : t.querySelectorAll("img"), function(c) {
            vt(i.filter) ? i.filter.call(e, c) && s.push(c) : e.getImageURL(c) && s.push(c)
        }),
        !s.length)
            return this;
        if (this.images = s,
        this.length = s.length,
        this.ready) {
            var o = [];
            if (bt(this.items, function(c, u) {
                var h = c.querySelector("img")
                  , f = s[u];
                f && h ? (f.src !== h.src || f.alt !== h.alt) && o.push(u) : o.push(u)
            }),
            Qn(this.list, {
                width: "auto"
            }),
            this.initList(),
            this.isShown)
                if (this.length) {
                    if (this.viewed) {
                        var a = o.indexOf(this.index);
                        if (a >= 0)
                            this.viewed = !1,
                            this.view(Math.max(Math.min(this.index - a, this.length - 1), 0));
                        else {
                            var l = this.items[this.index];
                            Xe(l, Nc),
                            l.setAttribute("aria-selected", !0)
                        }
                    }
                } else
                    this.image = null,
                    this.viewed = !1,
                    this.index = 0,
                    this.imageData = {},
                    this.canvas.innerHTML = "",
                    this.title.innerHTML = ""
        } else
            this.build();
        return this
    },
    destroy: function() {
        var e = this.element
          , t = this.options;
        return e[Je] ? (this.destroyed = !0,
        this.ready ? (this.played && this.stop(),
        t.inline ? (this.fulled && this.exit(),
        this.unbind()) : this.isShown ? (this.viewing && (this.imageRendering ? this.imageRendering.abort() : this.imageInitializing && this.imageInitializing.abort()),
        this.hiding && this.transitioning.abort(),
        this.hidden()) : this.showing && (this.transitioning.abort(),
        this.hidden()),
        this.ready = !1,
        this.viewer.parentNode.removeChild(this.viewer)) : t.inline && (this.delaying ? this.delaying.abort() : this.initializing && this.initializing.abort()),
        t.inline || _t(e, Ao, this.onStart),
        e[Je] = void 0,
        this) : this
    }
}
  , cN = {
    getImageURL: function(e) {
        var t = this.options.url;
        return al(t) ? t = e.getAttribute(t) : vt(t) ? t = t.call(this, e) : t = "",
        t
    },
    enforceFocus: function() {
        var e = this;
        this.clearEnforceFocus(),
        $e(document, p_, this.onFocusin = function(t) {
            var i = e.viewer
              , r = t.target;
            if (!(r === document || r === i || i.contains(r))) {
                for (; r; ) {
                    if (r.getAttribute("tabindex") !== null || r.getAttribute("aria-modal") === "true")
                        return;
                    r = r.parentElement
                }
                i.focus()
            }
        }
        )
    },
    clearEnforceFocus: function() {
        this.onFocusin && (_t(document, p_, this.onFocusin),
        this.onFocusin = null)
    },
    open: function() {
        var e = this.body;
        Xe(e, f_),
        this.scrollbarWidth > 0 && (e.style.paddingRight = "".concat(this.scrollbarWidth + (parseFloat(this.initialBodyComputedPaddingRight) || 0), "px"))
    },
    close: function() {
        var e = this.body;
        ot(e, f_),
        this.scrollbarWidth > 0 && (e.style.paddingRight = this.initialBodyPaddingRight)
    },
    shown: function() {
        var e = this.element
          , t = this.options
          , i = this.viewer;
        this.fulled = !0,
        this.isShown = !0,
        this.render(),
        this.bind(),
        this.showing = !1,
        t.focus && (i.focus(),
        this.enforceFocus()),
        vt(t.shown) && $e(e, S_, t.shown, {
            once: !0
        }),
        Ut(e, S_) !== !1 && this.ready && this.isShown && !this.hiding && this.view(this.index)
    },
    hidden: function() {
        var e = this.element
          , t = this.options
          , i = this.viewer;
        t.fucus && this.clearEnforceFocus(),
        this.close(),
        this.unbind(),
        Xe(i, ts),
        i.removeAttribute("role"),
        i.removeAttribute("aria-labelledby"),
        i.removeAttribute("aria-modal"),
        i.setAttribute("aria-hidden", !0),
        this.resetList(),
        this.resetImage(),
        this.fulled = !1,
        this.viewed = !1,
        this.isShown = !1,
        this.hiding = !1,
        this.destroyed || (vt(t.hidden) && $e(e, E_, t.hidden, {
            once: !0
        }),
        Ut(e, E_, null, {
            cancelable: !1
        }))
    },
    requestFullscreen: function(e) {
        var t = this.element.ownerDocument;
        if (this.fulled && !(t.fullscreenElement || t.webkitFullscreenElement || t.mozFullScreenElement || t.msFullscreenElement)) {
            var i = t.documentElement;
            i.requestFullscreen ? so(e) ? i.requestFullscreen(e) : i.requestFullscreen() : i.webkitRequestFullscreen ? i.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT) : i.mozRequestFullScreen ? i.mozRequestFullScreen() : i.msRequestFullscreen && i.msRequestFullscreen()
        }
    },
    exitFullscreen: function() {
        var e = this.element.ownerDocument;
        this.fulled && (e.fullscreenElement || e.webkitFullscreenElement || e.mozFullScreenElement || e.msFullscreenElement) && (e.exitFullscreen ? e.exitFullscreen() : e.webkitExitFullscreen ? e.webkitExitFullscreen() : e.mozCancelFullScreen ? e.mozCancelFullScreen() : e.msExitFullscreen && e.msExitFullscreen())
    },
    change: function(e) {
        var t = this.options
          , i = this.pointers
          , r = i[Object.keys(i)[0]];
        if (r) {
            var s = r.endX - r.startX
              , o = r.endY - r.startY;
            switch (this.action) {
            case qc:
                (s !== 0 || o !== 0) && (this.pointerMoved = !0,
                this.move(s, o, e));
                break;
            case la:
                this.zoom(iN(i), !1, null, e);
                break;
            case aM:
                {
                    this.action = "switched";
                    var a = Math.abs(s);
                    a > 1 && a > Math.abs(o) && (this.pointers = {},
                    s > 1 ? this.prev(t.loop) : s < -1 && this.next(t.loop));
                    break
                }
            }
            bt(i, function(l) {
                l.startX = l.endX,
                l.startY = l.endY
            })
        }
    },
    isSwitchable: function() {
        var e = this.imageData
          , t = this.viewerData;
        return this.length > 1 && e.x >= 0 && e.y >= 0 && e.width <= t.width && e.height <= t.height
    }
}
  , uN = Yi.Viewer
  , hN = function(n) {
    return function() {
        return n += 1,
        n
    }
}(-1)
  , Co = function() {
    function n(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (O2(this, n),
        !e || e.nodeType !== 1)
            throw new Error("The first argument is required and must be an element.");
        this.element = e,
        this.options = Dn({}, u_, so(t) && t),
        this.action = !1,
        this.fading = !1,
        this.fulled = !1,
        this.hiding = !1,
        this.imageClicked = !1,
        this.imageData = {},
        this.index = this.options.initialViewIndex,
        this.isImg = !1,
        this.isShown = !1,
        this.length = 0,
        this.moving = !1,
        this.played = !1,
        this.playing = !1,
        this.pointers = {},
        this.ready = !1,
        this.rotating = !1,
        this.scaling = !1,
        this.showing = !1,
        this.timeout = !1,
        this.tooltipping = !1,
        this.viewed = !1,
        this.viewing = !1,
        this.wheeling = !1,
        this.zooming = !1,
        this.pointerMoved = !1,
        this.id = hN(),
        this.init()
    }
    return F2(n, [{
        key: "init",
        value: function() {
            var t = this
              , i = this.element
              , r = this.options;
            if (!i[Je]) {
                i[Je] = this,
                r.focus && !r.keyboard && (r.focus = !1);
                var s = i.localName === "img"
                  , o = [];
                if (bt(s ? [i] : i.querySelectorAll("img"), function(c) {
                    vt(r.filter) ? r.filter.call(t, c) && o.push(c) : t.getImageURL(c) && o.push(c)
                }),
                this.isImg = s,
                this.length = o.length,
                this.images = o,
                this.initBody(),
                ro(document.createElement(Je).style.transition) && (r.transition = !1),
                r.inline) {
                    var a = 0
                      , l = function() {
                        if (a += 1,
                        a === t.length) {
                            var u;
                            t.initializing = !1,
                            t.delaying = {
                                abort: function() {
                                    clearTimeout(u)
                                }
                            },
                            u = setTimeout(function() {
                                t.delaying = !1,
                                t.build()
                            }, 0)
                        }
                    };
                    this.initializing = {
                        abort: function() {
                            bt(o, function(u) {
                                u.complete || (_t(u, Hn, l),
                                _t(u, ps, l))
                            })
                        }
                    },
                    bt(o, function(c) {
                        if (c.complete)
                            l();
                        else {
                            var u, h;
                            $e(c, Hn, u = function() {
                                _t(c, ps, h),
                                l()
                            }
                            , {
                                once: !0
                            }),
                            $e(c, ps, h = function() {
                                _t(c, Hn, u),
                                l()
                            }
                            , {
                                once: !0
                            })
                        }
                    })
                } else
                    $e(i, Ao, this.onStart = function(c) {
                        var u = c.target;
                        u.localName === "img" && (!vt(r.filter) || r.filter.call(t, u)) && t.view(t.images.indexOf(u))
                    }
                    )
            }
        }
    }, {
        key: "build",
        value: function() {
            if (!this.ready) {
                var t = this.element
                  , i = this.options
                  , r = t.parentNode
                  , s = document.createElement("div");
                s.innerHTML = k2;
                var o = s.querySelector(".".concat(Je, "-container"))
                  , a = o.querySelector(".".concat(Je, "-title"))
                  , l = o.querySelector(".".concat(Je, "-toolbar"))
                  , c = o.querySelector(".".concat(Je, "-navbar"))
                  , u = o.querySelector(".".concat(Je, "-button"))
                  , h = o.querySelector(".".concat(Je, "-canvas"));
                if (this.parent = r,
                this.viewer = o,
                this.title = a,
                this.toolbar = l,
                this.navbar = c,
                this.button = u,
                this.canvas = h,
                this.footer = o.querySelector(".".concat(Je, "-footer")),
                this.tooltipBox = o.querySelector(".".concat(Je, "-tooltip")),
                this.player = o.querySelector(".".concat(Je, "-player")),
                this.list = o.querySelector(".".concat(Je, "-list")),
                o.id = "".concat(Je).concat(this.id),
                a.id = "".concat(Je, "Title").concat(this.id),
                Xe(a, i.title ? Oc(Array.isArray(i.title) ? i.title[0] : i.title) : ts),
                Xe(c, i.navbar ? Oc(i.navbar) : ts),
                ll(u, ts, !i.button),
                i.keyboard && u.setAttribute("tabindex", 0),
                i.backdrop && (Xe(o, "".concat(Je, "-backdrop")),
                !i.inline && i.backdrop !== "static" && $d(h, Ou, "hide")),
                al(i.className) && i.className && i.className.split(mm).forEach(function(_) {
                    Xe(o, _)
                }),
                i.toolbar) {
                    var f = document.createElement("ul")
                      , d = so(i.toolbar)
                      , p = Uc.slice(0, 3)
                      , v = Uc.slice(7, 9)
                      , g = Uc.slice(9);
                    d || Xe(l, Oc(i.toolbar)),
                    bt(d ? i.toolbar : Uc, function(_, x) {
                        var C = d && so(_)
                          , w = d ? gm(x) : _
                          , E = C && !ro(_.show) ? _.show : _;
                        if (!(!E || !i.zoomable && p.indexOf(w) !== -1 || !i.rotatable && v.indexOf(w) !== -1 || !i.scalable && g.indexOf(w) !== -1)) {
                            var L = C && !ro(_.size) ? _.size : _
                              , S = C && !ro(_.click) ? _.click : _
                              , b = document.createElement("li");
                            i.keyboard && b.setAttribute("tabindex", 0),
                            b.setAttribute("role", "button"),
                            Xe(b, "".concat(Je, "-").concat(w)),
                            vt(S) || $d(b, Ou, w),
                            Et(E) && Xe(b, Oc(E)),
                            ["small", "large"].indexOf(L) !== -1 ? Xe(b, "".concat(Je, "-").concat(L)) : w === "play" && Xe(b, "".concat(Je, "-large")),
                            vt(S) && $e(b, Ao, S),
                            f.appendChild(b)
                        }
                    }),
                    l.appendChild(f)
                } else
                    Xe(l, ts);
                if (!i.rotatable) {
                    var m = l.querySelectorAll('li[class*="rotate"]');
                    Xe(m, wa),
                    bt(m, function(_) {
                        l.appendChild(_)
                    })
                }
                if (i.inline)
                    Xe(u, H2),
                    Qn(o, {
                        zIndex: i.zIndexInline
                    }),
                    window.getComputedStyle(r).position === "static" && Qn(r, {
                        position: "relative"
                    }),
                    r.insertBefore(o, t.nextSibling);
                else {
                    Xe(u, V2),
                    Xe(o, Xd),
                    Xe(o, $c),
                    Xe(o, ts),
                    Qn(o, {
                        zIndex: i.zIndex
                    });
                    var y = i.container;
                    al(y) && (y = t.ownerDocument.querySelector(y)),
                    y || (y = this.body),
                    y.appendChild(o)
                }
                if (i.inline && (this.render(),
                this.bind(),
                this.isShown = !0),
                this.ready = !0,
                vt(i.ready) && $e(t, b_, i.ready, {
                    once: !0
                }),
                Ut(t, b_) === !1) {
                    this.ready = !1;
                    return
                }
                this.ready && i.inline && this.view(this.index)
            }
        }
    }], [{
        key: "noConflict",
        value: function() {
            return window.Viewer = uN,
            n
        }
    }, {
        key: "setDefaults",
        value: function(t) {
            Dn(u_, so(t) && t)
        }
    }]),
    n
}();
Dn(Co.prototype, sN, oN, aN, lN, cN);
var fN = typeof global == "object" && global && global.Object === Object && global;
const uM = fN;
var dN = typeof self == "object" && self && self.Object === Object && self
  , pN = uM || dN || Function("return this")();
const Vh = pN;
var mN = Vh.Symbol;
const Fu = mN;
var hM = Object.prototype
  , gN = hM.hasOwnProperty
  , vN = hM.toString
  , na = Fu ? Fu.toStringTag : void 0;
function _N(n) {
    var e = gN.call(n, na)
      , t = n[na];
    try {
        n[na] = void 0;
        var i = !0
    } catch {}
    var r = vN.call(n);
    return i && (e ? n[na] = t : delete n[na]),
    r
}
var yN = Object.prototype
  , xN = yN.toString;
function bN(n) {
    return xN.call(n)
}
var MN = "[object Null]"
  , SN = "[object Undefined]"
  , F_ = Fu ? Fu.toStringTag : void 0;
function Hh(n) {
    return n == null ? n === void 0 ? SN : MN : F_ && F_ in Object(n) ? _N(n) : bN(n)
}
function Gh(n) {
    return n != null && typeof n == "object"
}
var wN = "[object Symbol]";
function EN(n) {
    return typeof n == "symbol" || Gh(n) && Hh(n) == wN
}
var AN = Array.isArray;
const TN = AN;
var CN = /\s/;
function RN(n) {
    for (var e = n.length; e-- && CN.test(n.charAt(e)); )
        ;
    return e
}
var PN = /^\s+/;
function IN(n) {
    return n && n.slice(0, RN(n) + 1).replace(PN, "")
}
function bs(n) {
    var e = typeof n;
    return n != null && (e == "object" || e == "function")
}
var B_ = NaN
  , LN = /^[-+]0x[0-9a-f]+$/i
  , DN = /^0b[01]+$/i
  , NN = /^0o[0-7]+$/i
  , UN = parseInt;
function z_(n) {
    if (typeof n == "number")
        return n;
    if (EN(n))
        return B_;
    if (bs(n)) {
        var e = typeof n.valueOf == "function" ? n.valueOf() : n;
        n = bs(e) ? e + "" : e
    }
    if (typeof n != "string")
        return n === 0 ? n : +n;
    n = IN(n);
    var t = DN.test(n);
    return t || NN.test(n) ? UN(n.slice(2), t ? 2 : 8) : LN.test(n) ? B_ : +n
}
function fM(n) {
    return n
}
var ON = "[object AsyncFunction]"
  , FN = "[object Function]"
  , BN = "[object GeneratorFunction]"
  , zN = "[object Proxy]";
function dM(n) {
    if (!bs(n))
        return !1;
    var e = Hh(n);
    return e == FN || e == BN || e == ON || e == zN
}
var kN = Vh["__core-js_shared__"];
const nd = kN;
var k_ = function() {
    var n = /[^.]+$/.exec(nd && nd.keys && nd.keys.IE_PROTO || "");
    return n ? "Symbol(src)_1." + n : ""
}();
function VN(n) {
    return !!k_ && k_ in n
}
var HN = Function.prototype
  , GN = HN.toString;
function WN(n) {
    if (n != null) {
        try {
            return GN.call(n)
        } catch {}
        try {
            return n + ""
        } catch {}
    }
    return ""
}
var XN = /[\\^$.*+?()[\]{}|]/g
  , qN = /^\[object .+?Constructor\]$/
  , $N = Function.prototype
  , YN = Object.prototype
  , jN = $N.toString
  , KN = YN.hasOwnProperty
  , ZN = RegExp("^" + jN.call(KN).replace(XN, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function JN(n) {
    if (!bs(n) || VN(n))
        return !1;
    var e = dM(n) ? ZN : qN;
    return e.test(WN(n))
}
function QN(n, e) {
    return n == null ? void 0 : n[e]
}
function eU(n, e) {
    var t = QN(n, e);
    return JN(t) ? t : void 0
}
function tU(n, e, t) {
    switch (t.length) {
    case 0:
        return n.call(e);
    case 1:
        return n.call(e, t[0]);
    case 2:
        return n.call(e, t[0], t[1]);
    case 3:
        return n.call(e, t[0], t[1], t[2])
    }
    return n.apply(e, t)
}
var nU = 800
  , iU = 16
  , rU = Date.now;
function sU(n) {
    var e = 0
      , t = 0;
    return function() {
        var i = rU()
          , r = iU - (i - t);
        if (t = i,
        r > 0) {
            if (++e >= nU)
                return arguments[0]
        } else
            e = 0;
        return n.apply(void 0, arguments)
    }
}
function oU(n) {
    return function() {
        return n
    }
}
var aU = function() {
    try {
        var n = eU(Object, "defineProperty");
        return n({}, "", {}),
        n
    } catch {}
}();
const Bu = aU;
var lU = Bu ? function(n, e) {
    return Bu(n, "toString", {
        configurable: !0,
        enumerable: !1,
        value: oU(e),
        writable: !0
    })
}
: fM;
const cU = lU;
var uU = sU(cU);
const hU = uU;
var fU = 9007199254740991
  , dU = /^(?:0|[1-9]\d*)$/;
function pM(n, e) {
    var t = typeof n;
    return e = e ?? fU,
    !!e && (t == "number" || t != "symbol" && dU.test(n)) && n > -1 && n % 1 == 0 && n < e
}
function mM(n, e, t) {
    e == "__proto__" && Bu ? Bu(n, e, {
        configurable: !0,
        enumerable: !0,
        value: t,
        writable: !0
    }) : n[e] = t
}
function vm(n, e) {
    return n === e || n !== n && e !== e
}
var pU = Object.prototype
  , mU = pU.hasOwnProperty;
function gM(n, e, t) {
    var i = n[e];
    (!(mU.call(n, e) && vm(i, t)) || t === void 0 && !(e in n)) && mM(n, e, t)
}
function gU(n, e, t, i) {
    var r = !t;
    t || (t = {});
    for (var s = -1, o = e.length; ++s < o; ) {
        var a = e[s]
          , l = void 0;
        l === void 0 && (l = n[a]),
        r ? mM(t, a, l) : gM(t, a, l)
    }
    return t
}
var V_ = Math.max;
function vU(n, e, t) {
    return e = V_(e === void 0 ? n.length - 1 : e, 0),
    function() {
        for (var i = arguments, r = -1, s = V_(i.length - e, 0), o = Array(s); ++r < s; )
            o[r] = i[e + r];
        r = -1;
        for (var a = Array(e + 1); ++r < e; )
            a[r] = i[r];
        return a[e] = t(o),
        tU(n, this, a)
    }
}
function vM(n, e) {
    return hU(vU(n, e, fM), n + "")
}
var _U = 9007199254740991;
function _M(n) {
    return typeof n == "number" && n > -1 && n % 1 == 0 && n <= _U
}
function Wh(n) {
    return n != null && _M(n.length) && !dM(n)
}
function yM(n, e, t) {
    if (!bs(t))
        return !1;
    var i = typeof e;
    return (i == "number" ? Wh(t) && pM(e, t.length) : i == "string" && e in t) ? vm(t[e], n) : !1
}
function yU(n) {
    return vM(function(e, t) {
        var i = -1
          , r = t.length
          , s = r > 1 ? t[r - 1] : void 0
          , o = r > 2 ? t[2] : void 0;
        for (s = n.length > 3 && typeof s == "function" ? (r--,
        s) : void 0,
        o && yM(t[0], t[1], o) && (s = r < 3 ? void 0 : s,
        r = 1),
        e = Object(e); ++i < r; ) {
            var a = t[i];
            a && n(e, a, i, s)
        }
        return e
    })
}
var xU = Object.prototype;
function _m(n) {
    var e = n && n.constructor
      , t = typeof e == "function" && e.prototype || xU;
    return n === t
}
function bU(n, e) {
    for (var t = -1, i = Array(n); ++t < n; )
        i[t] = e(t);
    return i
}
var MU = "[object Arguments]";
function H_(n) {
    return Gh(n) && Hh(n) == MU
}
var xM = Object.prototype
  , SU = xM.hasOwnProperty
  , wU = xM.propertyIsEnumerable
  , EU = H_(function() {
    return arguments
}()) ? H_ : function(n) {
    return Gh(n) && SU.call(n, "callee") && !wU.call(n, "callee")
}
;
const AU = EU;
function TU() {
    return !1
}
var bM = typeof exports == "object" && exports && !exports.nodeType && exports
  , G_ = bM && typeof module == "object" && module && !module.nodeType && module
  , CU = G_ && G_.exports === bM
  , W_ = CU ? Vh.Buffer : void 0
  , RU = W_ ? W_.isBuffer : void 0
  , PU = RU || TU;
const IU = PU;
var LU = "[object Arguments]"
  , DU = "[object Array]"
  , NU = "[object Boolean]"
  , UU = "[object Date]"
  , OU = "[object Error]"
  , FU = "[object Function]"
  , BU = "[object Map]"
  , zU = "[object Number]"
  , kU = "[object Object]"
  , VU = "[object RegExp]"
  , HU = "[object Set]"
  , GU = "[object String]"
  , WU = "[object WeakMap]"
  , XU = "[object ArrayBuffer]"
  , qU = "[object DataView]"
  , $U = "[object Float32Array]"
  , YU = "[object Float64Array]"
  , jU = "[object Int8Array]"
  , KU = "[object Int16Array]"
  , ZU = "[object Int32Array]"
  , JU = "[object Uint8Array]"
  , QU = "[object Uint8ClampedArray]"
  , eO = "[object Uint16Array]"
  , tO = "[object Uint32Array]"
  , St = {};
St[$U] = St[YU] = St[jU] = St[KU] = St[ZU] = St[JU] = St[QU] = St[eO] = St[tO] = !0;
St[LU] = St[DU] = St[XU] = St[NU] = St[qU] = St[UU] = St[OU] = St[FU] = St[BU] = St[zU] = St[kU] = St[VU] = St[HU] = St[GU] = St[WU] = !1;
function nO(n) {
    return Gh(n) && _M(n.length) && !!St[Hh(n)]
}
function iO(n) {
    return function(e) {
        return n(e)
    }
}
var MM = typeof exports == "object" && exports && !exports.nodeType && exports
  , Ea = MM && typeof module == "object" && module && !module.nodeType && module
  , rO = Ea && Ea.exports === MM
  , id = rO && uM.process
  , sO = function() {
    try {
        var n = Ea && Ea.require && Ea.require("util").types;
        return n || id && id.binding && id.binding("util")
    } catch {}
}();
const X_ = sO;
var q_ = X_ && X_.isTypedArray
  , oO = q_ ? iO(q_) : nO;
const aO = oO;
var lO = Object.prototype
  , cO = lO.hasOwnProperty;
function SM(n, e) {
    var t = TN(n)
      , i = !t && AU(n)
      , r = !t && !i && IU(n)
      , s = !t && !i && !r && aO(n)
      , o = t || i || r || s
      , a = o ? bU(n.length, String) : []
      , l = a.length;
    for (var c in n)
        (e || cO.call(n, c)) && !(o && (c == "length" || r && (c == "offset" || c == "parent") || s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || pM(c, l))) && a.push(c);
    return a
}
function uO(n, e) {
    return function(t) {
        return n(e(t))
    }
}
var hO = uO(Object.keys, Object);
const fO = hO;
var dO = Object.prototype
  , pO = dO.hasOwnProperty;
function mO(n) {
    if (!_m(n))
        return fO(n);
    var e = [];
    for (var t in Object(n))
        pO.call(n, t) && t != "constructor" && e.push(t);
    return e
}
function gO(n) {
    return Wh(n) ? SM(n) : mO(n)
}
var vO = Object.prototype
  , _O = vO.hasOwnProperty
  , yO = yU(function(n, e) {
    if (_m(e) || Wh(e)) {
        gU(e, gO(e), n);
        return
    }
    for (var t in e)
        _O.call(e, t) && gM(n, t, e[t])
});
const xO = yO;
function bO(n) {
    var e = [];
    if (n != null)
        for (var t in Object(n))
            e.push(t);
    return e
}
var MO = Object.prototype
  , SO = MO.hasOwnProperty;
function wO(n) {
    if (!bs(n))
        return bO(n);
    var e = _m(n)
      , t = [];
    for (var i in n)
        i == "constructor" && (e || !SO.call(n, i)) || t.push(i);
    return t
}
function EO(n) {
    return Wh(n) ? SM(n, !0) : wO(n)
}
var AO = function() {
    return Vh.Date.now()
};
const rd = AO;
var TO = "Expected a function"
  , CO = Math.max
  , RO = Math.min;
function PO(n, e, t) {
    var i, r, s, o, a, l, c = 0, u = !1, h = !1, f = !0;
    if (typeof n != "function")
        throw new TypeError(TO);
    e = z_(e) || 0,
    bs(t) && (u = !!t.leading,
    h = "maxWait"in t,
    s = h ? CO(z_(t.maxWait) || 0, e) : s,
    f = "trailing"in t ? !!t.trailing : f);
    function d(w) {
        var E = i
          , L = r;
        return i = r = void 0,
        c = w,
        o = n.apply(L, E),
        o
    }
    function p(w) {
        return c = w,
        a = setTimeout(m, e),
        u ? d(w) : o
    }
    function v(w) {
        var E = w - l
          , L = w - c
          , S = e - E;
        return h ? RO(S, s - L) : S
    }
    function g(w) {
        var E = w - l
          , L = w - c;
        return l === void 0 || E >= e || E < 0 || h && L >= s
    }
    function m() {
        var w = rd();
        if (g(w))
            return y(w);
        a = setTimeout(m, v(w))
    }
    function y(w) {
        return a = void 0,
        f && i ? d(w) : (i = r = void 0,
        o)
    }
    function _() {
        a !== void 0 && clearTimeout(a),
        c = 0,
        i = l = r = a = void 0
    }
    function x() {
        return a === void 0 ? o : y(rd())
    }
    function C() {
        var w = rd()
          , E = g(w);
        if (i = arguments,
        r = this,
        l = w,
        E) {
            if (a === void 0)
                return p(l);
            if (h)
                return clearTimeout(a),
                a = setTimeout(m, e),
                d(l)
        }
        return a === void 0 && (a = setTimeout(m, e)),
        o
    }
    return C.cancel = _,
    C.flush = x,
    C
}
var wM = Object.prototype
  , IO = wM.hasOwnProperty
  , LO = vM(function(n, e) {
    n = Object(n);
    var t = -1
      , i = e.length
      , r = i > 2 ? e[2] : void 0;
    for (r && yM(e[0], e[1], r) && (i = 1); ++t < i; )
        for (var s = e[t], o = EO(s), a = -1, l = o.length; ++a < l; ) {
            var c = o[a]
              , u = n[c];
            (u === void 0 || vm(u, wM[c]) && !IO.call(n, c)) && (n[c] = s[c])
        }
    return n
});
const DO = LO
  , NO = ({images: n=[], options: e}) => {
    e = xO(e, {
        inline: !1
    });
    const t = document.createElement("div")
      , i = gs("div", {
        style: {
            display: "none"
        },
        class: ["__viewer-token"]
    }, n.map(a => gs("img", typeof a == "string" ? {
        src: a
    } : a)));
    gg(i, t);
    const r = t.firstElementChild;
    document.body.appendChild(r);
    const s = new Co(r,e)
      , o = s.destroy.bind(s);
    return s.destroy = function() {
        return o(),
        gg(null, t),
        s
    }
    ,
    s.show(),
    r.addEventListener("hidden", function() {
        this.viewer === s && s.destroy()
    }),
    s
}
  , UO = ({name: n="viewer", debug: e=!1}={}) => {
    async function t(u, h, f=!1, d=!1) {
        await as(),
        !(d && !i(u)) && (f || !u[`$${n}`] ? (o(u),
        u[`$${n}`] = new Co(u,h),
        c("Viewer created")) : (u[`$${n}`].update(),
        c("Viewer updated")))
    }
    function i(u) {
        const h = u.innerHTML.match(/<img([\w\W]+?)[\\/]?>/g)
          , f = h ? h.join("") : void 0;
        return u.__viewerImageDiffCache === f ? (c("Element change detected, but image(s) has not changed"),
        !1) : (c("Image change detected"),
        u.__viewerImageDiffCache = f,
        !0)
    }
    function r(u, h, f, d) {
        a(u);
        const p = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
        if (!p) {
            c("Observer not supported");
            return
        }
        const v = new p(m => {
            m.forEach(y => {
                c(`Viewer mutation:${y.type}`),
                f(u, h, d, !0)
            }
            )
        }
        )
          , g = {
            attributes: !0,
            childList: !0,
            characterData: !0,
            subtree: !0
        };
        v.observe(u, g),
        u.__viewerMutationObserver = v,
        c("Observer created")
    }
    function s(u, h, f, d) {
        u.__viewerUnwatch = Bt( () => h.value, (p, v) => {
            c("Change detected by watcher: ", h.value),
            d(u, p, !0, !1)
        }
        , {
            deep: !0
        }),
        c("Watcher created, expression: ", h.value)
    }
    function o(u) {
        !u[`$${n}`] || (u[`$${n}`].destroy(),
        delete u[`$${n}`],
        c("Viewer destroyed"))
    }
    function a(u) {
        !u.__viewerMutationObserver || (u.__viewerMutationObserver.disconnect(),
        delete u.__viewerMutationObserver,
        c("observer destroyed"))
    }
    function l(u) {
        !u.__viewerUnwatch || (u.__viewerUnwatch(),
        delete u.__viewerUnwatch,
        c("Watcher destroyed"))
    }
    function c(...u) {
        e && console.log(...u)
    }
    return {
        mounted(u, h, f) {
            c("Viewer bind");
            const d = PO(t, 50);
            d(u, h.value),
            s(u, h, f, d),
            h.modifiers.static || r(u, h.value, d, h.modifiers.rebuild)
        },
        unmounted(u) {
            c("Viewer unbind"),
            a(u),
            l(u),
            o(u)
        }
    }
}
  , OO = Ua({
    name: "Viewer",
    props: {
        images: {
            type: Array,
            default: () => []
        },
        rebuild: {
            type: Boolean,
            default: !1
        },
        trigger: {
            type: Object,
            default: null
        },
        options: {
            type: Object,
            default: () => null
        }
    },
    emits: ["inited"],
    setup(n, {emit: e}) {
        let t;
        const i = Qe();
        function r() {
            t = new Co(i.value,n.options),
            e("inited", t)
        }
        function s() {
            t && t.destroy()
        }
        function o() {
            s(),
            r()
        }
        function a() {
            t ? (t.update(),
            e("inited", t)) : r()
        }
        function l() {
            n.rebuild ? o() : a()
        }
        const c = {
            deep: !0
        };
        return Bt( () => n.images, () => {
            as( () => {
                l()
            }
            )
        }
        , c),
        Bt( () => n.trigger, () => {
            as( () => {
                l()
            }
            )
        }
        , c),
        Bt( () => n.options, () => {
            as( () => {
                o()
            }
            )
        }
        , c),
        Ms( () => r()),
        Hi( () => s()),
        {
            root: i,
            createViewer: r,
            rebuildViewer: o,
            updateViewer: a,
            destroyViewer: s
        }
    }
})
  , FO = (n, e) => {
    const t = n.__vccOpts || n;
    for (const [i,r] of e)
        t[i] = r;
    return t
}
  , BO = {
    ref: "root"
};
function zO(n, e, t, i, r, s) {
    return br(),
    wy("div", BO, [lw(n.$slots, "default", {
        images: n.images,
        options: n.options
    })], 512)
}
const kO = FO(OO, [["render", zO]])
  , VO = {
    install(n, {name: e="viewer", debug: t=!1, defaultOptions: i}={}) {
        i && Co.setDefaults(i),
        n.config.globalProperties[`$${e}Api`] = NO,
        n.component(e, DO(kO, {
            name: e
        })),
        n.directive(e, UO({
            name: e,
            debug: t
        }))
    },
    setDefaults(n) {
        Co.setDefaults(n)
    }
}
  , HO = n => {
    n.use(VO, {
        defaultOptions: {
            zIndex: 5e3,
            inline: !1,
            button: !0,
            navbar: !0,
            title: !1,
            toolbar: !0,
            tooltip: !0,
            movable: !0,
            zoomable: !0,
            rotatable: !1,
            scalable: !1,
            transition: !0,
            fullscreen: !1,
            keyboard: !0,
            url: "src"
        }
    })
}
  , GO = (n, e) => {
    const t = n.__vccOpts || n;
    for (const [i,r] of e)
        t[i] = r;
    return t
}
  , WO = {};
function XO(n, e) {
    const t = ow("router-view");
    return br(),
    po(t, null, {
        default: hd( ({Component: i}) => [on(eE, {
            name: "fade-transform",
            mode: "out-in"
        }, {
            default: hd( () => [(br(),
            po(KS, null, [(br(),
            po(aw(i)))], 1024))]),
            _: 2
        }, 1024)]),
        _: 1
    })
}
const qO = GO(WO, [["render", XO]]);
/*!
  * vue-router v4.4.5
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
const Js = typeof document < "u";
function EM(n) {
    return typeof n == "object" || "displayName"in n || "props"in n || "__vccOpts"in n
}
function $O(n) {
    return n.__esModule || n[Symbol.toStringTag] === "Module" || n.default && EM(n.default)
}
const dt = Object.assign;
function sd(n, e) {
    const t = {};
    for (const i in e) {
        const r = e[i];
        t[i] = ai(r) ? r.map(n) : n(r)
    }
    return t
}
const Aa = () => {}
  , ai = Array.isArray
  , AM = /#/g
  , YO = /&/g
  , jO = /\//g
  , KO = /=/g
  , ZO = /\?/g
  , TM = /\+/g
  , JO = /%5B/g
  , QO = /%5D/g
  , CM = /%5E/g
  , e3 = /%60/g
  , RM = /%7B/g
  , t3 = /%7C/g
  , PM = /%7D/g
  , n3 = /%20/g;
function ym(n) {
    return encodeURI("" + n).replace(t3, "|").replace(JO, "[").replace(QO, "]")
}
function i3(n) {
    return ym(n).replace(RM, "{").replace(PM, "}").replace(CM, "^")
}
function Yd(n) {
    return ym(n).replace(TM, "%2B").replace(n3, "+").replace(AM, "%23").replace(YO, "%26").replace(e3, "`").replace(RM, "{").replace(PM, "}").replace(CM, "^")
}
function r3(n) {
    return Yd(n).replace(KO, "%3D")
}
function s3(n) {
    return ym(n).replace(AM, "%23").replace(ZO, "%3F")
}
function o3(n) {
    return n == null ? "" : s3(n).replace(jO, "%2F")
}
function cl(n) {
    try {
        return decodeURIComponent("" + n)
    } catch {}
    return "" + n
}
const a3 = /\/$/
  , l3 = n => n.replace(a3, "");
function od(n, e, t="/") {
    let i, r = {}, s = "", o = "";
    const a = e.indexOf("#");
    let l = e.indexOf("?");
    return a < l && a >= 0 && (l = -1),
    l > -1 && (i = e.slice(0, l),
    s = e.slice(l + 1, a > -1 ? a : e.length),
    r = n(s)),
    a > -1 && (i = i || e.slice(0, a),
    o = e.slice(a, e.length)),
    i = f3(i ?? e, t),
    {
        fullPath: i + (s && "?") + s + o,
        path: i,
        query: r,
        hash: cl(o)
    }
}
function c3(n, e) {
    const t = e.query ? n(e.query) : "";
    return e.path + (t && "?") + t + (e.hash || "")
}
function $_(n, e) {
    return !e || !n.toLowerCase().startsWith(e.toLowerCase()) ? n : n.slice(e.length) || "/"
}
function u3(n, e, t) {
    const i = e.matched.length - 1
      , r = t.matched.length - 1;
    return i > -1 && i === r && Ro(e.matched[i], t.matched[r]) && IM(e.params, t.params) && n(e.query) === n(t.query) && e.hash === t.hash
}
function Ro(n, e) {
    return (n.aliasOf || n) === (e.aliasOf || e)
}
function IM(n, e) {
    if (Object.keys(n).length !== Object.keys(e).length)
        return !1;
    for (const t in n)
        if (!h3(n[t], e[t]))
            return !1;
    return !0
}
function h3(n, e) {
    return ai(n) ? Y_(n, e) : ai(e) ? Y_(e, n) : n === e
}
function Y_(n, e) {
    return ai(e) ? n.length === e.length && n.every( (t, i) => t === e[i]) : n.length === 1 && n[0] === e
}
function f3(n, e) {
    if (n.startsWith("/"))
        return n;
    if (!n)
        return e;
    const t = e.split("/")
      , i = n.split("/")
      , r = i[i.length - 1];
    (r === ".." || r === ".") && i.push("");
    let s = t.length - 1, o, a;
    for (o = 0; o < i.length; o++)
        if (a = i[o],
        a !== ".")
            if (a === "..")
                s > 1 && s--;
            else
                break;
    return t.slice(0, s).join("/") + "/" + i.slice(o).join("/")
}
const hr = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
};
var ul;
(function(n) {
    n.pop = "pop",
    n.push = "push"
}
)(ul || (ul = {}));
var Ta;
(function(n) {
    n.back = "back",
    n.forward = "forward",
    n.unknown = ""
}
)(Ta || (Ta = {}));
function d3(n) {
    if (!n)
        if (Js) {
            const e = document.querySelector("base");
            n = e && e.getAttribute("href") || "/",
            n = n.replace(/^\w+:\/\/[^\/]+/, "")
        } else
            n = "/";
    return n[0] !== "/" && n[0] !== "#" && (n = "/" + n),
    l3(n)
}
const p3 = /^[^#]+#/;
function m3(n, e) {
    return n.replace(p3, "#") + e
}
function g3(n, e) {
    const t = document.documentElement.getBoundingClientRect()
      , i = n.getBoundingClientRect();
    return {
        behavior: e.behavior,
        left: i.left - t.left - (e.left || 0),
        top: i.top - t.top - (e.top || 0)
    }
}
const Xh = () => ({
    left: window.scrollX,
    top: window.scrollY
});
function v3(n) {
    let e;
    if ("el"in n) {
        const t = n.el
          , i = typeof t == "string" && t.startsWith("#")
          , r = typeof t == "string" ? i ? document.getElementById(t.slice(1)) : document.querySelector(t) : t;
        if (!r)
            return;
        e = g3(r, n)
    } else
        e = n;
    "scrollBehavior"in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.scrollX, e.top != null ? e.top : window.scrollY)
}
function j_(n, e) {
    return (history.state ? history.state.position - e : -1) + n
}
const jd = new Map;
function _3(n, e) {
    jd.set(n, e)
}
function y3(n) {
    const e = jd.get(n);
    return jd.delete(n),
    e
}
let x3 = () => location.protocol + "//" + location.host;
function LM(n, e) {
    const {pathname: t, search: i, hash: r} = e
      , s = n.indexOf("#");
    if (s > -1) {
        let a = r.includes(n.slice(s)) ? n.slice(s).length : 1
          , l = r.slice(a);
        return l[0] !== "/" && (l = "/" + l),
        $_(l, "")
    }
    return $_(t, n) + i + r
}
function b3(n, e, t, i) {
    let r = []
      , s = []
      , o = null;
    const a = ({state: f}) => {
        const d = LM(n, location)
          , p = t.value
          , v = e.value;
        let g = 0;
        if (f) {
            if (t.value = d,
            e.value = f,
            o && o === p) {
                o = null;
                return
            }
            g = v ? f.position - v.position : 0
        } else
            i(d);
        r.forEach(m => {
            m(t.value, p, {
                delta: g,
                type: ul.pop,
                direction: g ? g > 0 ? Ta.forward : Ta.back : Ta.unknown
            })
        }
        )
    }
    ;
    function l() {
        o = t.value
    }
    function c(f) {
        r.push(f);
        const d = () => {
            const p = r.indexOf(f);
            p > -1 && r.splice(p, 1)
        }
        ;
        return s.push(d),
        d
    }
    function u() {
        const {history: f} = window;
        f.state && f.replaceState(dt({}, f.state, {
            scroll: Xh()
        }), "")
    }
    function h() {
        for (const f of s)
            f();
        s = [],
        window.removeEventListener("popstate", a),
        window.removeEventListener("beforeunload", u)
    }
    return window.addEventListener("popstate", a),
    window.addEventListener("beforeunload", u, {
        passive: !0
    }),
    {
        pauseListeners: l,
        listen: c,
        destroy: h
    }
}
function K_(n, e, t, i=!1, r=!1) {
    return {
        back: n,
        current: e,
        forward: t,
        replaced: i,
        position: window.history.length,
        scroll: r ? Xh() : null
    }
}
function M3(n) {
    const {history: e, location: t} = window
      , i = {
        value: LM(n, t)
    }
      , r = {
        value: e.state
    };
    r.value || s(i.value, {
        back: null,
        current: i.value,
        forward: null,
        position: e.length - 1,
        replaced: !0,
        scroll: null
    }, !0);
    function s(l, c, u) {
        const h = n.indexOf("#")
          , f = h > -1 ? (t.host && document.querySelector("base") ? n : n.slice(h)) + l : x3() + n + l;
        try {
            e[u ? "replaceState" : "pushState"](c, "", f),
            r.value = c
        } catch (d) {
            console.error(d),
            t[u ? "replace" : "assign"](f)
        }
    }
    function o(l, c) {
        const u = dt({}, e.state, K_(r.value.back, l, r.value.forward, !0), c, {
            position: r.value.position
        });
        s(l, u, !0),
        i.value = l
    }
    function a(l, c) {
        const u = dt({}, r.value, e.state, {
            forward: l,
            scroll: Xh()
        });
        s(u.current, u, !0);
        const h = dt({}, K_(i.value, l, null), {
            position: u.position + 1
        }, c);
        s(l, h, !1),
        i.value = l
    }
    return {
        location: i,
        state: r,
        push: a,
        replace: o
    }
}
function S3(n) {
    n = d3(n);
    const e = M3(n)
      , t = b3(n, e.state, e.location, e.replace);
    function i(s, o=!0) {
        o || t.pauseListeners(),
        history.go(s)
    }
    const r = dt({
        location: "",
        base: n,
        go: i,
        createHref: m3.bind(null, n)
    }, e, t);
    return Object.defineProperty(r, "location", {
        enumerable: !0,
        get: () => e.location.value
    }),
    Object.defineProperty(r, "state", {
        enumerable: !0,
        get: () => e.state.value
    }),
    r
}
function w3(n) {
    return n = location.host ? n || location.pathname + location.search : "",
    n.includes("#") || (n += "#"),
    S3(n)
}
function E3(n) {
    return typeof n == "string" || n && typeof n == "object"
}
function DM(n) {
    return typeof n == "string" || typeof n == "symbol"
}
const NM = Symbol("");
var Z_;
(function(n) {
    n[n.aborted = 4] = "aborted",
    n[n.cancelled = 8] = "cancelled",
    n[n.duplicated = 16] = "duplicated"
}
)(Z_ || (Z_ = {}));
function Po(n, e) {
    return dt(new Error, {
        type: n,
        [NM]: !0
    }, e)
}
function Di(n, e) {
    return n instanceof Error && NM in n && (e == null || !!(n.type & e))
}
const J_ = "[^/]+?"
  , A3 = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
}
  , T3 = /[.+*?^${}()[\]/\\]/g;
function C3(n, e) {
    const t = dt({}, A3, e)
      , i = [];
    let r = t.start ? "^" : "";
    const s = [];
    for (const c of n) {
        const u = c.length ? [] : [90];
        t.strict && !c.length && (r += "/");
        for (let h = 0; h < c.length; h++) {
            const f = c[h];
            let d = 40 + (t.sensitive ? .25 : 0);
            if (f.type === 0)
                h || (r += "/"),
                r += f.value.replace(T3, "\\$&"),
                d += 40;
            else if (f.type === 1) {
                const {value: p, repeatable: v, optional: g, regexp: m} = f;
                s.push({
                    name: p,
                    repeatable: v,
                    optional: g
                });
                const y = m || J_;
                if (y !== J_) {
                    d += 10;
                    try {
                        new RegExp(`(${y})`)
                    } catch (x) {
                        throw new Error(`Invalid custom RegExp for param "${p}" (${y}): ` + x.message)
                    }
                }
                let _ = v ? `((?:${y})(?:/(?:${y}))*)` : `(${y})`;
                h || (_ = g && c.length < 2 ? `(?:/${_})` : "/" + _),
                g && (_ += "?"),
                r += _,
                d += 20,
                g && (d += -8),
                v && (d += -20),
                y === ".*" && (d += -50)
            }
            u.push(d)
        }
        i.push(u)
    }
    if (t.strict && t.end) {
        const c = i.length - 1;
        i[c][i[c].length - 1] += .7000000000000001
    }
    t.strict || (r += "/?"),
    t.end ? r += "$" : t.strict && (r += "(?:/|$)");
    const o = new RegExp(r,t.sensitive ? "" : "i");
    function a(c) {
        const u = c.match(o)
          , h = {};
        if (!u)
            return null;
        for (let f = 1; f < u.length; f++) {
            const d = u[f] || ""
              , p = s[f - 1];
            h[p.name] = d && p.repeatable ? d.split("/") : d
        }
        return h
    }
    function l(c) {
        let u = ""
          , h = !1;
        for (const f of n) {
            (!h || !u.endsWith("/")) && (u += "/"),
            h = !1;
            for (const d of f)
                if (d.type === 0)
                    u += d.value;
                else if (d.type === 1) {
                    const {value: p, repeatable: v, optional: g} = d
                      , m = p in c ? c[p] : "";
                    if (ai(m) && !v)
                        throw new Error(`Provided param "${p}" is an array but it is not repeatable (* or + modifiers)`);
                    const y = ai(m) ? m.join("/") : m;
                    if (!y)
                        if (g)
                            f.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : h = !0);
                        else
                            throw new Error(`Missing required param "${p}"`);
                    u += y
                }
        }
        return u || "/"
    }
    return {
        re: o,
        score: i,
        keys: s,
        parse: a,
        stringify: l
    }
}
function R3(n, e) {
    let t = 0;
    for (; t < n.length && t < e.length; ) {
        const i = e[t] - n[t];
        if (i)
            return i;
        t++
    }
    return n.length < e.length ? n.length === 1 && n[0] === 80 ? -1 : 1 : n.length > e.length ? e.length === 1 && e[0] === 80 ? 1 : -1 : 0
}
function UM(n, e) {
    let t = 0;
    const i = n.score
      , r = e.score;
    for (; t < i.length && t < r.length; ) {
        const s = R3(i[t], r[t]);
        if (s)
            return s;
        t++
    }
    if (Math.abs(r.length - i.length) === 1) {
        if (Q_(i))
            return 1;
        if (Q_(r))
            return -1
    }
    return r.length - i.length
}
function Q_(n) {
    const e = n[n.length - 1];
    return n.length > 0 && e[e.length - 1] < 0
}
const P3 = {
    type: 0,
    value: ""
}
  , I3 = /[a-zA-Z0-9_]/;
function L3(n) {
    if (!n)
        return [[]];
    if (n === "/")
        return [[P3]];
    if (!n.startsWith("/"))
        throw new Error(`Invalid path "${n}"`);
    function e(d) {
        throw new Error(`ERR (${t})/"${c}": ${d}`)
    }
    let t = 0
      , i = t;
    const r = [];
    let s;
    function o() {
        s && r.push(s),
        s = []
    }
    let a = 0, l, c = "", u = "";
    function h() {
        c && (t === 0 ? s.push({
            type: 0,
            value: c
        }) : t === 1 || t === 2 || t === 3 ? (s.length > 1 && (l === "*" || l === "+") && e(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),
        s.push({
            type: 1,
            value: c,
            regexp: u,
            repeatable: l === "*" || l === "+",
            optional: l === "*" || l === "?"
        })) : e("Invalid state to consume buffer"),
        c = "")
    }
    function f() {
        c += l
    }
    for (; a < n.length; ) {
        if (l = n[a++],
        l === "\\" && t !== 2) {
            i = t,
            t = 4;
            continue
        }
        switch (t) {
        case 0:
            l === "/" ? (c && h(),
            o()) : l === ":" ? (h(),
            t = 1) : f();
            break;
        case 4:
            f(),
            t = i;
            break;
        case 1:
            l === "(" ? t = 2 : I3.test(l) ? f() : (h(),
            t = 0,
            l !== "*" && l !== "?" && l !== "+" && a--);
            break;
        case 2:
            l === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + l : t = 3 : u += l;
            break;
        case 3:
            h(),
            t = 0,
            l !== "*" && l !== "?" && l !== "+" && a--,
            u = "";
            break;
        default:
            e("Unknown state");
            break
        }
    }
    return t === 2 && e(`Unfinished custom RegExp for param "${c}"`),
    h(),
    o(),
    r
}
function D3(n, e, t) {
    const i = C3(L3(n.path), t)
      , r = dt(i, {
        record: n,
        parent: e,
        children: [],
        alias: []
    });
    return e && !r.record.aliasOf == !e.record.aliasOf && e.children.push(r),
    r
}
function N3(n, e) {
    const t = []
      , i = new Map;
    e = i0({
        strict: !1,
        end: !0,
        sensitive: !1
    }, e);
    function r(h) {
        return i.get(h)
    }
    function s(h, f, d) {
        const p = !d
          , v = t0(h);
        v.aliasOf = d && d.record;
        const g = i0(e, h)
          , m = [v];
        if ("alias"in h) {
            const x = typeof h.alias == "string" ? [h.alias] : h.alias;
            for (const C of x)
                m.push(t0(dt({}, v, {
                    components: d ? d.record.components : v.components,
                    path: C,
                    aliasOf: d ? d.record : v
                })))
        }
        let y, _;
        for (const x of m) {
            const {path: C} = x;
            if (f && C[0] !== "/") {
                const w = f.record.path
                  , E = w[w.length - 1] === "/" ? "" : "/";
                x.path = f.record.path + (C && E + C)
            }
            if (y = D3(x, f, g),
            d ? d.alias.push(y) : (_ = _ || y,
            _ !== y && _.alias.push(y),
            p && h.name && !n0(y) && o(h.name)),
            OM(y) && l(y),
            v.children) {
                const w = v.children;
                for (let E = 0; E < w.length; E++)
                    s(w[E], y, d && d.children[E])
            }
            d = d || y
        }
        return _ ? () => {
            o(_)
        }
        : Aa
    }
    function o(h) {
        if (DM(h)) {
            const f = i.get(h);
            f && (i.delete(h),
            t.splice(t.indexOf(f), 1),
            f.children.forEach(o),
            f.alias.forEach(o))
        } else {
            const f = t.indexOf(h);
            f > -1 && (t.splice(f, 1),
            h.record.name && i.delete(h.record.name),
            h.children.forEach(o),
            h.alias.forEach(o))
        }
    }
    function a() {
        return t
    }
    function l(h) {
        const f = F3(h, t);
        t.splice(f, 0, h),
        h.record.name && !n0(h) && i.set(h.record.name, h)
    }
    function c(h, f) {
        let d, p = {}, v, g;
        if ("name"in h && h.name) {
            if (d = i.get(h.name),
            !d)
                throw Po(1, {
                    location: h
                });
            g = d.record.name,
            p = dt(e0(f.params, d.keys.filter(_ => !_.optional).concat(d.parent ? d.parent.keys.filter(_ => _.optional) : []).map(_ => _.name)), h.params && e0(h.params, d.keys.map(_ => _.name))),
            v = d.stringify(p)
        } else if (h.path != null)
            v = h.path,
            d = t.find(_ => _.re.test(v)),
            d && (p = d.parse(v),
            g = d.record.name);
        else {
            if (d = f.name ? i.get(f.name) : t.find(_ => _.re.test(f.path)),
            !d)
                throw Po(1, {
                    location: h,
                    currentLocation: f
                });
            g = d.record.name,
            p = dt({}, f.params, h.params),
            v = d.stringify(p)
        }
        const m = [];
        let y = d;
        for (; y; )
            m.unshift(y.record),
            y = y.parent;
        return {
            name: g,
            path: v,
            params: p,
            matched: m,
            meta: O3(m)
        }
    }
    n.forEach(h => s(h));
    function u() {
        t.length = 0,
        i.clear()
    }
    return {
        addRoute: s,
        resolve: c,
        removeRoute: o,
        clearRoutes: u,
        getRoutes: a,
        getRecordMatcher: r
    }
}
function e0(n, e) {
    const t = {};
    for (const i of e)
        i in n && (t[i] = n[i]);
    return t
}
function t0(n) {
    const e = {
        path: n.path,
        redirect: n.redirect,
        name: n.name,
        meta: n.meta || {},
        aliasOf: n.aliasOf,
        beforeEnter: n.beforeEnter,
        props: U3(n),
        children: n.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components"in n ? n.components || null : n.component && {
            default: n.component
        }
    };
    return Object.defineProperty(e, "mods", {
        value: {}
    }),
    e
}
function U3(n) {
    const e = {}
      , t = n.props || !1;
    if ("component"in n)
        e.default = t;
    else
        for (const i in n.components)
            e[i] = typeof t == "object" ? t[i] : t;
    return e
}
function n0(n) {
    for (; n; ) {
        if (n.record.aliasOf)
            return !0;
        n = n.parent
    }
    return !1
}
function O3(n) {
    return n.reduce( (e, t) => dt(e, t.meta), {})
}
function i0(n, e) {
    const t = {};
    for (const i in n)
        t[i] = i in e ? e[i] : n[i];
    return t
}
function F3(n, e) {
    let t = 0
      , i = e.length;
    for (; t !== i; ) {
        const s = t + i >> 1;
        UM(n, e[s]) < 0 ? i = s : t = s + 1
    }
    const r = B3(n);
    return r && (i = e.lastIndexOf(r, i - 1)),
    i
}
function B3(n) {
    let e = n;
    for (; e = e.parent; )
        if (OM(e) && UM(n, e) === 0)
            return e
}
function OM({record: n}) {
    return !!(n.name || n.components && Object.keys(n.components).length || n.redirect)
}
function z3(n) {
    const e = {};
    if (n === "" || n === "?")
        return e;
    const i = (n[0] === "?" ? n.slice(1) : n).split("&");
    for (let r = 0; r < i.length; ++r) {
        const s = i[r].replace(TM, " ")
          , o = s.indexOf("=")
          , a = cl(o < 0 ? s : s.slice(0, o))
          , l = o < 0 ? null : cl(s.slice(o + 1));
        if (a in e) {
            let c = e[a];
            ai(c) || (c = e[a] = [c]),
            c.push(l)
        } else
            e[a] = l
    }
    return e
}
function r0(n) {
    let e = "";
    for (let t in n) {
        const i = n[t];
        if (t = r3(t),
        i == null) {
            i !== void 0 && (e += (e.length ? "&" : "") + t);
            continue
        }
        (ai(i) ? i.map(s => s && Yd(s)) : [i && Yd(i)]).forEach(s => {
            s !== void 0 && (e += (e.length ? "&" : "") + t,
            s != null && (e += "=" + s))
        }
        )
    }
    return e
}
function k3(n) {
    const e = {};
    for (const t in n) {
        const i = n[t];
        i !== void 0 && (e[t] = ai(i) ? i.map(r => r == null ? null : "" + r) : i == null ? i : "" + i)
    }
    return e
}
const V3 = Symbol("")
  , s0 = Symbol("")
  , xm = Symbol("")
  , bm = Symbol("")
  , Kd = Symbol("");
function ia() {
    let n = [];
    function e(i) {
        return n.push(i),
        () => {
            const r = n.indexOf(i);
            r > -1 && n.splice(r, 1)
        }
    }
    function t() {
        n = []
    }
    return {
        add: e,
        list: () => n.slice(),
        reset: t
    }
}
function vr(n, e, t, i, r, s=o => o()) {
    const o = i && (i.enterCallbacks[r] = i.enterCallbacks[r] || []);
    return () => new Promise( (a, l) => {
        const c = f => {
            f === !1 ? l(Po(4, {
                from: t,
                to: e
            })) : f instanceof Error ? l(f) : E3(f) ? l(Po(2, {
                from: e,
                to: f
            })) : (o && i.enterCallbacks[r] === o && typeof f == "function" && o.push(f),
            a())
        }
          , u = s( () => n.call(i && i.instances[r], e, t, c));
        let h = Promise.resolve(u);
        n.length < 3 && (h = h.then(c)),
        h.catch(f => l(f))
    }
    )
}
function ad(n, e, t, i, r=s => s()) {
    const s = [];
    for (const o of n)
        for (const a in o.components) {
            let l = o.components[a];
            if (!(e !== "beforeRouteEnter" && !o.instances[a]))
                if (EM(l)) {
                    const u = (l.__vccOpts || l)[e];
                    u && s.push(vr(u, t, i, o, a, r))
                } else {
                    let c = l();
                    s.push( () => c.then(u => {
                        if (!u)
                            throw new Error(`Couldn't resolve component "${a}" at "${o.path}"`);
                        const h = $O(u) ? u.default : u;
                        o.mods[a] = u,
                        o.components[a] = h;
                        const d = (h.__vccOpts || h)[e];
                        return d && vr(d, t, i, o, a, r)()
                    }
                    ))
                }
        }
    return s
}
function o0(n) {
    const e = ni(xm)
      , t = ni(bm)
      , i = Lt( () => {
        const l = Pn(n.to);
        return e.resolve(l)
    }
    )
      , r = Lt( () => {
        const {matched: l} = i.value
          , {length: c} = l
          , u = l[c - 1]
          , h = t.matched;
        if (!u || !h.length)
            return -1;
        const f = h.findIndex(Ro.bind(null, u));
        if (f > -1)
            return f;
        const d = a0(l[c - 2]);
        return c > 1 && a0(u) === d && h[h.length - 1].path !== d ? h.findIndex(Ro.bind(null, l[c - 2])) : f
    }
    )
      , s = Lt( () => r.value > -1 && X3(t.params, i.value.params))
      , o = Lt( () => r.value > -1 && r.value === t.matched.length - 1 && IM(t.params, i.value.params));
    function a(l={}) {
        return W3(l) ? e[Pn(n.replace) ? "replace" : "push"](Pn(n.to)).catch(Aa) : Promise.resolve()
    }
    return {
        route: i,
        href: Lt( () => i.value.href),
        isActive: s,
        isExactActive: o,
        navigate: a
    }
}
const H3 = Ua({
    name: "RouterLink",
    compatConfig: {
        MODE: 3
    },
    props: {
        to: {
            type: [String, Object],
            required: !0
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: "page"
        }
    },
    useLink: o0,
    setup(n, {slots: e}) {
        const t = hl(o0(n))
          , {options: i} = ni(xm)
          , r = Lt( () => ({
            [l0(n.activeClass, i.linkActiveClass, "router-link-active")]: t.isActive,
            [l0(n.exactActiveClass, i.linkExactActiveClass, "router-link-exact-active")]: t.isExactActive
        }));
        return () => {
            const s = e.default && e.default(t);
            return n.custom ? s : gs("a", {
                "aria-current": t.isExactActive ? n.ariaCurrentValue : null,
                href: t.href,
                onClick: t.navigate,
                class: r.value
            }, s)
        }
    }
})
  , G3 = H3;
function W3(n) {
    if (!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey) && !n.defaultPrevented && !(n.button !== void 0 && n.button !== 0)) {
        if (n.currentTarget && n.currentTarget.getAttribute) {
            const e = n.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(e))
                return
        }
        return n.preventDefault && n.preventDefault(),
        !0
    }
}
function X3(n, e) {
    for (const t in e) {
        const i = e[t]
          , r = n[t];
        if (typeof i == "string") {
            if (i !== r)
                return !1
        } else if (!ai(r) || r.length !== i.length || i.some( (s, o) => s !== r[o]))
            return !1
    }
    return !0
}
function a0(n) {
    return n ? n.aliasOf ? n.aliasOf.path : n.path : ""
}
const l0 = (n, e, t) => n ?? e ?? t
  , q3 = Ua({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
        name: {
            type: String,
            default: "default"
        },
        route: Object
    },
    compatConfig: {
        MODE: 3
    },
    setup(n, {attrs: e, slots: t}) {
        const i = ni(Kd)
          , r = Lt( () => n.route || i.value)
          , s = ni(s0, 0)
          , o = Lt( () => {
            let c = Pn(s);
            const {matched: u} = r.value;
            let h;
            for (; (h = u[c]) && !h.components; )
                c++;
            return c
        }
        )
          , a = Lt( () => r.value.matched[o.value]);
        cs(s0, Lt( () => o.value + 1)),
        cs(V3, a),
        cs(Kd, r);
        const l = Qe();
        return Bt( () => [l.value, a.value, n.name], ([c,u,h], [f,d,p]) => {
            u && (u.instances[h] = c,
            d && d !== u && c && c === f && (u.leaveGuards.size || (u.leaveGuards = d.leaveGuards),
            u.updateGuards.size || (u.updateGuards = d.updateGuards))),
            c && u && (!d || !Ro(u, d) || !f) && (u.enterCallbacks[h] || []).forEach(v => v(c))
        }
        , {
            flush: "post"
        }),
        () => {
            const c = r.value
              , u = n.name
              , h = a.value
              , f = h && h.components[u];
            if (!f)
                return c0(t.default, {
                    Component: f,
                    route: c
                });
            const d = h.props[u]
              , p = d ? d === !0 ? c.params : typeof d == "function" ? d(c) : d : null
              , g = gs(f, dt({}, p, e, {
                onVnodeUnmounted: m => {
                    m.component.isUnmounted && (h.instances[u] = null)
                }
                ,
                ref: l
            }));
            return c0(t.default, {
                Component: g,
                route: c
            }) || g
        }
    }
});
function c0(n, e) {
    if (!n)
        return null;
    const t = n(e);
    return t.length === 1 ? t[0] : t
}
const $3 = q3;
function Y3(n) {
    const e = N3(n.routes, n)
      , t = n.parseQuery || z3
      , i = n.stringifyQuery || r0
      , r = n.history
      , s = ia()
      , o = ia()
      , a = ia()
      , l = gi(hr);
    let c = hr;
    Js && n.scrollBehavior && "scrollRestoration"in history && (history.scrollRestoration = "manual");
    const u = sd.bind(null, k => "" + k)
      , h = sd.bind(null, o3)
      , f = sd.bind(null, cl);
    function d(k, se) {
        let oe, he;
        return DM(k) ? (oe = e.getRecordMatcher(k),
        he = se) : he = k,
        e.addRoute(he, oe)
    }
    function p(k) {
        const se = e.getRecordMatcher(k);
        se && e.removeRoute(se)
    }
    function v() {
        return e.getRoutes().map(k => k.record)
    }
    function g(k) {
        return !!e.getRecordMatcher(k)
    }
    function m(k, se) {
        if (se = dt({}, se || l.value),
        typeof k == "string") {
            const R = od(t, k, se.path)
              , O = e.resolve({
                path: R.path
            }, se)
              , B = r.createHref(R.fullPath);
            return dt(R, O, {
                params: f(O.params),
                hash: cl(R.hash),
                redirectedFrom: void 0,
                href: B
            })
        }
        let oe;
        if (k.path != null)
            oe = dt({}, k, {
                path: od(t, k.path, se.path).path
            });
        else {
            const R = dt({}, k.params);
            for (const O in R)
                R[O] == null && delete R[O];
            oe = dt({}, k, {
                params: h(R)
            }),
            se.params = h(se.params)
        }
        const he = e.resolve(oe, se)
          , Re = k.hash || "";
        he.params = u(f(he.params));
        const I = c3(i, dt({}, k, {
            hash: i3(Re),
            path: he.path
        }))
          , A = r.createHref(I);
        return dt({
            fullPath: I,
            hash: Re,
            query: i === r0 ? k3(k.query) : k.query || {}
        }, he, {
            redirectedFrom: void 0,
            href: A
        })
    }
    function y(k) {
        return typeof k == "string" ? od(t, k, l.value.path) : dt({}, k)
    }
    function _(k, se) {
        if (c !== k)
            return Po(8, {
                from: se,
                to: k
            })
    }
    function x(k) {
        return E(k)
    }
    function C(k) {
        return x(dt(y(k), {
            replace: !0
        }))
    }
    function w(k) {
        const se = k.matched[k.matched.length - 1];
        if (se && se.redirect) {
            const {redirect: oe} = se;
            let he = typeof oe == "function" ? oe(k) : oe;
            return typeof he == "string" && (he = he.includes("?") || he.includes("#") ? he = y(he) : {
                path: he
            },
            he.params = {}),
            dt({
                query: k.query,
                hash: k.hash,
                params: he.path != null ? {} : k.params
            }, he)
        }
    }
    function E(k, se) {
        const oe = c = m(k)
          , he = l.value
          , Re = k.state
          , I = k.force
          , A = k.replace === !0
          , R = w(oe);
        if (R)
            return E(dt(y(R), {
                state: typeof R == "object" ? dt({}, Re, R.state) : Re,
                force: I,
                replace: A
            }), se || oe);
        const O = oe;
        O.redirectedFrom = se;
        let B;
        return !I && u3(i, he, oe) && (B = Po(16, {
            to: O,
            from: he
        }),
        te(he, he, !0, !1)),
        (B ? Promise.resolve(B) : b(O, he)).catch(Y => Di(Y) ? Di(Y, 2) ? Y : xe(Y) : Z(Y, O, he)).then(Y => {
            if (Y) {
                if (Di(Y, 2))
                    return E(dt({
                        replace: A
                    }, y(Y.to), {
                        state: typeof Y.to == "object" ? dt({}, Re, Y.to.state) : Re,
                        force: I
                    }), se || O)
            } else
                Y = F(O, he, !0, A, Re);
            return D(O, he, Y),
            Y
        }
        )
    }
    function L(k, se) {
        const oe = _(k, se);
        return oe ? Promise.reject(oe) : Promise.resolve()
    }
    function S(k) {
        const se = re.values().next().value;
        return se && typeof se.runWithContext == "function" ? se.runWithContext(k) : k()
    }
    function b(k, se) {
        let oe;
        const [he,Re,I] = j3(k, se);
        oe = ad(he.reverse(), "beforeRouteLeave", k, se);
        for (const R of he)
            R.leaveGuards.forEach(O => {
                oe.push(vr(O, k, se))
            }
            );
        const A = L.bind(null, k, se);
        return oe.push(A),
        Me(oe).then( () => {
            oe = [];
            for (const R of s.list())
                oe.push(vr(R, k, se));
            return oe.push(A),
            Me(oe)
        }
        ).then( () => {
            oe = ad(Re, "beforeRouteUpdate", k, se);
            for (const R of Re)
                R.updateGuards.forEach(O => {
                    oe.push(vr(O, k, se))
                }
                );
            return oe.push(A),
            Me(oe)
        }
        ).then( () => {
            oe = [];
            for (const R of I)
                if (R.beforeEnter)
                    if (ai(R.beforeEnter))
                        for (const O of R.beforeEnter)
                            oe.push(vr(O, k, se));
                    else
                        oe.push(vr(R.beforeEnter, k, se));
            return oe.push(A),
            Me(oe)
        }
        ).then( () => (k.matched.forEach(R => R.enterCallbacks = {}),
        oe = ad(I, "beforeRouteEnter", k, se, S),
        oe.push(A),
        Me(oe))).then( () => {
            oe = [];
            for (const R of o.list())
                oe.push(vr(R, k, se));
            return oe.push(A),
            Me(oe)
        }
        ).catch(R => Di(R, 8) ? R : Promise.reject(R))
    }
    function D(k, se, oe) {
        a.list().forEach(he => S( () => he(k, se, oe)))
    }
    function F(k, se, oe, he, Re) {
        const I = _(k, se);
        if (I)
            return I;
        const A = se === hr
          , R = Js ? history.state : {};
        oe && (he || A ? r.replace(k.fullPath, dt({
            scroll: A && R && R.scroll
        }, Re)) : r.push(k.fullPath, Re)),
        l.value = k,
        te(k, se, oe, A),
        xe()
    }
    let z;
    function $() {
        z || (z = r.listen( (k, se, oe) => {
            if (!pe.listening)
                return;
            const he = m(k)
              , Re = w(he);
            if (Re) {
                E(dt(Re, {
                    replace: !0
                }), he).catch(Aa);
                return
            }
            c = he;
            const I = l.value;
            Js && _3(j_(I.fullPath, oe.delta), Xh()),
            b(he, I).catch(A => Di(A, 12) ? A : Di(A, 2) ? (E(A.to, he).then(R => {
                Di(R, 20) && !oe.delta && oe.type === ul.pop && r.go(-1, !1)
            }
            ).catch(Aa),
            Promise.reject()) : (oe.delta && r.go(-oe.delta, !1),
            Z(A, he, I))).then(A => {
                A = A || F(he, I, !1),
                A && (oe.delta && !Di(A, 8) ? r.go(-oe.delta, !1) : oe.type === ul.pop && Di(A, 20) && r.go(-1, !1)),
                D(he, I, A)
            }
            ).catch(Aa)
        }
        ))
    }
    let ne = ia(), W = ia(), ie;
    function Z(k, se, oe) {
        xe(k);
        const he = W.list();
        return he.length ? he.forEach(Re => Re(k, se, oe)) : console.error(k),
        Promise.reject(k)
    }
    function ve() {
        return ie && l.value !== hr ? Promise.resolve() : new Promise( (k, se) => {
            ne.add([k, se])
        }
        )
    }
    function xe(k) {
        return ie || (ie = !k,
        $(),
        ne.list().forEach( ([se,oe]) => k ? oe(k) : se()),
        ne.reset()),
        k
    }
    function te(k, se, oe, he) {
        const {scrollBehavior: Re} = n;
        if (!Js || !Re)
            return Promise.resolve();
        const I = !oe && y3(j_(k.fullPath, 0)) || (he || !oe) && history.state && history.state.scroll || null;
        return as().then( () => Re(k, se, I)).then(A => A && v3(A)).catch(A => Z(A, k, se))
    }
    const Se = k => r.go(k);
    let ze;
    const re = new Set
      , pe = {
        currentRoute: l,
        listening: !0,
        addRoute: d,
        removeRoute: p,
        clearRoutes: e.clearRoutes,
        hasRoute: g,
        getRoutes: v,
        resolve: m,
        options: n,
        push: x,
        replace: C,
        go: Se,
        back: () => Se(-1),
        forward: () => Se(1),
        beforeEach: s.add,
        beforeResolve: o.add,
        afterEach: a.add,
        onError: W.add,
        isReady: ve,
        install(k) {
            const se = this;
            k.component("RouterLink", G3),
            k.component("RouterView", $3),
            k.config.globalProperties.$router = se,
            Object.defineProperty(k.config.globalProperties, "$route", {
                enumerable: !0,
                get: () => Pn(l)
            }),
            Js && !ze && l.value === hr && (ze = !0,
            x(r.location).catch(Re => {}
            ));
            const oe = {};
            for (const Re in hr)
                Object.defineProperty(oe, Re, {
                    get: () => l.value[Re],
                    enumerable: !0
                });
            k.provide(xm, se),
            k.provide(bm, F0(oe)),
            k.provide(Kd, l);
            const he = k.unmount;
            re.add(k),
            k.unmount = function() {
                re.delete(k),
                re.size < 1 && (c = hr,
                z && z(),
                z = null,
                l.value = hr,
                ze = !1,
                ie = !1),
                he()
            }
        }
    };
    function Me(k) {
        return k.reduce( (se, oe) => se.then( () => S(oe)), Promise.resolve())
    }
    return pe
}
function j3(n, e) {
    const t = []
      , i = []
      , r = []
      , s = Math.max(e.matched.length, n.matched.length);
    for (let o = 0; o < s; o++) {
        const a = e.matched[o];
        a && (n.matched.find(c => Ro(c, a)) ? i.push(a) : t.push(a));
        const l = n.matched[o];
        l && (e.matched.find(c => Ro(c, l)) || r.push(l))
    }
    return [t, i, r]
}
function pF(n) {
    return ni(bm)
}
const K3 = "modulepreload"
  , Z3 = function(n, e) {
    return new URL(n,e).href
}
  , u0 = {}
  , J3 = function(e, t, i) {
    let r = Promise.resolve();
    if (t && t.length > 0) {
        const o = document.getElementsByTagName("link")
          , a = document.querySelector("meta[property=csp-nonce]")
          , l = (a == null ? void 0 : a.nonce) || (a == null ? void 0 : a.getAttribute("nonce"));
        r = Promise.allSettled(t.map(c => {
            if (c = Z3(c, i),
            c in u0)
                return;
            u0[c] = !0;
            const u = c.endsWith(".css")
              , h = u ? '[rel="stylesheet"]' : "";
            if (!!i)
                for (let p = o.length - 1; p >= 0; p--) {
                    const v = o[p];
                    if (v.href === c && (!u || v.rel === "stylesheet"))
                        return
                }
            else if (document.querySelector(`link[href="${c}"]${h}`))
                return;
            const d = document.createElement("link");
            if (d.rel = u ? "stylesheet" : K3,
            u || (d.as = "script"),
            d.crossOrigin = "",
            d.href = c,
            l && d.setAttribute("nonce", l),
            document.head.appendChild(d),
            u)
                return new Promise( (p, v) => {
                    d.addEventListener("load", p),
                    d.addEventListener("error", () => v(new Error(`Unable to preload CSS for ${c}`)))
                }
                )
        }
        ))
    }
    function s(o) {
        const a = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (a.payload = o,
        window.dispatchEvent(a),
        !a.defaultPrevented)
            throw o
    }
    return r.then(o => {
        for (const a of o || [])
            a.status === "rejected" && s(a.reason);
        return e().catch(s)
    }
    )
}
  , Q3 = [{
    path: "/ImdcPod",
    name: "ImdcPod",
    component: () => J3( () => import("./index-DwwWu58x.js"), [], import.meta.url),
    meta: {
        title: "机柜POD冷通道",
        project: "ImdcPod"
    }
}]
  , Ca = [...Q3, {
    path: "/:pathMatch(.*)",
    redirect: "/"
}]
  , eF = Ca.some(n => n.path !== "/");
if (eF && Ca.length) {
    const {meta: n, name: e, component: t} = Ca[0];
    Ca.push({
        path: "/",
        name: `home-${e}`,
        component: t,
        meta: n
    })
}
const qh = Y3({
    history: w3("./"),
    routes: Ca
});
qh.beforeEach( (n, e, t) => {
    Zd.start(),
    t()
}
);
qh.afterEach( (n, e) => {
    Zd.done(),
    document.title = n.meta.title || "广州商迪科技有限公司"
}
);
window.router = qh;
Zd.configure({
    showSpinner: !1
});
const Al = RE(qO);
Al.use(NE());
Al.use(qh);
Al.use(U2);
HO(Al);
Al.mount("#app");
export {wt as $, Ob as A, Ss as B, Bh as C, XI as D, za as E, Mn as F, no as G, Do as H, Qe as I, Bt as J, Pn as K, Ki as L, Be as M, M0 as N, tt as O, Nb as P, Sn as Q, Xb as R, Rn as S, qI as T, aS as U, ae as V, Gc as W, wr as X, Ms as Y, as as Z, J3 as _, KA as a, oi as a$, ii as a0, Ua as a1, br as a2, wy as a3, Ay as a4, mt as a5, ht as a6, aF as a7, ei as a8, Lt as a9, cF as aA, sF as aB, hF as aC, nF as aD, Gi as aE, eh as aF, sn as aG, iF as aH, eE as aI, lF as aJ, yo as aK, JS as aL, rt as aM, uF as aN, Ju as aO, rF as aP, fF as aQ, RE as aR, gs as aS, Tr as aT, xb as aU, yb as aV, pF as aW, Ee as aX, Up as aY, Dt as aZ, Kt as a_, ni as aa, Ft as ab, qe as ac, gi as ad, pp as ae, ew as af, cs as ag, lw as ah, Vw as ai, tF as aj, Hi as ak, Oe as al, hl as am, NS as an, Wu as ao, dp as ap, on as aq, mn as ar, uw as as, hd as at, po as au, aw as av, Gu as aw, kw as ax, sS as ay, oF as az, Gt as b, wl as b$, am as b0, Uo as b1, Md as b2, Va as b3, GO as b4, si as b5, Vi as b6, Gx as b7, Vp as b8, Zn as b9, xh as bA, pi as bB, Xp as bC, cn as bD, xn as bE, it as bF, nb as bG, wi as bH, Ar as bI, sb as bJ, ob as bK, bh as bL, il as bM, Wp as bN, Iu as bO, Mp as bP, pa as bQ, Qs as bR, Gn as bS, Ha as bT, Ga as bU, Wi as bV, ys as bW, nl as bX, tl as bY, El as bZ, an as b_, Cx as ba, _b as bb, st as bc, xt as bd, vx as be, _x as bf, yx as bg, ih as bh, bx as bi, Mx as bj, mh as bk, Ze as bl, Le as bm, UE as bn, OE as bo, ML as bp, wn as bq, $i as br, pt as bs, WE as bt, qE as bu, XE as bv, Ud as bw, ib as bx, wo as by, JI as bz, nm as c, ft as c0, li as c1, Fp as c2, Ye as c3, yi as c4, Si as d, N as e, yh as f, Jp as g, _n as h, Ot as i, Sb as j, Ht as k, fi as l, GL as m, Ub as n, Db as o, Lb as p, Cd as q, NL as r, DL as s, CL as t, AL as u, Ml as v, Zi as w, PL as x, yn as y, Un as z};
